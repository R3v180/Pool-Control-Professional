# √çNDICE DE ARCHIVOS (ESTRUCTURA REFACTORIZADA)

1. DEVELOPMENT_PLAN.md
2. PROJECT_STATUS.md
3. README.md
4. package.json
5. packages/client/index.html
6. packages/client/package.json
7. packages/client/src/App.tsx
8. packages/client/src/api/apiClient.ts
9. packages/client/src/features/admin/pages/AdminDashboard.tsx
10. packages/client/src/features/admin/pages/IncidentsHistoryPage.tsx
11. packages/client/src/features/admin/pages/ParameterCatalogPage.tsx
12. packages/client/src/features/admin/pages/ProductCatalogPage.tsx
13. packages/client/src/features/admin/pages/ProductCategoryCatalogPage.tsx
14. packages/client/src/features/admin/pages/TaskCatalogPage.tsx
15. packages/client/src/features/admin/pages/clients/ClientDetailPage.tsx
16. packages/client/src/features/admin/pages/clients/ClientsPage.tsx
17. packages/client/src/features/admin/pages/incidents/IncidentDetailPage.tsx
18. packages/client/src/features/admin/pages/planner/PlannerPage.tsx
19. packages/client/src/features/admin/pages/pools/PoolDetailPage.tsx
20. packages/client/src/features/admin/pages/reports/ConsumptionReportPage.tsx
21. packages/client/src/features/auth/pages/LoginPage.tsx
22. packages/client/src/features/financials/pages/ExpensesPage.tsx
23. packages/client/src/features/financials/pages/PaymentsPage.tsx
24. packages/client/src/features/manager/pages/InvoicingReportPage.tsx
25. packages/client/src/features/manager/pages/ManagerDashboard.tsx
26. packages/client/src/features/superadmin/pages/TenantsPage.tsx
27. packages/client/src/features/technician/pages/MyRoutePage.tsx
28. packages/client/src/features/technician/pages/WorkOrderPage.tsx
29. packages/client/src/main.tsx
30. packages/client/src/providers/AuthProvider.tsx
31. packages/client/src/router/components.tsx
32. packages/client/src/router/index.tsx
33. packages/client/src/stores/auth.store.ts
34. packages/client/src/styles/theme.ts
35. packages/client/tsconfig.json
36. packages/client/tsconfig.node.json
37. packages/client/vite.config.ts
38. packages/server/package.json
39. packages/server/prisma/data/catalogs.ts
40. packages/server/prisma/data/clients.ts
41. packages/server/prisma/data/consumptions.ts
42. packages/server/prisma/data/financial-rules.ts
43. packages/server/prisma/data/incident-tasks.ts
44. packages/server/prisma/data/product-categories.ts
45. packages/server/prisma/data/products.ts
46. packages/server/prisma/data/transactions.ts
47. packages/server/prisma/data/users.ts
48. packages/server/prisma/seed.ts
49. packages/server/src/api/auth/auth.controller.ts
50. packages/server/src/api/auth/auth.routes.ts
51. packages/server/src/api/auth/auth.service.ts
52. packages/server/src/api/client-product-pricing/client-product-pricing.controller.ts
53. packages/server/src/api/client-product-pricing/client-product-pricing.routes.ts
54. packages/server/src/api/client-product-pricing/client-product-pricing.service.ts
55. packages/server/src/api/clients/clients.controller.ts
56. packages/server/src/api/clients/clients.routes.ts
57. packages/server/src/api/clients/clients.service.ts
58. packages/server/src/api/dashboard/dashboard.controller.ts
59. packages/server/src/api/dashboard/dashboard.routes.ts
60. packages/server/src/api/dashboard/dashboard.service.ts
61. packages/server/src/api/expenses/expenses.controller.ts
62. packages/server/src/api/expenses/expenses.routes.ts
63. packages/server/src/api/expenses/expenses.service.ts
64. packages/server/src/api/incident-tasks/incident-tasks.controller.ts
65. packages/server/src/api/incident-tasks/incident-tasks.routes.ts
66. packages/server/src/api/incident-tasks/incident-tasks.service.ts
67. packages/server/src/api/notifications/notifications.controller.ts
68. packages/server/src/api/notifications/notifications.routes.ts
69. packages/server/src/api/notifications/notifications.service.ts
70. packages/server/src/api/parameters/parameters.controller.ts
71. packages/server/src/api/parameters/parameters.routes.ts
72. packages/server/src/api/parameters/parameters.service.ts
73. packages/server/src/api/payments/payments.controller.ts
74. packages/server/src/api/payments/payments.routes.ts
75. packages/server/src/api/payments/payments.service.ts
76. packages/server/src/api/pool-configurations/pool-configurations.controller.ts
77. packages/server/src/api/pool-configurations/pool-configurations.routes.ts
78. packages/server/src/api/pool-configurations/pool-configurations.service.ts
79. packages/server/src/api/pools/pools.controller.ts
80. packages/server/src/api/pools/pools.routes.ts
81. packages/server/src/api/pools/pools.service.ts
82. packages/server/src/api/product-categories/product-categories.controller.ts
83. packages/server/src/api/product-categories/product-categories.routes.ts
84. packages/server/src/api/product-categories/product-categories.service.ts
85. packages/server/src/api/products/products.controller.ts
86. packages/server/src/api/products/products.routes.ts
87. packages/server/src/api/products/products.service.ts
88. packages/server/src/api/reports/reports.controller.ts
89. packages/server/src/api/reports/reports.routes.ts
90. packages/server/src/api/reports/reports.service.ts
91. packages/server/src/api/tasks/tasks.controller.ts
92. packages/server/src/api/tasks/tasks.routes.ts
93. packages/server/src/api/tasks/tasks.service.ts
94. packages/server/src/api/tenants/tenants.controller.ts
95. packages/server/src/api/tenants/tenants.routes.ts
96. packages/server/src/api/tenants/tenants.service.ts
97. packages/server/src/api/uploads/uploads.controller.ts
98. packages/server/src/api/uploads/uploads.routes.ts
99. packages/server/src/api/uploads/uploads.service.ts
100. packages/server/src/api/users/users.controller.ts
101. packages/server/src/api/users/users.routes.ts
102. packages/server/src/api/users/users.service.ts
103. packages/server/src/api/visits/visits.controller.ts
104. packages/server/src/api/visits/visits.routes.ts
105. packages/server/src/api/visits/visits.service.ts
106. packages/server/src/app.ts
107. packages/server/src/config/index.ts
108. packages/server/src/middleware/auth.middleware.ts
109. packages/server/src/middleware/authorize.middleware.ts
110. packages/server/src/middleware/error.middleware.ts
111. packages/server/src/server.ts
112. packages/server/src/utils/jwt.utils.ts
113. packages/server/src/utils/password.utils.ts
114. packages/server/tsconfig.json
115. tsconfig.json


# CONTENIDO DE ARCHIVOS


// ====== [1] DEVELOPMENT_PLAN.md ======
# Plan de Desarrollo y Arquitectura: Pool-Control Professional

**Filosof√≠a del Documento:** Este no es solo un plan, es la narrativa arquitect√≥nica y de negocio del proyecto. Sirve como la hoja de ruta para el trabajo futuro y, a la vez, como una cr√≥nica de las decisiones tomadas, garantizando un entendimiento profundo del sistema en cualquier punto de su ciclo de vida.

---

## ‚úÖ FASE 0 a 7: Fundaci√≥n y Operativa Inteligente

- **Estado:** `COMPLETADA`
- **Resumen:** Durante estas fases, se ha construido una plataforma operativa robusta y completa. Se ha digitalizado todo el flujo de trabajo, desde la configuraci√≥n de cat√°logos y fichas de mantenimiento, hasta la planificaci√≥n de rutas y la ejecuci√≥n de partes de trabajo. La Fase 7 culmin√≥ con la implementaci√≥n de un **sistema de ticketing avanzado**, que asegura una comunicaci√≥n y resoluci√≥n de incidencias eficiente y completamente trazable, sentando las bases para un control de calidad proactivo.

---

## üöß FASE 8 y Sprint Final v1.0: El Motor Financiero y la Inteligencia de Negocio

- **Estado:** `EN PROGRESO`
- **Intenci√≥n Estrat√©gica:** Esta es la fase crucial que eleva la plataforma de una herramienta operativa a un **socio estrat√©gico para el negocio**. El objetivo es implementar un conjunto de funcionalidades de alto valor para la presentaci√≥n de la v1.0, centr√°ndonos en la gesti√≥n financiera, el an√°lisis de datos y la supervisi√≥n proactiva.

- **Plan de Acci√≥n Detallado y Priorizado para la v1.0:**

  1.  **M√≥dulo de Informes de Consumo y Rentabilidad v1:**

      - **Estado:** `COMPLETADO`
      - **Valor Aportado:** Se ha construido la base de la inteligencia de negocio. Esta primera versi√≥n del m√≥dulo permite a los administradores y gerentes responder a una pregunta fundamental: **"¬øcu√°nto nos cuesta realmente cada cliente?"**. La implementaci√≥n incluye una API de agregaci√≥n, una interfaz interactiva con filtros y una potente funcionalidad de **desglose (drill-down)** que permite auditar un coste hasta el parte de trabajo original.

  2.  **Mejoras de Usabilidad del Dashboard:**

      - **Estado:** `PENDIENTE`
      - **Intenci√≥n Estrat√©gica:** Incrementar la eficiencia del `ADMIN` en su d√≠a a d√≠a mediante mejoras de alto impacto en la interfaz principal.
      - **Capacidades a Implementar:**
        - **Navegaci√≥n Directa:** Hacer que las tarjetas de "Visitas de Hoy" sean clicables para un acceso directo al detalle del parte de trabajo.
        - **Visibilidad de Alertas:** Estandarizar y potenciar los indicadores visuales (bordes de color intenso) para las incidencias cr√≠ticas, permitiendo una identificaci√≥n inmediata.

  3.  **Evoluci√≥n a "Motor Financiero" (Facturaci√≥n y Precios Avanzados):**

      - **Estado:** `PENDIENTE (Prioridad M√°xima)`
      - **Intenci√≥n Estrat√©gica:** Dotar al sistema de la flexibilidad necesaria para manejar los modelos de negocio y las estructuras de precios del mundo real, permitiendo generar informes listos para la facturaci√≥n.
      - **Capacidades a Implementar:**
        - **Precios y Fiscalidad:** Diferenciaci√≥n entre `cost` y `salePrice` (PVP) en los productos, y un campo `taxRate` (IVA) para futuros c√°lculos.
        - **Modelos de Contrato:** Configuraci√≥n por cliente de su `billingModel` (`Todo Incluido`, `Cuota + Materiales`, etc.) y su `monthlyFee` (cuota fija).
        - **Reglas de Precios Flexibles:** Sistema para definir descuentos por cliente, aplicables a productos individuales o a familias de productos completas.
        - **Historial de Pagos:** Implementaci√≥n de la capacidad de registrar pagos para llevar un control de saldos pendientes por cliente.
        - **Registro de Gastos:** Sistema para a√±adir gastos operativos manuales (combustible, salarios) para un c√°lculo de rentabilidad global preciso.

  4.  **Dashboard de Gerencia y Rol "Camale√≥n":**

      - **Estado:** `PENDIENTE (Prioridad M√°xima)`
      - **Intenci√≥n Estrat√©gica:** Crear el centro de mando definitivo para la direcci√≥n del negocio, combinando supervisi√≥n estrat√©gica con capacidad de intervenci√≥n operativa.
      - **Capacidades a Implementar:**
        - **Dashboard de KPIs:** Un panel con gr√°ficos visuales sobre la rentabilidad, eficiencia del equipo y estado de las incidencias (ej. tiempo medio de resoluci√≥n).
        - **Selector de Vista:** Implementaci√≥n de la funcionalidad del "rol camale√≥n", que permitir√° al gerente cambiar su vista para actuar con todos los permisos de un `ADMIN` o un `TECHNICIAN`, garantizando la cobertura operativa con una auditor√≠a completa de sus acciones.

  5.  **Alertas Proactivas por Umbrales:**
      - **Estado:** `PENDIENTE (Prioridad M√°xima)`
      - **Intenci√≥n Estrat√©gica:** Implementar un sistema de vigilancia autom√°tica para pasar de la correcci√≥n a la prevenci√≥n de problemas, aportando un valor diferencial al servicio ofrecido.
      - **Capacidades a Implementar:** Se implementar√° la l√≥gica en el backend para que el sistema genere notificaciones autom√°ticas cuando un valor de par√°metro medido por un t√©cnico est√© fuera de los rangos de seguridad configurados.

---

## ‚ñ∂Ô∏è Visi√≥n Post-v1.0: Hacia el ERP Completo

Una vez presentada y validada la v1.0, el desarrollo continuar√° con los siguientes grandes m√≥dulos para convertir la plataforma en una soluci√≥n integral.

- **M√≥dulo de Gesti√≥n de Inventario:**

  - **Estado:** `PLANIFICADO`
  - **Prop√≥sito:** Optimizar la gesti√≥n de stock y las compras. Incluir√° control de niveles de stock, definici√≥n de m√≠nimos/m√°ximos y generaci√≥n de informes de necesidades o propuestas de compra.

- **Modo Offline (PWA) para T√©cnicos:**

  - **Estado:** `PLANIFICADO`
  - **Prop√≥sito:** Garantizar la continuidad del negocio en campo, permitiendo a los t√©cnicos trabajar sin conexi√≥n a internet.

- **M√≥dulo de Facturaci√≥n y Contabilidad Completo:**
  - **Estado:** `PLANIFICADO (Largo Plazo)`
  - **Prop√≥sito:** Convertir la plataforma en una soluci√≥n todo en uno, eliminando la necesidad de software de terceros para la facturaci√≥n y contabilidad.
  - **Capacidades Futuras:** Generaci√≥n de facturas con validez legal, gesti√≥n de impuestos, presupuestos, pedidos a proveedores y, eventualmente, adaptaci√≥n a las normativas contables de diferentes pa√≠ses.



// ====== [2] PROJECT_STATUS.md ======
# Estado del Proyecto y Cr√≥nica de Desarrollo: Pool-Control Professional

**Filosof√≠a de este documento:** Este no es solo un registro de tareas, es el pulso del proyecto. Refleja nuestro compromiso con la excelencia, documentando no solo _qu√©_ hemos hecho, sino _por qu√©_ lo hemos hecho y el _valor_ que cada fase aporta al producto final. Est√° dise√±ado para ser la fuente de verdad para cualquier miembro del equipo, presente o futuro.

_√öltima actualizaci√≥n: 13 de julio de 2025, 06:30 CEST_

---

## 1. Visi√≥n Estrat√©gica Actual: Sprint Final hacia la Versi√≥n 1.0

El proyecto entra en su fase final de desarrollo para la Versi√≥n 1.0. El objetivo es consolidar una aplicaci√≥n funcional, robusta y con funcionalidades diferenciales clave. Durante los pr√≥ximos 3 d√≠as, el enfoque ser√° total en la implementaci√≥n de las herramientas de gesti√≥n financiera, an√°lisis y supervisi√≥n proactiva que definir√°n el producto para su presentaci√≥n.

---

## 2. Hitos de Desarrollo Validados

### ‚úÖ **M√≥dulo de Informes de Consumo y Rentabilidad v1**

- **Estado:** `COMPLETADO Y VALIDADO`
- **Resumen:** Se ha implementado con √©xito la primera versi√≥n del m√≥dulo de informes. Esta base nos proporciona una visi√≥n de la **rentabilidad interna** (basada en el coste de los productos) y una potente funcionalidad de **desglose interactivo (drill-down)** que permite auditar cualquier coste hasta el parte de trabajo original. La infraestructura t√©cnica (API, componentes de UI, exportaci√≥n a CSV) est√° lista para evolucionar.

### ‚úÖ **Flujo de Trabajo Avanzado para Incidencias (Ticketing)**

- **Estado:** `COMPLETADO Y VALIDADO`
- **Resumen:** Se ha finalizado la implementaci√≥n del sistema de ticketing avanzado, creando un flujo de comunicaci√≥n bidireccional y completamente trazable entre administradores y t√©cnicos. La comunicaci√≥n y la resoluci√≥n de problemas ahora son eficientes y auditables.

---

## 3. Plan de Acci√≥n y Tareas Pendientes

### **Plan de Ataque para la Versi√≥n 1.0 (Pr√≥ximos 3 D√≠as)**

Esta es la m√°xima prioridad actual. El plan se ha detallado para maximizar el valor entregado en el sprint final.

#### **Mejoras de Usabilidad y UI (Tareas R√°pidas)**

- **Estado:** `PENDIENTE`
- **Objetivo:** Implementar peque√±as mejoras de alto impacto en la interfaz actual para aumentar la eficiencia del `ADMIN`.
- **Tareas T√©cnicas:**
  - **Navegaci√≥n desde el Dashboard:** Hacer que las tarjetas de "Visitas de Hoy" en el `AdminDashboard` sean clicables, permitiendo al administrador navegar directamente al detalle del parte de trabajo (`WorkOrderPage`) con un solo clic, de la misma forma que ya funciona con las incidencias.
  - **Mejora Visual de Alertas:** Recuperar y estandarizar el indicador visual para las incidencias cr√≠ticas. Adem√°s del fondo tenue, se a√±adir√° un **borde izquierdo rojo intenso** a las incidencias vencidas o cr√≠ticas en el `AdminDashboard`, replicando el estilo del `PlannerPage` para una coherencia visual y una identificaci√≥n m√°s r√°pida de los problemas urgentes.

#### **D√çA 1: La Gran Refundaci√≥n (Cimientos del Backend)**

- **Estado:** `PENDIENTE`
- **Objetivo:** Modificar el `schema.prisma` para dar soporte a TODAS las nuevas funcionalidades de la v1.0. Es el paso m√°s cr√≠tico y bloqueante.
- **Tareas T√©cnicas:**
  - **Motor Financiero:** A√±adir campos `salePrice` (PVP), `taxRate` (IVA), `monthlyFee` (Cuota Fija) y `billingModel` (Modelo de Contrato).
  - **Precios Avanzados:** Crear los nuevos modelos `ProductCategory` (para familias de productos) y `ClientProductPricing` (para reglas de descuento).
  - **Historial de Pagos:** Crear el nuevo modelo `Payment` para registrar los pagos de los clientes.
  - **Gastos Adicionales:** Crear el nuevo modelo `Expense` para el registro de gastos manuales.
  - **Actualizar Seed:** Modificar el script de `seed.ts` para generar datos de prueba realistas para toda esta nueva estructura.

#### **D√çA 2: Construcci√≥n de APIs y L√≥gica de Negocio (Backend)**

- **Estado:** `PENDIENTE`
- **Objetivo:** Desarrollar todos los endpoints de la API necesarios.
- **Tareas T√©cnicas:**
  - **API Financiera:** Crear los endpoints para gestionar las reglas de precios, gastos y pagos.
  - **API de Alertas:** Implementar la l√≥gica en `visits.service.ts` para comprobar umbrales de par√°metros y crear las notificaciones de alerta.
  - **API de Dashboard:** Crear los endpoints de agregaci√≥n de datos para los KPIs del Dashboard de Gerencia.
  - **Evoluci√≥n de Informes:** Actualizar el `reports.service.ts` para generar el "Informe para Facturaci√≥n".

#### **D√çA 3: Marat√≥n de Frontend e Integraci√≥n Final**

- **Estado:** `PENDIENTE`
- **Objetivo:** Construir todas las interfaces de usuario necesarias.
- **Tareas T√©cnicas:**
  - **Ficha de Cliente:** A√±adir la secci√≥n de "Configuraci√≥n de Facturaci√≥n".
  - **P√°gina de Informes:** Implementar el selector de modo ("Rentabilidad" vs "Facturaci√≥n").
  - **Historial de Pagos:** A√±adir la pesta√±a y formulario de pagos en la ficha del cliente.
  - **Dashboard de Gerencia:** Construir la primera versi√≥n del `ManagerDashboard.tsx` con los KPIs principales y el "Selector de Vista".

### **Tareas de Refinamiento (Post-v1.0)**

Estas son las tareas que ten√≠amos pendientes del hito anterior. Se abordar√°n despu√©s del sprint de la v1.0 para pulir la aplicaci√≥n.

- **Refinamiento de UI del M√≥dulo de Incidencias:** Realizar una pasada de pulido visual sobre la interfaz de `IncidentDetailPage`.
- **Mejora a Notificaciones en Tiempo Real:** Implementar WebSockets para que la campana de notificaciones se actualice de forma instant√°nea.

---

## 4. Bloqueos Actuales

- **ESTADO:** `SIN BLOQUEOS`
- **Descripci√≥n:** El bloqueo cr√≠tico de frontend que afectaba al m√≥dulo de incidencias ha sido **resuelto**. No existen impedimentos t√©cnicos para comenzar la implementaci√≥n del plan.



// ====== [3] README.md ======
# Pool-Control Professional: Especificaci√≥n Funcional y Arquitect√≥nica v10.0

| **Documentos de Apoyo:** | [Ver Plan de Desarrollo Estrat√©gico](./DEVELOPMENT_PLAN.md) | [Ver Estado Actual del Proyecto](./PROJECT_STATUS.md) |
| :----------------------- | :---------------------------------------------------------- | :---------------------------------------------------- |

---

**Fecha de la Versi√≥n:** 13 de julio de 2025
**Proyecto:** Plataforma SaaS de Gesti√≥n Integral para Empresas de Mantenimiento de Piscinas.

---

## 1. üéØ Visi√≥n del Producto: El Sistema Nervioso Inteligente de su Negocio

**Pool-Control Professional** no es una aplicaci√≥n de gesti√≥n m√°s; es una plataforma SaaS (Software como Servicio) concebida para ser el **centro de operaciones digital, proactivo e inteligente** que impulsa a las empresas de mantenimiento de piscinas hacia una nueva era de eficiencia, control y rentabilidad.

Nuestra misi√≥n es erradicar las ineficiencias sist√©micas que lastran al sector: la dependencia del papel y la desorganizaci√≥n, la comunicaci√≥n fragmentada que causa errores costosos, la falta de control sobre los costes de materiales y, sobre todo, la incapacidad de tomar decisiones estrat√©gicas basadas en datos. A trav√©s de la digitalizaci√≥n, la automatizaci√≥n y la **inteligencia de negocio**, transformamos la gesti√≥n reactiva en una **operativa estandarizada, medible y, fundamentalmente, m√°s rentable.**

---

## 2. üë• Definici√≥n de Roles: Un Ecosistema Conectado y Flexible

La plataforma se fundamenta en un sistema de roles dise√±ado para que cada miembro del equipo tenga exactamente las herramientas que necesita, maximizando la eficiencia y la seguridad.

| Rol                  | Misi√≥n Principal                        | Capacidades Clave y Flujo de Trabajo Detallado                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| :------------------- | :-------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **SuperAdmin**       | **Gestionar la Plataforma SaaS.**       | Responsable del ciclo de vida de los tenants (las empresas clientes). Realiza el CRUD completo sobre los **Tenants** y crea el usuario `ADMIN` inicial para cada nueva empresa. Por dise√±o, no tiene visibilidad alguna sobre los datos operativos de sus clientes, garantizando la m√°xima privacidad.                                                                                                                                                                                                                                                                                                                                                                              |
| **Admin (Isa)**      | **Orquestar la Operativa y Finanzas.**  | Es la "Arquitecta del Servicio". Su misi√≥n es configurar, planificar, supervisar y analizar. Define los cat√°logos de **servicios** y **productos**, gestiona **clientes** y **piscinas**, dise√±a las **fichas de mantenimiento**, establece los **modelos de facturaci√≥n** y reglas de precios para cada cliente, planifica las **rutas semanales**, gestiona proactivamente las **incidencias** a trav√©s de un sistema de ticketing avanzado y analiza la **rentabilidad** con informes detallados.                                                                                                                                                                                |
| **T√©cnico**          | **Ejecutar con Precisi√≥n en Campo.**    | Su interfaz est√° 100% optimizada para la eficiencia en movilidad. Su flujo es simple y directo: consultar su **ruta de trabajo del d√≠a** (visitas y tareas especiales), rellenar el **parte de trabajo din√°mico** (mediciones, tareas, consumo de productos) y reportar cualquier **incidencia** con notas y fotograf√≠as. Es notificado de cualquier actualizaci√≥n sobre sus tareas, manteniendo una comunicaci√≥n fluida con la oficina.                                                                                                                                                                                                                                            |
| **Gerencia (Jorge)** | **Analizar y Actuar sobre el Negocio.** | üëë **El Rol "Camale√≥n"**. Este es el rol m√°s potente y flexible, dise√±ado para el propietario o gerente del negocio. Por defecto, opera en un **Modo Supervisor** de solo lectura, enfocado en el an√°lisis estrat√©gico a trav√©s de un dashboard con KPIs de alto nivel. Sin embargo, su caracter√≠stica clave es el **"Selector de Vista"**: en caso de necesidad (ej. cubrir una baja), el gerente puede asumir temporalmente la **Vista de Administraci√≥n** o la **Vista de T√©cnico**, heredando todas sus funcionalidades. Cada acci√≥n realizada, sin importar la vista, queda registrada con su propio usuario, garantizando una auditor√≠a completa y una responsabilidad total. |

---

## 3. ‚öôÔ∏è Especificaci√≥n Funcional: El Ciclo Virtuoso de Operaciones

El sistema opera como un ciclo continuo y perfectamente enlazado: **CONFIGURAR ‚ûî PLANIFICAR ‚ûî EJECUTAR ‚ûî SUPERVISAR ‚ûî ANALIZAR**.

### **ETAPA 1: CONFIGURACI√ìN (El Cerebro Financiero y Operativo)**

_Rol: Admin_

- **Pantallas de Cat√°logos:** Aqu√≠ se define el ADN de la empresa.

  - **Productos:** Se gestiona el inventario, definiendo para cada producto su `coste` (para rentabilidad interna), su `salePrice` (PVP para el cliente), su `taxRate` (IVA) y su `ProductCategory` (familia).
  - **Par√°metros y Tareas:** Se crea la librer√≠a de mediciones y acciones, definiendo tipos de datos, unidades y los **umbrales de alerta** (m√≠n/m√°x) que activar√°n las notificaciones proactivas.

- **Ficha del Cliente (`ClientDetailPage`):** Mucho m√°s que datos de contacto, es el centro de la relaci√≥n comercial.
  - **Configuraci√≥n Financiera:** Se establece la `monthlyFee` (cuota fija) y el `billingModel` (modelo de contrato: `Todo Incluido`, `Cuota + Materiales`, etc.).
  - **Reglas de Precios:** Se definen descuentos personalizados para ese cliente, ya sea sobre productos espec√≠ficos o sobre familias enteras de productos (ej. "100% de descuento en toda la familia de 'Cloros'").

### **ETAPA 2: PLANIFICACI√ìN Y EJECUCI√ìN (El Coraz√≥n Operativo)**

_Roles: Admin, T√©cnico_

- **Planificador Semanal (`PlannerPage`):** Una interfaz visual `Drag & Drop` donde el `ADMIN` asigna visitas. La interfaz ofrece feedback visual instant√°neo sobre el estado de las visitas (verde para OK, rojo para incidencia).
- **Parte de Trabajo Din√°mico (`WorkOrderPage`):** La herramienta de campo del t√©cnico. Un formulario inteligente generado a partir de la ficha de la piscina. El t√©cnico registra valores y consumos, y puede reportar una **incidencia** con notas detalladas y **m√∫ltiples fotograf√≠as**.

### **ETAPA 3: SUPERVISI√ìN Y GESTI√ìN DE INCIDENCIAS (Control de Calidad Proactivo)**

_Roles: Admin, Gerencia, T√©cnico_

- **Dashboard del Administrador (`AdminDashboard`):** Una "torre de control" con widgets en tiempo real. Las **visitas son clicables** para un acceso directo al parte. Las incidencias activas se resaltan con un **borde rojo intenso** si son cr√≠ticas.
- **Gesti√≥n de Incidencias Avanzada (`IncidentDetailPage`):** Un centro de mando para la resoluci√≥n de problemas. El `ADMIN` puede crear **Tareas de Seguimiento (`IncidentTask`)** y asignarlas a **cualquier usuario**. Se establece un **hilo de comunicaci√≥n bidireccional** con notificaciones autom√°ticas para cada comentario o cambio de estado, y todas las acciones quedan registradas en un **historial de auditor√≠a inmutable**.

### **ETAPA 4: AN√ÅLISIS Y GESTI√ìN FINANCIERA (Inteligencia de Negocio)**

_Roles: Admin, Gerencia_

- **P√°gina de Informes (`ConsumptionReportPage`):**
  - **Doble Visi√≥n:** Permite generar tanto un **Informe de Rentabilidad Interna** (basado en `coste` y gastos) como un **Informe para Facturaci√≥n** (basado en `salePrice`, `monthlyFee` y reglas de descuento).
  - **Desglose Interactivo Total (Drill-Down):** Permite auditar un dato desde el nivel m√°s alto hasta el origen: `Coste Total Cliente ‚ûî Desglose por Producto ‚ûî Lista de Visitas con ese consumo ‚ûî Parte de Trabajo original`.
  - **Exportaci√≥n a CSV:** Permite descargar los datos para su uso en programas de contabilidad.
- **Registro de Pagos y Saldos:** En la ficha del cliente, se podr√° registrar pagos y visualizar un historial, manteniendo un control claro sobre los saldos pendientes.

---

## 4. üó∫Ô∏è Hoja de Ruta y Visi√≥n de Futuro

### **Sprint Final v1.0 (Pr√≥ximos 3 D√≠as)**

Nuestro enfoque inmediato para tener una versi√≥n de presentaci√≥n incre√≠blemente potente.

- **Dashboard de Gerencia Avanzado:** Implementar la vista principal para el rol `MANAGER`, con KPIs y el "Selector de Vista".
- **Motor Financiero Completo:** Implementar la l√≥gica para manejar `Precios de Venta`, `IVA`, `Modelos de Facturaci√≥n` y `Reglas de Descuento`.
- **Alertas Proactivas por Umbrales:** Desarrollar la l√≥gica para notificar autom√°ticamente cuando los par√°metros se salgan de los rangos de seguridad.
- **Historial de Pagos y Saldos:** Implementar la capacidad de registrar pagos y visualizar el estado de cuenta de un cliente.

### **Visi√≥n Post-v1.0**

- **Gesti√≥n de Inventario y Compras:** Un m√≥dulo completo para controlar el stock, definir m√≠nimos/m√°ximos y generar informes de necesidades o propuestas de compra.
- **Modo Offline (PWA):** Permitir a los t√©cnicos trabajar sin conexi√≥n a internet.

### **Visi√≥n a Largo Plazo**

- **M√≥dulo de Facturaci√≥n y Contabilidad Completo:** La evoluci√≥n final. Permitir√≠a generar facturas con validez legal, gestionar impuestos, crear presupuestos y pedidos, y adaptarse a las normativas contables de diferentes pa√≠ses, convirtiendo a Pool-Control Professional en una soluci√≥n ERP todo en uno para el sector.



// ====== [4] package.json ======
{
  "name": "pool-control-professional",
  "private": true,
  "version": "1.0.0",
  "description": "SaaS para la gesti√≥n integral de empresas de mantenimiento de piscinas.",
  "author": "",
  "license": "ISC",
  "scripts": {
    "dev:server": "pnpm --filter @pool-control/server dev",
    "dev:client": "pnpm --filter @pool-control/client dev",
    "build": "pnpm --filter \"./packages/**\" build",
    "prisma:generate": "pnpm --filter @pool-control/server prisma:generate",
    "prisma:migrate": "pnpm --filter @pool-control/server prisma:migrate --",
    "prisma:studio": "pnpm --filter @pool-control/server prisma:studio",
    "db:reset": "pnpm prisma:migrate reset --skip-seed --force && pnpm --filter @pool-control/server db:seed"
  },
  "devDependencies": {
    "typescript": "^5.4.5"
  },
  "engines": {
    "node": ">=20.0.0",
    "pnpm": ">=9.0.0"
  }
}


// ====== [5] packages/client/index.html ======
<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pool-Control Professional</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


// ====== [6] packages/client/package.json ======
{
  "name": "@pool-control/client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite --host",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "@dnd-kit/core": "^6.3.1",
    "@mantine/core": "^8.1.3",
    "@mantine/dates": "^8.1.3",
    "@mantine/form": "^8.1.3",
    "@mantine/hooks": "^8.1.3",
    "axios": "^1.7.2",
    "chart.js": "^4.5.0",
    "date-fns": "^4.1.0",
    "dayjs": "^1.11.13",
    "react": "^18.3.1",
    "react-chartjs-2": "^5.3.0",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.23.1",
    "zustand": "^5.0.6"
  },
  "devDependencies": {
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@typescript-eslint/eslint-plugin": "^7.13.0",
    "@typescript-eslint/parser": "^7.13.0",
    "@vitejs/plugin-react": "^4.3.1",
    "eslint": "^8.57.0",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-react-refresh": "0.4.7",
    "typescript": "^5.4.5",
    "vite": "^5.3.1"
  }
}


// ====== [7] packages/client/src/App.tsx ======
import { MantineProvider } from '@mantine/core';
import { RouterProvider } from 'react-router-dom';
import { theme } from './styles/theme.js';
import { router } from './router/index.js';
import { AuthProvider } from './providers/AuthProvider.js';

// Importa los estilos base de Mantine
import '@mantine/core/styles.css';

function App() {
  return (
    <MantineProvider theme={theme}>
      <AuthProvider>
        <RouterProvider router={router} />
      </AuthProvider>
    </MantineProvider>
  );
}

export default App;


// ====== [8] packages/client/src/api/apiClient.ts ======
// filename: packages/client/src/api/apiClient.ts
// version: 2.0.0 (FEAT: Add interceptor for Manager role view)

import axios from 'axios';

// Importamos el store de Zustand que crearemos a continuaci√≥n.
// Es una soluci√≥n m√°s limpia que importar el hook useAuth fuera de un componente.
import { useAuthStore } from '../stores/auth.store.js';

const apiClient = axios.create({
  baseURL: '/api',
  withCredentials: true,
});

// --- ‚úÖ NUEVO INTERCEPTOR ---
// Este c√≥digo se ejecuta antes de CADA petici√≥n que se haga con apiClient.
apiClient.interceptors.request.use(
  (config) => {
    // Obtenemos el estado actual del store de autenticaci√≥n.
    const { user, activeView } = useAuthStore.getState();

    // Si el usuario es un MANAGER y la vista activa NO es 'MANAGER',
    // a√±adimos la cabecera especial.
    if (user?.role === 'MANAGER' && activeView !== 'MANAGER') {
      config.headers['X-View-As-Role'] = activeView;
    }
    
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);


export default apiClient;


// ====== [9] packages/client/src/features/admin/pages/AdminDashboard.tsx ======
// filename: packages/client/src/features/admin/pages/AdminDashboard.tsx
// version: 2.0.0 (FEAT: Clickable visits and critical incident highlighting)

import { useEffect, useState } from 'react';
import { Container, Title, Grid, Paper, Text, Badge, Loader, Alert, Stack } from '@mantine/core';
import { useNavigate } from 'react-router-dom';
import apiClient from '../../../api/apiClient';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';

// --- Tipos de Datos ---
interface Visit {
  id: string;
  timestamp: string;
  status: 'PENDING' | 'COMPLETED' | 'CANCELLED';
  pool: { name: string; client: { name:string } };
  technician: { name: string } | null;
}

// ‚úÖ Se a√±ade isCritical al tipo de notificaci√≥n del frontend
interface Notification {
  id: string;
  message: string;
  visitId: string | null;
  isCritical: boolean;
}

// --- Componente Principal ---
export function AdminDashboard() {
  const [visits, setVisits] = useState<Visit[]>([]);
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const navigate = useNavigate();

  useEffect(() => {
    const fetchData = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const [visitsResponse, notificationsResponse] = await Promise.all([
          apiClient.get('/visits/scheduled', { params: { date: new Date().toISOString() } }),
          // Usamos el endpoint de historial para obtener el flag 'isCritical'
          apiClient.get('/notifications/history') 
        ]);
        
        const today = new Date().toDateString();
        const todayVisits = visitsResponse.data.data.filter((v: Visit) => 
            new Date(v.timestamp).toDateString() === today
        );
        
        // El endpoint de historial ya nos da las notificaciones con el flag 'isCritical'
        const allNotifications = notificationsResponse.data.data.notifications;
        // Mostramos solo las que est√°n pendientes en el dashboard
        const pendingNotifications = allNotifications.filter((n: any) => n.status === 'PENDING');

        setVisits(todayVisits);
        setNotifications(pendingNotifications);
      } catch (err) {
        setError('No se pudo cargar la informaci√≥n del dashboard.');
        console.error(err);
      } finally {
        setIsLoading(false);
      }
    };

    fetchData();
  }, []);

  const handleCardClick = (path: string) => {
    navigate(path);
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  return (
    <Container fluid>
      <Title order={2} mb="xl">
        Dashboard - {format(new Date(), 'eeee, d MMMM yyyy', { locale: es })}
      </Title>

      <Grid>
        {/* Columna de Visitas de Hoy */}
        <Grid.Col span={{ base: 12, md: 7 }}>
          <Paper withBorder p="md" shadow="sm">
            <Title order={4} mb="md">Visitas de Hoy ({visits.length})</Title>
            <Stack>
              {visits.length > 0 ? (
                visits.map(visit => (
                  <Paper 
                    key={visit.id} 
                    withBorder p="sm" radius="md"
                    // ‚úÖ Se a√±ade el manejador de click y estilos para indicar que es interactivo
                    onClick={() => handleCardClick(`/visits/${visit.id}`)}
                    style={{ 
                      cursor: 'pointer',
                      opacity: visit.status === 'COMPLETED' ? 0.65 : 1,
                    }}
                    onMouseEnter={(e) => e.currentTarget.style.boxShadow = 'var(--mantine-shadow-md)'}
                    onMouseLeave={(e) => e.currentTarget.style.boxShadow = 'none'}
                  >
                    <Grid align="center">
                      <Grid.Col span={8}>
                        <Text fw={500}>{visit.pool.name}</Text>
                        <Text size="sm" c="dimmed">{visit.pool.client.name}</Text>
                        <Text size="xs" c="dimmed">T√©cnico: {visit.technician?.name || 'Sin asignar'}</Text>
                      </Grid.Col>
                      <Grid.Col span={4} ta="right">
                        <Badge 
                          color={visit.status === 'COMPLETED' ? 'green' : 'blue'}
                          variant="light"
                        >
                          {visit.status}
                        </Badge>
                      </Grid.Col>
                    </Grid>
                  </Paper>
                ))
              ) : (
                <Text c="dimmed">No hay visitas programadas para hoy.</Text>
              )}
            </Stack>
          </Paper>
        </Grid.Col>

        {/* Columna de Incidencias */}
        <Grid.Col span={{ base: 12, md: 5 }}>
          <Paper withBorder p="md" shadow="sm">
            <Title order={4} mb="md">Incidencias Activas</Title>
             <Stack>
              {notifications.length > 0 ? (
                notifications.map(notification => (
                  <Paper 
                    key={notification.id} 
                    withBorder p="sm" radius="md" 
                    onClick={() => notification.visitId && handleCardClick(`/incidents/${notification.id}`)}
                    style={{ 
                      cursor: notification.visitId ? 'pointer' : 'default',
                      // ‚úÖ Se a√±ade el borde rojo si la incidencia es cr√≠tica
                      borderLeft: notification.isCritical ? '4px solid var(--mantine-color-red-7)' : undefined,
                    }}
                    onMouseEnter={(e) => e.currentTarget.style.boxShadow = 'var(--mantine-shadow-md)'}
                    onMouseLeave={(e) => e.currentTarget.style.boxShadow = 'none'}
                  >
                    <Text size="sm">{notification.message}</Text>
                  </Paper>
                ))
              ) : (
                <Text c="dimmed">No hay incidencias activas.</Text>
              )}
            </Stack>
          </Paper>
        </Grid.Col>
      </Grid>
    </Container>
  );
}


// ====== [10] packages/client/src/features/admin/pages/IncidentsHistoryPage.tsx ======
// filename: packages/client/src/features/admin/pages/IncidentsHistoryPage.tsx
// version: 2.3.0
// description: Convierte las filas de la tabla en enlaces a la nueva p√°gina de detalles de la incidencia.

import { useEffect, useState, useRef } from 'react';
import { Container, Title, Table, Loader, Alert, Badge, ActionIcon, Tooltip, Text, Select, Grid, Pagination, Center } from '@mantine/core';
import { Link, useNavigate } from 'react-router-dom';
import apiClient from '../../../api/apiClient';
import { format, formatDistanceToNow } from 'date-fns';
import { es } from 'date-fns/locale';

// --- Tipos de Datos ---
type IncidentStatus = 'PENDING' | 'RESOLVED';
type IncidentPriority = 'LOW' | 'NORMAL' | 'HIGH' | 'CRITICAL';

interface IncidentHistoryItem {
  id: string;
  createdAt: string;
  message: string;
  status: IncidentStatus;
  priority: IncidentPriority | null;
  resolutionNotes: string | null;
  isCritical: boolean;
  visit: {
    id: string;
    technician: { name: string } | null;
    pool: { name: string; client: { id: string; name: string } };
  } | null;
}

interface PaginatedResponse {
    notifications: IncidentHistoryItem[];
    total: number;
}

interface ApiResponse<T> {
    success: boolean;
    data: T;
}

// --- Mapeo de colores ---
const priorityColors: Record<IncidentPriority, string> = { LOW: 'gray', NORMAL: 'blue', HIGH: 'orange', CRITICAL: 'red' };
const statusColors: Record<IncidentStatus, string> = { PENDING: 'orange', RESOLVED: 'green' };

// --- Componente Principal ---
export function IncidentsHistoryPage() {
  const [incidents, setIncidents] = useState<IncidentHistoryItem[]>([]);
  const [clientOptions, setClientOptions] = useState<{ value: string; label: string; }[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const [activePage, setPage] = useState(1);
  const [totalPages, setTotalPages] = useState(0);
  const PAGE_SIZE = 10;

  const [filterStatus, setFilterStatus] = useState<string | null>('PENDING');
  const [filterClient, setFilterClient] = useState<string | null>(null);

  const isInitialMount = useRef(true);
  const navigate = useNavigate(); // <-- Hook para la navegaci√≥n

  useEffect(() => {
    if (!isInitialMount.current) {
        setPage(1);
    }
  }, [filterStatus, filterClient]);


  useEffect(() => {
    const fetchHistory = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const params: Record<string, any> = { page: activePage, pageSize: PAGE_SIZE, status: filterStatus, clientId: filterClient };
        Object.keys(params).forEach(key => (params[key] == null || params[key] === '') && delete params[key]);

        const response = await apiClient.get<ApiResponse<PaginatedResponse>>('/notifications/history', { params });
        
        const { notifications, total } = response.data.data;
        setIncidents(notifications);
        setTotalPages(Math.ceil(total / PAGE_SIZE));
      } catch (err) {
        setError('No se pudo cargar el historial de incidencias.');
      } finally {
        setIsLoading(false);
        isInitialMount.current = false;
      }
    };

    fetchHistory();
  }, [activePage, filterStatus, filterClient]);

  useEffect(() => {
    const fetchClients = async () => {
        try {
            const response = await apiClient.get('/clients');
            const options = response.data.data.map((client: { id: string; name: string }) => ({
                value: client.id,
                label: client.name,
            }));
            setClientOptions(options);
        } catch (error) {
            console.error("Failed to fetch clients for filter");
        }
    };
    fetchClients();
  }, []);
  
  // --- Manejador para la navegaci√≥n ---
  const handleRowClick = (notificationId: string) => {
    navigate(`/incidents/${notificationId}`);
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;
  
  const rows = incidents.map((item) => (
    <Table.Tr 
      key={item.id} 
      style={{ 
        backgroundColor: item.isCritical ? 'var(--mantine-color-red-0)' : 'transparent',
        cursor: 'pointer' // <-- Cambia el cursor para indicar que es clicable
      }}
      onClick={() => handleRowClick(item.id)} // <-- A√±adimos el evento onClick
      onMouseEnter={(e) => e.currentTarget.style.backgroundColor = 'var(--mantine-color-gray-1)'}
      onMouseLeave={(e) => e.currentTarget.style.backgroundColor = item.isCritical ? 'var(--mantine-color-red-0)' : 'transparent'}
    >
      <Table.Td>
        <Tooltip label={format(new Date(item.createdAt), 'dd/MM/yyyy HH:mm')}>
            <Text size="sm">{formatDistanceToNow(new Date(item.createdAt), { addSuffix: true, locale: es })}</Text>
        </Tooltip>
      </Table.Td>
      <Table.Td>{item.visit?.pool?.client?.name || 'N/A'}</Table.Td>
      <Table.Td>{item.visit?.pool?.name || 'N/A'}</Table.Td>
      <Table.Td>{item.visit?.technician?.name || 'N/A'}</Table.Td>
      <Table.Td>
        <Badge color={item.priority ? priorityColors[item.priority] : 'gray'}>
          {item.priority || 'SIN ASIGNAR'}
        </Badge>
      </Table.Td>
      <Table.Td>
        <Badge color={statusColors[item.status]}>
          {item.status}
        </Badge>
      </Table.Td>
      <Table.Td>
        {item.visit && (
          <Tooltip label="Ver Parte de Trabajo Original">
            {/* Detenemos la propagaci√≥n para que al hacer clic en el icono no navegue a la p√°gina de detalle de incidencia */}
            <ActionIcon component={Link} to={`/visits/${item.visit.id}`} variant="subtle" onClick={(e) => e.stopPropagation()}>
              üìÑ
            </ActionIcon>
          </Tooltip>
        )}
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <Container fluid>
      <Title order={2} my="lg">Gesti√≥n de Incidencias</Title>
      
      <Grid align="flex-end" mb="md">
        <Grid.Col span={{ base: 12, sm: 4 }}>
          <Select
            label="Filtrar por Cliente" placeholder="Todos los clientes"
            value={filterClient} onChange={setFilterClient}
            data={clientOptions} clearable
          />
        </Grid.Col>
        <Grid.Col span={{ base: 12, sm: 4 }}>
          <Select
            label="Filtrar por Estado" placeholder="Todos los estados"
            value={filterStatus} onChange={setFilterStatus}
            data={[ { value: 'PENDING', label: 'Pendientes' }, { value: 'RESOLVED', label: 'Resueltas' } ]}
            clearable
          />
        </Grid.Col>
      </Grid>
      
      <Table striped withTableBorder withColumnBorders mt="md">
        <Table.Thead>
            <Table.Tr>
              <Table.Th>Antig√ºedad</Table.Th>
              <Table.Th>Cliente</Table.Th>
              <Table.Th>Piscina</Table.Th>
              <Table.Th>T√©cnico</Table.Th>
              <Table.Th>Prioridad</Table.Th>
              <Table.Th>Estado</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
        </Table.Thead>
        <Table.Tbody>
            {rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={7}>No se han encontrado incidencias con los filtros seleccionados.</Table.Td></Table.Tr>}
        </Table.Tbody>
      </Table>
      
      {totalPages > 1 && (
          <Center mt="xl">
              <Pagination value={activePage} onChange={setPage} total={totalPages} />
          </Center>
      )}
    </Container>
  );
}


// ====== [11] packages/client/src/features/admin/pages/ParameterCatalogPage.tsx ======
// filename: packages/client/src/features/admin/pages/ParameterCatalogPage.tsx
// Version: 1.2.0 (Implement TagsInput for SELECT options in the form)
import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  Select,
  TagsInput,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient.js';

// --- Tipos ---
const InputTypes = ['NUMBER', 'BOOLEAN', 'TEXT', 'SELECT'] as const;
type InputType = (typeof InputTypes)[number];

interface ParameterTemplate {
  id: string;
  name: string;
  unit: string | null;
  type: InputType;
  selectOptions: string[];
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function ParameterCatalogPage() {
  const [templates, setTemplates] = useState<ParameterTemplate[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingTemplate, setEditingTemplate] = useState<ParameterTemplate | null>(null);

  const form = useForm({
    initialValues: {
      name: '',
      unit: '',
      type: 'NUMBER' as InputType,
      selectOptions: [] as string[],
    },
    validate: {
      name: (value: string) => (value.trim().length < 2 ? 'El nombre es demasiado corto' : null),
      type: (value: string) => (InputTypes.includes(value as InputType) ? null : 'Tipo inv√°lido'),
      selectOptions: (value: string[], values) => {
        if (values.type === 'SELECT' && value.length === 0) {
          return 'Debe definir al menos una opci√≥n para el tipo SELECT';
        }
        return null;
      }
    },
  });

  const fetchTemplates = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<ParameterTemplate[]>>('/parameters');
      setTemplates(response.data.data);
    } catch (err) {
      setError('No se pudo cargar el cat√°logo de par√°metros.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchTemplates();
  }, []);

  const handleOpenModal = (template: ParameterTemplate | null = null) => {
    setEditingTemplate(template);
    if (template) {
      form.setValues({
        name: template.name,
        unit: template.unit || '',
        type: template.type,
        selectOptions: template.selectOptions || [],
      });
    } else {
      form.reset();
    }
    openModal();
  };

  const handleSubmit = async (values: typeof form.values) => {
    const payload = {
      ...values,
      selectOptions: values.type === 'SELECT' ? values.selectOptions : [],
    };
    try {
      if (editingTemplate) {
        await apiClient.patch(`/parameters/${editingTemplate.id}`, payload);
      } else {
        await apiClient.post('/parameters', payload);
      }
      await fetchTemplates();
      closeModal();
    } catch (err: any) {
      form.setErrors({ name: err.response?.data?.message || 'Error al guardar el par√°metro' });
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar este par√°metro?')) {
      try {
        await apiClient.delete(`/parameters/${id}`);
        setTemplates((current) => current.filter((t) => t.id !== id));
      } catch (err) {
        // TODO: Mostrar notificaci√≥n de error
        console.error('Failed to delete parameter', err);
      }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = templates.map((template) => (
    <Table.Tr key={template.id}>
      <Table.Td>{template.name}</Table.Td>
      <Table.Td>{template.unit || '-'}</Table.Td>
      <Table.Td>{template.type}</Table.Td>
      <Table.Td>
        <Group gap="xs">
          <Button variant="subtle" size="xs" onClick={() => handleOpenModal(template)}>Editar</Button>
          <Button variant="subtle" size="xs" color="red" onClick={() => handleDelete(template.id)}>Eliminar</Button>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingTemplate ? 'Editar Par√°metro' : 'Crear Nuevo Par√°metro'}
        centered
      >
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="Nombre del Par√°metro" {...form.getInputProps('name')} />
            <TextInput label="Unidad (ej. ppm, pH, ¬∞C)" {...form.getInputProps('unit')} />
            <Select
              label="Tipo de Input"
              required
              data={InputTypes as unknown as string[]}
              {...form.getInputProps('type')}
            />
            {form.values.type === 'SELECT' && (
              <TagsInput
                label="Opciones del Select"
                placeholder="A√±ade opciones y presiona Enter"
                description="Escribe una opci√≥n y presiona Enter para a√±adirla a la lista."
                required
                {...form.getInputProps('selectOptions')}
              />
            )}
            <Button type="submit" mt="md">{editingTemplate ? 'Guardar Cambios' : 'Crear Par√°metro'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Cat√°logo de Par√°metros</Title>
          <Button onClick={() => handleOpenModal()}>Crear Nuevo Par√°metro</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Unidad</Table.Th>
              <Table.Th>Tipo</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={4}>No hay par√°metros definidos en el cat√°logo.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [12] packages/client/src/features/admin/pages/ProductCatalogPage.tsx ======
// filename: packages/client/src/features/admin/pages/ProductCatalogPage.tsx
// version: 1.0.0
// description: P√°gina para la gesti√≥n completa (CRUD) del cat√°logo de productos.

import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  Textarea,
  NumberInput,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient';

// --- Tipos de Datos ---
// Define la estructura de un producto, que coincide con el modelo de Prisma
interface Product {
  id: string;
  name: string;
  description: string | null;
  unit: string;
  cost: number;
}

// Define la estructura de la respuesta de nuestra API
interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente Principal ---
export function ProductCatalogPage() {
  // --- Estados del Componente ---
  const [products, setProducts] = useState<Product[]>([]); // Almacena la lista de productos
  const [isLoading, setIsLoading] = useState(true); // Controla el estado de carga
  const [error, setError] = useState<string | null>(null); // Almacena cualquier error de la API
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false); // Controla la visibilidad del modal
  const [editingProduct, setEditingProduct] = useState<Product | null>(null); // Guarda el producto que se est√° editando, o null si es una creaci√≥n

  // --- Formulario (Mantine Form) ---
  // Se encarga de la gesti√≥n de estado y validaci√≥n de los inputs del modal
  const form = useForm({
    initialValues: {
      name: '',
      description: '',
      unit: '',
      cost: 0,
    },
    validate: {
      name: (value) => (value.trim().length < 2 ? 'El nombre del producto es demasiado corto.' : null),
      unit: (value) => (value.trim().length === 0 ? 'La unidad de medida es obligatoria.' : null),
      cost: (value) => (value < 0 ? 'El coste no puede ser un valor negativo.' : null),
    },
  });

  // --- L√≥gica de Datos (API Calls) ---
  const fetchProducts = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<Product[]>>('/products');
      setProducts(response.data.data);
    } catch (err) {
      setError('No se pudo cargar el cat√°logo de productos.');
    } finally {
      setIsLoading(false);
    }
  };

  // Carga inicial de datos cuando el componente se monta
  useEffect(() => {
    fetchProducts();
  }, []);

  // --- Manejadores de Eventos ---

  // Se ejecuta al hacer clic en "A√±adir Producto" o "Editar"
  const handleOpenModal = (product: Product | null = null) => {
    setEditingProduct(product);
    if (product) {
      // Si estamos editando, llenamos el formulario con los datos del producto
      form.setValues({
        name: product.name,
        description: product.description || '',
        unit: product.unit,
        cost: product.cost,
      });
    } else {
      // Si estamos creando, reseteamos el formulario a sus valores iniciales
      form.reset();
      form.setFieldValue('cost', 0);
    }
    openModal();
  };

  // Se ejecuta al enviar el formulario del modal
  const handleSubmit = async (values: typeof form.values) => {
    try {
      if (editingProduct) {
        // Si est√°bamos editando, hacemos una petici√≥n PATCH
        await apiClient.patch(`/products/${editingProduct.id}`, values);
      } else {
        // Si est√°bamos creando, hacemos una petici√≥n POST
        await apiClient.post('/products', values);
      }
      // Despu√©s de la operaci√≥n, refrescamos la lista y cerramos el modal
      await fetchProducts();
      closeModal();
    } catch (err: any) {
      form.setErrors({ name: err.response?.data?.message || 'Error al guardar el producto.' });
    }
  };

  // Se ejecuta al hacer clic en el bot√≥n "Eliminar"
  const handleDelete = async (id: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar este producto? Esta acci√≥n no se puede deshacer.')) {
      try {
        await apiClient.delete(`/products/${id}`);
        // Actualizaci√≥n optimista de la UI: eliminamos el producto del estado local
        setProducts((current) => current.filter((p) => p.id !== id));
      } catch (err) {
        alert('No se pudo eliminar el producto. Es probable que ya est√© en uso en alguna visita.');
        console.error('Failed to delete product', err);
      }
    }
  };

  // --- Renderizado del Componente ---

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  // Mapeamos los datos de los productos para generar las filas de la tabla
  const rows = products.map((product) => (
    <Table.Tr key={product.id}>
      <Table.Td>{product.name}</Table.Td>
      <Table.Td>{product.description || '-'}</Table.Td>
      <Table.Td>{product.unit}</Table.Td>
      <Table.Td>{product.cost.toFixed(2)} ‚Ç¨</Table.Td>
      <Table.Td>
        <Group gap="xs">
          <Button variant="subtle" size="xs" onClick={() => handleOpenModal(product)}>Editar</Button>
          <Button variant="subtle" size="xs" color="red" onClick={() => handleDelete(product.id)}>Eliminar</Button>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingProduct ? 'Editar Producto' : 'Crear Nuevo Producto'}
        centered
      >
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="Nombre del Producto" placeholder="Ej: Hipoclorito S√≥dico 25L" {...form.getInputProps('name')} />
            <Textarea label="Descripci√≥n (opcional)" placeholder="Detalles adicionales del producto" {...form.getInputProps('description')} />
            <TextInput required label="Unidad de Medida" placeholder="Ej: L, Kg, Saco, Unidad" {...form.getInputProps('unit')} />
            <NumberInput
                required
                label="Coste por Unidad (‚Ç¨)"
                placeholder="15.50"
                decimalScale={2}
                fixedDecimalScale
                step={0.5}
                min={0}
                {...form.getInputProps('cost')}
            />
            <Button type="submit" mt="md">{editingProduct ? 'Guardar Cambios' : 'Crear Producto'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Cat√°logo de Productos</Title>
          <Button onClick={() => handleOpenModal()}>A√±adir Nuevo Producto</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Descripci√≥n</Table.Th>
              <Table.Th>Unidad</Table.Th>
              <Table.Th>Coste</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={5}>No hay productos definidos en el cat√°logo.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [13] packages/client/src/features/admin/pages/ProductCategoryCatalogPage.tsx ======
// filename: packages/client/src/features/admin/pages/ProductCategoryCatalogPage.tsx
// version: 1.0.0
// description: P√°gina para la gesti√≥n CRUD del cat√°logo de categor√≠as de productos.

import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient';

// --- Tipos de Datos ---
interface ProductCategory {
  id: string;
  name: string;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente Principal ---
export function ProductCategoryCatalogPage() {
  const [categories, setCategories] = useState<ProductCategory[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingCategory, setEditingCategory] = useState<ProductCategory | null>(null);

  const form = useForm({
    initialValues: {
      name: '',
    },
    validate: {
      name: (value) => (value.trim().length < 2 ? 'El nombre de la categor√≠a es demasiado corto.' : null),
    },
  });

  const fetchCategories = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<ProductCategory[]>>('/product-categories');
      setCategories(response.data.data);
    } catch (err) {
      setError('No se pudo cargar el cat√°logo de categor√≠as.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchCategories();
  }, []);

  const handleOpenModal = (category: ProductCategory | null = null) => {
    setEditingCategory(category);
    if (category) {
      form.setValues({ name: category.name });
    } else {
      form.reset();
    }
    openModal();
  };

  const handleSubmit = async (values: typeof form.values) => {
    try {
      if (editingCategory) {
        await apiClient.patch(`/product-categories/${editingCategory.id}`, values);
      } else {
        await apiClient.post('/product-categories', values);
      }
      await fetchCategories();
      closeModal();
    } catch (err: any) {
      form.setErrors({ name: err.response?.data?.message || 'Error al guardar la categor√≠a.' });
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar esta categor√≠a? Los productos asociados no se borrar√°n, pero quedar√°n sin categor√≠a.')) {
      try {
        await apiClient.delete(`/product-categories/${id}`);
        setCategories((current) => current.filter((c) => c.id !== id));
      } catch (err) {
        alert('No se pudo eliminar la categor√≠a.');
        console.error('Failed to delete category', err);
      }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = categories.map((category) => (
    <Table.Tr key={category.id}>
      <Table.Td>{category.name}</Table.Td>
      <Table.Td>
        <Group gap="xs">
          <Button variant="subtle" size="xs" onClick={() => handleOpenModal(category)}>Editar</Button>
          <Button variant="subtle" size="xs" color="red" onClick={() => handleDelete(category.id)}>Eliminar</Button>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingCategory ? 'Editar Categor√≠a' : 'Crear Nueva Categor√≠a'}
        centered
      >
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="Nombre de la Categor√≠a" placeholder="Ej: Qu√≠micos Reguladores" {...form.getInputProps('name')} />
            <Button type="submit" mt="md">{editingCategory ? 'Guardar Cambios' : 'Crear Categor√≠a'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Cat√°logo de Categor√≠as de Productos</Title>
          <Button onClick={() => handleOpenModal()}>Crear Nueva Categor√≠a</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={2}>No hay categor√≠as definidas en el cat√°logo.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [14] packages/client/src/features/admin/pages/TaskCatalogPage.tsx ======
// filename: packages/client/src/features/admin/pages/TaskCatalogPage.tsx
// Version: 1.0.0 (Initial implementation of the task template catalog page with full CRUD)
import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  Textarea,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient.js';

// --- Tipos ---
interface TaskTemplate {
  id: string;
  name: string;
  description: string | null;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function TaskCatalogPage() {
  const [templates, setTemplates] = useState<TaskTemplate[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingTemplate, setEditingTemplate] = useState<TaskTemplate | null>(null);

  const form = useForm({
    initialValues: {
      name: '',
      description: '',
    },
    validate: {
      name: (value: string) => (value.trim().length < 2 ? 'El nombre es demasiado corto' : null),
    },
  });

  const fetchTemplates = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<TaskTemplate[]>>('/tasks');
      setTemplates(response.data.data);
    } catch (err) {
      setError('No se pudo cargar el cat√°logo de tareas.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchTemplates();
  }, []);

  const handleOpenModal = (template: TaskTemplate | null = null) => {
    setEditingTemplate(template);
    if (template) {
      form.setValues({
        name: template.name,
        description: template.description || '',
      });
    } else {
      form.reset();
    }
    openModal();
  };

  const handleSubmit = async (values: typeof form.values) => {
    try {
      if (editingTemplate) {
        await apiClient.patch(`/tasks/${editingTemplate.id}`, values);
      } else {
        await apiClient.post('/tasks', values);
      }
      await fetchTemplates();
      closeModal();
    } catch (err: any) {
      form.setErrors({ name: err.response?.data?.message || 'Error al guardar la tarea' });
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar esta tarea?')) {
      try {
        await apiClient.delete(`/tasks/${id}`);
        setTemplates((current) => current.filter((t) => t.id !== id));
      } catch (err) {
        // TODO: Mostrar notificaci√≥n de error
        console.error('Failed to delete task', err);
      }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = templates.map((template) => (
    <Table.Tr key={template.id}>
      <Table.Td>{template.name}</Table.Td>
      <Table.Td>{template.description || '-'}</Table.Td>
      <Table.Td>
        <Group gap="xs">
          <Button variant="subtle" size="xs" onClick={() => handleOpenModal(template)}>Editar</Button>
          <Button variant="subtle" size="xs" color="red" onClick={() => handleDelete(template.id)}>Eliminar</Button>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingTemplate ? 'Editar Tarea' : 'Crear Nueva Tarea'}
        centered
      >
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="Nombre de la Tarea" {...form.getInputProps('name')} />
            <Textarea label="Descripci√≥n (opcional)" {...form.getInputProps('description')} />
            <Button type="submit" mt="md">{editingTemplate ? 'Guardar Cambios' : 'Crear Tarea'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Cat√°logo de Tareas</Title>
          <Button onClick={() => handleOpenModal()}>Crear Nueva Tarea</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Descripci√≥n</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={3}>No hay tareas definidas en el cat√°logo.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [15] packages/client/src/features/admin/pages/clients/ClientDetailPage.tsx ======
// filename: packages/client/src/features/admin/pages/clients/ClientDetailPage.tsx
// Version: 2.0.2 (FIXED)
// description: Corrige la propiedad 'precision' por 'decimalScale' en NumberInput.

import { useEffect, useState } from 'react';
import { useParams, Link } from 'react-router-dom';
import {
  Container, Title, Loader, Alert, Button, Group, Paper, Text, Table, Breadcrumbs, Modal,
  TextInput, Stack, NumberInput, Select, Anchor, Tabs, Grid,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../../api/apiClient';

// --- Tipos ---
type BillingModel = 'SERVICE_ONLY' | 'FEE_PLUS_MATERIALS' | 'ALL_INCLUSIVE';
interface Pool { id: string; name: string; address: string; volume: number | null; type: string | null; }
interface Client {
  id: string; name: string; contactPerson: string | null; email: string | null;
  phone: string | null; address: string | null; pools: Pool[];
  monthlyFee: number;
  billingModel: BillingModel;
}
interface ProductCategory { id: string; name: string; }
interface Product { id: string; name: string; }
interface PricingRule {
    id: string;
    discountPercentage: number;
    product?: { name: string };
    productCategory?: { name: string };
}
interface ApiResponse<T> { success: boolean; data: T; }

// --- Componente Principal ---
export function ClientDetailPage() {
  const { id: clientId } = useParams<{ id: string }>();
  const [client, setClient] = useState<Client | null>(null);
  const [pricingRules, setPricingRules] = useState<PricingRule[]>([]);
  const [products, setProducts] = useState<Product[]>([]);
  const [productCategories, setProductCategories] = useState<ProductCategory[]>([]);
  
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const [poolModalOpened, { open: openPoolModal, close: closePoolModal }] = useDisclosure(false);
  const [ruleModalOpened, { open: openRuleModal, close: closeRuleModal }] = useDisclosure(false);
  
  const [editingPool, setEditingPool] = useState<Pool | null>(null);

  const clientInfoForm = useForm({
    initialValues: { monthlyFee: 0, billingModel: 'SERVICE_ONLY' as BillingModel },
  });

  const poolForm = useForm({
    initialValues: { name: '', address: '', volume: null as number | null, type: '' },
    validate: {
      name: (value) => (value.trim().length < 2 ? 'El nombre es demasiado corto' : null),
      address: (value) => (value.trim().length < 5 ? 'La direcci√≥n es demasiado corta' : null),
    },
  });
  
  const ruleForm = useForm({
    initialValues: { type: 'product', targetId: '', discountPercentage: 0, },
    validate: {
        targetId: (value) => (!value ? 'Debe seleccionar un objetivo' : null),
        discountPercentage: (value) => (value <= 0 || value > 100 ? 'El descuento debe estar entre 1 y 100' : null),
    }
  });

  const fetchData = async () => {
    if (!clientId) return;
    setIsLoading(true);
    try {
      const [clientRes, rulesRes, productsRes, categoriesRes] = await Promise.all([
        apiClient.get<ApiResponse<Client>>(`/clients/${clientId}`),
        apiClient.get<ApiResponse<PricingRule[]>>(`/client-product-pricing/by-client/${clientId}`),
        apiClient.get<ApiResponse<Product[]>>('/products'),
        apiClient.get<ApiResponse<ProductCategory[]>>('/product-categories'),
      ]);
      setClient(clientRes.data.data);
      setPricingRules(rulesRes.data.data);
      setProducts(productsRes.data.data);
      setProductCategories(categoriesRes.data.data);
      clientInfoForm.setValues({
          monthlyFee: clientRes.data.data.monthlyFee,
          billingModel: clientRes.data.data.billingModel,
      });
    } catch (err) {
      setError('No se pudo cargar la informaci√≥n del cliente.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchData();
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [clientId]);
  
  const handleClientInfoSubmit = async (values: typeof clientInfoForm.values) => {
    try {
      await apiClient.patch(`/clients/${clientId}`, values);
      alert('Condiciones guardadas con √©xito');
      await fetchData();
    } catch {
      alert('Error al guardar las condiciones');
    }
  };

  const handleOpenPoolModal = (pool: Pool | null = null) => {
    setEditingPool(pool);
    if (pool) {
      poolForm.setValues({
        name: pool.name,
        address: pool.address,
        volume: pool.volume,
        type: pool.type || '',
      });
    } else {
      poolForm.reset();
    }
    openPoolModal();
  };
  
  const handlePoolSubmit = async (values: typeof poolForm.values) => {
    if (!clientId) return;
    try {
      if (editingPool) {
        await apiClient.patch(`/pools/${editingPool.id}`, { ...values, clientId });
      } else {
        await apiClient.post('/pools', { ...values, clientId });
      }
      await fetchData();
      closePoolModal();
    } catch (err) { poolForm.setErrors({ name: 'Error al guardar la piscina' }); }
  };

  const handlePoolDelete = async (poolId: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar esta piscina?')) {
      try {
        await apiClient.delete(`/pools/${poolId}`);
        await fetchData();
      } catch (err) {
        console.error('Failed to delete pool', err);
      }
    }
  };

  const handleRuleSubmit = async (values: typeof ruleForm.values) => {
    if (!clientId) return;
    const payload = {
        clientId,
        discountPercentage: values.discountPercentage,
        ...(values.type === 'product' ? { productId: values.targetId } : { productCategoryId: values.targetId })
    };
    try {
        await apiClient.post('/client-product-pricing', payload);
        await fetchData();
        closeRuleModal();
        ruleForm.reset();
    } catch { ruleForm.setErrors({ targetId: 'Error al crear la regla. ¬øQuiz√°s ya existe?' }); }
  };

  const handleRuleDelete = async (ruleId: string) => {
    if (window.confirm('¬øEliminar esta regla de precio?')) {
        try {
            await apiClient.delete(`/client-product-pricing/${ruleId}`);
            await fetchData();
        } catch { alert('No se pudo eliminar la regla.'); }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;
  if (!client) return <Alert color="yellow">Cliente no encontrado.</Alert>;

  const breadcrumbs = (<Breadcrumbs><Link to="/clients">Clientes</Link><Text>{client.name}</Text></Breadcrumbs>);
  const productOptions = products.map(p => ({ value: p.id, label: p.name }));
  const categoryOptions = productCategories.map(c => ({ value: c.id, label: c.name }));

  return (
    <>
      <Modal opened={poolModalOpened} onClose={closePoolModal} title={editingPool ? 'Editar Piscina' : 'A√±adir Piscina'} centered>
        <form onSubmit={poolForm.onSubmit(handlePoolSubmit)}>
          <Stack>
            <TextInput required label="Nombre de la Piscina" {...poolForm.getInputProps('name')} />
            <TextInput required label="Direcci√≥n de la Piscina" {...poolForm.getInputProps('address')} />
            <NumberInput label="Volumen (m¬≥)" min={0} {...poolForm.getInputProps('volume')} />
            <Select label="Tipo de Piscina" data={['Cloro', 'Sal']} {...poolForm.getInputProps('type')} />
            <Button type="submit" mt="md">{editingPool ? 'Guardar Cambios' : 'Crear Piscina'}</Button>
          </Stack>
        </form>
      </Modal>

      <Modal opened={ruleModalOpened} onClose={closeRuleModal} title="Nueva Regla de Precio" centered>
        <form onSubmit={ruleForm.onSubmit(handleRuleSubmit)}>
            <Stack>
                <Select label="Tipo de Regla" data={[{value: 'product', label: 'A un Producto'}, {value: 'category', label: 'A una Categor√≠a'}]} {...ruleForm.getInputProps('type')} />
                {ruleForm.values.type === 'product' ? (
                    <Select label="Seleccione el Producto" data={productOptions} searchable required {...ruleForm.getInputProps('targetId')} />
                ) : (
                    <Select label="Seleccione la Categor√≠a" data={categoryOptions} searchable required {...ruleForm.getInputProps('targetId')} />
                )}
                <NumberInput label="Porcentaje de Descuento (%)" min={1} max={100} required {...ruleForm.getInputProps('discountPercentage')} />
                <Button type="submit" mt="md">Crear Regla</Button>
            </Stack>
        </form>
      </Modal>

      <Container fluid>
        {breadcrumbs}
        <Title order={2} my="lg">{client.name}</Title>
        <Paper withBorder p="md" mb="xl">
          <Title order={4} mb="xs">Informaci√≥n de Contacto</Title>
          <Text><strong>Persona de contacto:</strong> {client.contactPerson || '-'}</Text>
          <Text><strong>Email:</strong> {client.email || '-'}</Text>
          <Text><strong>Tel√©fono:</strong> {client.phone || '-'}</Text>
        </Paper>
        
        <Tabs defaultValue="pools">
            <Tabs.List>
                <Tabs.Tab value="pools">Piscinas ({client.pools.length})</Tabs.Tab>
                <Tabs.Tab value="pricing">Condiciones y Precios</Tabs.Tab>
            </Tabs.List>

            <Tabs.Panel value="pools" pt="lg">
                <Group justify="space-between" align="center" mb="md">
                    <Title order={3}>Piscinas</Title>
                    <Button onClick={() => handleOpenPoolModal()}>A√±adir Piscina</Button>
                </Group>
                <Table striped withTableBorder>
                  <Table.Thead><Table.Tr><Table.Th>Nombre</Table.Th><Table.Th>Direcci√≥n</Table.Th><Table.Th>Acciones</Table.Th></Table.Tr></Table.Thead>
                  <Table.Tbody>
                    {client.pools.length > 0 ? (
                      client.pools.map(pool => (
                        <Table.Tr key={pool.id}>
                          <Table.Td><Anchor component={Link} to={`/pools/${pool.id}`}>{pool.name}</Anchor></Table.Td>
                          <Table.Td>{pool.address}</Table.Td>
                          <Table.Td>
                            <Group gap="xs">
                              <Button variant="subtle" size="xs" onClick={() => handleOpenPoolModal(pool)}>Editar</Button>
                              <Button variant="subtle" size="xs" color="red" onClick={() => handlePoolDelete(pool.id)}>Eliminar</Button>
                            </Group>
                          </Table.Td>
                        </Table.Tr>
                      ))
                    ) : (<Table.Tr><Table.Td colSpan={3}>Este cliente no tiene piscinas asociadas.</Table.Td></Table.Tr>)}
                  </Table.Tbody>
                </Table>
            </Tabs.Panel>

            <Tabs.Panel value="pricing" pt="lg">
                <Grid>
                    <Grid.Col span={{ base: 12, md: 5 }}>
                        <Paper withBorder p="md" shadow="sm">
                            <Title order={4} mb="md">Condiciones del Contrato</Title>
                            <form onSubmit={clientInfoForm.onSubmit(handleClientInfoSubmit)}>
                                <Stack>
                                    {/* --- ‚úÖ L√çNEA CORREGIDA --- */}
                                    <NumberInput label="Cuota Mensual (‚Ç¨)" decimalScale={2} fixedDecimalScale {...clientInfoForm.getInputProps('monthlyFee')} />
                                    <Select label="Modelo de Facturaci√≥n" data={['SERVICE_ONLY', 'FEE_PLUS_MATERIALS', 'ALL_INCLUSIVE']} {...clientInfoForm.getInputProps('billingModel')} />
                                    <Button type="submit">Guardar Condiciones</Button>
                                </Stack>
                            </form>
                        </Paper>
                    </Grid.Col>
                    <Grid.Col span={{ base: 12, md: 7 }}>
                        <Group justify="space-between" align="center" mb="md">
                            <Title order={4}>Reglas de Precios Personalizadas</Title>
                            <Button size="xs" onClick={openRuleModal}>+ A√±adir Regla</Button>
                        </Group>
                        <Table striped withTableBorder>
                            <Table.Thead><Table.Tr><Table.Th>Objetivo</Table.Th><Table.Th>Tipo</Table.Th><Table.Th>Descuento</Table.Th><Table.Th>Acciones</Table.Th></Table.Tr></Table.Thead>
                            <Table.Tbody>
                                {pricingRules.length > 0 ? pricingRules.map(rule => (
                                    <Table.Tr key={rule.id}>
                                        <Table.Td>{rule.product?.name || rule.productCategory?.name}</Table.Td>
                                        <Table.Td>{rule.product ? 'Producto' : 'Categor√≠a'}</Table.Td>
                                        <Table.Td>{rule.discountPercentage}%</Table.Td>
                                        <Table.Td><Button variant="subtle" color="red" size="xs" onClick={() => handleRuleDelete(rule.id)}>Eliminar</Button></Table.Td>
                                    </Table.Tr>
                                )) : <Table.Tr><Table.Td colSpan={4}>No hay reglas personalizadas.</Table.Td></Table.Tr>}
                            </Table.Tbody>
                        </Table>
                    </Grid.Col>
                </Grid>
            </Tabs.Panel>
        </Tabs>
      </Container>
    </>
  );
}


// ====== [16] packages/client/src/features/admin/pages/clients/ClientsPage.tsx ======
// filename: packages/client/src/features/admin/pages/clients/ClientsPage.tsx
// Version: 1.1.0 (Make client names link to their detail page)
import { useEffect, useState } from 'react';
import { Link } from 'react-router-dom';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  NumberInput,
  Anchor,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../../api/apiClient.js';

// --- Tipos ---
interface Client {
  id: string;
  name: string;
  contactPerson: string | null;
  email: string | null;
  phone: string | null;
  address: string | null;
  priceModifier: number;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function ClientsPage() {
  const [clients, setClients] = useState<Client[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingClient, setEditingClient] = useState<Client | null>(null);

  const form = useForm({
    initialValues: {
      name: '',
      contactPerson: '',
      email: '',
      phone: '',
      address: '',
      priceModifier: 1.0,
    },
    validate: {
      name: (value) => (value.trim().length < 2 ? 'El nombre es demasiado corto' : null),
      email: (value) => (value && !/^\S+@\S+$/.test(value) ? 'Email inv√°lido' : null),
      priceModifier: (value) => (value <= 0 ? 'El modificador debe ser mayor que 0' : null),
    },
  });

  const fetchClients = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<Client[]>>('/clients');
      setClients(response.data.data);
    } catch (err) {
      setError('No se pudo cargar la lista de clientes.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchClients();
  }, []);

  const handleOpenModal = (client: Client | null = null) => {
    setEditingClient(client);
    if (client) {
      form.setValues({
        name: client.name,
        contactPerson: client.contactPerson || '',
        email: client.email || '',
        phone: client.phone || '',
        address: client.address || '',
        priceModifier: client.priceModifier,
      });
    } else {
      form.reset();
    }
    openModal();
  };

  const handleSubmit = async (values: typeof form.values) => {
    try {
      if (editingClient) {
        await apiClient.patch(`/clients/${editingClient.id}`, values);
      } else {
        await apiClient.post('/clients', values);
      }
      await fetchClients();
      closeModal();
    } catch (err: any) {
      form.setErrors({ name: err.response?.data?.message || 'Error al guardar el cliente' });
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar este cliente? Se borrar√°n tambi√©n todas sus piscinas asociadas.')) {
      try {
        await apiClient.delete(`/clients/${id}`);
        setClients((current) => current.filter((c) => c.id !== id));
      } catch (err) {
        console.error('Failed to delete client', err);
      }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = clients.map((client) => (
    <Table.Tr key={client.id}>
      <Table.Td>
        <Anchor component={Link} to={`/clients/${client.id}`}>
          {client.name}
        </Anchor>
      </Table.Td>
      <Table.Td>{client.contactPerson || '-'}</Table.Td>
      <Table.Td>{client.phone || '-'}</Table.Td>
      <Table.Td>{client.email || '-'}</Table.Td>
      <Table.Td>
        <Group gap="xs">
          <Button variant="subtle" size="xs" onClick={() => handleOpenModal(client)}>Editar</Button>
          <Button variant="subtle" size="xs" color="red" onClick={() => handleDelete(client.id)}>Eliminar</Button>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingClient ? 'Editar Cliente' : 'Crear Nuevo Cliente'}
        centered
      >
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="Nombre del Cliente" {...form.getInputProps('name')} />
            <TextInput label="Persona de Contacto" {...form.getInputProps('contactPerson')} />
            <TextInput label="Email" type="email" {...form.getInputProps('email')} />
            <TextInput label="Tel√©fono" {...form.getInputProps('phone')} />
            <TextInput label="Direcci√≥n" {...form.getInputProps('address')} />
            <NumberInput 
              label="Modificador de Precio" 
              description="1.0 es normal, 0.9 es 10% dto, 1.1 es 10% recargo." 
              defaultValue={1.0} 
              step={0.05} 
              min={0} 
              decimalScale={2} 
              {...form.getInputProps('priceModifier')} 
            />
            <Button type="submit" mt="md">{editingClient ? 'Guardar Cambios' : 'Crear Cliente'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Gesti√≥n de Clientes</Title>
          <Button onClick={() => handleOpenModal()}>Crear Nuevo Cliente</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Contacto</Table.Th>
              <Table.Th>Tel√©fono</Table.Th>
              <Table.Th>Email</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={5}>No hay clientes creados.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [17] packages/client/src/features/admin/pages/incidents/IncidentDetailPage.tsx ======
// filename: packages/client/src/features/admin/pages/incidents/IncidentDetailPage.tsx
// version: 2.8.0 (Cleaned)

import { useEffect, useState } from 'react';
import { useParams, Link } from 'react-router-dom';
import {
  Container, Title, Loader, Alert, Paper, Text, Breadcrumbs, Button, Group,
  Modal, TextInput, Stack, Textarea, Select, Badge, Card, ActionIcon, Divider, SimpleGrid, Image, Tooltip
} from '@mantine/core';
import { DateTimePicker } from '@mantine/dates';
import 'dayjs/locale/es';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../../api/apiClient';
import { format, parse } from 'date-fns';
import { es } from 'date-fns/locale';
import { useAuth } from '../../../../providers/AuthProvider';

// --- Tipos, Interfaces y Mapeos ---
type IncidentStatus = 'PENDING' | 'RESOLVED';
type IncidentPriority = 'LOW' | 'NORMAL' | 'HIGH' | 'CRITICAL';
type IncidentTaskStatus = 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'CANCELLED';
type LogAction = 'CREATION' | 'STATUS_CHANGE' | 'COMMENT' | 'DEADLINE_REQUEST' | 'DEADLINE_UPDATE';

interface User { id: string; name: string; }
interface IncidentImage { id: string; url: string; }
interface IncidentTaskLog { id: string, action: LogAction, details: string, createdAt: string, user: { name: string } }
interface IncidentTask {
  id: string; title: string; description: string | null; status: IncidentTaskStatus;
  priority: IncidentPriority; deadline: string | null; assignedTo: User | null; resolutionNotes: string | null;
}
interface NotificationDetails {
  id:string; message: string; status: IncidentStatus; priority: IncidentPriority | null; createdAt: string;
  images: IncidentImage[];
  visit: { id: string; pool: { name: string; }; technician: { name: string } | null; } | null;
}
interface ApiResponse<T> { success: boolean; data: T; }
const taskStatusColors: Record<IncidentTaskStatus, string> = { PENDING: 'gray', IN_PROGRESS: 'blue', COMPLETED: 'green', CANCELLED: 'red' };
const priorityColors: Record<IncidentPriority, string> = { LOW: 'gray', NORMAL: 'blue', HIGH: 'orange', CRITICAL: 'red' };

// ===================================================================
// --- VISTA PARA EL T√âCNICO ---
// ===================================================================
const TechnicianTaskView = ({ tasks, onUpdate }: { tasks: IncidentTask[], onUpdate: () => void }) => {
  const { user } = useAuth();
  const myTask = tasks.find(t => t.assignedTo?.id === user?.id);

  const [comment, setComment] = useState('');
  const [newDeadline, setNewDeadline] = useState<Date | null>(null);
  const [logs, setLogs] = useState<IncidentTaskLog[]>([]);
  const [showHistory, setShowHistory] = useState(false);
  
  const handleStatusChange = async (status: IncidentTaskStatus, resolutionNotes?: string) => {
    if (!myTask) return;
    await apiClient.patch(`/incident-tasks/${myTask.id}/status`, { status, resolutionNotes });
    onUpdate();
  };

  const fetchLogs = async () => {
    if (!myTask) return;
    try {
      const response = await apiClient.get<ApiResponse<IncidentTaskLog[]>>(`/incident-tasks/${myTask.id}/logs`);
      setLogs(response.data.data);
    } catch {
      alert('No se pudo cargar el historial de la tarea.');
    }
  };

  const handleAddLog = async () => {
    if (!myTask || !comment) return;
    await apiClient.post(`/incident-tasks/${myTask.id}/log`, {
      details: comment,
      newDeadline: newDeadline instanceof Date ? newDeadline.toISOString() : undefined,
    });
    setComment('');
    setNewDeadline(null);
    if(showHistory) {
      fetchLogs();
    }
  };

  const toggleHistory = () => {
    const willBeOpen = !showHistory;
    setShowHistory(willBeOpen);
    if (willBeOpen && logs.length === 0) {
      fetchLogs();
    }
  };

  if (!myTask) {
    return <Alert color="orange">No tienes una tarea espec√≠fica asignada para esta incidencia.</Alert>
  }

  const isOverdue = myTask.deadline && new Date(myTask.deadline) < new Date() && myTask.status !== 'COMPLETED';

  return (
    <Stack>
      <Title order={3}>Tarea Asignada: {myTask.title}</Title>
      <Text c="dimmed">{myTask.description}</Text>
      <Group>
        <Badge color={taskStatusColors[myTask.status]}>{myTask.status}</Badge>
        <Badge color={priorityColors[myTask.priority]}>Prioridad: {myTask.priority}</Badge>
        <Button variant="subtle" size="xs" onClick={toggleHistory}>
          {showHistory ? 'Ocultar Historial' : 'Ver Historial'}
        </Button>
      </Group>

      {myTask.deadline && (
       <Text size="sm" c={isOverdue ? 'red' : 'dimmed'} fw={isOverdue ? 700 : 400} mt="xs">
          Plazo: {format(new Date(myTask.deadline), 'eeee, d MMMM yyyy, HH:mm', { locale: es })} {isOverdue && '(VENCIDA)'}
        </Text>
      )}

      {showHistory && (
        <Paper withBorder p="md" mt="sm">
            <Title order={5} mb="sm">Historial de la Tarea</Title>
            <Stack gap="xs">
                {logs.length > 0 
                    ? logs.map(log => (
                        <Paper key={log.id} p="xs" bg="gray.0" radius="sm">
                            <Text size="xs">
                                <strong>{log.user.name}</strong> ({format(new Date(log.createdAt), 'dd/MM HH:mm')})
                            </Text>
                            <Text size="sm" mt={4}>{log.details}</Text>
                        </Paper>
                    ))
                    : <Text size="sm" c="dimmed">No hay entradas en el historial.</Text>
                }
            </Stack>
        </Paper>
      )}

      <Paper withBorder p="md" mt="lg">
        <Title order={4} mb="md">Acciones</Title>
        <Group>
          <Button disabled={myTask.status !== 'PENDING'} onClick={() => handleStatusChange('IN_PROGRESS')}>Empezar Tarea</Button>
          <Button color="green" disabled={myTask.status === 'COMPLETED'} onClick={() => {
            const notes = prompt("A√±ade notas de resoluci√≥n para completar la tarea:");
            if (notes) handleStatusChange('COMPLETED', notes);
          }}>Completar Tarea</Button>
        </Group>

        <Divider my="lg" label="A√±adir Actualizaci√≥n o Solicitar Aplazamiento" />
        <Textarea
          placeholder="Ej: No hay stock de la pieza necesaria..."
          label="Comentario"
          value={comment}
          onChange={(e) => setComment(e.currentTarget.value)}
        />
        <DateTimePicker
          label="Sugerir nuevo plazo (opcional)"
          locale="es"
          clearable
          value={newDeadline}
          onChange={setNewDeadline as any}
          mt="sm"
        />
        <Button mt="md" onClick={handleAddLog} disabled={!comment}>Enviar Actualizaci√≥n</Button>
      </Paper>
    </Stack>
  );
};


// ===================================================================
// --- VISTA PARA EL ADMIN ---
// ===================================================================
const AdminIncidentView = ({ notification, tasks, technicians, onUpdate }: { notification: NotificationDetails, tasks: IncidentTask[], technicians: User[], onUpdate: () => void }) => {
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingTask, setEditingTask] = useState<IncidentTask | null>(null);
  const [logs, setLogs] = useState<IncidentTaskLog[]>([]);
  const [selectedTaskForLogs, setSelectedTaskForLogs] = useState<IncidentTask | null>(null);
  const [adminComment, setAdminComment] = useState('');
  
  const form = useForm({
    initialValues: {
      title: '', description: '', priority: 'NORMAL' as IncidentPriority,
      assignedToId: null as string | null, deadline: null as Date | null,
    },
    validate: { title: (value) => (value.trim().length < 5 ? 'El t√≠tulo es demasiado corto.' : null) },
  });

  const handleOpenModal = (task: IncidentTask | null = null) => {
    setEditingTask(task);
    if (task) {
      const deadlineDate = task.deadline ? new Date(task.deadline) : null;
      form.setValues({
        title: task.title, description: task.description || '', priority: task.priority,
        assignedToId: task.assignedTo?.id || null, deadline: deadlineDate,
      });
    } else {
      form.reset();
      form.setFieldValue('priority', 'NORMAL');
    }
    openModal();
  };

  const handleSubmit = async (values: typeof form.values) => {
    const isNewTask = !editingTask;
    const taskId = isNewTask ? null : editingTask.id;

    const payload: { [key: string]: any } = {
      title: values.title,
      description: values.description,
      priority: values.priority,
      assignedToId: values.assignedToId,
      deadline: values.deadline instanceof Date ? values.deadline.toISOString() : null,
    };

    try {
      if (isNewTask) {
        await apiClient.post('/incident-tasks', { ...payload, notificationId: notification.id });
      } else {
        await apiClient.patch(`/incident-tasks/${taskId}`, payload);
      }
      onUpdate();
      closeModal();
    } catch (err: any) {
      form.setErrors({ title: err.response?.data?.message || 'Error al guardar la tarea.' });
    }
  };

  const handleDelete = async (taskId: string) => {
    if (window.confirm('¬øEst√°s seguro?')) { try { await apiClient.delete(`/incident-tasks/${taskId}`); onUpdate(); } catch (err) { alert('No se pudo eliminar la tarea.'); } }
  };

  const handleViewLogs = async (task: IncidentTask) => {
    if (selectedTaskForLogs?.id === task.id) {
      setSelectedTaskForLogs(null);
      setLogs([]);
      return;
    }
    setSelectedTaskForLogs(task);
    try {
      const response = await apiClient.get<ApiResponse<IncidentTaskLog[]>>(`/incident-tasks/${task.id}/logs`);
      setLogs(response.data.data);
    } catch {
      alert('No se pudo cargar el historial de la tarea.');
    }
  };

  useEffect(() => {
    if (tasks.length === 1 && !selectedTaskForLogs) {
      if (tasks[0]) {
        handleViewLogs(tasks[0]);
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [tasks]); 
  
  const handleAcceptDeadline = async (taskId: string, logDetails: string) => {
    const dateString = logDetails.split('para: ')[1];
    if (!dateString) return;
    const newDate = parse(dateString.replace(' a las', ''), "d MMMM yyyy HH:mm", new Date(), { locale: es });
    if (isNaN(newDate.getTime())) return;
    
    try {
      await apiClient.patch(`/incident-tasks/${taskId}/deadline`, { deadline: newDate.toISOString() });
      onUpdate();
    } catch {
      alert('No se pudo aceptar el nuevo plazo.');
    }
  };

  const handleAdminComment = async (taskId: string) => {
    if (!adminComment.trim()) return;
    try {
      await apiClient.post(`/incident-tasks/${taskId}/log`, { details: adminComment });
      setAdminComment('');
      const taskToUpdate = tasks.find(t => t.id === taskId);
      if (taskToUpdate) {
        handleViewLogs(taskToUpdate);
      }
      onUpdate();
    } catch {
      alert('No se pudo enviar el comentario.');
    }
  };
  
  const technicianOptions = technicians.map(t => ({ value: t.id, label: t.name }));

  const renderLogEntry = (log: IncidentTaskLog, taskId: string) => {
    const isRequest = log.action === 'DEADLINE_REQUEST';
    return (
        <Paper key={log.id} p="xs" withBorder={isRequest} shadow={isRequest ? "sm" : "none"} radius="md" bg={isRequest ? 'blue.0' : 'gray.0'}>
            <Text size="xs">
                <strong>{log.user.name}</strong> ({format(new Date(log.createdAt), 'dd/MM HH:mm', { locale: es })})
            </Text>
            <Text size="sm" mt={4}>{log.details}</Text>
            {isRequest && (
                <Group mt="xs">
                    <Button size="xs" color="green" onClick={() => handleAcceptDeadline(taskId, log.details)}>Aceptar Plazo</Button>
                </Group>
            )}
        </Paper>
    );
  };

  return (
    <>
      <Modal opened={modalOpened} onClose={closeModal} title={editingTask ? 'Editar Tarea' : 'Crear Tarea'} centered>
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="T√≠tulo" {...form.getInputProps('title')} />
            <Textarea label="Descripci√≥n" {...form.getInputProps('description')} />
            <Select label="Prioridad" data={['LOW', 'NORMAL', 'HIGH', 'CRITICAL']} required {...form.getInputProps('priority')} />
            <Select label="Asignar a" data={technicianOptions} clearable {...form.getInputProps('assignedToId')} />
            <DateTimePicker
              label="Plazo L√≠mite"
              locale="es"
              clearable
              value={form.values.deadline}
              onChange={(value) => form.setFieldValue('deadline', value ? new Date(value) : null)}
            />
            <Button type="submit" mt="md">{editingTask ? 'Guardar Cambios' : 'Crear Tarea'}</Button>
          </Stack>
        </form>
      </Modal>

      <Group justify="space-between" align="center" mb="md"><Title order={3}>Tareas de Seguimiento</Title><Button onClick={() => handleOpenModal()}>+ Crear Tarea</Button></Group>
      
      <Stack>
        {tasks.length > 0 ? (
          tasks.map(task => {
            const isOverdue = task.deadline && new Date(task.deadline) < new Date() && task.status !== 'COMPLETED';
            return (
              <Card key={task.id} withBorder shadow="sm" p="md" style={ isOverdue ? { borderLeft: '4px solid var(--mantine-color-red-7)' } : {}}>
                <Group justify="space-between" align="flex-start">
                  <Stack gap="xs" style={{ flex: 1 }}>
                    <Title order={5}>{task.title}</Title>
                    {task.description && <Text size="sm" c="dimmed">{task.description}</Text>}
                    <Divider />
                    <Group gap="sm">
                      <Badge color={taskStatusColors[task.status]} variant="light">{task.status}</Badge>
                      <Badge color={priorityColors[task.priority]} variant="light">Prioridad: {task.priority}</Badge>
                      {task.assignedTo && <Text size="xs">Asignado a: <strong>{task.assignedTo.name}</strong></Text>}
                    </Group>
                    {task.deadline && <Text size="xs" c={isOverdue ? 'red' : 'dimmed'} fw={isOverdue ? 700 : 400}>Plazo: {format(new Date(task.deadline), 'd MMM yyyy, HH:mm', { locale: es })} {isOverdue && '(VENCIDA)'}</Text>}
                    {task.resolutionNotes && <Textarea value={task.resolutionNotes} readOnly label="Notas de Resoluci√≥n" mt="xs" />}
                    
                    {selectedTaskForLogs?.id === task.id && (
                      <Stack mt="sm" gap="xs">
                        {logs.length > 0 
                            ? logs.map(log => renderLogEntry(log, task.id))
                            : <Text size="xs" c="dimmed">No hay historial para esta tarea.</Text>
                        }
                        <Textarea
                          placeholder="Escribe una respuesta o nueva instrucci√≥n para el t√©cnico..."
                          value={adminComment}
                          onChange={(e) => setAdminComment(e.currentTarget.value)}
                          minRows={2}
                        />
                        <Button size="xs" onClick={() => handleAdminComment(task.id)} disabled={!adminComment.trim()}>Enviar Comentario</Button>
                      </Stack>
                    )}

                  </Stack>
                  <Stack>
                    <Tooltip label="Editar detalles de la tarea">
                      <ActionIcon variant="default" onClick={() => handleOpenModal(task)}>‚úèÔ∏è</ActionIcon>
                    </Tooltip>
                    <Tooltip label="Ver/Ocultar di√°logo e historial">
                      <ActionIcon variant="default" onClick={() => handleViewLogs(task)}>üí¨</ActionIcon>
                    </Tooltip>
                    <Tooltip label="Eliminar tarea">
                      <ActionIcon color="red" variant="subtle" onClick={() => handleDelete(task.id)}>üóëÔ∏è</ActionIcon>
                    </Tooltip>
                  </Stack>
                </Group>
              </Card>
            )
          })
        ) : (<Text c="dimmed">No hay tareas de seguimiento para esta incidencia.</Text>)}
      </Stack>
    </>
  );
};


// ===================================================================
// --- COMPONENTE PRINCIPAL (DESPACHADOR) ---
// ===================================================================
export function IncidentDetailPage() {
  const { notificationId } = useParams<{ notificationId: string }>();
  const { user } = useAuth();
  
  const [notification, setNotification] = useState<NotificationDetails | null>(null);
  const [tasks, setTasks] = useState<IncidentTask[]>([]);
  const [technicians, setTechnicians] = useState<User[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [imageModalOpened, { open: openImageModal, close: closeImageModal }] = useDisclosure(false);
  const [selectedImage, setSelectedImage] = useState<string | null>(null);

  const fetchData = async () => {
    if (!notificationId) return;
    setIsLoading(true);
    setError(null);
    try {
      const [notificationRes, tasksRes, techniciansRes] = await Promise.all([
        apiClient.get<ApiResponse<NotificationDetails>>(`/notifications/${notificationId}`),
        apiClient.get<ApiResponse<IncidentTask[]>>(`/incident-tasks/by-notification/${notificationId}`),
        apiClient.get<ApiResponse<User[]>>('/users/technicians')
      ]);
      setNotification(notificationRes.data.data);
      setTasks(tasksRes.data.data);
      setTechnicians(techniciansRes.data.data.map(t => ({ id: t.id, name: t.name })));
    } catch (err) {
      setError('No se pudo cargar la informaci√≥n de la incidencia.');
    } finally { setIsLoading(false); }
  };

  const handleImageClick = (url: string) => { setSelectedImage(url); openImageModal(); };

  useEffect(() => { fetchData(); // eslint-disable-next-line
  }, [notificationId]);
  
  if (isLoading) return <Container p="xl" style={{ display: 'flex', justifyContent: 'center' }}><Loader /></Container>;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;
  if (!notification) return <Alert color="yellow">Incidencia no encontrada.</Alert>;

  const breadcrumbs = (<Breadcrumbs><Link to={user?.role === 'ADMIN' ? "/incidents-history" : "/my-route"}>{user?.role === 'ADMIN' ? "Gesti√≥n de Incidencias" : "Mi Trabajo de Hoy"}</Link><Text>Detalle</Text></Breadcrumbs>);

  return (
    <Container fluid>
      <Modal opened={imageModalOpened} onClose={closeImageModal} title="Imagen de la Incidencia" centered size="xl">{selectedImage && <Image src={selectedImage} />}</Modal>
      {breadcrumbs}
      <Title order={2} my="lg">Incidencia en {notification.visit?.pool.name}</Title>

      <Paper withBorder p="md" mb="xl">
        <Group justify="space-between"><Title order={4}>Reporte Original</Title><Badge color={notification.status === 'PENDING' ? 'orange' : 'green'} size="lg">{notification.status}</Badge></Group>
        <Text size="sm" c="dimmed" mt="xs">Reportado por {notification.visit?.technician?.name || 'Sistema'} el {format(new Date(notification.createdAt), 'd MMM yyyy, HH:mm', { locale: es })}</Text>
        <Textarea value={notification.message} readOnly minRows={2} mt="md" label="Mensaje del t√©cnico" />
        {notification.images && notification.images.length > 0 && (
          <><Text fw={500} size="sm" mt="md">Im√°genes Adjuntas:</Text><SimpleGrid cols={{ base: 2, sm: 4, lg: 6 }} mt="xs">{notification.images.map(image => (<Paper key={image.id} withBorder radius="md" style={{ cursor: 'pointer' }} onClick={() => handleImageClick(image.url)}><Image src={image.url} height={100} radius="md" fit="cover" /></Paper>))}</SimpleGrid></>
        )}
        {notification.visit && <Button component={Link} to={`/visits/${notification.visit.id}`} variant="subtle" size="xs" mt="sm">Ver Parte de Trabajo Original</Button>}
      </Paper>
      
      {user?.role === 'ADMIN' 
        ? <AdminIncidentView notification={notification} tasks={tasks} technicians={technicians} onUpdate={fetchData} />
        : <TechnicianTaskView tasks={tasks} onUpdate={fetchData} />
      }
    </Container>
  );
}


// ====== [18] packages/client/src/features/admin/pages/planner/PlannerPage.tsx ======
// filename: packages/client/src/features/admin/pages/planner/PlannerPage.tsx
// version: 1.6.3 (Fix conditional styling merge with dnd-kit styles)
import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Loader,
  Alert,
  Paper,
  Text,
  Grid,
  Card,
  Group,
  ActionIcon,
  Stack,
  Badge,
} from '@mantine/core';
import { useAuth } from '../../../../providers/AuthProvider.js';
import apiClient from '../../../../api/apiClient.js';
import { startOfWeek, endOfWeek, format, addDays, subDays } from 'date-fns';
import { es } from 'date-fns/locale';
import { DndContext, useDraggable, useDroppable } from '@dnd-kit/core';
import type { DragEndEvent } from '@dnd-kit/core';
import { useNavigate } from 'react-router-dom';

// --- Tipos ---
interface Visit {
  id: string;
  timestamp: string;
  status: 'PENDING' | 'COMPLETED' | 'CANCELLED';
  hasIncident: boolean;
  pool: { name: string; client: { name: string; }; };
  technicianId: string | null;
}
interface Technician { id: string; name: string; }
interface ApiResponse<T> { success: boolean; data: T; }

// --- Componentes de Drag and Drop ---
function DraggableVisit({ visit }: { visit: Visit }) {
  const { attributes, listeners, setNodeRef, transform } = useDraggable({ id: visit.id, data: visit });
  const navigate = useNavigate();
  
  const isCompleted = visit.status === 'COMPLETED';

  // --- L√ìGICA DE ESTILOS CORREGIDA ---
  // 1. Estilos base para la transformaci√≥n del drag-and-drop
  const dndStyle = transform ? { transform: `translate3d(${transform.x}px, ${transform.y}px, 0)`, zIndex: 100 } : undefined;

  // 2. Nuestros estilos condicionales personalizados
  const customCardStyles: React.CSSProperties = {
    cursor: 'pointer',
  };
  
  if (isCompleted) {
    customCardStyles.opacity = 0.65;
    if (visit.hasIncident) {
      customCardStyles.borderLeft = '4px solid var(--mantine-color-red-6)';
    } else {
      customCardStyles.borderLeft = '4px solid var(--mantine-color-green-6)';
    }
  }

  // 3. Unimos ambos objetos de estilo
  const combinedDivStyle = { ...dndStyle, ...customCardStyles };

  const titleStyle = isCompleted ? { textDecoration: 'line-through' } : {};
  
  const handleCardClick = () => {
    navigate(`/visits/${visit.id}`);
  };

  return (
    // Aplicamos los estilos combinados al div exterior
    <div 
      ref={setNodeRef} 
      style={combinedDivStyle} 
      {...attributes} 
      {...listeners}
      onClick={handleCardClick} // El onClick ahora est√° en el div que se arrastra
    >
      <Card 
        shadow="sm" 
        p="xs" 
        withBorder 
        style={{ width: '100%', height: '100%' }} // La tarjeta ocupa todo el div
      >
        <Group justify="space-between">
          <Text fw={500} style={titleStyle}>{visit.pool.name}</Text>
          {isCompleted && (
            visit.hasIncident 
              ? <Badge size="sm" color="red" variant="light">‚ö†Ô∏è Incidencia</Badge>
              : <Badge size="sm" color="green" variant="light">OK</Badge>
          )}
        </Group>
        <Text size="sm" c="dimmed">{visit.pool.client.name}</Text>
        <Text size="xs" mt={4}>{format(new Date(visit.timestamp), 'eeee d', { locale: es })}</Text>
      </Card>
    </div>
  );
}

function DroppableArea({ id, children, title }: { id: string; children: React.ReactNode; title: string }) {
  const { setNodeRef, isOver } = useDroppable({ id });
  return (
    <Paper ref={setNodeRef} withBorder p="sm" style={{ minHeight: 400, backgroundColor: isOver ? '#e7f5ff' : '#f1f3f5', transition: 'background-color 0.2s ease' }}>
      <Title order={5} ta="center" mb="md">{title}</Title>
      <Stack>{children}</Stack>
    </Paper>
  );
}

// --- Componente Principal ---
export function PlannerPage() {
  const { user } = useAuth();
  const [visits, setVisits] = useState<Visit[]>([]);
  const [technicians, setTechnicians] = useState<Technician[]>([]);
  const [currentDate, setCurrentDate] = useState(new Date());
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const weekStart = startOfWeek(currentDate, { weekStartsOn: 1 });
  const weekEnd = endOfWeek(currentDate, { weekStartsOn: 1 });

  const fetchData = async () => {
    if (!user) return;
    setIsLoading(true);
    try {
      const [visitsRes, techsRes] = await Promise.all([
        apiClient.get<ApiResponse<Visit[]>>('/visits/scheduled', { params: { date: currentDate.toISOString() } }),
        apiClient.get<ApiResponse<Technician[]>>('/users/technicians'),
      ]);
      setVisits(visitsRes.data.data);
      setTechnicians(techsRes.data.data);
    } catch (err) { setError('No se pudo cargar la planificaci√≥n.'); } finally { setIsLoading(false); }
  };

  useEffect(() => { fetchData(); // eslint-disable-next-line
  }, [currentDate, user]);

  const handleDragEnd = async (event: DragEndEvent) => {
    const { over, active } = event;
    if (!over) return;

    const visitId = active.id as string;
    const targetId = String(over.id);
    const [type, id] = targetId.split('-');

    let technicianId: string | null = null;
    
    if (type === 'tech' && id) {
        technicianId = id;
    }

    const originalVisits = [...visits];
    const visitToUpdate = visits.find(v => v.id === visitId);
    if (!visitToUpdate || visitToUpdate.technicianId === technicianId) return;

    setVisits(prev => prev.map(v => v.id === visitId ? { ...v, technicianId } : v));

    try {
      await apiClient.post('/visits/assign', { visitId, technicianId });
    } catch (err) {
      setError('No se pudo asignar la visita.');
      setVisits(originalVisits);
    }
  };

  if (isLoading) return <Loader size="xl" />;
  
  const weekRange = `${format(weekStart, 'd')} - ${format(weekEnd, 'd MMMM yyyy', { locale: es })}`;

  return (
    <DndContext onDragEnd={handleDragEnd}>
      <Container fluid>
        {error && <Alert color="red" title="Error" mb="md">{error}</Alert>}
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Planificador Semanal</Title>
          <Group>
            <ActionIcon variant="default" onClick={() => setCurrentDate(subDays(currentDate, 7))}>{'<'}</ActionIcon>
            <Text size="lg" fw={500}>{weekRange}</Text>
            <ActionIcon variant="default" onClick={() => setCurrentDate(addDays(currentDate, 7))}>{'<'}</ActionIcon>
          </Group>
        </Group>

        <Grid grow>
          <Grid.Col span={{ base: 12, md: 2 }}>
            <DroppableArea id="tech-null" title="Visitas Pendientes">
              {visits.filter(v => !v.technicianId).map(visit => <DraggableVisit key={visit.id} visit={visit} />)}
            </DroppableArea>
          </Grid.Col>

          <Grid.Col span={{ base: 12, md: 10 }}>
            <Grid>
              {technicians.map(tech => (
                <Grid.Col key={tech.id} span={{ base: 12, md: 6, lg: 4 }}>
                   <DroppableArea id={`tech-${tech.id}`} title={tech.name}>
                    {visits
                      .filter(v => v.technicianId === tech.id)
                      .sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime())
                      .map(visit => <DraggableVisit key={visit.id} visit={visit} />)
                    }
                   </DroppableArea>
                </Grid.Col>
              ))}
            </Grid>
          </Grid.Col>
        </Grid>
      </Container>
    </DndContext>
  );
}


// ====== [19] packages/client/src/features/admin/pages/pools/PoolDetailPage.tsx ======
// filename: packages/client/src/features/admin/pages/pools/PoolDetailPage.tsx
// Version: 1.2.0 (Implement Edit functionality for Pool Configurations)
import { useEffect, useState } from 'react';
import { useParams, Link } from 'react-router-dom';
import {
  Container,
  Title,
  Loader,
  Alert,
  Paper,
  Text,
  Table,
  Breadcrumbs,
  Grid,
  Card,
  Button,
  Group,
  Modal,
  Select,
  NumberInput,
  Stack,
  Menu,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../../api/apiClient.js';

// --- Tipos ---
const Frequencies = ['DIARIA', 'SEMANAL', 'QUINCENAL', 'MENSUAL', 'TRIMESTRAL', 'SEMESTRAL', 'ANUAL'] as const;
type Frequency = (typeof Frequencies)[number];

interface Pool { id: string; name: string; clientId: string; }
interface ParameterTemplate { id: string; name: string; unit: string | null; type: 'NUMBER' | 'BOOLEAN' | 'TEXT' | 'SELECT'; }
interface TaskTemplate { id: string; name: string; }
interface PoolConfiguration {
  id: string;
  frequency: Frequency;
  minThreshold: number | null;
  maxThreshold: number | null;
  parameterTemplate?: ParameterTemplate;
  taskTemplate?: TaskTemplate;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function PoolDetailPage() {
  const { id: poolId } = useParams<{ id: string }>();
  const [pool, ] = useState<Pool | null>(null);
  const [configurations, setConfigurations] = useState<PoolConfiguration[]>([]);
  const [parameterCatalog, setParameterCatalog] = useState<ParameterTemplate[]>([]);
  const [taskCatalog, setTaskCatalog] = useState<TaskTemplate[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  // Estado para saber qu√© estamos configurando (un nuevo √≠tem o editando uno existente)
  const [editingConfig, setEditingConfig] = useState<PoolConfiguration | null>(null);
  const [itemToAdd, setItemToAdd] = useState<{ id: string; name: string; type: 'parameter' | 'task' } | null>(null);

  const configForm = useForm({
    initialValues: {
      frequency: 'SEMANAL' as Frequency,
      minThreshold: null as number | null,
      maxThreshold: null as number | null,
    },
    validate: {
      frequency: (value) => (Frequencies.includes(value) ? null : 'Frecuencia inv√°lida'),
    },
  });

  const fetchData = async () => {
    if (!poolId) return;
    setIsLoading(true);
    try {
      const [configsRes, paramsRes, tasksRes] = await Promise.all([
        apiClient.get<ApiResponse<PoolConfiguration[]>>(`/pool-configurations/by-pool/${poolId}`),
        apiClient.get<ApiResponse<ParameterTemplate[]>>('/parameters'),
        apiClient.get<ApiResponse<TaskTemplate[]>>('/tasks'),
      ]);
      setConfigurations(configsRes.data.data);
      setParameterCatalog(paramsRes.data.data);
      setTaskCatalog(tasksRes.data.data);
    } catch (err) {
      setError('No se pudo cargar la configuraci√≥n de la piscina.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [poolId]);

  const handleOpenModal = (config: PoolConfiguration | null, item: { id: string; name: string; } | null, type: 'parameter' | 'task' | null) => {
    setEditingConfig(config);
    setItemToAdd(item ? { ...item, type: type as 'parameter' | 'task' } : null);
    
    if (config) { // Estamos editando
      configForm.setValues({
        frequency: config.frequency,
        minThreshold: config.minThreshold,
        maxThreshold: config.maxThreshold,
      });
    } else { // Estamos creando
      configForm.reset();
    }
    openModal();
  };

  const handleConfigSubmit = async (values: typeof configForm.values) => {
    if (!poolId) return;
    try {
      if (editingConfig) { // L√≥gica para actualizar
        const payload = { frequency: values.frequency, minThreshold: values.minThreshold, maxThreshold: values.maxThreshold };
        await apiClient.patch(`/pool-configurations/${editingConfig.id}`, payload);
      } else if (itemToAdd) { // L√≥gica para crear
        const payload = {
          poolId,
          frequency: values.frequency,
          ...(itemToAdd.type === 'parameter' && { parameterTemplateId: itemToAdd.id, minThreshold: values.minThreshold, maxThreshold: values.maxThreshold }),
          ...(itemToAdd.type === 'task' && { taskTemplateId: itemToAdd.id }),
        };
        await apiClient.post('/pool-configurations', payload);
      }
      await fetchData();
      closeModal();
    } catch (err: any) {
      configForm.setErrors({ frequency: err.response?.data?.message || 'Error al guardar la configuraci√≥n' });
    }
  };
  
  const handleConfigDelete = async (configId: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres quitar este √≠tem de la ficha?')) {
      try {
        await apiClient.delete(`/pool-configurations/${configId}`);
        await fetchData();
      } catch (err) {}
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const currentItem = editingConfig?.parameterTemplate || editingConfig?.taskTemplate || itemToAdd;
  const modalTitle = editingConfig ? `Editar: ${currentItem?.name}` : `A√±adir: ${currentItem?.name}`;
  const isParameter = (editingConfig && editingConfig.parameterTemplate) || (itemToAdd?.type === 'parameter');
  
  const breadcrumbs = (
    <Breadcrumbs>
      <Link to="/clients">Clientes</Link>
      <Text>Cliente (TODO)</Text>
      <Text>{pool?.name || 'Piscina'}</Text>
    </Breadcrumbs>
  );

  return (
    <>
      <Modal opened={modalOpened} onClose={closeModal} title={modalTitle} centered>
        <form onSubmit={configForm.onSubmit(handleConfigSubmit)}>
          <Stack>
            <Select label="Frecuencia" required data={[...Frequencies]} {...configForm.getInputProps('frequency')} />
            {isParameter && (
              <>
                <NumberInput label="Umbral M√≠nimo (opcional)" {...configForm.getInputProps('minThreshold')} />
                <NumberInput label="Umbral M√°ximo (opcional)" {...configForm.getInputProps('maxThreshold')} />
              </>
            )}
            <Button type="submit" mt="md">{editingConfig ? 'Guardar Cambios' : 'A√±adir a la Ficha'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        {breadcrumbs}
        <Title order={2} my="lg">Constructor de Ficha: {pool?.name || ''}</Title>
        <Grid>
          <Grid.Col span={{ base: 12, md: 6 }}>
            <Paper withBorder p="md">
              <Title order={4} mb="md">Ficha de Mantenimiento Actual</Title>
              <Table>
                <Table.Thead><Table.Tr><Table.Th>√çtem</Table.Th><Table.Th>Frecuencia</Table.Th><Table.Th>Acciones</Table.Th></Table.Tr></Table.Thead>
                <Table.Tbody>
                  {configurations.length > 0 ? configurations.map(config => (
                    <Table.Tr key={config.id}>
                      <Table.Td>{config.parameterTemplate?.name || config.taskTemplate?.name}</Table.Td>
                      <Table.Td>{config.frequency}</Table.Td>
                      <Table.Td>
                        <Menu shadow="md" width={200}>
                          <Menu.Target><Button variant="outline" size="xs">Acciones</Button></Menu.Target>
                          <Menu.Dropdown>
                            <Menu.Item onClick={() => handleOpenModal(config, null, null)}>Editar</Menu.Item>
                            <Menu.Item color="red" onClick={() => handleConfigDelete(config.id)}>Quitar</Menu.Item>
                          </Menu.Dropdown>
                        </Menu>
                      </Table.Td>
                    </Table.Tr>
                  )) : <Table.Tr><Table.Td colSpan={3}>La ficha est√° vac√≠a. A√±ade √≠tems desde los cat√°logos.</Table.Td></Table.Tr>}
                </Table.Tbody>
              </Table>
            </Paper>
          </Grid.Col>

          <Grid.Col span={{ base: 12, md: 6 }}>
            <Paper withBorder p="md" mb="md">
              <Title order={4} mb="md">Cat√°logo de Par√°metros Disponibles</Title>
              {parameterCatalog.map(param => (
                <Card key={param.id} shadow="sm" p="sm" mb="xs" withBorder>
                  <Group justify="space-between">
                    <Text>{param.name} {param.unit ? `(${param.unit})` : ''}</Text>
                    <Button size="xs" onClick={() => handleOpenModal(null, param, 'parameter')}>A√±adir</Button>
                  </Group>
                </Card>
              ))}
            </Paper>
            <Paper withBorder p="md">
              <Title order={4} mb="md">Cat√°logo de Tareas Disponibles</Title>
              {taskCatalog.map(task => (
                <Card key={task.id} shadow="sm" p="sm" mb="xs" withBorder>
                  <Group justify="space-between">
                    <Text>{task.name}</Text>
                    <Button size="xs" onClick={() => handleOpenModal(null, task, 'task')}>A√±adir</Button>
                  </Group>
                </Card>
              ))}
            </Paper>
          </Grid.Col>
        </Grid>
      </Container>
    </>
  );
}


// ====== [20] packages/client/src/features/admin/pages/reports/ConsumptionReportPage.tsx ======
// filename: packages/client/src/features/admin/pages/reports/ConsumptionReportPage.tsx
// version: 2.2.2 (FIX: Definitively correct the string-to-date conversion on DatePickerInput's onChange)

import { useState, useEffect, Fragment } from 'react';
import { Link } from 'react-router-dom';
import { Container, Title, Paper, Group, Select, Button, Loader, Alert, Stack, Table, Text, Card, SimpleGrid, Collapse, Modal, Anchor } from '@mantine/core';
import { DatePickerInput } from '@mantine/dates';
import 'dayjs/locale/es';
import { startOfMonth, endOfMonth, startOfDay, endOfDay, format } from 'date-fns';
import { es } from 'date-fns/locale';
import apiClient from '../../../../api/apiClient';
import { useDisclosure } from '@mantine/hooks';

// --- Tipos de Datos para el Frontend ---
interface Client {
  id: string;
  name: string;
}

interface DetailedConsumption {
  productId: string;
  productName: string;
  unit: string;
  totalQuantity: number;
  totalCost: number;
}

interface ProductConsumptionDetail {
    visitId: string;
    visitDate: Date;
    quantity: number;
    cost: number;
    technicianName: string | null;
}

type DateRange = [Date | null, Date | null];

interface ReportData {
  summary: {
    totalCost: number;
    totalVisits: number;
  };
  byClient: {
    clientId: string;
    clientName: string;
    totalClientCost: number;
    visitCount: number;
    detailedConsumption: DetailedConsumption[];
  }[];
}

export function ConsumptionReportPage() {
  const [clients, setClients] = useState<Client[]>([]);
  const [selectedClientId, setSelectedClientId] = useState<string | null>(null);
  const [dateRange, setDateRange] = useState<DateRange>([startOfMonth(new Date()), endOfMonth(new Date())]);
  
  const [reportData, setReportData] = useState<ReportData | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [openedRow, setOpenedRow] = useState<string | null>(null);
  const [detailModalOpened, { open: openDetailModal, close: closeDetailModal }] = useDisclosure(false);
  const [productDetailData, setProductDetailData] = useState<ProductConsumptionDetail[]>([]);
  const [isDetailLoading, setIsDetailLoading] = useState(false);
  const [selectedProductInfo, setSelectedProductInfo] = useState<{ productName: string, clientId: string } | null>(null);


  useEffect(() => {
    const fetchClients = async () => {
      try {
        const response = await apiClient.get('/clients');
        setClients(response.data.data);
      } catch (err) {
        setError('No se pudo cargar la lista de clientes.');
      }
    };
    fetchClients();
  }, []);

  const handleGenerateReport = async () => {
    if (!dateRange[0] || !dateRange[1]) {
      setError('Por favor, seleccione un rango de fechas completo.');
      return;
    }

    setIsLoading(true);
    setError(null);
    setReportData(null);
    setOpenedRow(null);

    try {
      const params = new URLSearchParams({
        startDate: startOfDay(dateRange[0]).toISOString(),
        endDate: endOfDay(dateRange[1]).toISOString(),
      });
      if (selectedClientId) {
        params.append('clientId', selectedClientId);
      }
      
      const response = await apiClient.get(`/reports/consumption?${params.toString()}`);
      setReportData(response.data.data);
    } catch (err) {
      setError('Ocurri√≥ un error al generar el informe.');
      console.error(err);
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleProductDrillDown = async (clientId: string, product: DetailedConsumption) => {
    if (!dateRange[0] || !dateRange[1]) return;

    setSelectedProductInfo({ productName: product.productName, clientId });
    setIsDetailLoading(true);
    openDetailModal();
    setProductDetailData([]);

    try {
        const params = new URLSearchParams({
            startDate: startOfDay(dateRange[0]).toISOString(),
            endDate: endOfDay(dateRange[1]).toISOString(),
            clientId: clientId,
            productId: product.productId,
        });

        const response = await apiClient.get(`/reports/consumption/details?${params.toString()}`);
        setProductDetailData(response.data.data);
    } catch (err) {
        console.error("Error al cargar el detalle del producto", err);
    } finally {
        setIsDetailLoading(false);
    }
  }


  const handleExportToCSV = () => {
    if (!reportData) return;
  
    let csvContent = "data:text/csv;charset=utf-8,";
    csvContent += "ID Cliente,Nombre Cliente,Coste Total Cliente,Producto,Cantidad Consumida,Unidad,Coste Producto\r\n";
  
    reportData.byClient.forEach(client => {
      if (client.detailedConsumption.length === 0) {
        csvContent += `${client.clientId},"${client.clientName.replace(/"/g, '""')}",${client.totalClientCost.toFixed(2)},N/A,0,N/A,0\r\n`;
      } else {
        client.detailedConsumption.forEach(item => {
          csvContent += [
            client.clientId,
            `"${client.clientName.replace(/"/g, '""')}"`,
            client.totalClientCost.toFixed(2),
            `"${item.productName.replace(/"/g, '""')}"`,
            item.totalQuantity,
            item.unit,
            item.totalCost.toFixed(2)
          ].join(',') + '\r\n';
        });
      }
    });
  
    const encodedUri = encodeURI(csvContent);
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", `informe_consumo_${new Date().toISOString().split('T')[0]}.csv`);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };
  
  const clientOptions = clients.map(client => ({
    value: client.id,
    label: client.name,
  }));

  const reportRows = reportData?.byClient.map((client) => {
    const isOpened = openedRow === client.clientId;
    return (
      <Fragment key={client.clientId}>
        <Table.Tr 
          onClick={() => setOpenedRow(isOpened ? null : client.clientId)}
          style={{ cursor: 'pointer', backgroundColor: isOpened ? 'var(--mantine-color-blue-0)' : 'transparent' }}
        >
          <Table.Td>{client.clientName}</Table.Td>
          <Table.Td>{client.visitCount}</Table.Td>
          <Table.Td>{client.totalClientCost.toFixed(2)} ‚Ç¨</Table.Td>
        </Table.Tr>
        
        <Table.Tr>
          <Table.Td colSpan={3} p={0} style={{ border: 0 }}>
            <Collapse in={isOpened}>
              <Paper p="md" m="xs" withBorder bg="gray.0">
                <Text fw={700} mb="sm">Desglose de Productos para {client.clientName}</Text>
                <Table withColumnBorders>
                  <Table.Thead>
                    <Table.Tr>
                      <Table.Th>Producto</Table.Th>
                      <Table.Th>Cantidad Total</Table.Th>
                      <Table.Th>Coste</Table.Th>
                    </Table.Tr>
                  </Table.Thead>
                  <Table.Tbody>
                    {client.detailedConsumption.map(item => (
                      <Table.Tr key={item.productName}>
                        <Table.Td>
                            <Anchor component="button" type="button" onClick={() => handleProductDrillDown(client.clientId, item)}>
                                {item.productName}
                            </Anchor>
                        </Table.Td>
                        <Table.Td>{item.totalQuantity.toFixed(2)} {item.unit}</Table.Td>
                        <Table.Td>{item.totalCost.toFixed(2)} ‚Ç¨</Table.Td>
                      </Table.Tr>
                    ))}
                  </Table.Tbody>
                </Table>
              </Paper>
            </Collapse>
          </Table.Td>
        </Table.Tr>
      </Fragment>
    );
  });

  return (
    <Container fluid>
      <Modal 
        opened={detailModalOpened} 
        onClose={closeDetailModal} 
        title={`Detalle de consumo para: ${selectedProductInfo?.productName || ''}`}
        size="xl"
        centered
      >
        {isDetailLoading ? <Loader /> : (
            <Table>
                <Table.Thead>
                    <Table.Tr>
                        <Table.Th>Fecha de Visita</Table.Th>
                        <Table.Th>T√©cnico</Table.Th>
                        <Table.Th>Cantidad</Table.Th>
                        <Table.Th>Coste</Table.Th>
                        <Table.Th>Acciones</Table.Th>
                    </Table.Tr>
                </Table.Thead>
                <Table.Tbody>
                    {productDetailData.map(detail => (
                        <Table.Tr key={detail.visitId}>
                            <Table.Td>{format(new Date(detail.visitDate), 'd MMMM yyyy, HH:mm', { locale: es })}</Table.Td>
                            <Table.Td>{detail.technicianName}</Table.Td>
                            <Table.Td>{detail.quantity.toFixed(2)}</Table.Td>
                            <Table.Td>{detail.cost.toFixed(2)} ‚Ç¨</Table.Td>
                            <Table.Td>
                                <Button component={Link} to={`/visits/${detail.visitId}`} size="xs" variant="outline">
                                    Ver Parte
                                </Button>
                            </Table.Td>
                        </Table.Tr>
                    ))}
                </Table.Tbody>
            </Table>
        )}
      </Modal>

      <Title order={2} mb="xl">Informe de Consumos y Costes</Title>
      
      <Paper withBorder shadow="sm" p="md" mb="xl">
        <Group align="flex-end">
          <DatePickerInput
            type="range"
            label="Periodo del Informe"
            placeholder="Seleccione un rango de fechas"
            value={dateRange}
            // ‚úÖ SOLUCI√ìN FINAL Y DEFINITIVA
            onChange={(value: [string | null, string | null]) => {
              const [start, end] = value;
              setDateRange([start ? new Date(start) : null, end ? new Date(end) : null]);
            }}
            locale="es"
            valueFormat="D MMMM, YYYY"
            style={{ flex: 1 }}
          />
          
          <Select
            label="Cliente"
            placeholder="Todos los clientes"
            data={clientOptions}
            value={selectedClientId}
            onChange={setSelectedClientId}
            clearable
            style={{ width: '250px' }}
          />
          
          <Button onClick={handleGenerateReport} loading={isLoading}>
            Generar Informe
          </Button>
          {reportData && (
             <Button
                variant="outline"
                onClick={handleExportToCSV}
                disabled={!reportData || reportData.byClient.length === 0}
            >
                Exportar a CSV
            </Button>
          )}
        </Group>
      </Paper>
      
      {isLoading && <Loader size="xl" />}
      {error && <Alert color="red" title="Error">{error}</Alert>}
      
      {reportData && (
        <Stack>
            <SimpleGrid cols={{ base: 1, sm: 2 }}>
                <Card withBorder shadow="sm" p="md">
                    <Text size="lg" fw={700}>Coste Total del Periodo</Text>
                    <Text size="xl" c="blue">{reportData.summary.totalCost.toFixed(2)} ‚Ç¨</Text>
                </Card>
                <Card withBorder shadow="sm" p="md">
                    <Text size="lg" fw={700}>N¬∫ de Visitas Registradas</Text>
                    <Text size="xl" c="blue">{reportData.summary.totalVisits}</Text>
                </Card>
            </SimpleGrid>

            <Title order={4} mt="xl">Resumen por Cliente</Title>
            <Table striped withTableBorder>
                <Table.Thead>
                    <Table.Tr>
                        <Table.Th>Cliente</Table.Th>
                        <Table.Th>N¬∫ de Visitas</Table.Th>
                        <Table.Th>Coste Total</Table.Th>
                    </Table.Tr>
                </Table.Thead>
                <Table.Tbody>
                    {reportRows?.length ? reportRows : <Table.Tr><Table.Td colSpan={3}>No se encontraron datos para los filtros seleccionados.</Table.Td></Table.Tr>}
                </Table.Tbody>
            </Table>
        </Stack>
      )}
    </Container>
  );
}


// ====== [21] packages/client/src/features/auth/pages/LoginPage.tsx ======
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Container,
  Title,
  Paper,
  TextInput,
  PasswordInput,
  Button,
  Stack,
  Alert,
} from '@mantine/core';
import { useAuth } from '../../../providers/AuthProvider.js';

export function LoginPage() {
  const { login } = useAuth();
  const navigate = useNavigate();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setError(null);
    try {
      await login({ email, password });
      navigate('/'); // Redirige al dashboard en un login exitoso
    } catch (err) {
      setError('El email o la contrase√±a son incorrectos.');
      console.error(err);
    }
  };

  return (
    <Container size={420} my={40}>
      <Title ta="center">¬°Bienvenido!</Title>
      <Paper withBorder shadow="md" p={30} mt={30} radius="md">
        <form onSubmit={handleSubmit}>
          <Stack>
            <TextInput
              required
              label="Email"
              placeholder="tu@email.com"
              value={email}
              onChange={(event) => setEmail(event.currentTarget.value)}
              radius="md"
            />
            <PasswordInput
              required
              label="Contrase√±a"
              placeholder="Tu contrase√±a"
              value={password}
              onChange={(event) => setPassword(event.currentTarget.value)}
              radius="md"
            />
            {error && (
              <Alert title="Error de autenticaci√≥n" color="red" withCloseButton onClose={() => setError(null)}>
                {error}
              </Alert>
            )}
            <Button type="submit" fullWidth mt="xl" radius="md">
              Iniciar Sesi√≥n
            </Button>
          </Stack>
        </form>
      </Paper>
    </Container>
  );
}


// ====== [22] packages/client/src/features/financials/pages/ExpensesPage.tsx ======
// filename: packages/client/src/features/financials/pages/ExpensesPage.tsx
// version: 1.0.0
// description: P√°gina para visualizar y registrar los gastos generales de la empresa.

import { useEffect, useState } from 'react';
import { Container, Title, Table, Loader, Alert, Button, Group, Modal, NumberInput, Stack, TextInput } from '@mantine/core';
import { DatePickerInput } from '@mantine/dates';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient';
import { format } from 'date-fns';

// --- Tipos de Datos ---
interface Expense {
  id: string;
  amount: number;
  expenseDate: string;
  description: string;
  category: string;
}
interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente Principal ---
export function ExpensesPage() {
  const [expenses, setExpenses] = useState<Expense[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);

  const form = useForm({
    initialValues: {
      amount: 0,
      expenseDate: new Date(),
      description: '',
      category: '',
    },
    validate: {
      amount: (value) => value <= 0 ? 'El importe debe ser mayor que cero' : null,
      expenseDate: (value) => !value ? 'La fecha es obligatoria' : null,
      description: (value) => value.trim().length === 0 ? 'La descripci√≥n es obligatoria' : null,
      category: (value) => value.trim().length === 0 ? 'La categor√≠a es obligatoria' : null,
    },
  });

  const fetchExpenses = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<Expense[]>>('/expenses');
      setExpenses(response.data.data);
    } catch (err) {
      setError('No se pudo cargar la lista de gastos.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchExpenses();
  }, []);

  const handleSubmit = async (values: typeof form.values) => {
    try {
      await apiClient.post('/expenses', values);
      await fetchExpenses();
      closeModal();
      form.reset();
    } catch (err: any) {
      form.setErrors({ description: err.response?.data?.message || 'Error al registrar el gasto.' });
    }
  };

  const handleDelete = async (expenseId: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar este gasto?')) {
      try {
        await apiClient.delete(`/expenses/${expenseId}`);
        setExpenses((current) => current.filter((e) => e.id !== expenseId));
      } catch (err) {
        alert('No se pudo eliminar el gasto.');
      }
    }
  };

  const rows = expenses.map((expense) => (
    <Table.Tr key={expense.id}>
      <Table.Td>{format(new Date(expense.expenseDate), 'dd/MM/yyyy')}</Table.Td>
      <Table.Td>{expense.description}</Table.Td>
      <Table.Td>{expense.category}</Table.Td>
      <Table.Td>{new Intl.NumberFormat('es-ES', { style: 'currency', currency: 'EUR' }).format(expense.amount)}</Table.Td>
      <Table.Td>
        <Button variant="subtle" color="red" size="xs" onClick={() => handleDelete(expense.id)}>Eliminar</Button>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal opened={modalOpened} onClose={closeModal} title="Registrar Nuevo Gasto" centered>
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <DatePickerInput label="Fecha del Gasto" required {...form.getInputProps('expenseDate')} />
            <TextInput label="Descripci√≥n" placeholder="Ej: Compra de material de oficina" required {...form.getInputProps('description')} />
            <TextInput label="Categor√≠a" placeholder="Ej: Combustible, N√≥minas, Suministros" required {...form.getInputProps('category')} />
            <NumberInput label="Importe (‚Ç¨)" decimalScale={2} fixedDecimalScale required {...form.getInputProps('amount')} />
            <Button type="submit" mt="md">Registrar Gasto</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Gesti√≥n de Gastos Generales</Title>
          <Button onClick={openModal}>Registrar Nuevo Gasto</Button>
        </Group>
        
        {isLoading && <Loader />}
        {error && <Alert color="red" title="Error">{error}</Alert>}
        
        <Table striped withTableBorder mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Fecha</Table.Th>
              <Table.Th>Descripci√≥n</Table.Th>
              <Table.Th>Categor√≠a</Table.Th>
              <Table.Th>Importe</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>
            {expenses.length > 0 ? rows : <Table.Tr><Table.Td colSpan={5}>No hay gastos registrados.</Table.Td></Table.Tr>}
          </Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [23] packages/client/src/features/financials/pages/PaymentsPage.tsx ======
// filename: packages/client/src/features/financials/pages/PaymentsPage.tsx
// version: 1.0.1 (FIXED)
// description: Corrige importaciones y variables no utilizadas.

import { useEffect, useState } from 'react';
import { Container, Title, Table, Loader, Alert, Button, Group, Modal, Select, NumberInput, Stack, TextInput, Textarea, Paper } from '@mantine/core'; // ‚úÖ Paper a√±adido
import { DatePickerInput } from '@mantine/dates';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient';
import { format } from 'date-fns';

// --- Tipos de Datos ---
interface Payment {
  id: string;
  amount: number;
  paymentDate: string;
  method: string;
  notes: string | null;
  client: { name: string };
}
interface Client {
  id: string;
  name: string;
}
interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente Principal ---
export function PaymentsPage() {
  const [payments, setPayments] = useState<Payment[]>([]);
  const [clients, setClients] = useState<Client[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [selectedClient, setSelectedClient] = useState<string | null>(null);

  const form = useForm({
    initialValues: {
      clientId: '',
      amount: 0,
      paymentDate: new Date(),
      method: 'Transferencia Bancaria',
      notes: '',
    },
    validate: {
      clientId: (value) => !value ? 'Debe seleccionar un cliente' : null,
      amount: (value) => value <= 0 ? 'El importe debe ser mayor que cero' : null,
      paymentDate: (value) => !value ? 'La fecha es obligatoria' : null,
      method: (value) => value.trim().length === 0 ? 'El m√©todo es obligatorio' : null,
    },
  });

  const fetchInitialData = async () => {
    setIsLoading(true);
    try {
      // ‚úÖ Se elimina la variable 'url' no utilizada.
      const clientsRes = await apiClient.get<ApiResponse<Client[]>>('/clients');
      setClients(clientsRes.data.data);
      setPayments([]);
    } catch (err) {
      setError('No se pudo cargar la lista de clientes.');
    } finally {
      setIsLoading(false);
    }
  };

  const fetchPaymentsForClient = async (clientId: string | null) => {
    if (!clientId) {
        setPayments([]);
        return;
    }
    setIsLoading(true);
    try {
        const response = await apiClient.get<ApiResponse<Payment[]>>(`/payments/by-client/${clientId}`);
        setPayments(response.data.data);
    } catch (err) {
        setError(`No se pudieron cargar los pagos para este cliente.`);
    } finally {
        setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchInitialData();
  }, []);

  useEffect(() => {
    fetchPaymentsForClient(selectedClient);
  }, [selectedClient]);

  const handleSubmit = async (values: typeof form.values) => {
    try {
      await apiClient.post('/payments', values);
      // Si el pago es para el cliente actualmente seleccionado, refrescamos la lista
      if (values.clientId === selectedClient) {
        await fetchPaymentsForClient(values.clientId);
      }
      closeModal();
      form.reset();
    } catch (err: any) {
      form.setErrors({ clientId: err.response?.data?.message || 'Error al registrar el pago.' });
    }
  };

  const handleDelete = async (paymentId: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar este pago?')) {
      try {
        await apiClient.delete(`/payments/${paymentId}`);
        await fetchPaymentsForClient(selectedClient);
      } catch (err) {
        alert('No se pudo eliminar el pago.');
      }
    }
  };

  const clientOptions = clients.map(c => ({ value: c.id, label: c.name }));

  const rows = payments.map((payment) => (
    <Table.Tr key={payment.id}>
      <Table.Td>{format(new Date(payment.paymentDate), 'dd/MM/yyyy')}</Table.Td>
      {/* No necesitamos mostrar el cliente en la tabla si ya est√° filtrado
      <Table.Td>{payment.client.name}</Table.Td> 
      */}
      <Table.Td>{new Intl.NumberFormat('es-ES', { style: 'currency', currency: 'EUR' }).format(payment.amount)}</Table.Td>
      <Table.Td>{payment.method}</Table.Td>
      <Table.Td>{payment.notes || '-'}</Table.Td>
      <Table.Td>
        <Button variant="subtle" color="red" size="xs" onClick={() => handleDelete(payment.id)}>Eliminar</Button>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal opened={modalOpened} onClose={closeModal} title="Registrar Nuevo Pago" centered>
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <Select label="Cliente" placeholder="Seleccione un cliente" data={clientOptions} required {...form.getInputProps('clientId')} />
            <NumberInput label="Importe (‚Ç¨)" decimalScale={2} fixedDecimalScale required {...form.getInputProps('amount')} />
            <DatePickerInput label="Fecha de Pago" required {...form.getInputProps('paymentDate')} />
            <TextInput label="M√©todo de Pago" placeholder="Ej: Transferencia, Efectivo..." required {...form.getInputProps('method')} />
            <Textarea label="Notas (Opcional)" placeholder="Ej: Factura 2025-0045" {...form.getInputProps('notes')} />
            <Button type="submit" mt="md">Registrar Pago</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Gesti√≥n de Pagos Recibidos</Title>
          <Button onClick={openModal}>Registrar Nuevo Pago</Button>
        </Group>
        
        <Paper withBorder p="md" mb="xl">
            <Select 
                label="Filtrar por Cliente"
                placeholder="Seleccione un cliente para ver sus pagos"
                data={clientOptions}
                value={selectedClient}
                onChange={setSelectedClient}
                clearable
            />
        </Paper>

        {isLoading && <Loader />}
        {error && <Alert color="red" title="Error">{error}</Alert>}
        
        <Table striped withTableBorder mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Fecha</Table.Th>
              {/* <Table.Th>Cliente</Table.Th> */}
              <Table.Th>Importe</Table.Th>
              <Table.Th>M√©todo</Table.Th>
              <Table.Th>Notas</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>
            {payments.length > 0 ? rows : <Table.Tr><Table.Td colSpan={5}>Seleccione un cliente para ver sus pagos o registre uno nuevo.</Table.Td></Table.Tr>}
          </Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [24] packages/client/src/features/manager/pages/InvoicingReportPage.tsx ======
// filename: packages/client/src/features/manager/pages/InvoicingReportPage.tsx
// version: 1.0.3 (FIXED)
// description: Asegura que las fechas son objetos Date antes de usarlas.

import { useEffect, useState } from 'react';
import { Container, Title, Paper, Group, Button, Loader, Alert, Table, Accordion, Text, Stack } from '@mantine/core';
import { DatePickerInput } from '@mantine/dates';
import type { DatesRangeValue } from '@mantine/dates';
import 'dayjs/locale/es';
import apiClient from '../../../api/apiClient';
import { subMonths, startOfMonth, endOfMonth } from 'date-fns';

// --- Tipos ---
interface BilledConsumption {
  productId: string;
  productName: string;
  unit: string;
  totalQuantity: number;
  salePrice: number;
  totalLine: number;
}
interface ClientInvoiceData {
  clientId: string;
  clientName: string;
  billingModel: string;
  monthlyFee: number;
  materialsSubtotal: number;
  totalToInvoice: number;
  billedConsumption: BilledConsumption[];
}
interface InvoicingReport {
  summary: {
    totalToInvoice: number;
    totalFees: number;
    totalMaterials: number;
  };
  byClient: ClientInvoiceData[];
}

const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('es-ES', { style: 'currency', currency: 'EUR' }).format(amount);
};

export function InvoicingReportPage() {
  const [report, setReport] = useState<InvoicingReport | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [dateRange, setDateRange] = useState<DatesRangeValue>([
    startOfMonth(subMonths(new Date(), 1)),
    endOfMonth(subMonths(new Date(), 1)),
  ]);

  const fetchReport = async () => {
    const [startDate, endDate] = dateRange;
    if (!startDate || !endDate) {
      setError('Por favor, seleccione un rango de fechas v√°lido.');
      return;
    }
    
    // ‚úÖ Conversi√≥n y validaci√≥n segura de fechas
    const startDateObj = startDate instanceof Date ? startDate : new Date(startDate);
    const endDateObj = endDate instanceof Date ? endDate : new Date(endDate);
    
    if (isNaN(startDateObj.getTime()) || isNaN(endDateObj.getTime())) {
      setError('Formato de fecha inv√°lido.');
      return;
    }

    setIsLoading(true);
    setError(null);
    setReport(null);

    try {
      const response = await apiClient.get('/reports/invoicing', {
        params: {
          startDate: startDateObj.toISOString(),
          endDate: endDateObj.toISOString(),
        },
      });
      setReport(response.data.data);
    } catch (err) {
      setError('No se pudo generar el informe.');
      console.error(err);
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchReport();
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const clientRows = report?.byClient.map((clientData) => (
    <Accordion.Item key={clientData.clientId} value={clientData.clientId}>
      <Accordion.Control>
        <Group justify="space-between">
          <Text fw={500}>{clientData.clientName}</Text>
          <Text fw={700} c="blue">{formatCurrency(clientData.totalToInvoice)}</Text>
        </Group>
      </Accordion.Control>
      <Accordion.Panel>
        <Stack gap="xs">
            <Text><strong>Modelo de Contrato:</strong> {clientData.billingModel.replace(/_/g, ' ').toLowerCase()}</Text>
            <Text><strong>Cuota Fija:</strong> {formatCurrency(clientData.monthlyFee)}</Text>
            <Text><strong>Subtotal Materiales:</strong> {formatCurrency(clientData.materialsSubtotal)}</Text>
        </Stack>
        {clientData.billedConsumption.length > 0 && (
            <Table mt="md" striped withTableBorder>
                <Table.Thead>
                    <Table.Tr>
                        <Table.Th>Producto</Table.Th>
                        <Table.Th>Cantidad</Table.Th>
                        <Table.Th>PVP Unitario</Table.Th>
                        <Table.Th>Total L√≠nea</Table.Th>
                    </Table.Tr>
                </Table.Thead>
                <Table.Tbody>
                    {clientData.billedConsumption.map(item => (
                        <Table.Tr key={item.productId}>
                            <Table.Td>{item.productName}</Table.Td>
                            <Table.Td>{item.totalQuantity} {item.unit}</Table.Td>
                            <Table.Td>{formatCurrency(item.salePrice)}</Table.Td>
                            <Table.Td>{formatCurrency(item.totalLine)}</Table.Td>
                        </Table.Tr>
                    ))}
                </Table.Tbody>
            </Table>
        )}
      </Accordion.Panel>
    </Accordion.Item>
  ));


  return (
    <Container fluid>
      <Title order={2} mb="xl">Informe para Facturaci√≥n</Title>
      <Paper withBorder p="md" mb="xl" shadow="sm">
        <Group>
          <DatePickerInput
            type="range"
            label="Seleccione el periodo"
            placeholder="Inicio - Fin"
            value={dateRange}
            onChange={setDateRange}
            locale="es"
            maw={400}
          />
          <Button onClick={fetchReport} loading={isLoading} mt="xl">
            Generar Informe
          </Button>
        </Group>
      </Paper>

      {isLoading && <Loader />}
      {error && <Alert color="red" title="Error">{error}</Alert>}
      
      {report && (
        <Paper withBorder p="md" shadow="sm">
            <Title order={4} mb="md">Resumen Total del Periodo</Title>
            <Group justify="space-around" mb="xl">
                <Stack align="center" gap={0}>
                    <Text size="xl" fw={500}>Cuotas Fijas</Text>
                    <Text size="2rem" fw={700} c="dimmed">{formatCurrency(report.summary.totalFees)}</Text>
                </Stack>
                <Stack align="center" gap={0}>
                    <Text size="xl" fw={500}>Materiales</Text>
                    <Text size="2rem" fw={700} c="dimmed">{formatCurrency(report.summary.totalMaterials)}</Text>
                </Stack>
                <Stack align="center" gap={0}>
                    <Text size="xl" fw={500}>Total a Facturar</Text>
                    <Text size="2.5rem" fw={700} c="blue">{formatCurrency(report.summary.totalToInvoice)}</Text>
                </Stack>
            </Group>
            <Title order={4} my="md">Desglose por Cliente</Title>
            <Accordion variant="separated">
                {clientRows}
            </Accordion>
        </Paper>
      )}
    </Container>
  );
}


// ====== [25] packages/client/src/features/manager/pages/ManagerDashboard.tsx ======
// filename: packages/client/src/features/manager/pages/ManagerDashboard.tsx
// version: 1.1.6 (FEAT: Link financial widget to report page)
// description: Makes the financial widget clickable, navigating to the new invoicing report page.

import { useEffect, useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { Container, Title, Grid, Paper, Text, Loader, Alert, Center, RingProgress, Stack, Group, Anchor } from '@mantine/core';
import { Bar, Doughnut } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  BarElement,
  Title as ChartTitle,
  Tooltip,
  Legend,
  ArcElement,
} from 'chart.js';
import type { ChartData, ChartOptions } from 'chart.js';
import apiClient from '../../../api/apiClient';

ChartJS.register(
  CategoryScale,
  LinearScale,
  BarElement,
  ChartTitle,
  Tooltip,
  Legend,
  ArcElement
);

interface DashboardData {
  financials: { totalRevenue: number; totalCosts: number; netProfit: number; };
  incidents: { openIncidents: number; resolvedThisMonth: number; avgResolutionTimeHours: number | null; };
  topClientsByProfit: { clientId: string; clientName: string; netProfit: number; }[];
  topProductsByCost: { productId: string; productName: string; totalCost: number; }[];
}

const formatCurrency = (amount: number) => {
  return new Intl.NumberFormat('es-ES', { style: 'currency', currency: 'EUR' }).format(amount);
};

export function ManagerDashboard() {
  const [data, setData] = useState<DashboardData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const navigate = useNavigate();
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await apiClient.get<{ success: boolean; data: DashboardData }>('/dashboard/manager');
        setData(response.data.data);
      } catch (err) {
        setError('No se pudieron cargar los datos del dashboard.');
        console.error(err);
      } finally {
        setIsLoading(false);
      }
    };
    fetchData();
  }, []);

  if (isLoading) return <Center style={{ height: '100%' }}><Loader size="xl" /></Center>;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;
  if (!data) return <Alert color="yellow">No hay datos disponibles para mostrar.</Alert>;
  
  const profitMargin = data.financials.totalRevenue > 0 ? (data.financials.netProfit / data.financials.totalRevenue) * 100 : 0;

  const topProductsChartData: ChartData<'doughnut'> = {
    labels: data.topProductsByCost.map(p => p.productName),
    datasets: [{
      label: 'Coste Total',
      data: data.topProductsByCost.map(p => p.totalCost),
      backgroundColor: ['rgba(255, 99, 132, 0.5)','rgba(54, 162, 235, 0.5)','rgba(255, 206, 86, 0.5)','rgba(75, 192, 192, 0.5)','rgba(153, 102, 255, 0.5)'],
    }]
  };

  const topClientsChartData: ChartData<'bar'> = {
    labels: data.topClientsByProfit.map(c => c.clientName),
    datasets: [{
      label: 'Beneficio Neto',
      data: data.topClientsByProfit.map(c => c.netProfit),
      backgroundColor: 'rgba(75, 192, 192, 0.5)',
      borderColor: 'rgba(75, 192, 192, 1)',
      borderWidth: 1,
    }]
  };

  const topClientsChartOptions: ChartOptions<'bar'> = {
    indexAxis: 'y',
    responsive: true,
    maintainAspectRatio: false,
    onClick: (_, elements) => {
        const element = elements[0];
        if (element && data?.topClientsByProfit) {
            const clientIndex = element.index;
            const client = data.topClientsByProfit[clientIndex];
            if (client) {
                navigate(`/clients/${client.clientId}`);
            }
        }
    },
    plugins: {
        legend: { display: false },
        title: { display: true, text: 'Beneficio Neto en los √∫ltimos 30 d√≠as' }
    }
  };

  return (
    <Container fluid>
      <Title order={2} mb="xl">Dashboard de Gerencia</Title>
      <Grid>
        {/* Widget Salud Financiera */}
        <Grid.Col span={{ base: 12, md: 6, lg: 4 }}>
          {/* ‚úÖ Se envuelve el Paper en un Anchor para hacerlo clicable */}
          <Anchor component={Link} to="/reports/invoicing" underline="never">
            <Paper withBorder p="md" shadow="sm" h="100%">
              <Title order={4} mb="md">Salud Financiera (√öltimos 30 d√≠as)</Title>
              <Group justify="space-around" align="center">
                  <RingProgress
                      size={140}
                      thickness={14}
                      roundCaps
                      label={<Text c="blue" fw={700} ta="center" size="xl">{profitMargin.toFixed(1)}%</Text>}
                      sections={[{ value: profitMargin, color: 'blue' }]}
                  />
                  <Stack gap="xs">
                      <Text>Ingresos: {formatCurrency(data.financials.totalRevenue)}</Text>
                      <Text>Costes: {formatCurrency(data.financials.totalCosts)}</Text>
                      <Text fw={700}>Beneficio: {formatCurrency(data.financials.netProfit)}</Text>
                  </Stack>
              </Group>
            </Paper>
          </Anchor>
        </Grid.Col>

        {/* Widget Estado de Incidencias */}
        <Grid.Col span={{ base: 12, md: 6, lg: 4 }}>
          <Paper withBorder p="md" shadow="sm" h="100%">
            <Title order={4} mb="md">Estado de Incidencias</Title>
            <Group justify="space-around" align="flex-end" h="80%">
                <Stack align="center" gap={0}>
                    <Text size="3rem" fw={700} c="orange">{data.incidents.openIncidents}</Text>
                    <Text c="dimmed">Abiertas</Text>
                </Stack>
                <Stack align="center" gap={0}>
                    <Text size="3rem" fw={700} c="green">{data.incidents.resolvedThisMonth}</Text>
                    <Text c="dimmed">Resueltas (Mes)</Text>
                </Stack>
            </Group>
          </Paper>
        </Grid.Col>

        {/* Widget Top 5 Productos por Coste */}
        <Grid.Col span={{ base: 12, lg: 4 }}>
          <Paper withBorder p="md" shadow="sm" h="100%">
            <Title order={4} mb="md">Top 5 Productos por Coste</Title>
            <Center style={{maxHeight: 250}}>
                <Doughnut data={topProductsChartData} options={{ responsive: true, maintainAspectRatio: false }} />
            </Center>
          </Paper>
        </Grid.Col>

        <Grid.Col span={12}>
          <Paper withBorder p="md" shadow="sm">
            <Title order={4} mb="md">Top 5 Clientes por Rentabilidad</Title>
            <div style={{ height: '300px' }}>
                <Bar 
                    data={topClientsChartData}
                    options={topClientsChartOptions}
                />
            </div>
          </Paper>
        </Grid.Col>
      </Grid>
    </Container>
  );
}


// ====== [26] packages/client/src/features/superadmin/pages/TenantsPage.tsx ======
import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Badge,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  PasswordInput,
  Menu,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient.js';

// --- Tipos ---
type SubscriptionStatus = 'TRIAL' | 'ACTIVE' | 'PAYMENT_PENDING' | 'INACTIVE';

interface Tenant {
  id: string;
  companyName: string;
  subdomain: string;
  subscriptionStatus: SubscriptionStatus;
  createdAt: string;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function TenantsPage() {
  const [tenants, setTenants] = useState<Tenant[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);

  const form = useForm({
    initialValues: {
      companyName: '',
      subdomain: '',
      adminUser: {
        name: '',
        email: '',
        password: '',
      },
    },
    validate: {
      companyName: (value: string) => (value.length < 2 ? 'El nombre debe tener al menos 2 caracteres' : null),
      subdomain: (value: string) => (/^[a-z0-9]+(?:-[a-z0-9]+)*$/.test(value) ? null : 'Subdominio inv√°lido'),
      adminUser: {
        email: (value: string) => (/^\S+@\S+$/.test(value) ? null : 'Email inv√°lido'),
        password: (value: string) => (value.length < 8 ? 'La contrase√±a debe tener al menos 8 caracteres' : null),
      },
    },
  });

  const fetchTenants = async () => {
    if (tenants.length === 0) setIsLoading(true);
    setError(null);
    try {
      const response = await apiClient.get<ApiResponse<Tenant[]>>('/tenants');
      setTenants(response.data.data);
    } catch (err) {
      setError('No se pudo obtener la lista de tenants.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchTenants();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handleCreateTenant = async (values: typeof form.values) => {
    try {
      await apiClient.post<ApiResponse<Tenant>>('/tenants', values);
      await fetchTenants();
      closeModal();
      form.reset();
    } catch (err: any) {
      form.setErrors({ companyName: err.response?.data?.message || 'Error al crear el tenant' });
    }
  };

  const handleUpdateStatus = async (tenantId: string, status: SubscriptionStatus) => {
    try {
      setTenants((current) =>
        current.map((t) => (t.id === tenantId ? { ...t, subscriptionStatus: status } : t))
      );
      await apiClient.patch(`/tenants/${tenantId}/status`, { status });
    } catch (err) {
      console.error('Failed to update tenant status', err);
      await fetchTenants();
    }
  };

  const handleDeleteTenant = async (tenantId: string) => {
    if (window.confirm('¬øEst√°s seguro? Esta acci√≥n eliminar√° el tenant y todos sus datos (usuarios, clientes, piscinas, etc.) de forma irreversible.')) {
      try {
        await apiClient.delete(`/tenants/${tenantId}`);
        setTenants((current) => current.filter((t) => t.id !== tenantId));
      } catch (err) {
        console.error('Failed to delete tenant', err);
        // TODO: Mostrar notificaci√≥n de error al usuario
      }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = tenants.map((tenant) => (
    <Table.Tr key={tenant.id}>
      <Table.Td>{tenant.companyName}</Table.Td>
      <Table.Td>{tenant.subdomain}.pool-control.pro</Table.Td>
      <Table.Td>
        <Badge
          color={
            {
              ACTIVE: 'green',
              TRIAL: 'blue',
              PAYMENT_PENDING: 'orange',
              INACTIVE: 'gray',
            }[tenant.subscriptionStatus]
          }
        >
          {tenant.subscriptionStatus}
        </Badge>
      </Table.Td>
      <Table.Td>{new Date(tenant.createdAt).toLocaleDateString()}</Table.Td>
      <Table.Td>
        <Menu shadow="md" width={200}>
          <Menu.Target>
            <Button variant="outline" size="xs">Acciones</Button>
          </Menu.Target>
          <Menu.Dropdown>
            <Menu.Label>Cambiar estado</Menu.Label>
            <Menu.Item onClick={() => handleUpdateStatus(tenant.id, 'ACTIVE')}>Activar</Menu.Item>
            <Menu.Item onClick={() => handleUpdateStatus(tenant.id, 'TRIAL')}>Poner en Trial</Menu.Item>
            <Menu.Item onClick={() => handleUpdateStatus(tenant.id, 'PAYMENT_PENDING')}>Pago Pendiente</Menu.Item>
            <Menu.Item onClick={() => handleUpdateStatus(tenant.id, 'INACTIVE')}>Desactivar</Menu.Item>
            <Menu.Divider />
            <Menu.Label>Zona de Peligro</Menu.Label>
            <Menu.Item color="red" onClick={() => handleDeleteTenant(tenant.id)}>
              Eliminar Tenant
            </Menu.Item>
          </Menu.Dropdown>
        </Menu>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal opened={modalOpened} onClose={closeModal} title="Crear Nuevo Tenant" centered>
        <form onSubmit={form.onSubmit(handleCreateTenant)}>
          <Stack>
            <TextInput required label="Nombre de la Empresa" placeholder="Ej. Piscinas Mart√≠nez" {...form.getInputProps('companyName')} />
            <TextInput required label="Subdominio" placeholder="ej. martinez" {...form.getInputProps('subdomain')} />
            <Title order={4} mt="md">Usuario Administrador</Title>
            <TextInput required label="Nombre del Admin" placeholder="Ej. Juan Mart√≠nez" {...form.getInputProps('adminUser.name')} />
            <TextInput required label="Email del Admin" placeholder="ej. juan@piscinasmartinez.com" {...form.getInputProps('adminUser.email')} />
            <PasswordInput required label="Contrase√±a del Admin" {...form.getInputProps('adminUser.password')} />
            <Button type="submit" mt="md">Crear Tenant</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Gesti√≥n de Tenants</Title>
          <Button onClick={openModal}>Crear Nuevo Tenant</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Empresa</Table.Th>
              <Table.Th>Subdominio</Table.Th>
              <Table.Th>Estado</Table.Th>
              <Table.Th>Fecha de Creaci√≥n</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={5}>No hay tenants creados.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [27] packages/client/src/features/technician/pages/MyRoutePage.tsx ======
// filename: packages/client/src/features/technician/pages/MyRoutePage.tsx
// Version: 1.2.1 (FIXED - Decouple from @prisma/client)
import { useEffect, useState } from 'react';
import { Link, useLocation } from 'react-router-dom';
import {
  Container,
  Title,
  Loader,
  Alert,
  Stack,
  Card,
  Text,
  Group,
  Anchor,
  ThemeIcon,
  Badge,
  Divider,
} from '@mantine/core';
import apiClient from '../../../api/apiClient';

// --- Tipos del Frontend ---
// Definimos los tipos aqu√≠, bas√°ndonos en lo que esperamos de la API,
// sin acoplar el frontend al backend.
type IncidentPriority = 'LOW' | 'NORMAL' | 'HIGH' | 'CRITICAL';

interface Visit {
  id: string;
  timestamp: string;
  pool: {
    id: string;
    name: string;
    address: string;
    client: { name: string; };
  };
}

interface AssignedTask {
  id: string;
  title: string;
  priority: IncidentPriority;
  notification: {
    id: string;
    visit: {
      pool: { name: string; };
    } | null;
  };
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function MyRoutePage() {
  const [visits, setVisits] = useState<Visit[]>([]);
  const [tasks, setTasks] = useState<AssignedTask[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const location = useLocation();

  const fetchData = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const [visitsResponse, tasksResponse] = await Promise.all([
        apiClient.get<ApiResponse<Visit[]>>('/visits/my-route'),
        apiClient.get<ApiResponse<AssignedTask[]>>('/incident-tasks/my-tasks'),
      ]);
      setVisits(visitsResponse.data.data);
      setTasks(tasksResponse.data.data);
    } catch (err) {
      setError('No se pudo cargar tu trabajo del d√≠a.');
      console.error(err);
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchData();
  }, [location.key]);

  if (isLoading) {
    return (
      <Container style={{ textAlign: 'center', paddingTop: '50px' }}>
        <Loader size="xl" />
        <Text mt="md">Cargando tu trabajo del d√≠a...</Text>
      </Container>
    );
  }

  if (error) {
    return <Alert color="red" title="Error">{error}</Alert>;
  }

  const taskCards = tasks.map((task) => (
    <Card key={task.id} shadow="sm" padding="lg" radius="md" withBorder>
      <Link to={`/incidents/${task.notification.id}`} style={{ textDecoration: 'none', color: 'inherit' }}>
        <Group justify="space-between" mb="xs">
          <Text fw={500} size="lg">{task.title}</Text>
          <Badge color={task.priority === 'HIGH' || task.priority === 'CRITICAL' ? 'red' : 'orange'}>
            {task.priority}
          </Badge>
        </Group>
        <Text size="sm" c="dimmed">
          Incidencia en: {task.notification.visit?.pool.name || 'Piscina no especificada'}
        </Text>
      </Link>
    </Card>
  ));

  const visitCards = visits.map((visit) => (
    <Card key={visit.id} shadow="sm" padding="lg" radius="md" withBorder>
      <Link to={`/visits/${visit.id}`} style={{ textDecoration: 'none', color: 'inherit' }}>
        <Group justify="space-between" mb="xs">
          <Text fw={500} size="lg">{visit.pool.name}</Text>
          <ThemeIcon variant="light" radius="md" size="lg"><span>üìç</span></ThemeIcon>
        </Group>
        <Text size="sm" c="dimmed">Cliente: {visit.pool.client.name}</Text>
      </Link>
      <Anchor href={`https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(visit.pool.address)}`} target="_blank" rel="noopener noreferrer" size="sm" mt="sm">
        {visit.pool.address}
      </Anchor>
    </Card>
  ));

  return (
    <Container>
      <Title order={2} my="lg">Mi Trabajo de Hoy</Title>
      
      <Stack gap="xl">
        {tasks.length > 0 && (
          <Stack>
            <Title order={4} c="orange.7">Tareas Especiales</Title>
            {taskCards}
          </Stack>
        )}

        {visits.length > 0 && tasks.length > 0 && <Divider my="md" />}
        
        {visits.length > 0 && (
          <Stack>
            <Title order={4}>Visitas Programadas</Title>
            {visitCards}
          </Stack>
        )}

        {visits.length === 0 && tasks.length === 0 && (
          <Text>No tienes trabajo asignado para hoy.</Text>
        )}
      </Stack>
    </Container>
  );
}


// ====== [28] packages/client/src/features/technician/pages/WorkOrderPage.tsx ======
// filename: packages/client/src/features/technician/pages/WorkOrderPage.tsx
// version: 2.0.2 (REFACTOR: Remove redundant incident management modals)

import { useEffect, useState } from 'react';
import { useParams, Link, useNavigate } from 'react-router-dom';
import {
  Container,
  Title,
  Loader,
  Alert,
  Paper,
  Text,
  Breadcrumbs,
  Button,
  Stack,
  Checkbox,
  NumberInput,
  Switch,
  TextInput,
  Select,
  Textarea,
  Badge,
  Grid,
  Modal,
  Group,
  Divider,
  ActionIcon,
  FileInput,
  Progress,
  ThemeIcon,
  SimpleGrid,
  Image,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient';
import axios from 'axios';

// --- Tipos ---
type IncidentPriority = 'LOW' | 'NORMAL' | 'HIGH' | 'CRITICAL';

interface IncidentImage {
  id: string;
  url: string;
}

interface Notification {
    id: string;
    status: 'PENDING' | 'RESOLVED';
    resolutionNotes: string | null;
    priority: IncidentPriority | null;
    resolutionDeadline: string | null;
    images: IncidentImage[];
}

interface VisitResult { parameterName: string; parameterUnit: string | null; value: string; }
interface Product { id: string; name: string; unit: string; }
interface Consumption { quantity: number; product: Product; }
interface VisitDetails {
  id: string; status: 'PENDING' | 'COMPLETED' | 'CANCELLED'; notes: string | null; hasIncident: boolean;
  completedTasks: string[]; results: VisitResult[]; notifications: Notification[]; consumptions: Consumption[];
  pool: {
    name: string; address: string; client: { name: string };
    configurations: {
      id: string;
      parameterTemplate?: { id: string; name: string; unit: string | null; type: 'NUMBER' | 'BOOLEAN' | 'TEXT' | 'SELECT'; selectOptions: string[]; };
      taskTemplate?: { id: string; name: string; };
    }[];
  };
}
interface ApiResponse<T> { success: boolean; data: T; }

// --- Componente de Solo Lectura (para el Admin) ---
const ReadOnlyWorkOrder = ({ visit }: { visit: VisitDetails }) => {
  const [imageModalOpened, { open: openImageModal, close: closeImageModal }] = useDisclosure(false);
  const [selectedImage, setSelectedImage] = useState<string | null>(null);

  const incidentNotification = visit.notifications.length > 0 ? visit.notifications[0] : null;

  const handleImageClick = (url: string) => {
    setSelectedImage(url);
    openImageModal();
  };

  return (
    <>
      <Modal opened={imageModalOpened} onClose={closeImageModal} title="Imagen de la Incidencia" centered size="xl">
        {selectedImage && <Image src={selectedImage} />}
      </Modal>

      <Container>
          <Breadcrumbs><Link to="/">Dashboard</Link><Text>{visit.pool.name}</Text></Breadcrumbs>
          <Grid align="center" justify="space-between" my="lg"><Grid.Col span="auto"><Title order={2}>Resumen de Visita: {visit.pool.name}</Title></Grid.Col><Grid.Col span="content"><Badge color="green" size="lg">COMPLETADA</Badge></Grid.Col></Grid>
          <Text c="dimmed">{visit.pool.client.name} - {visit.pool.address}</Text>

          <Paper withBorder p="md" mt="xl">
              <Stack>
                  {visit.results.length > 0 && (<div><Title order={4} mb="sm">Resultados de Mediciones</Title>{visit.results.map(r => <Text key={r.parameterName}><strong>{r.parameterName}:</strong> {r.value} {r.parameterUnit || ''}</Text>)}</div>)}
                  {visit.completedTasks.length > 0 && (<div><Title order={4} mt="lg" mb="sm">Tareas Realizadas</Title>{visit.completedTasks.map(t => <Text key={t}>‚úÖ {t}</Text>)}</div>)}
                  {visit.consumptions.length > 0 && (<div><Title order={4} mt="lg" mb="sm">Productos Consumidos</Title>{visit.consumptions.map(c => <Text key={c.product.id}>- {c.quantity} {c.product.unit} de {c.product.name}</Text>)}</div>)}
                  <Divider my="sm" />
                  <div>
                      <Title order={4}>Observaciones e Incidencia</Title>
                      <Text fw={500} mt="sm">Notas del T√©cnico:</Text>
                      <Paper withBorder p="sm" bg="gray.0" mt="xs"><Text>{visit.notes || 'No se dejaron notas.'}</Text></Paper>
                      
                      {incidentNotification && incidentNotification.images.length > 0 && (
                        <>
                          <Text fw={500} mt="lg">Im√°genes Adjuntas:</Text>
                          <SimpleGrid cols={{ base: 2, sm: 3, lg: 4 }} mt="xs">
                            {incidentNotification.images.map(image => (
                              <Paper key={image.id} withBorder radius="md" style={{ cursor: 'pointer' }} onClick={() => handleImageClick(image.url)}>
                                <Image src={image.url} height={120} radius="md" />
                              </Paper>
                            ))}
                          </SimpleGrid>
                        </>
                      )}

                      {visit.hasIncident && incidentNotification && (
                        <Paper withBorder p="sm" mt="md" shadow="xs" bg={incidentNotification.status === 'RESOLVED' ? 'gray.0' : 'yellow.0'}>
                            {incidentNotification.status === 'RESOLVED' ? (
                                <Stack mt="md" gap="xs">
                                  <Badge color="green" size="lg">INCIDENCIA RESUELTA</Badge>
                                  <Text fw={500} mt="sm">Notas de Resoluci√≥n (Admin):</Text>
                                  <Paper withBorder p="sm" bg="green.0" mt="xs"><Text>{incidentNotification.resolutionNotes}</Text></Paper>
                                </Stack>
                            ) : (
                                <Group>
                                  <Badge color="red" size="lg" variant="filled">INCIDENCIA PENDIENTE</Badge>
                                  <Button 
                                    component={Link} 
                                    to={`/incidents/${incidentNotification.id}`}
                                    variant="light"
                                  >
                                    Gestionar Incidencia ‚Üí
                                  </Button>
                                </Group>
                            )}
                        </Paper>
                      )}
                  </div>
              </Stack>
          </Paper>
        </Container>
    </>
  );
};


// --- Componente de Formulario Editable (para el T√©cnico) ---
// (Este componente no ha sido modificado)
interface UploadedFile { file: File; progress: number; url?: string; error?: string; }
const EditableWorkOrder = ({ visit, products, onSubmit }: { visit: VisitDetails; products: Product[], onSubmit: (values: any) => Promise<void> }) => {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [uploadedFiles, setUploadedFiles] = useState<UploadedFile[]>([]);

  const form = useForm({
    initialValues: {
      results: visit.pool.configurations.filter(c => c.parameterTemplate).reduce((acc, c) => ({ ...acc, [c.id]: '' }), {}),
      completedTasks: visit.pool.configurations.filter(c => c.taskTemplate).reduce((acc, c) => ({ ...acc, [c.id]: false }), {}),
      consumptions: [] as { productId: string; quantity: number | '' }[],
      notes: '',
      hasIncident: false,
    },
  });

  const handleImageUpload = async (files: File[]) => {
    if (!files || files.length === 0) return;
    const newFiles = files.map(file => ({ file, progress: 0 }));
    setUploadedFiles(prev => [...prev, ...newFiles]);

    try {
      const { data: signatureData } = await apiClient.get('/uploads/signature');
      const { signature, timestamp, apiKey, cloudName } = signatureData.data;

      for (const fileObj of newFiles) {
        const formData = new FormData();
        formData.append('file', fileObj.file);
        formData.append('signature', signature);
        formData.append('timestamp', timestamp);
        formData.append('api_key', apiKey);

        try {
          const response = await axios.post(
            `https://api.cloudinary.com/v1_1/${cloudName}/image/upload`,
            formData,
            { onUploadProgress: (event) => {
                const progress = event.total ? Math.round((100 * event.loaded) / event.total) : 0;
                setUploadedFiles(prev => prev.map(f => f.file === fileObj.file ? { ...f, progress } : f));
            }}
          );
          setUploadedFiles(prev => prev.map(f => f.file === fileObj.file ? { ...f, url: response.data.secure_url } : f));
        } catch (uploadError) {
          setUploadedFiles(prev => prev.map(f => f.file === fileObj.file ? { ...f, error: 'Error al subir' } : f));
        }
      }
    } catch (signatureError) {
      console.error("Error al obtener la firma", signatureError);
    }
  };

  const handleSubmit = async (values: typeof form.values) => {
    setIsSubmitting(true);
    const successfulUrls = uploadedFiles.filter(f => f.url).map(f => f.url!);
    const payload = { ...values, imageUrls: successfulUrls };
    await onSubmit(payload);
    setIsSubmitting(false);
  };
  
  const productOptions = products.map(p => ({ value: p.id, label: `${p.name} (${p.unit})` }));
  const consumptionFields = form.values.consumptions.map((_, index) => <Grid key={index} align="flex-end"><Grid.Col span={7}><Select label={index === 0 ? 'Producto' : ''} placeholder="Seleccione un producto" data={productOptions} {...form.getInputProps(`consumptions.${index}.productId`)} required /></Grid.Col><Grid.Col span={3}><NumberInput label={index === 0 ? 'Cantidad' : ''} placeholder="0.0" min={0} decimalScale={2} {...form.getInputProps(`consumptions.${index}.quantity`)} required /></Grid.Col><Grid.Col span={2}><ActionIcon color="red" onClick={() => form.removeListItem('consumptions', index)}>üóëÔ∏è</ActionIcon></Grid.Col></Grid>);
  const parametersToMeasure = visit.pool.configurations.filter(c => c.parameterTemplate);
  const tasksToComplete = visit.pool.configurations.filter(c => c.taskTemplate);
  const renderParameterInput = (config: typeof parametersToMeasure[0]) => { const param = config.parameterTemplate; if (!param) return null; const label = `${param.name}${param.unit ? ` (${param.unit})` : ''}`; switch (param.type) { case 'NUMBER': return <NumberInput label={label} {...form.getInputProps(`results.${config.id}`)} />; case 'BOOLEAN': return <Switch mt="md" label={label} {...form.getInputProps(`results.${config.id}`, { type: 'checkbox' })} />; case 'TEXT': return <TextInput label={label} {...form.getInputProps(`results.${config.id}`)} />; case 'SELECT': return <Select label={label} data={param.selectOptions} {...form.getInputProps(`results.${config.id}`)} />; default: return <Text c="red">Tipo no soportado: {param.type}</Text>; } };

  return (
      <Container>
        <Breadcrumbs><Link to="/my-route">Mi Ruta</Link><Text>{visit.pool.name}</Text></Breadcrumbs>
        <Title order={2} my="lg">Parte de Trabajo: {visit.pool.name}</Title>
        <Text c="dimmed">{visit.pool.client.name} - {visit.pool.address}</Text>
        <Paper withBorder p="md" mt="xl">
          <form onSubmit={form.onSubmit(handleSubmit)}>
            <Stack>
              {parametersToMeasure.length > 0 && (<div><Title order={4} mb="sm">Mediciones</Title><Stack>{parametersToMeasure.map(p => <div key={p.id}>{renderParameterInput(p)}</div>)}</Stack></div>)}
              {tasksToComplete.length > 0 && (<div><Title order={4} mt="lg" mb="sm">Tareas</Title><Stack>{tasksToComplete.map(t => <Checkbox key={t.id} label={t.taskTemplate?.name} {...form.getInputProps(`completedTasks.${t.id}`, { type: 'checkbox' })} />)}</Stack></div>)}
              <Divider my="md" label="Consumo de Productos" labelPosition="center" />
              {consumptionFields}
              <Button mt="xs" variant="outline" onClick={() => form.insertListItem('consumptions', { productId: '', quantity: '' })}>+ A√±adir Producto</Button>
              <Divider my="md" />
              <Title order={4} mb="sm">Observaciones e Incidencias</Title>
              <Textarea label="Notas de la visita" placeholder="Cualquier observaci√≥n relevante..." {...form.getInputProps('notes')} />
              <Checkbox label="Reportar como Incidencia" description="Marcar si hay un problema para el administrador." {...form.getInputProps('hasIncident', { type: 'checkbox' })} />
              
              {form.values.hasIncident && (
                <Stack mt="sm" gap="xs">
                  <FileInput label="Adjuntar Fotos" placeholder="Seleccionar im√°genes..." multiple accept="image/png,image/jpeg" onChange={handleImageUpload} />
                  {uploadedFiles.length > 0 && (
                    <Stack gap="xs">
                      {uploadedFiles.map((fileObj, index) => (
                        <Paper key={index} withBorder p="xs" radius="sm">
                          <Group justify="space-between">
                            <Text size="sm" truncate style={{flex: 1}}>{fileObj.file.name}</Text>
                            {fileObj.progress < 100 && !fileObj.error && <Progress value={fileObj.progress} striped animated size="lg" style={{width: '100px'}} />}
                            {fileObj.url && <ThemeIcon color="green" variant="light">‚úì</ThemeIcon>}
                            {fileObj.error && <ThemeIcon color="red" variant="light">‚úó</ThemeIcon>}
                          </Group>
                        </Paper>
                      ))}
                    </Stack>
                  )}
                </Stack>
              )}
              
              <Button type="submit" mt="xl" size="lg" loading={isSubmitting}>Guardar y Finalizar Visita</Button>
            </Stack>
          </form>
        </Paper>
      </Container>
  );
};


// --- Componente Principal ---
export function WorkOrderPage() {
  const { visitId } = useParams<{ visitId: string }>();
  const navigate = useNavigate();
  const [visit, setVisit] = useState<VisitDetails | null>(null); // <-- L√çNEA CORREGIDA
  const [products, setProducts] = useState<Product[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!visitId) { setError('No se ha proporcionado un ID de visita.'); setIsLoading(false); return; }
    
    const fetchAllData = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const [visitResponse, productsResponse] = await Promise.all([
          apiClient.get<ApiResponse<VisitDetails>>(`/visits/${visitId}`),
          apiClient.get<ApiResponse<Product[]>>('/products')
        ]);
        setVisit(visitResponse.data.data);
        setProducts(productsResponse.data.data);
      } catch (err) { setError('No se pudo cargar la informaci√≥n de la visita o los productos.'); } finally { setIsLoading(false); }
    };
    fetchAllData();
  }, [visitId]);

  const handleSubmit = async (values: any) => {
    if (!visitId) return;
    try {
      await apiClient.post(`/visits/${visitId}/complete`, values);
      navigate('/my-route');
    } catch (err) { console.error('Error submitting work order', err); }
  };

  if (isLoading) return <Container style={{ textAlign: 'center', paddingTop: '50px' }}><Loader size="xl" /></Container>;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;
  if (!visit) return <Alert color="yellow" title="Aviso">Visita no encontrada.</Alert>;
  
  if (visit.status === 'COMPLETED') {
    return <ReadOnlyWorkOrder visit={visit} />;
  }
  
  return <EditableWorkOrder visit={visit} products={products} onSubmit={handleSubmit} />;
}


// ====== [29] packages/client/src/main.tsx ======
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.js';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


// ====== [30] packages/client/src/providers/AuthProvider.tsx ======
// filename: packages/client/src/providers/AuthProvider.tsx
// version: 2.1.0 (FEAT: Synchronize with Zustand store)

import {
  createContext,
  useContext,
  useState,
  useEffect,
  useCallback,
  useMemo,
} from 'react';
import type { PropsWithChildren } from 'react';
import apiClient from '../api/apiClient.js';
// --- ‚úÖ 1. IMPORTAR EL HOOK DEL STORE ---
import { useAuthStore } from '../stores/auth.store.js';

// --- Tipos ---
type LoginCredentials = {
  email: string;
  password: string;
};

interface User {
  id: string;
  name: string;
  email: string;
  role: 'SUPER_ADMIN' | 'ADMIN' | 'TECHNICIAN' | 'MANAGER';
}

export type ViewAsRole = 'MANAGER' | 'ADMIN' | 'TECHNICIAN';

interface AuthContextType {
  user: User | null;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => Promise<void>;
  isLoading: boolean;
  isAuthenticated: boolean;
  activeView: ViewAsRole;
  setViewAs: (role: ViewAsRole) => void;
  activeRole: User['role'] | null;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: PropsWithChildren) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [activeView, setActiveView] = useState<ViewAsRole>('MANAGER');

  // --- ‚úÖ 2. OBTENER LA FUNCI√ìN PARA ACTUALIZAR EL STORE ---
  const setAuthStateInStore = useAuthStore((state) => state.setAuthState);

  // --- ‚úÖ 3. SINCRONIZAR EL ESTADO LOCAL CON EL STORE ---
  // Cada vez que el usuario o la vista activa cambien, actualizamos el store.
  useEffect(() => {
    setAuthStateInStore(user, activeView);
  }, [user, activeView, setAuthStateInStore]);


  const checkAuthStatus = useCallback(async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get('/auth/me');
      const loggedUser: User = response.data.data;
      setUser(loggedUser);
      if (loggedUser.role === 'ADMIN' || loggedUser.role === 'TECHNICIAN') {
        setActiveView(loggedUser.role);
      } else {
        setActiveView('MANAGER');
      }
    } catch (error) {
      setUser(null);
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    checkAuthStatus();
  }, [checkAuthStatus]);

  const login = async (credentials: LoginCredentials) => {
    const response = await apiClient.post('/auth/login', credentials);
    const loggedUser: User = response.data.data;
    setUser(loggedUser);
    if (loggedUser.role === 'ADMIN' || loggedUser.role === 'TECHNICIAN') {
      setActiveView(loggedUser.role);
    } else {
      setActiveView('MANAGER');
    }
  };

  const logout = async () => {
    await apiClient.post('/auth/logout');
    setUser(null);
  };

  const setViewAs = (role: ViewAsRole) => {
    if (user?.role === 'MANAGER') {
      setActiveView(role);
    }
  };

  const activeRole = useMemo(() => {
    if (!user) return null;
    if (user.role === 'MANAGER') {
      return activeView;
    }
    return user.role;
  }, [user, activeView]);


  const value: AuthContextType = {
    user,
    login,
    logout,
    isLoading,
    isAuthenticated: !!user,
    activeView,
    setViewAs,
    activeRole,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};


// ====== [31] packages/client/src/router/components.tsx ======
// filename: packages/client/src/router/components.tsx
// version: 2.4.0 (REFACTOR: Rename ManagerRoute to FinancialAdminRoute and adjust logic)

import { AppShell, Burger, Group, NavLink, Title, Button, Indicator, ActionIcon, Popover, Text, Stack, SegmentedControl } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { Navigate, Outlet, Link, useNavigate } from 'react-router-dom';
import { useAuth } from '../providers/AuthProvider.js';
import type { ViewAsRole } from '../providers/AuthProvider.js';
import { useEffect, useState } from 'react';
import apiClient from '../api/apiClient.js';

interface Notification {
  id: string;
  message: string;
  visitId: string | null;
  parentNotificationId: string | null;
  isRead: boolean;
}

const NotificationBell = () => {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [popoverOpened, setPopoverOpened] = useState(false);
  const navigate = useNavigate();

  const fetchNotifications = async () => {
    try {
      const response = await apiClient.get<{ success: boolean; data: Notification[] }>('/notifications');
      setNotifications(response.data.data);
    } catch (error) {
      console.error('Failed to fetch notifications', error);
    }
  };

  useEffect(() => {
    fetchNotifications();
    const interval = setInterval(fetchNotifications, 60000);
    return () => clearInterval(interval);
  }, []);

  const handleNotificationClick = async (notification: Notification) => {
    if (!notification.isRead) {
      setNotifications(current =>
        current.map(n =>
          n.id === notification.id ? { ...n, isRead: true } : n
        )
      );
      try {
        await apiClient.post(`/notifications/${notification.id}/read`);
      } catch (error) {
        console.error('Failed to mark notification as read', error);
        fetchNotifications();
      }
    }
    
    const incidentId = notification.parentNotificationId || notification.id;
    navigate(`/incidents/${incidentId}`);
    
    setPopoverOpened(false);
  };
  
  const hasUnread = notifications.some(n => !n.isRead);

  return (
    <Popover opened={popoverOpened} onChange={setPopoverOpened} width={300} position="bottom-end" withArrow shadow="md">
      <Popover.Target>
        <Indicator color="red" disabled={!hasUnread} withBorder processing>
          <ActionIcon variant="default" size="lg" onClick={() => setPopoverOpened((o) => !o)}>
            üîî
          </ActionIcon>
        </Indicator>
      </Popover.Target>

      <Popover.Dropdown>
        <Stack>
          <Text fw={500}>Notificaciones</Text>
          {notifications.length > 0 ? (
            notifications.map(notification => (
              <Text
                key={notification.id}
                size="sm"
                onClick={() => handleNotificationClick(notification)}
                style={{
                  cursor: 'pointer',
                  padding: '5px',
                  borderRadius: '4px',
                  fontWeight: notification.isRead ? 400 : 700,
                  color: notification.isRead ? 'gray' : 'black',
                }}
                onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#f1f3f5'}
                onMouseLeave={(e) => e.currentTarget.style.backgroundColor = 'transparent'}
              >
                {notification.message}
              </Text>
            ))
          ) : (
            <Text size="sm" c="dimmed">No hay notificaciones pendientes.</Text>
          )}
        </Stack>
      </Popover.Dropdown>
    </Popover>
  );
};

export const AppLayout = () => {
  const [opened, { toggle }] = useDisclosure();
  const { user, logout, activeView, setViewAs, activeRole } = useAuth();
  const navigate = useNavigate();

  const handleLogout = async () => {
    await logout();
    navigate('/login');
  };

  const handleViewChange = (value: string) => {
    const role = value as ViewAsRole;
    setViewAs(role);
    if (role === 'ADMIN' || role === 'MANAGER') navigate('/');
    if (role === 'TECHNICIAN') navigate('/my-route');
  };

  return (
    <AppShell
      header={{ height: 60 }}
      navbar={{ width: 300, breakpoint: 'sm', collapsed: { mobile: !opened } }}
      padding="md"
    >
      <AppShell.Header>
        <Group h="100%" px="md" justify="space-between">
          <Group>
            <Burger opened={opened} onClick={toggle} hiddenFrom="sm" size="sm" />
            <Title order={3}>Pool Control Pro</Title>
          </Group>
          <Group>
            {user?.role === 'MANAGER' && (
              <SegmentedControl
                value={activeView}
                onChange={handleViewChange}
                data={[
                  { label: 'Gerencia', value: 'MANAGER' },
                  { label: 'Admin', value: 'ADMIN' },
                  { label: 'T√©cnico', value: 'TECHNICIAN' },
                ]}
              />
            )}
            {activeRole === 'ADMIN' && <NotificationBell />}
            <Button variant="light" onClick={handleLogout}>Cerrar Sesi√≥n</Button>
          </Group>
        </Group>
      </AppShell.Header>

      <AppShell.Navbar p="md">
        {activeRole === 'MANAGER' && (
          <NavLink
            component={Link}
            to="/"
            label="Dashboard de Gerencia"
            onClick={toggle}
          />
        )}
        
        {activeRole === 'ADMIN' && (
          <>
            <NavLink component={Link} to="/" label="Dashboard de Admin" onClick={toggle} />
            <NavLink component={Link} to="/planner" label="Planificador" onClick={toggle} />
            <NavLink component={Link} to="/clients" label="Clientes" onClick={toggle} />
            <NavLink component={Link} to="/incidents-history" label="Gesti√≥n de Incidencias" onClick={toggle} />
            <NavLink label="Informes" defaultOpened>
                <NavLink component={Link} to="/reports/invoicing" label="Informe para Facturaci√≥n" onClick={toggle}/>
            </NavLink>
            <NavLink label="Cat√°logos" defaultOpened>
              <NavLink component={Link} to="/catalog/parameters" label="Par√°metros" onClick={toggle} />
              <NavLink component={Link} to="/catalog/tasks" label="Tareas" onClick={toggle} />
              <NavLink component={Link} to="/catalog/products" label="Productos" onClick={toggle} />
              <NavLink component={Link} to="/catalog/product-categories" label="Categor√≠as de Productos" onClick={toggle} />
            </NavLink>
            <NavLink label="Finanzas" defaultOpened>
                <NavLink component={Link} to="/financials/payments" label="Pagos Recibidos" onClick={toggle} />
                <NavLink component={Link} to="/financials/expenses" label="Gastos Generales" onClick={toggle} />
            </NavLink>
          </>
        )}

        {activeRole === 'TECHNICIAN' && (
          <NavLink component={Link} to="/my-route" label="Mi Ruta de Hoy" onClick={toggle} />
        )}

        {user?.role === 'SUPER_ADMIN' && (
           <NavLink component={Link} to="/superadmin/tenants" label="Gesti√≥n de Tenants" onClick={toggle} />
        )}
      </AppShell.Navbar>

      <AppShell.Main>
        <Outlet />
      </AppShell.Main>
    </AppShell>
  );
};

export const ProtectedRoute = () => {
  const { isAuthenticated, isLoading } = useAuth();
  if (isLoading) return <div>Cargando...</div>;
  if (!isAuthenticated) return <Navigate to="/login" replace />;
  return <Outlet />;
};

export const SuperAdminRoute = () => {
  const { user, isLoading } = useAuth();
  if (isLoading) return <div>Cargando...</div>;
  if (user?.role !== 'SUPER_ADMIN') return <Navigate to="/" replace />;
  return <Outlet />;
};

export const AdminRoute = () => {
  const { activeRole, isLoading } = useAuth();
  if (isLoading) return <div>Cargando...</div>;
  if (activeRole !== 'ADMIN') {
    return <Navigate to="/" replace />;
  }
  return <Outlet />;
};

export const TechnicianRoute = () => {
  const { activeRole, isLoading } = useAuth();
  if (isLoading) return <div>Cargando...</div>;
  if (activeRole !== 'TECHNICIAN') {
    return <Navigate to="/" replace />;
  }
  return <Outlet />;
};

// Renombrado de ManagerRoute -> FinancialAdminRoute
export const FinancialAdminRoute = () => {
    const { activeRole, isLoading } = useAuth();
    if (isLoading) return <div>Cargando...</div>;
    // Ahora permite el acceso a MANAGER o ADMIN
    if (activeRole !== 'MANAGER' && activeRole !== 'ADMIN') {
      return <Navigate to="/" replace />;
    }
    return <Outlet />;
};


// ====== [32] packages/client/src/router/index.tsx ======
// filename: packages/client/src/router/index.tsx
// Version: 2.5.0 (REFACTOR: Use FinancialAdminRoute and activeRole for navigation logic)

import { createBrowserRouter } from 'react-router-dom';
import { LoginPage } from '../features/auth/pages/LoginPage.js';
import { TenantsPage } from '../features/superadmin/pages/TenantsPage.js';
import { ParameterCatalogPage } from '../features/admin/pages/ParameterCatalogPage.js';
import { TaskCatalogPage } from '../features/admin/pages/TaskCatalogPage.js';
import { ProductCatalogPage } from '../features/admin/pages/ProductCatalogPage.js';
import { ProductCategoryCatalogPage } from '../features/admin/pages/ProductCategoryCatalogPage.js';
import { ClientsPage } from '../features/admin/pages/clients/ClientsPage.js';
import { ClientDetailPage } from '../features/admin/pages/clients/ClientDetailPage.js';
import { PoolDetailPage } from '../features/admin/pages/pools/PoolDetailPage.js';
import { PlannerPage } from '../features/admin/pages/planner/PlannerPage.js';
import { MyRoutePage } from '../features/technician/pages/MyRoutePage.js';
import { WorkOrderPage } from '../features/technician/pages/WorkOrderPage.js';
import { AdminDashboard } from '../features/admin/pages/AdminDashboard.js';
import { IncidentsHistoryPage } from '../features/admin/pages/IncidentsHistoryPage.js';
import { IncidentDetailPage } from '../features/admin/pages/incidents/IncidentDetailPage.js';
import { ManagerDashboard } from '../features/manager/pages/ManagerDashboard.js';
import { InvoicingReportPage } from '../features/manager/pages/InvoicingReportPage.js';
import { PaymentsPage } from '../features/financials/pages/PaymentsPage.js';
import { ExpensesPage } from '../features/financials/pages/ExpensesPage.js';
import { useAuth } from '../providers/AuthProvider.js';
import {
  AppLayout,
  ProtectedRoute,
  SuperAdminRoute,
  AdminRoute,
  TechnicianRoute,
  FinancialAdminRoute, // <-- Se importa el componente de ruta renombrado
} from './components.js';

// Este componente decide qu√© dashboard mostrar basado en el rol activo (respetando el "rol camale√≥n")
const RoleBasedDashboard = () => {
  const { activeRole, user } = useAuth();
  if (user?.role === 'SUPER_ADMIN') return <TenantsPage />;
  
  // Se usa activeRole para que el cambio de vista del Manager funcione
  switch (activeRole) {
    case 'ADMIN': return <AdminDashboard />;
    case 'TECHNICIAN': return <MyRoutePage />;
    case 'MANAGER': return <ManagerDashboard />;
    default: return <div>Cargando...</div>;
  }
};


export const router = createBrowserRouter([
  {
    path: '/login',
    element: <LoginPage />,
  },
  {
    path: '/',
    element: <ProtectedRoute />,
    children: [
      {
        element: <AppLayout />,
        children: [
          { index: true, element: <RoleBasedDashboard /> },
          {
            path: 'reports',
            // Se usa la nueva ruta que permite acceso a ADMIN y MANAGER
            element: <FinancialAdminRoute />, 
            children: [
                { path: 'invoicing', element: <InvoicingReportPage /> }
            ]
          },
          {
            path: 'financials',
            element: <AdminRoute />,
            children: [
                { path: 'payments', element: <PaymentsPage /> },
                { path: 'expenses', element: <ExpensesPage /> }
            ]
          },
          {
            path: 'superadmin',
            element: <SuperAdminRoute />,
            children: [ { path: 'tenants', element: <TenantsPage /> } ],
          },
          {
            path: 'planner',
            element: <AdminRoute />,
            children: [ { index: true, element: <PlannerPage /> } ],
          },
          {
            path: 'clients',
            element: <AdminRoute />,
            children: [
              { index: true, element: <ClientsPage /> },
              { path: ':id', element: <ClientDetailPage /> },
            ],
          },
          {
            path: 'pools/:id', 
            element: <AdminRoute />,
            children: [ { index: true, element: <PoolDetailPage /> } ]
          },
          {
            path: 'incidents-history',
            element: <AdminRoute />,
            children: [ { index: true, element: <IncidentsHistoryPage /> } ],
          },
          {
            path: 'incidents/:notificationId',
            element: <ProtectedRoute />, // Accesible por Admin y T√©cnico
            children: [ { index: true, element: <IncidentDetailPage /> } ]
          },
          {
            path: 'catalog',
            element: <AdminRoute />,
            children: [
              { path: 'parameters', element: <ParameterCatalogPage /> },
              { path: 'tasks', element: <TaskCatalogPage /> },
              { path: 'products', element: <ProductCatalogPage /> },
              { path: 'product-categories', element: <ProductCategoryCatalogPage /> }
            ],
          },
          {
            path: 'my-route',
            element: <TechnicianRoute />,
            children: [ { index: true, element: <MyRoutePage /> } ],
          },
          {
            path: 'visits/:visitId',
            element: <ProtectedRoute />, // Accesible por Admin y T√©cnico
            children: [ { index: true, element: <WorkOrderPage /> } ],
          },
        ],
      },
    ],
  },
]);


// ====== [33] packages/client/src/stores/auth.store.ts ======
// filename: packages/client/src/stores/auth.store.ts
// version: 1.0.1 (FIXED)
// description: Desacopla el store de @prisma/client.

import { create } from 'zustand';

// --- Tipos desacoplados del backend ---
// Definimos los tipos expl√≠citamente en el frontend.
// Esto mantiene la separaci√≥n entre cliente y servidor.
type UserRole = 'SUPER_ADMIN' | 'ADMIN' | 'TECHNICIAN' | 'MANAGER';

interface User {
  id: string;
  name: string;
  email: string;
  role: UserRole;
}

type ViewAsRole = 'MANAGER' | 'ADMIN' | 'TECHNICIAN';

interface AuthState {
  user: User | null;
  activeView: ViewAsRole;
  setAuthState: (user: User | null, activeView: ViewAsRole) => void;
}

/**
 * Creamos el store de Zustand.
 * Este store contendr√° el estado de autenticaci√≥n que necesita ser
 * accesible fuera de los componentes de React, como en nuestro apiClient.
 */
export const useAuthStore = create<AuthState>((set) => ({
  user: null,
  activeView: 'MANAGER',
  setAuthState: (user, activeView) => set({ user, activeView }),
}));


// ====== [34] packages/client/src/styles/theme.ts ======
import { createTheme } from '@mantine/core';
import type { MantineColorsTuple } from '@mantine/core';

// Definimos una paleta de colores personalizada para nuestra marca.
// Puedes generar las tuyas en https://mantine.dev/colors-generator/
const brandBlue: MantineColorsTuple = [
  '#e7f5ff',
  '#d0ebff',
  '#a5d8ff',
  '#74c0fc',
  '#4dabf7',
  '#339af0',
  '#228be6',
  '#1c7ed6',
  '#1572c3',
  '#1068b1',
];

export const theme = createTheme({
  fontFamily: 'Inter, sans-serif',
  primaryColor: 'brandBlue',

  colors: {
    brandBlue,
  },

  headings: {
    fontFamily: 'Inter, sans-serif',
  },
});


// ====== [35] packages/client/tsconfig.json ======
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "allowJs": false,
    "skipLibCheck": true,
    "esModuleInterop": false,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}


// ====== [36] packages/client/tsconfig.node.json ======
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}


// ====== [37] packages/client/vite.config.ts ======
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    // Configuramos un proxy para evitar problemas de CORS en desarrollo.
    // Todas las peticiones del frontend a '/api' ser√°n redirigidas
    // a nuestro servidor de backend en el puerto 3001.
    proxy: {
      '/api': {
        target: 'http://localhost:3001',
        changeOrigin: true,
      },
    },
  },
});


// ====== [38] packages/server/package.json ======
{
  "name": "@pool-control/server",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "main": "dist/server.js",
  "scripts": {
    "dev": "tsx watch src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate",
    "prisma:studio": "prisma studio",
    "db:seed": "prisma generate && tsx prisma/seed.ts"
  },
  "prisma": {
    "seed": "prisma generate && tsx prisma/seed.ts"
  },
  "dependencies": {
    "@prisma/client": "^5.15.0",
    "bcryptjs": "^2.4.3",
    "cloudinary": "^2.7.0",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "date-fns": "^4.1.0",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "jsonwebtoken": "^9.0.2",
    "ms": "^2.1.3"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cookie-parser": "^1.4.7",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.6",
    "@types/ms": "^0.7.34",
    "@types/node": "^20.14.2",
    "prisma": "^5.15.0",
    "tsx": "^4.15.4",
    "typescript": "^5.4.5"
  }
}


// ====== [39] packages/server/prisma/data/catalogs.ts ======
// filename: packages/server/prisma/data/catalogs.ts
// version: 1.0.1
// description: Datos de semilla para los cat√°logos de Par√°metros y Tareas de "Piscival S.L.".

import type { InputType } from '@prisma/client';

/**
 * Define la librer√≠a central de todos los servicios (mediciones y acciones).
 * Se especifica el tipo InputType para cumplir con la validaci√≥n estricta de Prisma.
 */

// --- CAT√ÅLOGO DE PAR√ÅMETROS A MEDIR ---
export const parameterData: { name: string; unit?: string | null; type: InputType; selectOptions?: string[] }[] = [
  // Par√°metros Qu√≠micos Esenciales (Tipo NUMBER)
  { name: 'Nivel de pH', unit: 'pH', type: 'NUMBER' },
  { name: 'Cloro Libre (DPD-1)', unit: 'ppm', type: 'NUMBER' },
  { name: 'Cloro Total (DPD-3)', unit: 'ppm', type: 'NUMBER' },
  { name: 'Alcalinidad Total (TA)', unit: 'ppm', type: 'NUMBER' },
  { name: 'Dureza C√°lcica (TH)', unit: 'ppm', type: 'NUMBER' },
  { name: '√Åcido Cian√∫rico (Estabilizante)', unit: 'ppm', type: 'NUMBER' },
  { name: 'Nivel de Sal (para piscinas de sal)', unit: 'ppm', type: 'NUMBER' },

  // Par√°metros F√≠sicos (Tipo NUMBER)
  { name: 'Temperatura del Agua', unit: '¬∞C', type: 'NUMBER' },
  { name: 'Presi√≥n del Filtro', unit: 'bar', type: 'NUMBER' },

  // Par√°metros de Observaci√≥n (Tipos SELECT y BOOLEAN para probar la UI)
  {
    name: 'Estado del Agua',
    type: 'SELECT',
    selectOptions: ['Cristalina', 'Ligeramente turbia', 'Muy turbia', 'Verde', 'Blanquecina'],
  },
  {
    name: 'Nivel del Agua en Skimmer',
    type: 'SELECT',
    selectOptions: ['Correcto', 'Alto', 'Bajo'],
  },
  {
    name: 'Fondo de la piscina limpio',
    type: 'BOOLEAN',
  },
];

// --- CAT√ÅLOGO DE TAREAS A REALIZAR ---
export const taskData = [
  // Tareas de Limpieza Rutinaria
  {
    name: 'Limpieza de cestos de skimmers',
    description: 'Vaciar y limpiar los cestos de los skimmers de hojas y otros residuos.',
  },
  {
    name: 'Limpieza de cesto de bomba',
    description: 'Vaciar y limpiar el pre-filtro de la bomba para asegurar un buen flujo.',
  },
  {
    name: 'Pasar limpiafondos manual',
    description: 'Aspirar el fondo de la piscina manualmente para recoger la suciedad sedimentada.',
  },
  {
    name: 'Cepillado de paredes y l√≠nea de flotaci√≥n',
    description: 'Cepillar las superficies para prevenir la adhesi√≥n de algas y dep√≥sitos calc√°reos.',
  },

  // Tareas de Mantenimiento T√©cnico
  {
    name: 'Contralavado de filtro (Backwash)',
    description: 'Realizar un backwash completo del sistema de filtraci√≥n seguido de un enjuague.',
  },
  {
    name: 'Revisi√≥n y ajuste de dosificadores autom√°ticos',
    description: 'Comprobar el funcionamiento de bombas dosificadoras de pH y cloro.',
  },
  {
    name: 'Revisi√≥n de clorador salino',
    description: 'Verificar la producci√≥n de cloro y el estado de la c√©lula del clorador salino.',
  },
  {
    name: 'Comprobaci√≥n visual de fugas en local t√©cnico',
    description: 'Inspeccionar tuber√≠as, bomba y filtro en busca de goteos o fugas de agua.',
  },
  
  // Tareas de Adici√≥n de Productos (para futuro control de stock)
  {
    name: 'A√±adir producto alguicida',
    description: 'Dosificar la cantidad necesaria de alguicida preventivo.',
  },
  {
    name: 'A√±adir producto floculante',
    description: 'Dosificar floculante para ayudar a clarificar el agua si es necesario.',
  },
];


// ====== [40] packages/server/prisma/data/clients.ts ======
// filename: packages/server/prisma/data/clients.ts
// version: 2.0.0
// description: A√±ade modelo de facturaci√≥n y cuota mensual a cada cliente.

import type { BillingModel } from '@prisma/client';

/**
 * Define la cartera de clientes de la empresa de prueba.
 * Cada cliente tiene un array de piscinas asociadas. Esta estructura anidada
 * facilita la creaci√≥n de ambas entidades y sus relaciones en el script de seed.
 * La variedad de clientes y modelos de facturaci√≥n permite probar m√∫ltiples escenarios.
 */
export const clientsData = [
  // --- Cliente 1: Comunidad de Propietarios (Cuota + Materiales) ---
  {
    client: {
      name: 'Comunidad de Propietarios "El Oasis"',
      contactPerson: 'Sr. Garc√≠a (Presidente)',
      email: 'comunidad.oasis@email.com',
      phone: '611223344',
      address: 'Calle de la Concordia, 1, 28080 Madrid',
      priceModifier: 1.0,
      // --- NUEVOS DATOS ---
      monthlyFee: 350.0,
      billingModel: 'FEE_PLUS_MATERIALS' as BillingModel,
    },
    pools: [
      {
        name: 'Piscina Comunitaria Grande',
        address: 'Calle de la Concordia, 1, Zonas Comunes, 28080 Madrid',
        volume: 150,
        type: 'Cloro',
      },
      {
        name: 'Piscina Infantil',
        address: 'Calle de la Concordia, 1, Zona Infantil, 28080 Madrid',
        volume: 25,
        type: 'Cloro',
      },
    ],
  },

  // --- Cliente 2: Chalet Privado (Todo Incluido) ---
  {
    client: {
      name: 'Chalet "Villa Sol"',
      contactPerson: 'Familia P√©rez-L√≥pez',
      email: 'perez.lopez.familia@email.com',
      phone: '655667788',
      address: 'Avenida de la Brisa, 45, Urbanizaci√≥n Mirasierra, 28035 Madrid',
      priceModifier: 1.1, // Cliente premium, paga un 10% m√°s sobre el PVP base si algo no estuviera incluido.
      // --- NUEVOS DATOS ---
      monthlyFee: 220.0,
      billingModel: 'ALL_INCLUSIVE' as BillingModel,
    },
    pools: [
      {
        name: 'Piscina Privada con Jacuzzi',
        address: 'Avenida de la Brisa, 45, 28035 Madrid',
        volume: 75,
        type: 'Sal',
      },
    ],
  },

  // --- Cliente 3: Hotel (Solo paga materiales, sin cuota) ---
  {
    client: {
      name: 'Hotel "Costa Serena"',
      contactPerson: 'Dpto. de Mantenimiento',
      email: 'mantenimiento@costaserena-hotel.com',
      phone: '911223344',
      address: 'Paseo del Relax, 2, 28010 Madrid',
      priceModifier: 0.95, // Cliente grande con descuento del 5% sobre el PVP base.
      // --- NUEVOS DATOS ---
      monthlyFee: 0.0,
      billingModel: 'SERVICE_ONLY' as BillingModel,
    },
    pools: [
      {
        name: 'Piscina Exterior Principal',
        address: 'Paseo del Relax, 2, Zona de Jardines, 28010 Madrid',
        volume: 250,
        type: 'Cloro',
      },
    ],
  },

  // --- Cliente 4: Gimnasio (Cuota + Materiales) ---
  {
    client: {
      name: 'Gimnasio "Fisic-Center"',
      contactPerson: 'Gerencia',
      email: 'gerencia@fisic-center.es',
      phone: '918765432',
      address: 'Calle del M√∫sculo, 12, 28020 Madrid',
      priceModifier: 1.0,
      // --- NUEVOS DATOS ---
      monthlyFee: 250.0,
      billingModel: 'FEE_PLUS_MATERIALS' as BillingModel,
    },
    pools: [
      {
        name: 'Piscina Climatizada Interior',
        address: 'Calle del M√∫sculo, 12, S√≥tano, 28020 Madrid',
        volume: 100,
        type: 'Cloro',
      },
    ],
  },
];


// ====== [41] packages/server/prisma/data/consumptions.ts ======
// filename: packages/server/prisma/data/consumptions.ts
// version: 1.0.0
// description: Datos de semilla para los consumos de productos en las visitas.

/**
 * Define un conjunto de consumos de productos para las visitas de prueba.
 * * - `visitNotesIdentifier`: Un fragmento de texto √∫nico de las notas de la visita
 * a la que queremos asociar estos consumos. Se usar√° en el script de seed para
 * encontrar el ID de la visita correcta.
 * - `consumptions`: Un array de los productos y cantidades consumidas en esa visita.
 */
export const consumptionsData = [
  {
    // Para la visita con la incidencia CR√çTICA en "El Oasis"
    visitNotesIdentifier: 'Fuga de agua detectada en la tuber√≠a principal del skimmer',
    consumptions: [
      {
        productName: 'Reductor de pH L√≠quido', // El pH era de 7.9, es l√≥gico a√±adir reductor.
        quantity: 5, // 5 Litros
      },
      {
        productName: 'Cloro Granulado (Dicloro 55%)', // Para un tratamiento de choque r√°pido.
        quantity: 0.5, // 0.5 Kg
      },
    ],
  },
  {
    // Para la visita con la incidencia CLASIFICADA en el "Gimnasio Fisic-Center"
    visitNotesIdentifier: 'La bomba de calor hace un ruido met√°lico',
    consumptions: [
      {
        productName: 'Floculante L√≠quido Clarificante', // La presi√≥n del filtro era alta (1.5 bar), es com√∫n a√±adir clarificante tras un lavado.
        quantity: 0.5, // 0.5 Litros
      },
    ],
  },
  {
    // Para a√±adir m√°s consumo a la visita OK del "Hotel Costa Serena"
    // Esta visita ya tiene 1 saco de sal a√±adido directamente en el seed.ts, ahora a√±adimos m√°s.
    visitNotesIdentifier: 'Todo en orden. Valores perfectos.',
    consumptions: [
        {
            productName: 'Pastillas Multiacci√≥n 250g', // Consumo de mantenimiento rutinario.
            quantity: 2, // 2 pastillas
        }
    ]
  }
];


// ====== [42] packages/server/prisma/data/financial-rules.ts ======
// filename: packages/server/prisma/data/financial-rules.ts
// version: 1.0.0
// description: Datos de semilla para las reglas de precios personalizadas.

/**
 * Define las reglas de descuento espec√≠ficas por cliente.
 * Cada regla se identifica por el nombre del cliente y el nombre del producto/categor√≠a.
 * El script de seed.ts se encargar√° de buscar los IDs correspondientes.
 */
export const clientPricingRulesData = [
  {
    // REGLA 1: Descuento aplicado a una CATEGOR√çA completa para un cliente.
    // La Comunidad "El Oasis" tiene un 5% de descuento en todos los desinfectantes.
    clientName: 'Comunidad de Propietarios "El Oasis"',
    categoryName: 'Qu√≠micos Desinfectantes',
    discountPercentage: 5.0,
  },
  {
    // REGLA 2: Descuento aplicado a un PRODUCTO espec√≠fico para un cliente.
    // El Hotel "Costa Serena" tiene un 10% de descuento en las pastillas de cloro,
    // que es un producto de alto consumo para ellos.
    clientName: 'Hotel "Costa Serena"',
    productName: 'Pastillas Multiacci√≥n 250g',
    discountPercentage: 10.0,
  },
  {
    // REGLA 3: M√∫ltiples reglas para un mismo cliente.
    // El Gimnasio "Fisic-Center" tiene un descuento en los reguladores (categor√≠a)
    // y uno a√∫n mayor en el alguicida (producto).
    clientName: 'Gimnasio "Fisic-Center"',
    categoryName: 'Qu√≠micos Reguladores',
    discountPercentage: 7.5,
  },
  {
    clientName: 'Gimnasio "Fisic-Center"',
    productName: 'Alguicida Concentrado',
    discountPercentage: 15.0,
  },
  // NOTA: El cliente "Chalet 'Villa Sol'" no tiene reglas espec√≠ficas.
  // Esto nos permitir√° probar que el sistema le aplica correctamente su
  // recargo general (`priceModifier`) sin descuentos adicionales.
];


// ====== [43] packages/server/prisma/data/incident-tasks.ts ======
// filename: packages/server/prisma/data/incident-tasks.ts
// version: 1.0.0
// description: Datos de semilla para las Tareas de Incidencia (Ticketing).

import { IncidentPriority, IncidentTaskStatus } from '@prisma/client';
import { addDays, subDays } from 'date-fns';

const today = new Date();
const tomorrow = addDays(today, 1);
const yesterday = subDays(today, 1);
const nextWeek = addDays(today, 7);

/**
 * Define un conjunto de tareas de incidencia de prueba.
 * Cada objeto tiene una propiedad 'notificationMessage' que usaremos en el script
 * de seed para encontrar la notificaci√≥n padre correcta a la que asociar la tarea.
 */
export const incidentTasksData = [
  {
    // Tarea para la incidencia CR√çTICA de la fuga. Es urgente y ya est√° en progreso.
    notificationMessage: 'Fuga de agua detectada en la tuber√≠a principal del skimmer.',
    task: {
      title: 'Contactar a fontanero para presupuesto de reparaci√≥n de fuga',
      description: 'Llamar a Fontaner√≠a Express (91 123 45 67) y pedir presupuesto urgente. Mencionar que es para la Comunidad "El Oasis".',
      priority: 'CRITICAL' as IncidentPriority,
      status: 'IN_PROGRESS' as IncidentTaskStatus,
      deadline: tomorrow, // Plazo para ma√±ana
      // La asignaci√≥n se har√° en el script de seed.
    },
  },
  {
    // Tarea secundaria para la misma incidencia de la fuga.
    notificationMessage: 'Fuga de agua detectada en la tuber√≠a principal del skimmer.',
    task: {
      title: 'Cerrar llave de paso del skimmer afectado',
      description: 'Para minimizar la p√©rdida de agua hasta que venga el fontanero, cerrar la llave de paso correspondiente en el local t√©cnico.',
      priority: 'HIGH' as IncidentPriority,
      status: 'COMPLETED' as IncidentTaskStatus,
      resolutionNotes: 'Llave de paso cerrada a las 10:30. Ya no gotea. Se ha informado al presidente.',
      // La asignaci√≥n se har√° en el script de seed.
    },
  },
  {
    // Tarea para la incidencia de falta de sal.
    notificationMessage: 'El nivel de sal es bajo, pero no hay producto en el almac√©n. Avisar para reponer.',
    task: {
      title: 'Comprar sacos de sal para el almac√©n',
      description: 'Ir al proveedor habitual (PRO-PISCINAS) y comprar 5 sacos de sal especial para clorador. Guardar factura.',
      priority: 'NORMAL' as IncidentPriority,
      status: 'PENDING' as IncidentTaskStatus,
      deadline: nextWeek, // Plazo de una semana
      // La asignaci√≥n se har√° en el script de seed.
    },
  },
  {
    // Tarea para la incidencia del ruido de la bomba de calor. Plazo vencido.
    notificationMessage: 'La bomba de calor hace un ruido met√°lico muy fuerte al arrancar.',
    task: {
      title: 'Revisar rodamientos de la bomba de calor',
      description: 'Desmontar la carcasa y verificar si los rodamientos del motor tienen holgura o est√°n oxidados. Engrasar si es posible.',
      priority: 'HIGH' as IncidentPriority,
      status: 'PENDING' as IncidentTaskStatus, // Sigue pendiente
      deadline: yesterday, // El plazo era para ayer, por lo que est√° VENCIDA.
      // La asignaci√≥n se har√° en el script de seed.
    },
  },
];


// ====== [44] packages/server/prisma/data/product-categories.ts ======
// filename: packages/server/prisma/data/product-categories.ts
// version: 1.0.0
// description: Datos de semilla para las categor√≠as de productos.

/**
 * Define las familias o categor√≠as en las que se agrupar√°n los productos.
 * Esto es clave para poder aplicar reglas de precios a nivel de categor√≠a.
 */
export const productCategoriesData = [
  { name: 'Qu√≠micos Reguladores' },     // Para productos como pH, alcalinidad, etc.
  { name: 'Qu√≠micos Desinfectantes' },  // Para cloro, bromo, etc.
  { name: 'Qu√≠micos de Mantenimiento' },// Para alguicidas, floculantes, etc.
  { name: 'Sal y Electr√≥lisis' },       // Para sacos de sal y recambios de cloradores.
  { name: 'Material de Limpieza' },     // Para cepillos, recogehojas, etc.
  { name: 'Recambios y Fontaner√≠a' },  // Para juntas, v√°lvulas, etc.
];


// ====== [45] packages/server/prisma/data/products.ts ======
// filename: packages/server/prisma/data/products.ts
// version: 2.0.0
// description: A√±ade PVP, IVA y categor√≠a a cada producto.

export const productData = [
  // --- Qu√≠micos Desinfectantes ---
  {
    name: 'Hipoclorito S√≥dico 15%',
    description: 'Cloro l√≠quido para desinfecci√≥n de choque y mantenimiento.',
    unit: 'L',
    cost: 1.20,
    salePrice: 2.50, // PVP
    taxRate: 21,
    categoryName: 'Qu√≠micos Desinfectantes',
  },
  {
    name: 'Cloro Granulado (Dicloro 55%)',
    description: 'Cloro de disoluci√≥n r√°pida para tratamientos de choque.',
    unit: 'Kg',
    cost: 8.50,
    salePrice: 14.90,
    taxRate: 21,
    categoryName: 'Qu√≠micos Desinfectantes',
  },
  {
    name: 'Pastillas Multiacci√≥n 250g',
    description: 'Pastillas de cloro de disoluci√≥n lenta con acci√≥n desinfectante, alguicida y floculante.',
    unit: 'Unidad',
    cost: 2.75,
    salePrice: 4.50,
    taxRate: 21,
    categoryName: 'Qu√≠micos Desinfectantes',
  },

  // --- Qu√≠micos Reguladores ---
  {
    name: 'Reductor de pH L√≠quido',
    description: '√Åcido sulf√∫rico para bajar el nivel de pH del agua.',
    unit: 'L',
    cost: 2.10,
    salePrice: 3.95,
    taxRate: 21,
    categoryName: 'Qu√≠micos Reguladores',
  },
  {
    name: 'Incrementador de pH S√≥lido',
    description: 'Producto en polvo para subir el nivel de pH del agua.',
    unit: 'Kg',
    cost: 4.50,
    salePrice: 7.80,
    taxRate: 21,
    categoryName: 'Qu√≠micos Reguladores',
  },

  // --- Qu√≠micos de Mantenimiento ---
  {
    name: 'Alguicida Concentrado',
    description: 'Tratamiento preventivo y de choque contra todo tipo de algas.',
    unit: 'L',
    cost: 9.70,
    salePrice: 18.50,
    taxRate: 21,
    categoryName: 'Qu√≠micos de Mantenimiento',
  },
  {
    name: 'Floculante L√≠quido Clarificante',
    description: 'Agrupa las part√≠culas en suspensi√≥n para mejorar la filtraci√≥n y dar transparencia al agua.',
    unit: 'L',
    cost: 5.80,
    salePrice: 11.20,
    taxRate: 21,
    categoryName: 'Qu√≠micos de Mantenimiento',
  },

  // --- Sal y Electr√≥lisis ---
  {
    name: 'Sal para Piscinas (Saco)',
    description: 'Sal especial para equipos de cloraci√≥n salina.',
    unit: 'Saco 25Kg',
    cost: 12.50,
    salePrice: 22.00,
    taxRate: 21,
    categoryName: 'Sal y Electr√≥lisis',
  },
];


// ====== [46] packages/server/prisma/data/transactions.ts ======
// filename: packages/server/prisma/data/transactions.ts
// version: 1.0.0
// description: Datos de semilla para pagos de clientes y gastos de la empresa.

import { subMonths, subDays } from 'date-fns';

const today = new Date();

/**
 * Define un historial de pagos de clientes.
 * Se identifica al cliente por su nombre para que el seed.ts busque el ID.
 */
export const paymentsData = [
  {
    clientName: 'Comunidad de Propietarios "El Oasis"',
    amount: 350.00, // Simula el pago de su cuota mensual
    paymentDate: subMonths(today, 1),
    method: 'Transferencia Bancaria',
    notes: 'Cuota de Mantenimiento Mes Anterior',
  },
  {
    clientName: 'Comunidad de Propietarios "El Oasis"',
    amount: 85.50, // Simula el pago de una factura de materiales
    paymentDate: subDays(today, 20),
    method: 'Transferencia Bancaria',
    notes: 'Factura 2025-0045 Materiales',
  },
  {
    clientName: 'Chalet "Villa Sol"',
    amount: 220.00, // Simula el pago de su cuota todo incluido
    paymentDate: subDays(today, 15),
    method: 'Recibo Domiciliado',
    notes: 'Cuota All-Inclusive Mes Actual',
  },
  {
    clientName: 'Hotel "Costa Serena"',
    amount: 550.75, // Simula el pago de una gran factura de productos
    paymentDate: subDays(today, 5),
    method: 'Confirming',
    notes: 'Factura 2025-0048 Consumo Productos',
  },
];

/**
 * Define un historial de gastos generales de la empresa.
 * No est√°n asociados a un cliente, sino al tenant.
 */
export const expensesData = [
  {
    amount: 250.00,
    expenseDate: subDays(today, 10),
    description: 'Repostaje furgonetas Carlos y Ana',
    category: 'Combustible',
  },
  {
    amount: 3200.00,
    expenseDate: subMonths(today, 1),
    description: 'N√≥minas mes anterior',
    category: 'N√≥minas',
  },
  {
    amount: 80.00,
    expenseDate: subDays(today, 3),
    description: 'Compra de material de oficina',
    category: 'Suministros Oficina',
  },
  {
    amount: 150.00,
    expenseDate: subDays(today, 1),
    description: 'Comida de equipo',
    category: 'Dietas y Representaci√≥n',
  },
];


// ====== [47] packages/server/prisma/data/users.ts ======
// filename: packages/server/prisma/data/users.ts
// version: 1.0.1
// description: Datos de semilla para los usuarios del tenant de prueba "Piscival S.L.".

import type { UserRole } from '@prisma/client';

/**
 * Define los usuarios que se crear√°n para el tenant principal de prueba.
 * Se especifica el tipo UserRole para cumplir con la validaci√≥n estricta de Prisma.
 */
export const usersData: { name: string; email: string; password: string; role: UserRole }[] = [
  // --- ROL: Administradora ---
  {
    name: 'Isa Gestora',
    email: 'admin@piscival.com',
    password: 'password123',
    role: 'ADMIN',
  },

  // --- ROL: T√©cnicos de Campo ---
  {
    name: 'Carlos T√©cnico',
    email: 'carlos.t@piscival.com',
    password: 'password123',
    role: 'TECHNICIAN',
  },
  {
    name: 'Ana T√©cnica',
    email: 'ana.t@piscival.com',
    password: 'password123',
    role: 'TECHNICIAN',
  },
  {
    name: 'Leo Ayudante',
    email: 'leo.a@piscival.com',
    password: 'password123',
    role: 'TECHNICIAN',
  },

  // --- ROL: Gerencia/Supervisor (para futuras funcionalidades) ---
  {
    name: 'Jorge Supervisor',
    email: 'manager@piscival.com',
    password: 'password123',
    role: 'MANAGER',
  },
];


// ====== [48] packages/server/prisma/seed.ts ======
// filename: packages/server/prisma/seed.ts
// version: 6.0.1 (COMPLETE AND LINT-FIXED)

import { PrismaClient } from '@prisma/client';
import type { Frequency, ParameterTemplate, ScheduledTaskTemplate, User, Pool, Product, Client, ProductCategory } from '@prisma/client';
import { hashPassword } from '../src/utils/password.utils.js';
import { subDays, addDays } from 'date-fns';

// --- Importaci√≥n de los datos modulares ---
import { usersData } from './data/users.js';
import { parameterData, taskData } from './data/catalogs.js';
import { clientsData } from './data/clients.js';
import { productData } from './data/products.js';
import { incidentTasksData } from './data/incident-tasks.js';
import { productCategoriesData } from './data/product-categories.js';
import { clientPricingRulesData } from './data/financial-rules.js';
import { paymentsData, expensesData } from './data/transactions.js';

// --- Funciones de ayuda ---
const getRandomItems = <T>(arr: T[], count: number): T[] => {
  if (arr.length < count) {
    throw new Error(`No se pueden obtener ${count} elementos de un array con solo ${arr.length} elementos.`);
  }
  const shuffled = [...arr].sort(() => 0.5 - Math.random());
  return shuffled.slice(0, count);
};

// --- Script Principal ---
async function main() {
  // Instanciamos el cliente aqu√≠, dentro de la funci√≥n, para garantizar una conexi√≥n fresca.
  const prisma = new PrismaClient();

  try {
    console.log('üå± Empezando el proceso de seeding para la demo v4.0 (con motor financiero)...');

    // 1. --- CREACI√ìN DE ENTIDADES DEL SISTEMA ---
    const systemTenant = await prisma.tenant.create({
      data: { companyName: 'SYSTEM_INTERNAL', subdomain: 'system', subscriptionStatus: 'ACTIVE' },
    });
    const superAdminPassword = await hashPassword('superadmin123');
    await prisma.user.create({
      data: { email: 'super@admin.com', name: 'Super Admin', password: superAdminPassword, role: 'SUPER_ADMIN', tenantId: systemTenant.id },
    });
    console.log('üëë SuperAdmin y Tenant del sistema creados.');

    // 2. --- CREACI√ìN DEL TENANT DE PRUEBA Y USUARIOS ---
    const mainTenant = await prisma.tenant.create({
      data: { companyName: 'Piscival S.L.', subdomain: 'piscival', subscriptionStatus: 'ACTIVE' },
    });
    console.log(`\nüè¢ Tenant de prueba creado: ${mainTenant.companyName}`);
    
    const createdUsers: User[] = [];
    for (const userData of usersData) {
      const hashedPassword = await hashPassword(userData.password);
      const user = await prisma.user.create({ data: { ...userData, password: hashedPassword, tenantId: mainTenant.id } });
      createdUsers.push(user);
      console.log(`   üë§ Usuario creado: ${userData.name} (${userData.role})`);
    }
    const adminUser = createdUsers.find(u => u.role === 'ADMIN');
    const technicians = createdUsers.filter(u => u.role === 'TECHNICIAN');
    if (!adminUser || technicians.length < 3) throw new Error('Seeding fallido: No se encontraron suficientes usuarios admin o t√©cnicos.');

    // 3. --- CREACI√ìN DE CAT√ÅLOGOS Y ENTIDADES FINANCIERAS BASE ---
    console.log('\n- Fase de creaci√≥n de cat√°logos y finanzas -');

    const createdParams: ParameterTemplate[] = [];
    for (const p of parameterData) {
      const param = await prisma.parameterTemplate.create({ data: { ...p, tenantId: mainTenant.id } });
      createdParams.push(param);
    }
    console.log(`üìä Creados ${createdParams.length} par√°metros en el cat√°logo.`);

    const createdTasks: ScheduledTaskTemplate[] = [];
    for (const t of taskData) {
      const task = await prisma.scheduledTaskTemplate.create({ data: { ...t, tenantId: mainTenant.id } });
      createdTasks.push(task);
    }
    console.log(`üìã Creadas ${createdTasks.length} tareas en el cat√°logo.`);

    const createdCategories: ProductCategory[] = [];
    for (const catData of productCategoriesData) {
      const category = await prisma.productCategory.create({ data: { ...catData, tenantId: mainTenant.id } });
      createdCategories.push(category);
    }
    console.log(`üìÅ Creadas ${createdCategories.length} categor√≠as de productos.`);

    const createdProducts: Product[] = [];
    for (const prodData of productData) {
      const { categoryName, ...restOfProdData } = prodData;
      const category = createdCategories.find(c => c.name === categoryName);
      const product = await prisma.product.create({
        data: {
          ...restOfProdData,
          tenantId: mainTenant.id,
          categoryId: category?.id,
        },
      });
      createdProducts.push(product);
    }
    console.log(`üì¶ Creados ${createdProducts.length} productos en el cat√°logo.`);

    // 4. --- CREACI√ìN DE CLIENTES Y PISCINAS ---
    console.log('\n- Fase de creaci√≥n de clientes y piscinas -');
    const allPools: Pool[] = [];
    const createdClients: Client[] = [];
    for (const data of clientsData) {
      const client = await prisma.client.create({ data: { ...data.client, tenantId: mainTenant.id } });
      createdClients.push(client);
      console.log(`\nüë®‚Äçüíº Cliente creado: ${client.name} (Modelo: ${client.billingModel})`);
      for (const poolData of data.pools) {
        const pool = await prisma.pool.create({ data: { ...poolData, clientId: client.id, tenantId: mainTenant.id } });
        allPools.push(pool);
        console.log(`   üèä Piscina creada: ${pool.name}`);
        const configsToCreate = createPoolMaintenanceSheet(pool.id, createdParams, createdTasks, poolData.type);
        await prisma.poolConfiguration.createMany({ data: configsToCreate, skipDuplicates: true });
        console.log(`      üìù Ficha de mantenimiento creada para ${pool.name} con ${configsToCreate.length} √≠tems.`);
      }
    }
    if (allPools.length < 5) throw new Error('Seeding fallido: No se crearon suficientes piscinas.');

    // 5. --- CREACI√ìN DE REGLAS DE PRECIOS Y TRANSACCIONES ---
    console.log('\n- Fase de creaci√≥n de reglas de precios y transacciones -');
    let rulesCount = 0;
    for (const rule of clientPricingRulesData) {
      const client = createdClients.find(c => c.name === rule.clientName);
      if (!client) continue;

      const product = rule.productName ? createdProducts.find(p => p.name === rule.productName) : null;
      const category = rule.categoryName ? createdCategories.find(c => c.name === rule.categoryName) : null;

      await prisma.clientProductPricing.create({
        data: {
          clientId: client.id,
          productId: product?.id,
          productCategoryId: category?.id,
          discountPercentage: rule.discountPercentage,
        },
      });
      rulesCount++;
    }
    console.log(`üí∞ Creadas ${rulesCount} reglas de precios personalizadas.`);

    for (const payment of paymentsData) {
      const client = createdClients.find(c => c.name === payment.clientName);
      if (!client) continue;
      await prisma.payment.create({
        data: {
          amount: payment.amount,
          paymentDate: payment.paymentDate,
          method: payment.method,
          notes: payment.notes,
          clientId: client.id,
        },
      });
    }
    console.log(`üí≥ Creados ${paymentsData.length} registros de pagos.`);

    await prisma.expense.createMany({
      data: expensesData.map(e => ({ ...e, tenantId: mainTenant.id })),
    });
    console.log(`üí∏ Creados ${expensesData.length} registros de gastos.`);

    // 6. --- SIMULACI√ìN DE ACTIVIDAD RECIENTE (VISITAS, INCIDENCIAS, ETC.) ---
    console.log('\n- Fase de simulaci√≥n de actividad operativa -');
    const today = new Date();
    const threeDaysAgo = subDays(today, 3);
    const tomorrow = addDays(today, 1);
    
    await prisma.visit.create({ data: { timestamp: today, poolId: allPools[1]!.id, technicianId: technicians[0]!.id, status: 'PENDING' } });
    await prisma.visit.create({ data: { timestamp: today, poolId: allPools[3]!.id, technicianId: technicians[1]!.id, status: 'PENDING' } });
    console.log('   - 2 visitas PENDIENTES para hoy creadas.');

    const okVisit = await prisma.visit.create({ data: { timestamp: today, poolId: allPools[2]!.id, technicianId: technicians[1]!.id, status: 'COMPLETED', hasIncident: false, notes: 'Todo en orden. Valores perfectos. El cliente ha comentado que est√° muy contento con el servicio.', completedTasks: ['Limpieza de cestos de skimmers', 'Revisi√≥n de clorador salino'] } });
    await prisma.visitResult.createMany({ data: [ { visitId: okVisit.id, parameterName: 'Nivel de pH', value: '7.4', parameterUnit: 'pH' }, { visitId: okVisit.id, parameterName: 'Nivel de Sal (para piscinas de sal)', value: '4500', parameterUnit: 'ppm' } ] });
    const salProduct = createdProducts.find(p => p.name.includes('Sal para Piscinas'));
    if(salProduct) { await prisma.consumption.create({ data: { visitId: okVisit.id, productId: salProduct.id, quantity: 1 }}); }
    console.log('   - 1 visita COMPLETADA OK (con consumo de sal) creada.');
    
    const criticalVisitNotes = 'Fuga de agua detectada en la tuber√≠a principal del skimmer. Gotea constantemente, el nivel de la piscina ha bajado notablemente.';
    const criticalVisit = await prisma.visit.create({ data: { timestamp: threeDaysAgo, poolId: allPools[0]!.id, technicianId: technicians[0]!.id, status: 'COMPLETED', hasIncident: true, notes: criticalVisitNotes, completedTasks: ['Limpieza de cestos de skimmers'] } });
    await prisma.visitResult.createMany({ data: [ { visitId: criticalVisit.id, parameterName: 'Nivel del Agua en Skimmer', value: 'Bajo' }, { visitId: criticalVisit.id, parameterName: 'Nivel de pH', value: '7.9' }, ] });
    await prisma.notification.create({ data: { message: criticalVisitNotes, visitId: criticalVisit.id, tenantId: mainTenant.id, userId: adminUser.id, createdAt: threeDaysAgo, } });
    console.log('   - 1 incidencia CR√çTICA (de hace 3 d√≠as) creada.');

    const pendingVisitNotes = 'El nivel de sal es bajo, pero no hay producto en el almac√©n. Avisar para reponer.';
    const pendingVisit = await prisma.visit.create({ data: { timestamp: today, poolId: allPools[1]!.id, technicianId: technicians[1]!.id, status: 'COMPLETED', hasIncident: true, notes: pendingVisitNotes, completedTasks: ['Limpieza de cestos de skimmers'] } });
    await prisma.visitResult.createMany({ data: [{ visitId: pendingVisit.id, parameterName: 'Nivel de Sal (para piscinas de sal)', value: '3800', parameterUnit: 'ppm' }] });
    await prisma.notification.create({ data: { message: pendingVisitNotes, visitId: pendingVisit.id, tenantId: mainTenant.id, userId: adminUser.id, } });
    console.log('   - 1 incidencia PENDIENTE (de hoy) creada.');
    
    const classifiedVisitNotes = 'La bomba de calor hace un ruido met√°lico muy fuerte al arrancar. Podr√≠a romperse. Recomiendo no encenderla hasta que se revise.';
    const classifiedVisit = await prisma.visit.create({ data: { timestamp: today, poolId: allPools[4]!.id, technicianId: technicians[2]!.id, status: 'COMPLETED', hasIncident: true, notes: classifiedVisitNotes, completedTasks: ['Limpieza de cestos de skimmers', 'Cepillado de paredes y l√≠nea de flotaci√≥n'] } });
    await prisma.visitResult.createMany({ data: [ { visitId: classifiedVisit.id, parameterName: 'Temperatura del Agua', value: '24', parameterUnit: '¬∞C' }, { visitId: classifiedVisit.id, parameterName: 'Presi√≥n del Filtro', value: '1.5', parameterUnit: 'bar' }, ] });
    await prisma.notification.create({ data: { message: classifiedVisitNotes, visitId: classifiedVisit.id, tenantId: mainTenant.id, userId: adminUser.id, priority: 'HIGH',  resolutionDeadline: tomorrow, } });
    console.log('   - 1 incidencia PENDIENTE CLASIFICADA (Prioridad ALTA) creada.');

    // 7. --- SIMULACI√ìN DE TICKETING AVANZADO ---
    const allNotifications = await prisma.notification.findMany({ where: { tenantId: mainTenant.id } });
    let taskCount = 0;
    for (const taskSeed of incidentTasksData) {
      const parentNotification = allNotifications.find(n => n.message.includes(taskSeed.notificationMessage));
      if (!parentNotification) { console.warn(`   - ‚ö†Ô∏è  No se encontr√≥ la notificaci√≥n padre para la tarea: "${taskSeed.task.title}"`); continue; }
      
      const assignedUser = taskSeed.task.title.includes('Contactar') ? adminUser : technicians[taskCount % technicians.length];
      if (!assignedUser) continue;

      const taskData = { ...taskSeed.task, notificationId: parentNotification.id, assignedToId: assignedUser.id, tenantId: mainTenant.id };
      const createdTask = await prisma.incidentTask.create({ data: taskData });
      taskCount++;

      await prisma.incidentTaskLog.create({ data: { action: 'CREATION', details: `Tarea creada por ${adminUser.name}. Asignada a ${assignedUser.name}.`, incidentTaskId: createdTask.id, userId: adminUser.id, }});
      if (createdTask.status !== 'PENDING') {
        await prisma.incidentTaskLog.create({ data: { action: 'STATUS_CHANGE', details: `Estado cambiado a ${createdTask.status}.`, incidentTaskId: createdTask.id, userId: assignedUser.id, }});
      }
    }
    console.log(`   - ${taskCount} tareas de incidencia creadas con sus logs.`);


    console.log('\n\n‚úÖ Seeding de demostraci√≥n completado con √©xito!');
    console.log('--- Credenciales de prueba ---');
    console.log('SuperAdmin: super@admin.com / superadmin123');
    console.log('Admin:      admin@piscival.com / password123');
    console.log('T√©cnicos:   carlos.t@piscival.com, ana.t@piscival.com, leo.a@piscival.com (pass: password123)');
    console.log('Manager:    manager@piscival.com / password123');

  } catch (e) {
    console.error('‚ùå Error fatal durante el proceso de seeding:', e);
    throw e;
  } finally {
    await prisma.$disconnect();
  }
}

function createPoolMaintenanceSheet(
  poolId: string,
  allParams: ParameterTemplate[],
  allTasks: ScheduledTaskTemplate[],
  poolType: string | null
): any[] {
  const configs: any[] = [];
  const commonParams = allParams.filter(p => ['Nivel de pH', 'Alcalinidad Total (TA)', 'Estado del Agua'].includes(p.name));
  for (const param of commonParams) {
    configs.push({ poolId, parameterTemplateId: param.id, frequency: 'SEMANAL' as Frequency, minThreshold: param.name.includes('pH') ? 7.2 : null, maxThreshold: param.name.includes('pH') ? 7.6 : null, });
  }
  const commonTasks = allTasks.filter(t => ['Limpieza de cestos de skimmers', 'Cepillado de paredes y l√≠nea de flotaci√≥n'].includes(t.name));
  for (const task of commonTasks) {
    configs.push({ poolId, taskTemplateId: task.id, frequency: 'SEMANAL' as Frequency });
  }
  const backwashTask = allTasks.find(t => t.name.includes('Contralavado'));
  if (backwashTask) {
    configs.push({ poolId, taskTemplateId: backwashTask.id, frequency: 'QUINCENAL' as Frequency });
  }
  if (poolType === 'Cloro') {
    const cloroParams = allParams.filter(p => p.name.includes('Cloro Libre') || p.name.includes('Cloro Total'));
    for (const param of cloroParams) {
      configs.push({ poolId, parameterTemplateId: param.id, frequency: 'SEMANAL' as Frequency });
    }
  } else if (poolType === 'Sal') {
    const salParam = allParams.find(p => p.name.includes('Nivel de Sal'));
    const salTask = allTasks.find(t => t.name.includes('Revisi√≥n de clorador salino'));
    if (salParam) { configs.push({ poolId, parameterTemplateId: salParam.id, frequency: 'MENSUAL' as Frequency }); }
    if (salTask) { configs.push({ poolId, taskTemplateId: salTask.id, frequency: 'QUINCENAL' as Frequency }); }
  }
  const availableExtraParams = allParams.filter(p => !configs.some(c => c.parameterTemplateId === p.id));
  if (availableExtraParams.length >= 2) {
    const extraParams = getRandomItems(availableExtraParams, 2);
    for (const param of extraParams) {
      configs.push({ poolId, parameterTemplateId: param.id, frequency: 'MENSUAL' as Frequency });
    }
  }
  return configs;
}

// ‚úÖ Correcci√≥n final: Eliminamos el argumento 'e' para que no d√© el aviso del linter.
main().catch(() => {
    process.exit(1);
});


// ====== [49] packages/server/src/api/auth/auth.controller.ts ======
import type { Response, NextFunction } from 'express';
import { register, login } from './auth.service.js';
import { signToken } from '../../utils/jwt.utils.js';
import config from '../../config/index.js';
import type { CookieOptions, Request } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';

const cookieOptions: CookieOptions = {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'lax',
  maxAge: config.JWT_EXPIRES_IN * 1000, // maxAge est√° en milisegundos
};

/**
 * Maneja la petici√≥n de registro de un nuevo usuario.
 */
export const registerHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const user = await register(req.body);
    res.status(201).json({
      success: true,
      data: user,
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la petici√≥n de login de un usuario.
 */
export const loginHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const user = await login(req.body);
    const token = signToken({ id: user.id, role: user.role });
    res.cookie('token', token, cookieOptions);
    res.status(200).json({
      success: true,
      data: user,
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n del usuario actualmente autenticado (a trav√©s del token).
 */
export const getMeHandler = (req: AuthRequest, res: Response) => {
  // El middleware 'protect' se ejecuta antes que este manejador.
  // Si llega hasta aqu√≠, significa que el token es v√°lido y 'req.user' existe.
  res.status(200).json({
    success: true,
    data: req.user,
  });
};


// ====== [50] packages/server/src/api/auth/auth.routes.ts ======
import { Router } from 'express';
import type { Response } from 'express';
import {
  registerHandler,
  loginHandler,
  getMeHandler,
} from './auth.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const authRouter = Router();

/**
 * @route   POST /api/auth/register
 * @desc    Registra un nuevo usuario
 * @access  Public
 */
authRouter.post('/register', registerHandler);

/**
 * @route   POST /api/auth/login
 * @desc    Inicia sesi√≥n y devuelve un token en una cookie
 * @access  Public
 */
authRouter.post('/login', loginHandler);

/**
 * @route   GET /api/auth/me
 * @desc    Obtiene los datos del usuario logueado a partir de su token
 * @access  Private
 */
authRouter.get('/me', protect, getMeHandler);

/**
 * @route   POST /api/auth/logout
 * @desc    Cierra la sesi√≥n del usuario eliminando la cookie
 * @access  Public
 */
authRouter.post('/logout', (_req, res: Response) => {
  res.cookie('token', '', {
    httpOnly: true,
    expires: new Date(0),
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
  });
  res.status(200).json({ success: true, message: 'Sesi√≥n cerrada con √©xito.' });
});

export default authRouter;


// ====== [51] packages/server/src/api/auth/auth.service.ts ======
import { PrismaClient } from '@prisma/client';
import type { User } from '@prisma/client';
import { hashPassword, comparePassword } from '../../utils/password.utils.js';

const prisma = new PrismaClient();

// Tipo para la entrada de datos del registro.
export type RegisterUserInput = Omit<User, 'id' | 'createdAt' | 'updatedAt'>;

// Tipo para la entrada de datos del login.
export type LoginUserInput = {
  email: string;
  password: string;
};

/**
 * Registra un nuevo usuario en la base de datos.
 * @param input - Datos del usuario para el registro.
 * @returns El objeto de usuario creado (sin la contrase√±a).
 */
export const register = async (input: RegisterUserInput) => {
  const { email, password, ...rest } = input;

  const existingUser = await prisma.user.findUnique({
    where: { email },
  });

  if (existingUser) {
    throw new Error('Ya existe un usuario con este correo electr√≥nico.');
  }

  const hashedPassword = await hashPassword(password);

  const user = await prisma.user.create({
    data: {
      email,
      password: hashedPassword,
      ...rest,
    },
    select: {
      id: true,
      email: true,
      name: true,
      role: true,
      tenantId: true,
      createdAt: true,
      updatedAt: true,
    },
  });

  return user;
};

/**
 * Valida las credenciales de un usuario para el login.
 * @param input - Email y contrase√±a del usuario.
 * @returns El objeto de usuario autenticado (sin la contrase√±a).
 */
export const login = async (input: LoginUserInput): Promise<Omit<User, 'password'>> => {
  const user = await prisma.user.findUnique({
    where: { email: input.email },
  });

  if (!user) {
    throw new Error('El email o la contrase√±a son incorrectos.');
  }

  const isPasswordValid = await comparePassword(input.password, user.password);

  if (!isPasswordValid) {
    throw new Error('El email o la contrase√±a son incorrectos.');
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const { password, ...userWithoutPassword } = user;

  return userWithoutPassword;
};


// ====== [52] packages/server/src/api/client-product-pricing/client-product-pricing.controller.ts ======
// filename: packages/server/src/api/client-product-pricing/client-product-pricing.controller.ts
// version: 1.0.0
// description: Controlador para manejar las peticiones HTTP del CRUD de reglas de precios.

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createPricingRule,
  getPricingRulesByClient,
  updatePricingRule,
  deletePricingRule,
} from './client-product-pricing.service.js';

/**
 * Maneja la creaci√≥n de una nueva regla de precios.
 */
export const createPricingRuleHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    // Aqu√≠ el clientId vendr√° en el cuerpo de la petici√≥n.
    // Podr√≠amos a√±adir una validaci√≥n para asegurar que el cliente pertenece al tenant del usuario.
    const newRule = await createPricingRule(req.body);
    res.status(201).json({ success: true, data: newRule });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todas las reglas de precios de un cliente.
 */
export const getPricingRulesByClientHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { clientId } = req.params;
    if (!clientId) {
      return res.status(400).json({ success: false, message: 'El ID del cliente es requerido.' });
    }
    // TODO: Validar que el cliente pertenece al tenant del usuario.
    const rules = await getPricingRulesByClient(clientId);
    res.status(200).json({ success: true, data: rules });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n de una regla de precios.
 */
export const updatePricingRuleHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ success: false, message: 'El ID de la regla es requerido.' });
    }
    // TODO: Validar que la regla pertenece a un cliente del tenant del usuario.
    const updatedRule = await updatePricingRule(id, req.body);
    res.status(200).json({ success: true, data: updatedRule });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de una regla de precios.
 */
export const deletePricingRuleHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ success: false, message: 'El ID de la regla es requerido.' });
    }
    // TODO: Validar que la regla pertenece a un cliente del tenant del usuario.
    await deletePricingRule(id);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [53] packages/server/src/api/client-product-pricing/client-product-pricing.routes.ts ======
// filename: packages/server/src/api/client-product-pricing/client-product-pricing.routes.ts
// version: 2.0.0 (FEAT: Protect routes with ADMIN authorization)

import { Router } from 'express';
import {
  createPricingRuleHandler,
  getPricingRulesByClientHandler,
  updatePricingRuleHandler,
  deletePricingRuleHandler,
} from './client-product-pricing.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const clientProductPricingRouter = Router();

// Protegemos todas las rutas de este m√≥dulo.
// Solo los usuarios autenticados con rol de ADMIN pueden gestionar las reglas de precios.
clientProductPricingRouter.use(protect, authorize('ADMIN'));


// Ruta para crear una nueva regla
clientProductPricingRouter.post('/', createPricingRuleHandler);

// Ruta para obtener todas las reglas de un cliente espec√≠fico
clientProductPricingRouter.get('/by-client/:clientId', getPricingRulesByClientHandler);

// Rutas para actualizar o eliminar una regla espec√≠fica por su ID
clientProductPricingRouter.route('/:id')
  .patch(updatePricingRuleHandler)
  .delete(deletePricingRuleHandler);

export default clientProductPricingRouter;


// ====== [54] packages/server/src/api/client-product-pricing/client-product-pricing.service.ts ======
// filename: packages/server/src/api/client-product-pricing/client-product-pricing.service.ts
// version: 1.0.0
// description: Servicio para la l√≥gica de negocio de las reglas de precios.

import { PrismaClient } from '@prisma/client';
import type { ClientProductPricing } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreatePricingRuleInput = {
  clientId: string;
  discountPercentage: number;
  productId?: string;
  productCategoryId?: string;
};

export type UpdatePricingRuleInput = {
  discountPercentage: number;
};

/**
 * Crea una nueva regla de precios para un cliente.
 * @param data - Los datos de la regla.
 * @returns La regla reci√©n creada.
 */
export const createPricingRule = async (data: CreatePricingRuleInput): Promise<ClientProductPricing> => {
  // La unicidad se maneja a nivel de base de datos con @@unique
  return prisma.clientProductPricing.create({
    data,
  });
};

/**
 * Obtiene todas las reglas de precios para un cliente espec√≠fico.
 * @param clientId - El ID del cliente.
 * @returns Un array con todas las reglas de precios del cliente.
 */
export const getPricingRulesByClient = async (clientId: string): Promise<ClientProductPricing[]> => {
  return prisma.clientProductPricing.findMany({
    where: { clientId },
    include: {
      product: { select: { name: true } },
      productCategory: { select: { name: true } },
    },
    orderBy: {
      // Opcional: alg√∫n orden l√≥gico si se desea
      product: { name: 'asc' },
    },
  });
};

/**
 * Actualiza una regla de precios existente.
 * @param id - El ID de la regla a actualizar.
 * @param data - Los datos a modificar (solo el descuento).
 * @returns La regla actualizada.
 */
export const updatePricingRule = async (id: string, data: UpdatePricingRuleInput): Promise<ClientProductPricing> => {
  return prisma.clientProductPricing.update({
    where: { id },
    data,
  });
};

/**
 * Elimina una regla de precios.
 * @param id - El ID de la regla a eliminar.
 */
export const deletePricingRule = async (id: string): Promise<void> => {
  await prisma.clientProductPricing.delete({
    where: { id },
  });
};


// ====== [55] packages/server/src/api/clients/clients.controller.ts ======
// filename: packages/server/src/api/clients/clients.controller.ts
// Version: 2.0.0 (FEAT: Pass tenantId to service for validation)

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createClient,
  deleteClient,
  getClientById,
  getClientsByTenant,
  updateClient,
} from './clients.service.js';

/**
 * Maneja la creaci√≥n de un nuevo cliente.
 */
export const createClientHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }

    const input = { ...req.body, tenantId };
    const newClient = await createClient(input);
    res.status(201).json({ success: true, data: newClient });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todos los clientes de un tenant.
 */
export const getClientsByTenantHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }

    const clients = await getClientsByTenant(tenantId);
    res.status(200).json({ success: true, data: clients });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de un cliente espec√≠fico por ID.
 */
export const getClientByIdHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    const { id: clientId } = req.params;

    if (!tenantId || !clientId) {
      return res.status(400).json({ success: false, message: 'ID de cliente o de tenant faltante.' });
    }

    const client = await getClientById(clientId, tenantId);
    if (!client) {
      return res.status(404).json({ success: false, message: 'Cliente no encontrado.' });
    }

    res.status(200).json({ success: true, data: client });
  } catch (error) {
    next(error);
  }
};


/**
 * Maneja la actualizaci√≥n de un cliente.
 */
export const updateClientHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;
    
    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de cliente o de tenant faltante.' });
    }
    
    const updatedClient = await updateClient(id, tenantId, req.body);
    res.status(200).json({ success: true, data: updatedClient });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de un cliente.
 */
export const deleteClientHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de cliente o de tenant faltante.' });
    }

    await deleteClient(id, tenantId);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [56] packages/server/src/api/clients/clients.routes.ts ======
// filename: packages/server/src/api/clients/clients.routes.ts
// Version: 2.0.0 (FEAT: Protect routes with ADMIN/MANAGER authorization)

import { Router } from 'express';
import {
  createClientHandler,
  deleteClientHandler,
  getClientByIdHandler,
  getClientsByTenantHandler,
  updateClientHandler,
} from './clients.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const clientsRouter = Router();

// Aplicamos el middleware 'protect' a TODAS las rutas de este enrutador.
clientsRouter.use(protect);

// Las rutas para listar y crear clientes solo son accesibles para ADMINS.
clientsRouter.route('/')
  .get(authorize('ADMIN', 'MANAGER'), getClientsByTenantHandler)
  .post(authorize('ADMIN'), createClientHandler);

// Las rutas para un cliente espec√≠fico son accesibles para ADMIN y MANAGER para ver,
// pero solo para ADMIN para modificar o eliminar.
// Esto permite al MANAGER ver los detalles del cliente desde su dashboard.
clientsRouter.route('/:id')
  .get(authorize('ADMIN', 'MANAGER'), getClientByIdHandler)
  .patch(authorize('ADMIN'), updateClientHandler)
  .delete(authorize('ADMIN'), deleteClientHandler);

export default clientsRouter;


// ====== [57] packages/server/src/api/clients/clients.service.ts ======
// filename: packages/server/src/api/clients/clients.service.ts
// Version: 2.0.0 (FEAT: Add tenantId validation for CUD operations)

import { PrismaClient } from '@prisma/client';
import type { Client } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateClientInput = Omit<Client, 'id' | 'createdAt' | 'updatedAt'>;
export type UpdateClientInput = Partial<Omit<CreateClientInput, 'tenantId' | 'createdAt' | 'updatedAt'>>;

// --- Funciones del Servicio ---

/**
 * Crea un nuevo cliente para un tenant espec√≠fico.
 * @param data - Datos del nuevo cliente.
 * @returns El cliente creado.
 */
export const createClient = async (data: CreateClientInput): Promise<Client> => {
  return prisma.client.create({
    data,
  });
};

/**
 * Obtiene todos los clientes de un tenant espec√≠fico.
 * @param tenantId - El ID del tenant.
 * @returns Un array de clientes.
 */
export const getClientsByTenant = async (tenantId: string): Promise<Client[]> => {
  return prisma.client.findMany({
    where: { tenantId },
    orderBy: { name: 'asc' },
    include: {
      pools: true,
    },
  });
};

/**
 * Obtiene un cliente espec√≠fico por su ID.
 * @param id - El ID del cliente a buscar.
 * @param tenantId - El ID del tenant para asegurar la pertenencia.
 * @returns El objeto del cliente o null si no se encuentra o no pertenece al tenant.
 */
export const getClientById = async (id: string, tenantId: string): Promise<Client | null> => {
  return prisma.client.findFirst({
    where: { id, tenantId },
     include: {
      pools: true,
    },
  });
};


/**
 * Actualiza un cliente existente, verificando la pertenencia al tenant.
 * @param id - El ID del cliente a actualizar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 * @param data - Los datos a actualizar.
 * @returns El cliente actualizado.
 */
export const updateClient = async (id: string, tenantId: string, data: UpdateClientInput): Promise<Client> => {
  const { count } = await prisma.client.updateMany({
    where: {
      id,
      tenantId, // <-- Condici√≥n de seguridad
    },
    data,
  });

  if (count === 0) {
    throw new Error('Cliente no encontrado o sin permisos para modificar.');
  }

  return prisma.client.findUniqueOrThrow({ where: { id } });
};

/**
 * Elimina un cliente, verificando la pertenencia al tenant.
 * @param id - El ID del cliente a eliminar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 */
export const deleteClient = async (id: string, tenantId: string): Promise<void> => {
  const { count } = await prisma.client.deleteMany({
    where: {
      id,
      tenantId, // <-- Condici√≥n de seguridad
    },
  });

  if (count === 0) {
    throw new Error('Cliente no encontrado o sin permisos para eliminar.');
  }
};


// ====== [58] packages/server/src/api/dashboard/dashboard.controller.ts ======
// filename: packages/server/src/api/dashboard/dashboard.controller.ts
// version: 1.0.1 (FIXED)
// description: A√±ade la guarda de validaci√≥n para req.user.

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { getManagerDashboardData } from './dashboard.service.js';

/**
 * Maneja la obtenci√≥n de todos los datos agregados para el dashboard del manager.
 */
export const getManagerDashboardHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    // --- ‚úÖ GUARDA DE VALIDACI√ìN A√ëADIDA ---
    // Aseguramos que el usuario y el tenantId existen.
    // Aunque 'protect' ya lo hace, esto satisface a TypeScript.
    if (!req.user || !req.user.tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida. Usuario o Tenant no identificado.' });
    }
    
    const tenantId = req.user.tenantId;

    // Solo los roles MANAGER pueden acceder a este dashboard.
    // El 'activeRole' del frontend no importa aqu√≠, miramos el rol real.
    if (req.user.role !== 'MANAGER' && req.user.role !== 'SUPER_ADMIN') {
        return res.status(403).json({ success: false, message: 'Acceso denegado. Se requiere rol de Manager.'})
    }
    
    const dashboardData = await getManagerDashboardData(tenantId);
    res.status(200).json({ success: true, data: dashboardData });
  } catch (error) {
    next(error);
  }
};


// ====== [59] packages/server/src/api/dashboard/dashboard.routes.ts ======
// filename: packages/server/src/api/dashboard/dashboard.routes.ts
// version: 1.0.0
// description: Define el endpoint de la API para los datos del Dashboard de Gerencia.

import { Router } from 'express';
import { getManagerDashboardHandler } from './dashboard.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const dashboardRouter = Router();

// Protegemos la ruta para que solo usuarios autenticados puedan acceder.
dashboardRouter.use(protect);

/**
 * @route   GET /api/dashboard/manager
 * @desc    Obtiene todos los datos agregados para el Dashboard de Gerencia.
 * @access  Private (Manager)
 */
dashboardRouter.get('/manager', getManagerDashboardHandler);

export default dashboardRouter;


// ====== [60] packages/server/src/api/dashboard/dashboard.service.ts ======
// filename: packages/server/src/api/dashboard/dashboard.service.ts
// version: 1.3.0 (FIXED: Correct relation name 'clientPricingRules')
// description: Corrige el nombre de la relaci√≥n en la consulta de clientes para que coincida con el schema.prisma.

import { PrismaClient } from '@prisma/client';
import { startOfMonth, subDays } from 'date-fns';

const prisma = new PrismaClient();

interface DashboardData {
  financials: {
    totalRevenue: number;
    totalCosts: number;
    netProfit: number;
  };
  incidents: {
    openIncidents: number;
    resolvedThisMonth: number;
    avgResolutionTimeHours: number | null;
  };
  topClientsByProfit: {
    clientId: string;
    clientName: string;
    netProfit: number;
  }[];
  topProductsByCost: {
    productId: string;
    productName: string;
    totalCost: number;
  }[];
}

export const getManagerDashboardData = async (tenantId: string): Promise<DashboardData> => {
  const today = new Date();
  const thirtyDaysAgo = subDays(today, 30);
  const startOfCurrentMonth = startOfMonth(today);

  // --- 1. Datos Financieros (√öltimos 30 d√≠as) ---
  const expenses = await prisma.expense.aggregate({
    _sum: { amount: true },
    where: { tenantId, expenseDate: { gte: thirtyDaysAgo, lte: today } },
  });

  const consumptions = await prisma.consumption.findMany({
    where: {
      visit: {
        pool: { tenantId },
        timestamp: { gte: thirtyDaysAgo, lte: today },
      },
    },
    include: {
      product: true,
      visit: {
        include: {
          pool: true,
        },
      },
    },
  });
  
  const totalConsumptionCost = consumptions.reduce((sum, c) => sum + (c.quantity * c.product.cost), 0);
  const totalCosts = (expenses._sum.amount || 0) + totalConsumptionCost;

  const clientsForRevenue = await prisma.client.findMany({ where: { tenantId } });
  const totalFees = clientsForRevenue.reduce((sum, c) => sum + c.monthlyFee, 0);
  const totalMaterialsRevenue = consumptions.reduce((sum, c) => sum + (c.quantity * c.product.salePrice), 0);
  const totalRevenue = totalFees + totalMaterialsRevenue;

  // --- 2. Datos de Incidencias ---
  const openIncidents = await prisma.notification.count({
    where: { tenantId, status: 'PENDING' },
  });
  
  const resolvedThisMonth = await prisma.notification.count({
    where: {
      tenantId,
      status: 'RESOLVED',
      createdAt: { gte: startOfCurrentMonth },
    },
  });

  // --- 3. Top 5 Clientes por Rentabilidad ---
  // ‚úÖ CORRECCI√ìN 1: Usar el nombre de relaci√≥n correcto 'clientPricingRules' del schema.prisma
  const clientsWithPricing = await prisma.client.findMany({
    where: { tenantId },
    include: { clientPricingRules: true }, 
  });

  const clientProfits = clientsWithPricing.map(client => {
    let clientRevenue = client.monthlyFee;
    const clientConsumptions = consumptions.filter(c => c.visit.pool.clientId === client.id);

    if (client.billingModel !== 'ALL_INCLUSIVE') {
      for (const consumption of clientConsumptions) {
        const product = consumption.product;
        let finalSalePrice = product.salePrice;
        
        // ‚úÖ CORRECCI√ìN 2: Usar el nombre de propiedad correcto 'clientPricingRules' en el resto del c√≥digo
        const productRule = client.clientPricingRules.find(r => r.productId === product.id);
        const categoryRule = client.clientPricingRules.find(r => r.productCategoryId === product.categoryId);

        if (productRule) {
          finalSalePrice *= (1 - productRule.discountPercentage / 100);
        } else if (categoryRule) {
          finalSalePrice *= (1 - categoryRule.discountPercentage / 100);
        } else {
          finalSalePrice *= client.priceModifier;
        }
        clientRevenue += consumption.quantity * finalSalePrice;
      }
    }

    const clientCosts = clientConsumptions.reduce((sum, c) => sum + (c.quantity * c.product.cost), 0);
    
    return {
      clientId: client.id,
      clientName: client.name,
      netProfit: clientRevenue - clientCosts,
    };
  });

  const topClientsByProfit = clientProfits
    .sort((a, b) => b.netProfit - a.netProfit)
    .slice(0, 5);


  // --- 4. Top 5 Productos por Coste ---
  const productCosts = await prisma.consumption.groupBy({
    by: ['productId'],
    _sum: { quantity: true },
    where: {
        visit: {
            pool: { tenantId },
            timestamp: { gte: thirtyDaysAgo, lte: today },
        }
    },
  });
  
  const productDetails = await prisma.product.findMany({
    where: { id: { in: productCosts.map(p => p.productId) } },
  });

  const topProductsByCost = productCosts.map(p => {
    const detail = productDetails.find(d => d.id === p.productId);
    return {
      productId: p.productId,
      productName: detail?.name || 'Desconocido',
      totalCost: (p._sum.quantity || 0) * (detail?.cost || 0),
    };
  }).sort((a, b) => b.totalCost - a.totalCost).slice(0, 5);


  return {
    financials: {
      totalRevenue,
      totalCosts,
      netProfit: totalRevenue - totalCosts,
    },
    incidents: {
      openIncidents,
      resolvedThisMonth,
      avgResolutionTimeHours: null,
    },
    topClientsByProfit,
    topProductsByCost,
  };
};


// ====== [61] packages/server/src/api/expenses/expenses.controller.ts ======
// filename: packages/server/src/api/expenses/expenses.controller.ts
// version: 1.0.0
// description: Controlador para manejar las peticiones HTTP del CRUD de gastos.

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createExpense,
  getExpensesByTenant,
  deleteExpense,
} from './expenses.service.js';

/**
 * Maneja la creaci√≥n de un nuevo gasto.
 */
export const createExpenseHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }
    const input = { ...req.body, tenantId };
    const newExpense = await createExpense(input);
    res.status(201).json({ success: true, data: newExpense });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todos los gastos de un tenant.
 */
export const getExpensesByTenantHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }
    const expenses = await getExpensesByTenant(tenantId);
    res.status(200).json({ success: true, data: expenses });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de un gasto.
 */
export const deleteExpenseHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ success: false, message: 'El ID del gasto es requerido.' });
    }
    // TODO: Validar que el gasto pertenece al tenant del usuario.
    await deleteExpense(id);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [62] packages/server/src/api/expenses/expenses.routes.ts ======
// filename: packages/server/src/api/expenses/expenses.routes.ts
// version: 2.0.0 (FEAT: Protect routes with ADMIN authorization)

import { Router } from 'express';
import {
  createExpenseHandler,
  getExpensesByTenantHandler,
  deleteExpenseHandler,
} from './expenses.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const expensesRouter = Router();

// Protegemos todas las rutas de este m√≥dulo.
// Solo los usuarios autenticados con rol de ADMIN pueden gestionar los gastos.
expensesRouter.use(protect, authorize('ADMIN'));


// Rutas para /api/expenses
expensesRouter.route('/')
  .get(getExpensesByTenantHandler)
  .post(createExpenseHandler);

// Ruta para eliminar un gasto espec√≠fico por su ID
expensesRouter.delete('/:id', deleteExpenseHandler);

export default expensesRouter;


// ====== [63] packages/server/src/api/expenses/expenses.service.ts ======
// filename: packages/server/src/api/expenses/expenses.service.ts
// version: 1.0.0
// description: Servicio para la l√≥gica de negocio de los gastos de la empresa.

import { PrismaClient } from '@prisma/client';
import type { Expense } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateExpenseInput = Omit<Expense, 'id'>;

/**
 * Crea un nuevo registro de gasto para un tenant.
 * @param data - Los datos del gasto a crear.
 * @returns El gasto reci√©n creado.
 */
export const createExpense = async (data: CreateExpenseInput): Promise<Expense> => {
  return prisma.expense.create({
    data,
  });
};

/**
 * Obtiene todos los gastos de un tenant espec√≠fico.
 * @param tenantId - El ID del tenant.
 * @returns Un array con todos los gastos del tenant.
 */
export const getExpensesByTenant = async (tenantId: string): Promise<Expense[]> => {
  return prisma.expense.findMany({
    where: { tenantId },
    orderBy: { expenseDate: 'desc' },
  });
};

/**
 * Elimina un registro de gasto.
 * @param id - El ID del gasto a eliminar.
 */
export const deleteExpense = async (id: string): Promise<void> => {
  await prisma.expense.delete({
    where: { id },
  });
};


// ====== [64] packages/server/src/api/incident-tasks/incident-tasks.controller.ts ======
// filename: packages/server/src/api/incident-tasks/incident-tasks.controller.ts
// version: 1.3.1 (Cleaned)

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createIncidentTask,
  getTasksByNotificationId,
  updateIncidentTask,
  deleteIncidentTask,
  getTasksAssignedToUser,
  updateTaskStatus,
  addTaskLog,
  getTaskLogs,
  updateTaskDeadline,
} from './incident-tasks.service.js';

export const getMyAssignedTasksHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const userId = req.user?.id;
    if (!userId) { return res.status(401).json({ success: false, message: 'Usuario no autenticado.' }); }
    const tasks = await getTasksAssignedToUser(userId);
    res.status(200).json({ success: true, data: tasks });
  } catch (error) { next(error); }
};

export const createIncidentTaskHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const tenantId = req.user?.tenantId;
    const actorId = req.user?.id;

    if (!tenantId || !actorId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida. Usuario o tenant no identificado.' });
    }

    const input = { ...req.body, tenantId };
    const newTask = await createIncidentTask(input, actorId);
    res.status(201).json({ success: true, data: newTask });
  } catch (error) {
    next(error);
  }
};

export const getTasksByNotificationHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) { return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' }); }
    const { notificationId } = req.params;
    if (!notificationId) { return res.status(400).json({ success: false, message: 'El ID de la notificaci√≥n es requerido.' }); }
    const tasks = await getTasksByNotificationId(notificationId, tenantId);
    res.status(200).json({ success: true, data: tasks });
  } catch (error) { next(error); }
};

export const updateIncidentTaskHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const { id } = req.params;
    if (!id) { return res.status(400).json({ success: false, message: 'El ID de la tarea es requerido.' }); }
    
    const updatedTask = await updateIncidentTask(id, req.body);
    res.status(200).json({ success: true, data: updatedTask });
  } catch (error) { 
    next(error); 
  }
};

export const deleteIncidentTaskHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const { id } = req.params;
    if (!id) { return res.status(400).json({ success: false, message: 'El ID de la tarea es requerido.' }); }
    await deleteIncidentTask(id);
    res.status(204).send();
  } catch (error) { next(error); }
};

export const updateTaskStatusHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
    try {
        const { id: taskId } = req.params;
        const actorId = req.user?.id;
        const { status, resolutionNotes } = req.body;
        if (!taskId) { return res.status(400).json({ success: false, message: 'El ID de la tarea es requerido.'}); }
        if (!actorId) { return res.status(401).json({ success: false, message: 'Usuario no autenticado.'}); }
        if (!status) { return res.status(400).json({ success: false, message: 'El estado es requerido.'}); }

        const updatedTask = await updateTaskStatus(taskId, actorId, status, resolutionNotes);
        res.status(200).json({ success: true, data: updatedTask });
    } catch (error) {
        next(error);
    }
};

export const addTaskLogHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
    try {
        const { id: taskId } = req.params;
        const actorId = req.user?.id;
        if (!taskId) { return res.status(400).json({ success: false, message: 'El ID de la tarea es requerido.'}); }
        if (!actorId) { return res.status(401).json({ success: false, message: 'Usuario no autenticado.'}); }
        
        const log = await addTaskLog(taskId, actorId, req.body);
        res.status(201).json({ success: true, data: log });
    } catch (error) {
        next(error);
    }
};

export const getTaskLogsHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
    try {
        const { id: taskId } = req.params;
        if (!taskId) { return res.status(400).json({ success: false, message: 'El ID de la tarea es requerido.'}); }
        
        const logs = await getTaskLogs(taskId);
        res.status(200).json({ success: true, data: logs });
    } catch (error) {
        next(error);
    }
};

export const updateTaskDeadlineHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
    try {
        const { id: taskId } = req.params;
        const actorId = req.user?.id;
        const { deadline } = req.body;
        if (!taskId) { return res.status(400).json({ success: false, message: 'El ID de la tarea es requerido.'}); }
        if (!actorId) { return res.status(401).json({ success: false, message: 'Usuario no autenticado.'}); }
        if (typeof deadline !== 'string' || !deadline) { return res.status(400).json({ success: false, message: 'Se requiere un plazo (deadline) v√°lido.'}); }

        const updatedTask = await updateTaskDeadline(taskId, deadline, actorId);
        res.status(200).json({ success: true, data: updatedTask });
    } catch (error) {
        next(error);
    }
};


// ====== [65] packages/server/src/api/incident-tasks/incident-tasks.routes.ts ======
// filename: packages/server/src/api/incident-tasks/incident-tasks.routes.ts
// version: 2.0.0 (FEAT: Protect routes with granular ADMIN/TECHNICIAN authorization)

import { Router } from 'express';
import {
  createIncidentTaskHandler,
  getTasksByNotificationHandler,
  updateIncidentTaskHandler,
  deleteIncidentTaskHandler,
  getMyAssignedTasksHandler,
  updateTaskStatusHandler,
  addTaskLogHandler,
  getTaskLogsHandler,
  updateTaskDeadlineHandler,
} from './incident-tasks.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const incidentTasksRouter = Router();

// Todas las rutas de tareas de incidencia requieren autenticaci√≥n.
incidentTasksRouter.use(protect);

// --- Rutas Generales y de Listado ---
// El t√©cnico ve sus tareas pendientes.
incidentTasksRouter.get('/my-tasks', authorize('TECHNICIAN'), getMyAssignedTasksHandler);
// El admin ve las tareas asociadas a una notificaci√≥n.
incidentTasksRouter.get('/by-notification/:notificationId', authorize('ADMIN'), getTasksByNotificationHandler);
// Solo el admin puede crear tareas.
incidentTasksRouter.post('/', authorize('ADMIN'), createIncidentTaskHandler);


// --- Rutas para una Tarea Espec√≠fica por ID ---
// Tanto admin como t√©cnico pueden ver el historial de una tarea.
incidentTasksRouter.get('/:id/logs', authorize('ADMIN', 'TECHNICIAN'), getTaskLogsHandler);
// Tanto admin como t√©cnico pueden a√±adir comentarios/logs.
incidentTasksRouter.post('/:id/log', authorize('ADMIN', 'TECHNICIAN'), addTaskLogHandler);
// El t√©cnico actualiza el estado (ej: a IN_PROGRESS o COMPLETED).
incidentTasksRouter.patch('/:id/status', authorize('TECHNICIAN'), updateTaskStatusHandler);
// El admin actualiza el plazo (deadline).
incidentTasksRouter.patch('/:id/deadline', authorize('ADMIN'), updateTaskDeadlineHandler);
// El admin edita los detalles principales de la tarea.
incidentTasksRouter.patch('/:id', authorize('ADMIN'), updateIncidentTaskHandler);
// El admin elimina la tarea.
incidentTasksRouter.delete('/:id', authorize('ADMIN'), deleteIncidentTaskHandler);

export default incidentTasksRouter;


// ====== [66] packages/server/src/api/incident-tasks/incident-tasks.service.ts ======
// filename: packages/server/src/api/incident-tasks/incident-tasks.service.ts
// version: 1.5.1 (FIX: Correctly compare nullable dates)

import { PrismaClient } from '@prisma/client';
import type { IncidentTask, IncidentPriority, IncidentTaskStatus, IncidentTaskLog } from '@prisma/client';
// ‚úÖ Se elimina 'isEqual' que no se usa y causaba el error
import { format } from 'date-fns';
import { es } from 'date-fns/locale';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateIncidentTaskInput = {
  title: string;
  notificationId: string;
  tenantId: string;
  description?: string;
  priority?: IncidentPriority;
  assignedToId?: string;
};
export type UpdateIncidentTaskInput = {
  title?: string;
  description?: string;
  status?: IncidentTaskStatus;
  priority?: IncidentPriority;
  assignedToId?: string | null;
  resolutionNotes?: string;
  deadline?: string | null;
};
export type AddLogInput = {
  details: string;
  newDeadline?: string;
};

// --- Funciones del Servicio ---

export const createIncidentTask = async (data: CreateIncidentTaskInput, actorId: string): Promise<IncidentTask> => {
  const task = await prisma.incidentTask.create({
    data: {
      title: data.title,
      description: data.description,
      priority: data.priority,
      notificationId: data.notificationId,
      assignedToId: data.assignedToId,
      tenantId: data.tenantId,
    },
  });
  await prisma.incidentTaskLog.create({
    data: {
      action: 'CREATION',
      details: `Tarea creada.`,
      incidentTaskId: task.id,
      userId: actorId,
    }
  });
  return task;
};

export const getTasksByNotificationId = async (notificationId: string, tenantId: string): Promise<IncidentTask[]> => {
  return prisma.incidentTask.findMany({
    where: { notificationId, tenantId },
    select: {
      id: true,
      title: true,
      description: true,
      status: true,
      priority: true,
      deadline: true,
      resolutionNotes: true,
      assignedTo: {
        select: {
          id: true,
          name: true,
        },
      },
      createdAt: true,
      updatedAt: true,
      tenantId: true,
      notificationId: true,
      assignedToId: true,
      logs: false,
    },
    orderBy: { createdAt: 'asc' },
  });
};

export const getTasksAssignedToUser = async (userId: string): Promise<IncidentTask[]> => {
  return prisma.incidentTask.findMany({ where: { assignedToId: userId, status: { in: ['PENDING', 'IN_PROGRESS'], }, }, include: { notification: { include: { visit: { include: { pool: { select: { name: true } } } } } } }, orderBy: { priority: 'desc', }, });
};

export const updateIncidentTask = async (id: string, data: UpdateIncidentTaskInput): Promise<IncidentTask> => {
  return prisma.$transaction(async (tx) => {
    // 1. Obtenemos el estado de la tarea ANTES de la actualizaci√≥n
    const originalTask = await tx.incidentTask.findUniqueOrThrow({
      where: { id },
      include: { assignedTo: true }
    });

    // 2. Realizamos la actualizaci√≥n
    const updatedTask = await tx.incidentTask.update({
        where: { id },
        data: {
          ...data,
          deadline: data.deadline ? new Date(data.deadline) : null,
        },
        include: { assignedTo: true, notification: true }
    });

    // 3. Comparamos el plazo (deadline) de forma segura
    const originalDeadline = originalTask.deadline;
    const updatedDeadline = updatedTask.deadline;
    
    // ‚úÖ LA SOLUCI√ìN: Comparamos el valor num√©rico de las fechas, que maneja null/undefined correctamente.
    if (originalDeadline?.getTime() !== updatedDeadline?.getTime() && updatedTask.assignedTo) {
      const formattedDeadline = updatedDeadline 
        ? format(updatedDeadline, "d MMMM yyyy 'a las' HH:mm", { locale: es })
        : 'eliminado';
      
      const message = `El plazo para tu tarea "${updatedTask.title}" ha sido actualizado a: ${formattedDeadline}.`;
      
      // Creamos la notificaci√≥n para el t√©cnico
      await tx.notification.create({
        data: {
          message,
          tenantId: updatedTask.tenantId,
          userId: updatedTask.assignedTo.id,
          parentNotificationId: updatedTask.notificationId,
        }
      });
    }

    return updatedTask;
  });
};

export const deleteIncidentTask = async (id: string): Promise<void> => {
  await prisma.incidentTask.delete({ where: { id } });
};

export const updateTaskStatus = async (taskId: string, actorId: string, status: IncidentTaskStatus, resolutionNotes?: string) => {
  return prisma.$transaction(async (tx) => {
    const task = await tx.incidentTask.update({
      where: { id: taskId },
      data: { status, resolutionNotes },
      include: { assignedTo: true, notification: true },
    });

    if (!task.assignedTo) throw new Error("La tarea no tiene un asignado.");
    
    await tx.incidentTaskLog.create({
      data: {
        action: 'STATUS_CHANGE',
        details: `Estado cambiado a ${status} por ${task.assignedTo.name}.`,
        incidentTaskId: taskId,
        userId: actorId,
      }
    });

    if (status === 'COMPLETED') {
      await tx.notification.create({
        data: {
          message: `La tarea "${task.title}" ha sido completada.`,
          tenantId: task.tenantId,
          userId: task.notification.userId, 
          parentNotificationId: task.notificationId,
        }
      });
    }
    return task;
  });
};

export const addTaskLog = async (taskId: string, actorId: string, data: AddLogInput) => {
  return prisma.$transaction(async (tx) => {
    const task = await tx.incidentTask.findUnique({
      where: { id: taskId },
      include: { assignedTo: true, notification: true },
    });

    if (!task || !task.assignedTo) throw new Error("Tarea o t√©cnico asignado no encontrados.");

    let logDetails = data.details;
    let notificationMessage = `Actualizaci√≥n sobre "${task.title}": ${data.details}`;
    let logAction: any = 'COMMENT';

    if (data.newDeadline) {
      const formattedDeadline = format(new Date(data.newDeadline), "d MMMM yyyy 'a las' HH:mm", { locale: es });
      logDetails = `[SOLICITUD DE APLAZAMIENTO] ${data.details}. Se solicita nuevo plazo para: ${formattedDeadline}.`;
      notificationMessage = `Solicitud de aplazamiento de ${task.assignedTo.name} para la tarea "${task.title}".`;
      logAction = 'DEADLINE_REQUEST';
    }

    const log = await tx.incidentTaskLog.create({
      data: {
        action: logAction,
        details: logDetails,
        incidentTaskId: taskId,
        userId: actorId,
      }
    });

    const authorIsTechnician = actorId === task.assignedToId;
    const recipientId = authorIsTechnician ? task.notification.userId : task.assignedToId;

    if (recipientId) {
        await tx.notification.create({
            data: {
                message: notificationMessage,
                tenantId: task.tenantId,
                userId: recipientId,
                parentNotificationId: task.notificationId, 
            }
        });
    }

    return log;
  });
};

export const getTaskLogs = async (taskId: string): Promise<IncidentTaskLog[]> => {
    return prisma.incidentTaskLog.findMany({
        where: { incidentTaskId: taskId },
        include: { user: { select: { name: true } } },
        orderBy: { createdAt: 'asc' },
    });
};

export const updateTaskDeadline = async (taskId: string, deadline: string, actorId: string): Promise<IncidentTask> => {
  return prisma.$transaction(async (tx) => {
    const actor = await tx.user.findUniqueOrThrow({ where: { id: actorId } });
    
    const updatedTask = await tx.incidentTask.update({
      where: { id: taskId },
      data: { deadline: new Date(deadline) },
      include: { assignedTo: true }
    });

    const formattedDeadline = format(new Date(deadline), "d MMMM yyyy 'a las' HH:mm", { locale: es });
    await tx.incidentTaskLog.create({
      data: {
        action: 'DEADLINE_UPDATE',
        details: `[PLAZO ACTUALIZADO] El plazo ha sido modificado por ${actor.name} a: ${formattedDeadline}.`,
        incidentTaskId: taskId,
        userId: actorId,
      }
    });

    if (updatedTask.assignedTo) {
      await tx.notification.create({
        data: {
          message: `El plazo para tu tarea "${updatedTask.title}" ha sido actualizado por el administrador.`,
          tenantId: updatedTask.tenantId,
          userId: updatedTask.assignedTo.id,
          parentNotificationId: updatedTask.notificationId,
        }
      });
    }

    return updatedTask;
  });
};


// ====== [67] packages/server/src/api/notifications/notifications.controller.ts ======
// filename: packages/server/src/api/notifications/notifications.controller.ts
// version: 1.6.0 (Adds getNotificationByIdHandler)
// description: A√±ade el manejador para obtener una √∫nica notificaci√≥n por su ID.

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { 
  getNotificationsForUser, 
  markNotificationAsRead, 
  resolveNotification, 
  getNotificationHistory,
  classifyNotification,
  getNotificationById, // <-- Importar la nueva funci√≥n
} from './notifications.service.js';
import { IncidentPriority, NotificationStatus } from '@prisma/client';

/**
 * Maneja la obtenci√≥n de las notificaciones PENDIENTES para el usuario autenticado.
 */
export const getNotificationsHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ message: 'Usuario no autenticado.' });
    }
    const notifications = await getNotificationsForUser(userId);
    res.status(200).json({ success: true, data: notifications });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n del HISTORIAL COMPLETO de notificaciones para el tenant, con paginaci√≥n y filtros.
 */
export const getHistoryHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(401).json({ message: 'Usuario no autenticado o sin tenant.' });
    }
    const page = parseInt(req.query.page as string) || 1;
    const pageSize = parseInt(req.query.pageSize as string) || 10;
    const status = req.query.status as NotificationStatus | undefined;
    const clientId = req.query.clientId as string | undefined;

    if (status && !Object.values(NotificationStatus).includes(status)) {
        return res.status(400).json({ message: 'El estado proporcionado no es v√°lido.' });
    }
    const historyData = await getNotificationHistory(tenantId, page, pageSize, status, clientId);
    res.status(200).json({ success: true, data: historyData });
  } catch (error) {
    next(error);
  }
};

/**
 * --- NUEVO MANEJADOR ---
 * Maneja la obtenci√≥n de una notificaci√≥n espec√≠fica por su ID.
 */
export const getNotificationByIdHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { notificationId } = req.params;
    if (!notificationId) {
      return res.status(400).json({ message: 'El ID de la notificaci√≥n es requerido.' });
    }
    // TODO: A√±adir una capa de seguridad para verificar que el usuario
    // tiene permiso para ver esta notificaci√≥n (pertenece a su tenant).
    const notification = await getNotificationById(notificationId);
    if (!notification) {
      return res.status(404).json({ message: 'Notificaci√≥n no encontrada.' });
    }
    res.status(200).json({ success: true, data: notification });
  } catch (error) {
    next(error);
  }
};


/**
 * Maneja la acci√≥n de marcar una notificaci√≥n como le√≠da.
 */
export const markAsReadHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const userId = req.user?.id;
    const { notificationId } = req.params;
    if (!userId) { return res.status(401).json({ message: 'Usuario no autenticado.' }); }
    if (!notificationId) { return res.status(400).json({ message: 'El ID de la notificaci√≥n es requerido.' }); }
    const updatedNotification = await markNotificationAsRead(notificationId, userId);
    res.status(200).json({ success: true, data: updatedNotification });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la acci√≥n de resolver una notificaci√≥n.
 */
export const resolveNotificationHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const userId = req.user?.id;
    const { notificationId } = req.params;
    const { resolutionNotes } = req.body;
    if (!userId) { return res.status(401).json({ message: 'Usuario no autenticado.' }); }
    if (!notificationId) { return res.status(400).json({ message: 'El ID de la notificaci√≥n es requerido.' }); }
    if (typeof resolutionNotes !== 'string') { return res.status(400).json({ message: 'Se requieren notas de resoluci√≥n.' }); }
    const resolvedNotification = await resolveNotification(notificationId, userId, resolutionNotes);
    res.status(200).json({ success: true, data: resolvedNotification });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la acci√≥n de clasificar una notificaci√≥n (establecer prioridad y plazo).
 */
export const classifyNotificationHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
    try {
        const userId = req.user?.id;
        const { notificationId } = req.params;
        const { priority, deadline } = req.body;
        if (!userId) { return res.status(401).json({ message: 'Usuario no autenticado.' }); }
        if (!notificationId) { return res.status(400).json({ message: 'El ID de la notificaci√≥n es requerido.' }); }
        if (!priority || !Object.values(IncidentPriority).includes(priority)) { return res.status(400).json({ message: 'La prioridad proporcionada no es v√°lida.' }); }
        const deadlineDate = deadline ? new Date(deadline) : undefined;
        if (deadlineDate && isNaN(deadlineDate.getTime())) { return res.status(400).json({ message: 'El plazo proporcionado no es una fecha v√°lida.'}); }
        const classifiedNotification = await classifyNotification(notificationId, userId, priority, deadlineDate);
        res.status(200).json({ success: true, data: classifiedNotification });
    } catch (error) {
        next(error);
    }
};


// ====== [68] packages/server/src/api/notifications/notifications.routes.ts ======
// filename: packages/server/src/api/notifications/notifications.routes.ts
// version: 1.4.0 (Adds route to get a single notification by ID)
// description: A√±ade el endpoint para obtener los detalles de una notificaci√≥n espec√≠fica.

import { Router } from 'express';
import { 
  getNotificationsHandler, 
  markAsReadHandler, 
  resolveNotificationHandler,
  getHistoryHandler,
  classifyNotificationHandler,
  getNotificationByIdHandler, // <-- 1. Importar el nuevo manejador
} from './notifications.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const notificationsRouter = Router();

// --- Middleware de Protecci√≥n ---
notificationsRouter.use(protect);

/**
 * @route   GET /api/notifications/history
 * @desc    Obtiene el historial completo de notificaciones del tenant.
 * @access  Private (Admin)
 */
notificationsRouter.get('/history', getHistoryHandler);

/**
 * @route   GET /api/notifications
 * @desc    Obtiene todas las notificaciones PENDIENTES para el usuario autenticado.
 * @access  Private
 */
notificationsRouter.get('/', getNotificationsHandler);

/**
 * @route   POST /api/notifications/:notificationId/read
 * @desc    Marca una notificaci√≥n espec√≠fica como le√≠da.
 * @access  Private
 */
notificationsRouter.post('/:notificationId/read', markAsReadHandler);

/**
 * @route   POST /api/notifications/:notificationId/resolve
 * @desc    Resuelve una notificaci√≥n, cambiando su estado y a√±adiendo notas.
 * @access  Private (Admin)
 */
notificationsRouter.post('/:notificationId/resolve', resolveNotificationHandler);

/**
 * @route   PATCH /api/notifications/:notificationId/classify
 * @desc    Clasifica una notificaci√≥n (establece prioridad y/o plazo).
 * @access  Private (Admin)
 */
notificationsRouter.patch('/:notificationId/classify', classifyNotificationHandler);

/**
 * @route   GET /api/notifications/:notificationId
 * @desc    Obtiene los detalles de una notificaci√≥n espec√≠fica.
 * @access  Private (Admin)
 * @note    Esta ruta debe ir al final para no interferir con otras sub-rutas como '/history'.
 */
notificationsRouter.get('/:notificationId', getNotificationByIdHandler); // <-- 2. A√±adir la nueva ruta


export default notificationsRouter;


// ====== [69] packages/server/src/api/notifications/notifications.service.ts ======
// filename: packages/server/src/api/notifications/notifications.service.ts
// version: 1.6.1 (FIXED - Based on v1.5.1, adds getNotificationById)

import { PrismaClient } from '@prisma/client';
import type { Notification, IncidentPriority, NotificationStatus } from '@prisma/client';
import { subHours } from 'date-fns';

const prisma = new PrismaClient();

// --- Tipos ---
export type NotificationWithCriticality = Notification & { isCritical: boolean };

export type PaginatedNotifications = {
    notifications: (Notification & { visit: any })[]; // Ajustado para que coincida con el include
    total: number;
};

/**
 * Obtiene todas las notificaciones con estado PENDING para un usuario espec√≠fico.
 */
export const getNotificationsForUser = async (userId: string): Promise<Notification[]> => {
  return prisma.notification.findMany({
    where: { userId, status: 'PENDING' },
    orderBy: { createdAt: 'desc' },
  });
};

/**
 * Obtiene el historial de notificaciones para un tenant con filtros y paginaci√≥n.
 */
export const getNotificationHistory = async (
  tenantId: string,
  page: number,
  pageSize: number,
  status?: NotificationStatus,
  clientId?: string
): Promise<PaginatedNotifications> => {
    
    const skip = (page - 1) * pageSize;

    const whereClause: any = { tenantId };
    if (status) {
        whereClause.status = status;
    }
    if (clientId) {
        whereClause.visit = { pool: { clientId: clientId } };
    }
    
    const [notifications, total] = await prisma.$transaction([
        prisma.notification.findMany({
            where: whereClause,
            skip: skip,
            take: pageSize,
            include: {
                visit: {
                    include: {
                        pool: {
                            include: { client: { select: { id: true, name: true } } }
                        },
                        technician: { select: { name: true } }
                    }
                },
                images: true, // Incluimos las im√°genes
            }
        }),
        prisma.notification.count({ where: whereClause })
    ]);
    
    const now = new Date();
    const criticalThreshold = subHours(now, 48); 

    const enrichedAndSortedNotifications = notifications
        .map(notification => {
            const isOverdueByDeadline = notification.resolutionDeadline && notification.resolutionDeadline < now;
            const isOverdueByDefault = !notification.resolutionDeadline && notification.createdAt < criticalThreshold;
            return {
                ...notification,
                isCritical: (isOverdueByDeadline || isOverdueByDefault) && notification.status === 'PENDING',
            };
        })
        .sort((a, b) => {
            if (a.isCritical && !b.isCritical) return -1;
            if (!a.isCritical && b.isCritical) return 1;
            if (a.status === 'PENDING' && b.status === 'RESOLVED') return -1;
            if (a.status === 'RESOLVED' && b.status === 'PENDING') return 1;
            return b.createdAt.getTime() - a.createdAt.getTime();
        });

    return { notifications: enrichedAndSortedNotifications, total };
};


/**
 * Marca una notificaci√≥n espec√≠fica como le√≠da.
 */
export const markNotificationAsRead = async (
  notificationId: string,
  userId: string
): Promise<Notification> => {
  await prisma.notification.updateMany({
    where: { id: notificationId, userId: userId },
    data: { isRead: true },
  });
  return prisma.notification.findUniqueOrThrow({ where: { id: notificationId } });
};


/**
 * Resuelve una notificaci√≥n.
 */
export const resolveNotification = async (
    notificationId: string,
    userId: string,
    resolutionNotes: string,
): Promise<Notification> => {
    return prisma.notification.update({
        where: { id: notificationId, userId: userId },
        data: { status: 'RESOLVED', resolutionNotes: resolutionNotes },
    });
};

/**
 * Clasifica una notificaci√≥n.
 */
export const classifyNotification = async (
    notificationId: string,
    userId: string,
    priority: IncidentPriority,
    deadline?: Date,
): Promise<Notification> => {
    return prisma.notification.update({
        where: { id: notificationId, userId: userId },
        data: { priority: priority, resolutionDeadline: deadline },
    });
};


/**
 * --- NUEVA FUNCI√ìN ---
 * Obtiene los detalles de una √∫nica notificaci√≥n por su ID.
 * @param notificationId - El ID de la notificaci√≥n a buscar.
 * @returns El objeto de la notificaci√≥n con sus relaciones, o null si no se encuentra.
 */
export const getNotificationById = async (notificationId: string) => {
  return prisma.notification.findUnique({
    where: { id: notificationId },
    include: {
      images: true,
      visit: {
        include: {
          pool: { select: { name: true } },
          technician: { select: { name: true } },
        },
      },
    },
  });
};


// ====== [70] packages/server/src/api/parameters/parameters.controller.ts ======
// filename: packages/server/src/api/parameters/parameters.controller.ts
// Version: 2.0.0 (FEAT: Pass tenantId to service for validation)

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createParameterTemplate,
  deleteParameterTemplate,
  getParameterTemplatesByTenant,
  updateParameterTemplate,
} from './parameters.service.js';

/**
 * Maneja la creaci√≥n de una nueva plantilla de par√°metro.
 */
export const createParameterTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }
    const input = { ...req.body, tenantId };
    const newTemplate = await createParameterTemplate(input);
    res.status(201).json({ success: true, data: newTemplate });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todas las plantillas de un tenant.
 */
export const getParameterTemplatesByTenantHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }
    const templates = await getParameterTemplatesByTenant(tenantId);
    res.status(200).json({ success: true, data: templates });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n de una plantilla de par√°metro.
 */
export const updateParameterTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de plantilla o de tenant faltante.' });
    }

    const updatedTemplate = await updateParameterTemplate(id, tenantId, req.body);
    res.status(200).json({ success: true, data: updatedTemplate });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de una plantilla de par√°metro.
 */
export const deleteParameterTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de plantilla o de tenant faltante.' });
    }

    await deleteParameterTemplate(id, tenantId);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [71] packages/server/src/api/parameters/parameters.routes.ts ======
// filename: packages/server/src/api/parameters/parameters.routes.ts
// Version: 2.0.0 (FEAT: Protect routes with ADMIN authorization)

import { Router } from 'express';
import {
  createParameterTemplateHandler,
  deleteParameterTemplateHandler,
  getParameterTemplatesByTenantHandler,
  updateParameterTemplateHandler,
} from './parameters.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const parametersRouter = Router();

// Aplicamos la protecci√≥n y autorizaci√≥n a todas las rutas de este fichero.
// Solo los usuarios autenticados con rol de ADMIN pueden gestionar el cat√°logo.
parametersRouter.use(protect, authorize('ADMIN'));

parametersRouter.route('/')
  .get(getParameterTemplatesByTenantHandler)
  .post(createParameterTemplateHandler);

parametersRouter.route('/:id')
  .patch(updateParameterTemplateHandler)
  .delete(deleteParameterTemplateHandler);

export default parametersRouter;


// ====== [72] packages/server/src/api/parameters/parameters.service.ts ======
// filename: packages/server/src/api/parameters/parameters.service.ts
// Version: 2.0.1 (FIXED: Correct type definition for create operation)

import { PrismaClient } from '@prisma/client';
import type { ParameterTemplate, InputType } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateParameterTemplateInput = {
  name: string;
  tenantId: string; // Cada plantilla pertenece a un tenant
  unit?: string;
  type: InputType; // <-- CORREGIDO: Se ha eliminado el '?' para hacerlo obligatorio.
  selectOptions?: string[];
};

export type UpdateParameterTemplateInput = Partial<Omit<CreateParameterTemplateInput, 'tenantId'>>;

// --- Funciones del Servicio ---

/**
 * Crea una nueva plantilla de par√°metro para un tenant espec√≠fico.
 * @param input - Datos de la nueva plantilla.
 * @returns La plantilla de par√°metro creada.
 */
export const createParameterTemplate = async (
  input: CreateParameterTemplateInput
): Promise<ParameterTemplate> => {
  return prisma.parameterTemplate.create({
    data: input,
  });
};

/**
 * Obtiene todas las plantillas de par√°metros para un tenant espec√≠fico.
 * @param tenantId - El ID del tenant.
 * @returns Un array de plantillas de par√°metros.
 */
export const getParameterTemplatesByTenant = async (
  tenantId: string
): Promise<ParameterTemplate[]> => {
  return prisma.parameterTemplate.findMany({
    where: { tenantId },
    orderBy: { name: 'asc' },
  });
};

/**
 * Actualiza una plantilla de par√°metro existente, verificando la pertenencia al tenant.
 * @param id - El ID de la plantilla a actualizar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 * @param data - Los datos a actualizar.
 * @returns La plantilla de par√°metro actualizada.
 */
export const updateParameterTemplate = async (
  id: string,
  tenantId: string,
  data: UpdateParameterTemplateInput
): Promise<ParameterTemplate> => {
  const { count } = await prisma.parameterTemplate.updateMany({
    where: {
      id,
      tenantId, // <-- Condici√≥n de seguridad
    },
    data,
  });

  if (count === 0) {
    throw new Error('Plantilla de par√°metro no encontrada o sin permisos para modificar.');
  }

  return prisma.parameterTemplate.findUniqueOrThrow({ where: { id } });
};

/**
 * Elimina una plantilla de par√°metro, verificando la pertenencia al tenant.
 * @param id - El ID de la plantilla a eliminar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 */
export const deleteParameterTemplate = async (
  id: string,
  tenantId: string
): Promise<void> => {
  const { count } = await prisma.parameterTemplate.deleteMany({
    where: {
      id,
      tenantId, // <-- Condici√≥n de seguridad
    },
  });

  if (count === 0) {
    throw new Error('Plantilla de par√°metro no encontrada o sin permisos para eliminar.');
  }
};


// ====== [73] packages/server/src/api/payments/payments.controller.ts ======
// filename: packages/server/src/api/payments/payments.controller.ts
// version: 1.0.0
// description: Controlador para manejar las peticiones HTTP del CRUD de pagos.

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createPayment,
  getPaymentsByClient,
  deletePayment,
} from './payments.service.js';

/**
 * Maneja la creaci√≥n de un nuevo pago.
 */
export const createPaymentHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    // TODO: Validar que el clientId del body pertenece al tenant del usuario.
    const newPayment = await createPayment(req.body);
    res.status(201).json({ success: true, data: newPayment });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todos los pagos de un cliente.
 */
export const getPaymentsByClientHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { clientId } = req.params;
    if (!clientId) {
      return res.status(400).json({ success: false, message: 'El ID del cliente es requerido.' });
    }
    // TODO: Validar que el cliente pertenece al tenant del usuario.
    const payments = await getPaymentsByClient(clientId);
    res.status(200).json({ success: true, data: payments });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de un pago.
 */
export const deletePaymentHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ success: false, message: 'El ID del pago es requerido.' });
    }
    // TODO: Validar que el pago pertenece a un cliente del tenant del usuario.
    await deletePayment(id);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [74] packages/server/src/api/payments/payments.routes.ts ======
// filename: packages/server/src/api/payments/payments.routes.ts
// version: 2.0.0 (FEAT: Protect routes with ADMIN authorization)

import { Router } from 'express';
import {
  createPaymentHandler,
  getPaymentsByClientHandler,
  deletePaymentHandler,
} from './payments.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const paymentsRouter = Router();

// Protegemos todas las rutas de este m√≥dulo.
// Solo los usuarios autenticados con rol de ADMIN pueden gestionar los pagos.
paymentsRouter.use(protect, authorize('ADMIN'));


// Ruta para crear un nuevo pago
paymentsRouter.post('/', createPaymentHandler);

// Ruta para obtener todos los pagos de un cliente espec√≠fico
paymentsRouter.get('/by-client/:clientId', getPaymentsByClientHandler);

// Ruta para eliminar un pago espec√≠fico por su ID
paymentsRouter.delete('/:id', deletePaymentHandler);

export default paymentsRouter;


// ====== [75] packages/server/src/api/payments/payments.service.ts ======
// filename: packages/server/src/api/payments/payments.service.ts
// version: 1.0.0
// description: Servicio para la l√≥gica de negocio de los pagos de clientes.

import { PrismaClient } from '@prisma/client';
import type { Payment } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreatePaymentInput = Omit<Payment, 'id'>;

/**
 * Crea un nuevo registro de pago.
 * @param data - Los datos del pago a crear.
 * @returns El pago reci√©n creado.
 */
export const createPayment = async (data: CreatePaymentInput): Promise<Payment> => {
  return prisma.payment.create({
    data,
  });
};

/**
 * Obtiene todos los pagos de un cliente espec√≠fico.
 * @param clientId - El ID del cliente.
 * @returns Un array con todos los pagos del cliente.
 */
export const getPaymentsByClient = async (clientId: string): Promise<Payment[]> => {
  return prisma.payment.findMany({
    where: { clientId },
    orderBy: { paymentDate: 'desc' },
  });
};

/**
 * Elimina un registro de pago.
 * @param id - El ID del pago a eliminar.
 */
export const deletePayment = async (id: string): Promise<void> => {
  await prisma.payment.delete({
    where: { id },
  });
};


// ====== [76] packages/server/src/api/pool-configurations/pool-configurations.controller.ts ======
// filename: packages/server/src/api/pool-configurations/pool-configurations.controller.ts
// Version: 2.0.0 (FEAT: Pass tenantId to service for validation)

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createPoolConfiguration,
  deletePoolConfiguration,
  getConfigurationsByPool,
  updatePoolConfiguration,
} from './pool-configurations.service.js';

/**
 * Maneja la creaci√≥n de una nueva configuraci√≥n de mantenimiento.
 */
export const createPoolConfigurationHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }
    // TODO: El servicio de creaci√≥n a√∫n necesita validaci√≥n de tenantId.
    const newConfig = await createPoolConfiguration(req.body);
    res.status(201).json({ success: true, data: newConfig });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todas las configuraciones para una piscina.
 */
export const getConfigurationsByPoolHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { poolId } = req.params;
    if (!poolId) {
      return res.status(400).json({ success: false, message: 'El ID de la piscina es requerido.' });
    }
    // TODO: Validar que poolId pertenece al tenant del usuario.
    const configs = await getConfigurationsByPool(poolId);
    res.status(200).json({ success: true, data: configs });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n de una configuraci√≥n de mantenimiento.
 */
export const updatePoolConfigurationHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de configuraci√≥n o de tenant faltante.' });
    }
    
    const updatedConfig = await updatePoolConfiguration(id, tenantId, req.body);
    res.status(200).json({ success: true, data: updatedConfig });
  } catch (error) {
    next(error);
  }
};


/**
 * Maneja la eliminaci√≥n de una configuraci√≥n de mantenimiento.
 */
export const deletePoolConfigurationHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;
    
    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de configuraci√≥n o de tenant faltante.' });
    }

    await deletePoolConfiguration(id, tenantId);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [77] packages/server/src/api/pool-configurations/pool-configurations.routes.ts ======
// filename: packages/server/src/api/pool-configurations/pool-configurations.routes.ts
// Version: 1.1.0 (Add PATCH route for update functionality)
import { Router } from 'express';
import {
  createPoolConfigurationHandler,
  deletePoolConfigurationHandler,
  getConfigurationsByPoolHandler,
  updatePoolConfigurationHandler,
} from './pool-configurations.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const poolConfigurationsRouter = Router();

poolConfigurationsRouter.use(protect);

// TODO: A√±adir un middleware de autorizaci√≥n para asegurar que el rol sea 'ADMIN'.

poolConfigurationsRouter.route('/')
  .post(createPoolConfigurationHandler);

poolConfigurationsRouter.route('/by-pool/:poolId')
  .get(getConfigurationsByPoolHandler);

poolConfigurationsRouter.route('/:id')
  .patch(updatePoolConfigurationHandler) // Nueva ruta PATCH
  .delete(deletePoolConfigurationHandler);

export default poolConfigurationsRouter;


// ====== [78] packages/server/src/api/pool-configurations/pool-configurations.service.ts ======
// filename: packages/server/src/api/pool-configurations/pool-configurations.service.ts
// Version: 2.0.0 (FEAT: Add tenantId validation for CUD operations)

import { PrismaClient } from '@prisma/client';
import type { PoolConfiguration, Frequency } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreatePoolConfigurationInput = {
  poolId: string;
  frequency: Frequency;
  minThreshold?: number;
  maxThreshold?: number;
  parameterTemplateId?: string;
  taskTemplateId?: string;
};

export type UpdatePoolConfigurationInput = Partial<Omit<CreatePoolConfigurationInput, 'poolId' | 'parameterTemplateId' | 'taskTemplateId'>>;


// --- Funciones del Servicio ---

/**
 * Crea una nueva configuraci√≥n de mantenimiento para una piscina.
 */
export const createPoolConfiguration = async (
  data: CreatePoolConfigurationInput
): Promise<PoolConfiguration> => {
  if (data.parameterTemplateId && data.taskTemplateId) {
    throw new Error('Una configuraci√≥n solo puede estar asociada a un par√°metro O a una tarea, no a ambos.');
  }
  if (!data.parameterTemplateId && !data.taskTemplateId) {
    throw new Error('La configuraci√≥n debe estar asociada a un par√°metro o a una tarea.');
  }

  // TODO: A√±adir validaci√≥n para asegurar que poolId pertenece al tenant del usuario.
  return prisma.poolConfiguration.create({
    data,
  });
};

/**
 * Obtiene todas las configuraciones para una piscina espec√≠fica.
 */
export const getConfigurationsByPool = async (poolId: string): Promise<PoolConfiguration[]> => {
  return prisma.poolConfiguration.findMany({
    where: { poolId },
    include: {
      parameterTemplate: true,
      taskTemplate: true,
    },
  });
};

/**
 * Actualiza una configuraci√≥n de mantenimiento existente, verificando la pertenencia al tenant.
 * @param id - El ID de la configuraci√≥n a actualizar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 * @param data - Los datos a actualizar.
 * @returns La configuraci√≥n actualizada.
 */
export const updatePoolConfiguration = async (
  id: string,
  tenantId: string,
  data: UpdatePoolConfigurationInput
): Promise<PoolConfiguration> => {
  const { count } = await prisma.poolConfiguration.updateMany({
    where: {
      id,
      // Verificamos la pertenencia a trav√©s de la relaci√≥n con la piscina
      pool: {
        tenantId: tenantId,
      },
    },
    data,
  });

  if (count === 0) {
    throw new Error('Configuraci√≥n no encontrada o sin permisos para modificar.');
  }

  return prisma.poolConfiguration.findUniqueOrThrow({ where: { id } });
};


/**
 * Elimina una configuraci√≥n de mantenimiento de una piscina, verificando la pertenencia al tenant.
 * @param id - El ID de la configuraci√≥n a eliminar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 */
export const deletePoolConfiguration = async (id: string, tenantId: string): Promise<void> => {
  const { count } = await prisma.poolConfiguration.deleteMany({
    where: {
      id,
      // Verificamos la pertenencia a trav√©s de la relaci√≥n con la piscina
      pool: {
        tenantId: tenantId,
      },
    },
  });

  if (count === 0) {
    throw new Error('Configuraci√≥n no encontrada o sin permisos para eliminar.');
  }
};


// ====== [79] packages/server/src/api/pools/pools.controller.ts ======
// filename: packages/server/src/api/pools/pools.controller.ts
// Version: 2.0.0 (FEAT: Pass tenantId to service for validation)

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { createPool, deletePool, updatePool } from './pools.service.js';

/**
 * Maneja la creaci√≥n de una nueva piscina.
 */
export const createPoolHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }

    // Aseguramos que la piscina se asigne al tenant del usuario.
    const input = { ...req.body, tenantId };
    const newPool = await createPool(input);
    res.status(201).json({ success: true, data: newPool });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n de una piscina.
 */
export const updatePoolHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de piscina o de tenant faltante.' });
    }

    const updatedPool = await updatePool(id, tenantId, req.body);
    res.status(200).json({ success: true, data: updatedPool });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de una piscina.
 */
export const deletePoolHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de piscina o de tenant faltante.' });
    }

    await deletePool(id, tenantId);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [80] packages/server/src/api/pools/pools.routes.ts ======
// filename: packages/server/src/api/pools/pools.routes.ts
// Version: 2.0.0 (FEAT: Protect routes with ADMIN authorization)

import { Router } from 'express';
import {
  createPoolHandler,
  deletePoolHandler,
  updatePoolHandler,
} from './pools.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const poolsRouter = Router();

// Aplicamos la protecci√≥n en dos niveles a TODAS las rutas de este enrutador:
// 1. `protect`: Asegura que el usuario est√© autenticado.
// 2. `authorize('ADMIN')`: Asegura que el usuario autenticado tenga el rol de ADMIN.
poolsRouter.use(protect, authorize('ADMIN'));


// No hay una ruta GET / aqu√≠ porque las piscinas se obtienen
// a trav√©s de la ruta del cliente (/api/clients/:id) para mantener el contexto.
poolsRouter.route('/')
  .post(createPoolHandler);

poolsRouter.route('/:id')
  .patch(updatePoolHandler)
  .delete(deletePoolHandler);

export default poolsRouter;


// ====== [81] packages/server/src/api/pools/pools.service.ts ======
// filename: packages/server/src/api/pools/pools.service.ts
// Version: 2.0.0 (FEAT: Add tenantId validation for CUD operations)

import { PrismaClient } from '@prisma/client';
import type { Pool } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreatePoolInput = Omit<Pool, 'id' | 'qrCode' | 'createdAt' | 'updatedAt'>;
export type UpdatePoolInput = Partial<Omit<CreatePoolInput, 'tenantId'>>;

// --- Funciones del Servicio ---

/**
 * Crea una nueva piscina para un cliente y tenant espec√≠ficos.
 * @param data - Datos de la nueva piscina.
 * @returns La piscina creada.
 */
export const createPool = async (data: CreatePoolInput): Promise<Pool> => {
  return prisma.pool.create({
    data,
  });
};

/**
 * Actualiza una piscina existente, verificando la pertenencia al tenant.
 * @param id - El ID de la piscina a actualizar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 * @param data - Los datos a actualizar.
 * @returns La piscina actualizada.
 */
export const updatePool = async (id: string, tenantId: string, data: UpdatePoolInput): Promise<Pool> => {
  // Primero, verificamos que la piscina pertenece al tenant.
  // Esto es un paso extra de seguridad antes de la actualizaci√≥n.
  const poolExists = await prisma.pool.findFirst({
    where: { id, tenantId },
  });

  if (!poolExists) {
    throw new Error('Piscina no encontrada o sin permisos para modificar.');
  }

  return prisma.pool.update({
    where: { id },
    data,
  });
};

/**
 * Elimina una piscina, verificando la pertenencia al tenant.
 * @param id - El ID de la piscina a eliminar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 */
export const deletePool = async (id: string, tenantId: string): Promise<void> => {
  // Utilizamos deleteMany con una cl√°usula where para asegurar la pertenencia al tenant.
  const { count } = await prisma.pool.deleteMany({
    where: {
      id,
      tenantId, // <-- Condici√≥n de seguridad
    },
  });

  if (count === 0) {
    throw new Error('Piscina no encontrada o sin permisos para eliminar.');
  }
};


// ====== [82] packages/server/src/api/product-categories/product-categories.controller.ts ======
// filename: packages/server/src/api/product-categories/product-categories.controller.ts
// version: 2.0.0 (FEAT: Pass tenantId to service for validation)

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createProductCategory,
  getProductCategoriesByTenant,
  updateProductCategory,
  deleteProductCategory,
} from './product-categories.service.js';

/**
 * Maneja la creaci√≥n de una nueva categor√≠a de producto.
 */
export const createProductCategoryHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }

    const input = { ...req.body, tenantId };
    const newCategory = await createProductCategory(input);
    res.status(201).json({ success: true, data: newCategory });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todas las categor√≠as de un tenant.
 */
export const getProductCategoriesHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }

    const categories = await getProductCategoriesByTenant(tenantId);
    res.status(200).json({ success: true, data: categories });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n de una categor√≠a de producto.
 */
export const updateProductCategoryHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de categor√≠a o de tenant faltante.' });
    }
    
    const updatedCategory = await updateProductCategory(id, tenantId, req.body);
    res.status(200).json({ success: true, data: updatedCategory });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de una categor√≠a de producto.
 */
export const deleteProductCategoryHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de categor√≠a o de tenant faltante.' });
    }

    await deleteProductCategory(id, tenantId);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [83] packages/server/src/api/product-categories/product-categories.routes.ts ======
// filename: packages/server/src/api/product-categories/product-categories.routes.ts
// version: 2.0.0 (FEAT: Protect routes with ADMIN authorization)

import { Router } from 'express';
import {
  createProductCategoryHandler,
  getProductCategoriesHandler,
  updateProductCategoryHandler,
  deleteProductCategoryHandler,
} from './product-categories.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const productCategoriesRouter = Router();

// Protegemos todas las rutas de este m√≥dulo.
// Solo usuarios autenticados con rol de ADMIN podr√°n acceder.
productCategoriesRouter.use(protect, authorize('ADMIN'));

// Rutas para /api/product-categories
productCategoriesRouter.route('/')
  .get(getProductCategoriesHandler)   // GET /api/product-categories
  .post(createProductCategoryHandler); // POST /api/product-categories

// Rutas para /api/product-categories/:id
productCategoriesRouter.route('/:id')
  .patch(updateProductCategoryHandler)  // PATCH /api/product-categories/:id
  .delete(deleteProductCategoryHandler); // DELETE /api/product-categories/:id

export default productCategoriesRouter;


// ====== [84] packages/server/src/api/product-categories/product-categories.service.ts ======
// filename: packages/server/src/api/product-categories/product-categories.service.ts
// version: 2.0.0 (FEAT: Add tenantId validation for CUD operations)

import { PrismaClient } from '@prisma/client';
import type { ProductCategory } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateProductCategoryInput = {
  name: string;
  tenantId: string;
};

export type UpdateProductCategoryInput = Partial<Omit<CreateProductCategoryInput, 'tenantId'>>;

/**
 * Crea una nueva categor√≠a de producto para un tenant.
 * @param data - Los datos de la categor√≠a a crear.
 * @returns La categor√≠a reci√©n creada.
 */
export const createProductCategory = async (data: CreateProductCategoryInput): Promise<ProductCategory> => {
  return prisma.productCategory.create({
    data,
  });
};

/**
 * Obtiene todas las categor√≠as de productos de un tenant.
 * @param tenantId - El ID del tenant.
 * @returns Un array con todas las categor√≠as, ordenadas por nombre.
 */
export const getProductCategoriesByTenant = async (tenantId: string): Promise<ProductCategory[]> => {
  return prisma.productCategory.findMany({
    where: { tenantId },
    orderBy: { name: 'asc' },
  });
};

/**
 * Actualiza una categor√≠a de producto existente, verificando la pertenencia al tenant.
 * @param id - El ID de la categor√≠a a actualizar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 * @param data - Los datos a modificar.
 * @returns La categor√≠a actualizada.
 */
export const updateProductCategory = async (id: string, tenantId: string, data: UpdateProductCategoryInput): Promise<ProductCategory> => {
  const { count } = await prisma.productCategory.updateMany({
    where: {
      id,
      tenantId, // <-- Condici√≥n de seguridad
    },
    data,
  });

  if (count === 0) {
    throw new Error('Categor√≠a no encontrada o sin permisos para modificar.');
  }

  return prisma.productCategory.findUniqueOrThrow({ where: { id } });
};

/**
 * Elimina una categor√≠a de producto, verificando la pertenencia al tenant.
 * @param id - El ID de la categor√≠a a eliminar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 */
export const deleteProductCategory = async (id: string, tenantId: string): Promise<void> => {
  const { count } = await prisma.productCategory.deleteMany({
    where: {
      id,
      tenantId, // <-- Condici√≥n de seguridad
    },
  });

  if (count === 0) {
    throw new Error('Categor√≠a no encontrada o sin permisos para eliminar.');
  }
};


// ====== [85] packages/server/src/api/products/products.controller.ts ======
// filename: packages/server/src/api/products/products.controller.ts
// version: 2.0.0 (FEAT: Pass tenantId to service for validation)

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createProduct,
  getProductsByTenant,
  updateProduct,
  deleteProduct,
} from './products.service.js';

/**
 * Maneja la creaci√≥n de un nuevo producto.
 */
export const createProductHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }

    const input = { ...req.body, tenantId };
    const newProduct = await createProduct(input);
    res.status(201).json({ success: true, data: newProduct });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todos los productos de un tenant.
 */
export const getProductsHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }

    const products = await getProductsByTenant(tenantId);
    res.status(200).json({ success: true, data: products });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n de un producto.
 */
export const updateProductHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de producto o de tenant faltante.' });
    }
    
    // Pasamos el tenantId al servicio para la validaci√≥n de pertenencia.
    const updatedProduct = await updateProduct(id, tenantId, req.body);
    res.status(200).json({ success: true, data: updatedProduct });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de un producto.
 */
export const deleteProductHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;
    
    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de producto o de tenant faltante.' });
    }

    // Pasamos el tenantId al servicio para la validaci√≥n de pertenencia.
    await deleteProduct(id, tenantId);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [86] packages/server/src/api/products/products.routes.ts ======
// filename: packages/server/src/api/products/products.routes.ts
// version: 2.0.0 (FEAT: Protect routes with ADMIN authorization)

import { Router } from 'express';
import {
  createProductHandler,
  getProductsHandler,
  updateProductHandler,
  deleteProductHandler,
} from './products.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const productsRouter = Router();

// Aplicamos el middleware `protect` y `authorize` a todas las rutas de este enrutador.
// Solo los usuarios autenticados con rol de ADMIN podr√°n interactuar con el cat√°logo de productos.
productsRouter.use(protect, authorize('ADMIN'));

// Definimos las rutas para el recurso /api/products
productsRouter.route('/')
  .get(getProductsHandler)      // GET /api/products -> Obtiene todos los productos
  .post(createProductHandler);   // POST /api/products -> Crea un nuevo producto

// Definimos las rutas para un recurso espec√≠fico /api/products/:id
productsRouter.route('/:id')
  .patch(updateProductHandler)  // PATCH /api/products/:id -> Actualiza un producto
  .delete(deleteProductHandler); // DELETE /api/products/:id -> Elimina un producto

export default productsRouter;


// ====== [87] packages/server/src/api/products/products.service.ts ======
// filename: packages/server/src/api/products/products.service.ts
// version: 2.0.0 (FEAT: Add tenantId validation for CUD operations)

import { PrismaClient } from '@prisma/client';
import type { Product } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) para la creaci√≥n y actualizaci√≥n ---
export type CreateProductInput = Omit<Product, 'id' | 'createdAt' | 'updatedAt' | 'consumptions'>;
export type UpdateProductInput = Partial<Omit<CreateProductInput, 'tenantId'>>;

/**
 * Crea un nuevo producto para un tenant espec√≠fico.
 * @param data - Los datos del producto a crear.
 * @returns El producto reci√©n creado.
 */
export const createProduct = async (data: CreateProductInput): Promise<Product> => {
  return prisma.product.create({
    data,
  });
};

/**
 * Obtiene todos los productos de un tenant espec√≠fico.
 * @param tenantId - El ID del tenant.
 * @returns Un array con todos los productos del tenant, ordenados por nombre.
 */
export const getProductsByTenant = async (tenantId: string): Promise<Product[]> => {
  return prisma.product.findMany({
    where: { tenantId },
    orderBy: { name: 'asc' },
  });
};

/**
 * Actualiza un producto existente, verificando la pertenencia al tenant.
 * @param id - El ID del producto a actualizar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 * @param data - Los datos a modificar.
 * @returns El producto actualizado.
 */
export const updateProduct = async (id: string, tenantId: string, data: UpdateProductInput): Promise<Product> => {
  const { count } = await prisma.product.updateMany({
    where: {
      id,
      tenantId, // <-- La condici√≥n de seguridad clave
    },
    data,
  });

  if (count === 0) {
    throw new Error('Producto no encontrado o sin permisos para modificar.');
  }

  // Devolvemos el producto actualizado para mantener la consistencia de la API
  return prisma.product.findUniqueOrThrow({ where: { id } });
};

/**
 * Elimina un producto, verificando la pertenencia al tenant.
 * La operaci√≥n fallar√° si el producto ya ha sido usado en alg√∫n registro de consumo.
 * @param id - El ID del producto a eliminar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 */
export const deleteProduct = async (id: string, tenantId: string): Promise<void> => {
  const { count } = await prisma.product.deleteMany({
    where: {
      id,
      tenantId, // <-- La condici√≥n de seguridad clave
    },
  });

  if (count === 0) {
    throw new Error('Producto no encontrado o sin permisos para eliminar.');
  }
};


// ====== [88] packages/server/src/api/reports/reports.controller.ts ======
// filename: packages/server/src/api/reports/reports.controller.ts
// version: 1.2.0 (FEAT: Add handler for invoicing report)

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
// --- 1. Importar la nueva funci√≥n del servicio ---
import { generateConsumptionReport, getConsumptionDetailsForProduct, generateInvoicingReport } from './reports.service.js';

/**
 * Maneja la petici√≥n para generar y devolver un informe de consumo (costes).
 */
export const getConsumptionReportHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida. Tenant no identificado.' });
    }

    const { startDate: startDateStr, endDate: endDateStr, clientId } = req.query;

    if (!startDateStr || !endDateStr || typeof startDateStr !== 'string' || typeof endDateStr !== 'string') {
      return res.status(400).json({ success: false, message: 'Los par√°metros startDate y endDate son obligatorios.' });
    }

    const startDate = new Date(startDateStr);
    const endDate = new Date(endDateStr);

    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
      return res.status(400).json({ success: false, message: 'El formato de las fechas no es v√°lido.' });
    }

    const report = await generateConsumptionReport({
      tenantId,
      startDate,
      endDate,
      clientId: typeof clientId === 'string' ? clientId : undefined,
    });

    res.status(200).json({ success: true, data: report });

  } catch (error) {
    next(error);
  }
};


/**
 * Maneja la petici√≥n para obtener el detalle de las visitas donde se consumi√≥ un producto.
 */
export const getProductConsumptionDetailHandler = async (
    req: AuthRequest,
    res: Response,
    next: NextFunction
) => {
    try {
        const tenantId = req.user?.tenantId;
        if (!tenantId) {
            return res.status(403).json({ success: false, message: 'Acci√≥n no permitida. Tenant no identificado.' });
        }

        const { startDate: startDateStr, endDate: endDateStr, clientId, productId } = req.query;

        if (!startDateStr || !endDateStr || !clientId || !productId || 
            typeof startDateStr !== 'string' || typeof endDateStr !== 'string' ||
            typeof clientId !== 'string' || typeof productId !== 'string') {
            return res.status(400).json({ success: false, message: 'Los par√°metros startDate, endDate, clientId y productId son obligatorios.' });
        }

        const startDate = new Date(startDateStr);
        const endDate = new Date(endDateStr);

        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
            return res.status(400).json({ success: false, message: 'El formato de las fechas no es v√°lido.' });
        }

        const details = await getConsumptionDetailsForProduct({
            tenantId,
            startDate,
            endDate,
            clientId,
            productId,
        });

        res.status(200).json({ success: true, data: details });

    } catch (error) {
        next(error);
    }
};

/**
 * --- ‚úÖ 2. NUEVO MANEJADOR ---
 * Maneja la petici√≥n para generar y devolver un informe de pre-facturaci√≥n.
 */
export const getInvoicingReportHandler = async (
    req: AuthRequest,
    res: Response,
    next: NextFunction
) => {
    try {
        const tenantId = req.user?.tenantId;
        if (!tenantId) {
            return res.status(403).json({ success: false, message: 'Acci√≥n no permitida. Tenant no identificado.' });
        }

        const { startDate: startDateStr, endDate: endDateStr, clientId } = req.query;

        if (!startDateStr || !endDateStr || typeof startDateStr !== 'string' || typeof endDateStr !== 'string') {
            return res.status(400).json({ success: false, message: 'Los par√°metros startDate y endDate son obligatorios.' });
        }

        const startDate = new Date(startDateStr);
        const endDate = new Date(endDateStr);

        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
            return res.status(400).json({ success: false, message: 'El formato de las fechas no es v√°lido.' });
        }

        const report = await generateInvoicingReport({
            tenantId,
            startDate,
            endDate,
            clientId: typeof clientId === 'string' ? clientId : undefined,
        });

        res.status(200).json({ success: true, data: report });

    } catch (error) {
        next(error);
    }
};


// ====== [89] packages/server/src/api/reports/reports.routes.ts ======
// filename: packages/server/src/api/reports/reports.routes.ts
// version: 2.0.0 (FEAT: Protect routes with ADMIN/MANAGER authorization)

import { Router } from 'express';
import { 
    getConsumptionReportHandler, 
    getProductConsumptionDetailHandler,
    getInvoicingReportHandler 
} from './reports.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const reportsRouter = Router();

// Aplicamos la protecci√≥n en dos niveles a todas las rutas de informes:
// 1. `protect`: Asegura que el usuario est√© autenticado.
// 2. `authorize('ADMIN', 'MANAGER')`: Asegura que el usuario sea Admin o Manager.
reportsRouter.use(protect, authorize('ADMIN', 'MANAGER'));

/**
 * @route   GET /api/reports/consumption
 * @desc    Genera y devuelve un informe detallado de consumo de productos (costes).
 * @access  Private (Admin, Manager)
 */
reportsRouter.get('/consumption', getConsumptionReportHandler);

/**
 * @route   GET /api/reports/consumption/details
 * @desc    Obtiene el detalle de visitas donde se consumi√≥ un producto espec√≠fico.
 * @access  Private (Admin, Manager)
 */
reportsRouter.get('/consumption/details', getProductConsumptionDetailHandler);

/**
 * @route   GET /api/reports/invoicing
 * @desc    Genera un informe de pre-facturaci√≥n con precios de venta y cuotas.
 * @access  Private (Admin, Manager)
 */
reportsRouter.get('/invoicing', getInvoicingReportHandler);

export default reportsRouter;


// ====== [90] packages/server/src/api/reports/reports.service.ts ======
// filename: packages/server/src/api/reports/reports.service.ts
// version: 1.3.1 (FIXED: Correct relation name in generateInvoicingReport to match schema)
// description: Se ha corregido el nombre de la relaci√≥n a 'clientPricingRules' en la funci√≥n del informe de facturaci√≥n.

import { PrismaClient } from '@prisma/client';
import type { ClientProductPricing } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Datos (Interfaces) ---

interface ReportFilters {
  tenantId: string;
  startDate: Date;
  endDate: Date;
  clientId?: string;
}

interface ConsumptionReport {
  summary: {
    totalCost: number;
    totalVisits: number;
  };
  byClient: {
    clientId: string;
    clientName: string;
    totalClientCost: number;
    visitCount: number;
    detailedConsumption: {
      productId: string;
      productName: string;
      unit: string;
      totalQuantity: number;
      totalCost: number;
    }[];
  }[];
}

interface DetailFilters extends ReportFilters {
    productId: string;
    clientId: string;
}

export interface ProductConsumptionDetail {
    visitId: string;
    visitDate: Date;
    quantity: number;
    cost: number;
    technicianName: string | null;
}

export interface InvoicingReport {
  summary: {
    totalToInvoice: number;
    totalFees: number;
    totalMaterials: number;
  };
  byClient: {
    clientId: string;
    clientName: string;
    billingModel: string;
    monthlyFee: number;
    materialsSubtotal: number;
    totalToInvoice: number;
    billedConsumption: {
      productId: string;
      productName: string;
      unit: string;
      totalQuantity: number;
      salePrice: number;
      totalLine: number;
    }[];
  }[];
}


// --- Funciones de Servicio ---

export const generateConsumptionReport = async (filters: ReportFilters): Promise<ConsumptionReport> => {
  const { tenantId, startDate, endDate, clientId } = filters;

  const consumptions = await prisma.consumption.findMany({
    where: {
      visit: {
        pool: {
          tenantId: tenantId,
          clientId: clientId ? clientId : undefined,
        },
        timestamp: {
          gte: startDate,
          lte: endDate,
        },
      },
    },
    include: {
      product: true,
      visit: { include: { pool: { include: { client: true } } } },
    },
  });
  
  const reportData: Record<string, any> = {};
  let overallTotalCost = 0;
  const visitedVisits = new Set<string>();

  for (const consumption of consumptions) {
    if (!consumption.visit || !consumption.visit.pool || !consumption.visit.pool.client) continue;
    
    const client = consumption.visit.pool.client;
    const product = consumption.product;
    const itemCost = consumption.quantity * product.cost;

    overallTotalCost += itemCost;
    visitedVisits.add(consumption.visitId);

    if (!reportData[client.id]) {
      reportData[client.id] = {
        clientId: client.id,
        clientName: client.name,
        totalClientCost: 0,
        visitCount: new Set<string>(),
        detailedConsumption: {},
      };
    }
    
    reportData[client.id].totalClientCost += itemCost;
    reportData[client.id].visitCount.add(consumption.visitId);
    
    const detailedConsumption = reportData[client.id].detailedConsumption;
    if (!detailedConsumption[product.id]) {
      detailedConsumption[product.id] = {
        productId: product.id,
        productName: product.name,
        unit: product.unit,
        totalQuantity: 0,
        totalCost: 0,
      };
    }
    
    detailedConsumption[product.id].totalQuantity += consumption.quantity;
    detailedConsumption[product.id].totalCost += itemCost;
  }
  
  const byClientArray = Object.values(reportData).map(clientData => ({
    ...clientData,
    visitCount: clientData.visitCount.size,
    detailedConsumption: Object.values(clientData.detailedConsumption),
  }));
  
  return {
    summary: {
      totalCost: overallTotalCost,
      totalVisits: visitedVisits.size,
    },
    byClient: byClientArray,
  };
};

export const getConsumptionDetailsForProduct = async (filters: DetailFilters): Promise<ProductConsumptionDetail[]> => {
    const { tenantId, startDate, endDate, clientId, productId } = filters;

    const consumptions = await prisma.consumption.findMany({
        where: {
            productId,
            visit: {
                pool: { clientId, tenantId },
                timestamp: { gte: startDate, lte: endDate }
            }
        },
        include: {
            product: true,
            visit: { include: { technician: { select: { name: true } } } }
        },
        orderBy: { visit: { timestamp: 'desc' } }
    });

    return consumptions.map(c => ({
        visitId: c.visitId,
        visitDate: c.visit.timestamp,
        quantity: c.quantity,
        cost: c.quantity * c.product.cost,
        technicianName: c.visit.technician?.name ?? 'No asignado',
    }));
};

export const generateInvoicingReport = async (filters: ReportFilters): Promise<InvoicingReport> => {
    const { tenantId, startDate, endDate, clientId } = filters;

    const clients = await prisma.client.findMany({
        where: {
            tenantId,
            id: clientId ? clientId : undefined,
        },
        // ‚úÖ CORRECCI√ìN APLICADA AQU√ç
        include: {
            clientPricingRules: true, 
        },
    });

    const consumptions = await prisma.consumption.findMany({
        where: {
            visit: {
                pool: { tenantId, clientId: clientId ? clientId : undefined },
                timestamp: { gte: startDate, lte: endDate },
            },
        },
        include: {
            product: true,
            visit: { include: { pool: true } },
        },
    });

    const report: InvoicingReport = {
        summary: { totalToInvoice: 0, totalFees: 0, totalMaterials: 0 },
        byClient: [],
    };

    for (const client of clients) {
        const clientReport = {
            clientId: client.id,
            clientName: client.name,
            billingModel: client.billingModel,
            monthlyFee: client.monthlyFee,
            materialsSubtotal: 0,
            totalToInvoice: client.monthlyFee,
            billedConsumption: [] as InvoicingReport['byClient'][0]['billedConsumption'],
        };
        
        report.summary.totalFees += client.monthlyFee;

        if (client.billingModel === 'ALL_INCLUSIVE') {
            report.summary.totalToInvoice += client.monthlyFee;
            report.byClient.push(clientReport);
            continue;
        }

        const clientConsumptions = consumptions.filter(c => c.visit.pool.clientId === client.id);

        for (const consumption of clientConsumptions) {
            const product = consumption.product;
            let finalSalePrice = product.salePrice;

            // ‚úÖ CORRECCI√ìN APLICADA AQU√ç
            const productRule = client.clientPricingRules.find((r: ClientProductPricing) => r.productId === product.id);
            const categoryRule = client.clientPricingRules.find((r: ClientProductPricing) => r.productCategoryId === product.categoryId);

            if (productRule) {
                finalSalePrice *= (1 - productRule.discountPercentage / 100);
            } else if (categoryRule) {
                finalSalePrice *= (1 - categoryRule.discountPercentage / 100);
            } else {
                finalSalePrice *= client.priceModifier;
            }
            
            const lineTotal = consumption.quantity * finalSalePrice;
            clientReport.materialsSubtotal += lineTotal;

            const existingBilledItem = clientReport.billedConsumption.find(item => item.productId === product.id);
            if (existingBilledItem) {
                existingBilledItem.totalQuantity += consumption.quantity;
                existingBilledItem.totalLine += lineTotal;
            } else {
                clientReport.billedConsumption.push({
                    productId: product.id,
                    productName: product.name,
                    unit: product.unit,
                    totalQuantity: consumption.quantity,
                    salePrice: finalSalePrice,
                    totalLine: lineTotal,
                });
            }
        }
        
        clientReport.totalToInvoice += clientReport.materialsSubtotal;
        report.summary.totalMaterials += clientReport.materialsSubtotal;
        report.byClient.push(clientReport);
    }
    
    report.summary.totalToInvoice = report.summary.totalFees + report.summary.totalMaterials;

    return report;
};


// ====== [91] packages/server/src/api/tasks/tasks.controller.ts ======
// filename: packages/server/src/api/tasks/tasks.controller.ts
// Version: 2.0.0 (FEAT: Pass tenantId to service for validation)

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createTaskTemplate,
  deleteTaskTemplate,
  getTaskTemplatesByTenant,
  updateTaskTemplate,
} from './tasks.service.js';

/**
 * Maneja la creaci√≥n de una nueva plantilla de tarea.
 */
export const createTaskTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }

    const input = { ...req.body, tenantId };
    const newTemplate = await createTaskTemplate(input);
    res.status(201).json({ success: true, data: newTemplate });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todas las plantillas de tareas de un tenant.
 */
export const getTaskTemplatesByTenantHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }

    const templates = await getTaskTemplatesByTenant(tenantId);
    res.status(200).json({ success: true, data: templates });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n de una plantilla de tarea.
 */
export const updateTaskTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de plantilla o de tenant faltante.' });
    }
    
    const updatedTemplate = await updateTaskTemplate(id, tenantId, req.body);
    res.status(200).json({ success: true, data: updatedTemplate });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de una plantilla de tarea.
 */
export const deleteTaskTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de plantilla o de tenant faltante.' });
    }

    await deleteTaskTemplate(id, tenantId);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [92] packages/server/src/api/tasks/tasks.routes.ts ======
// filename: packages/server/src/api/tasks/tasks.routes.ts
// Version: 2.0.0 (FEAT: Protect routes with ADMIN authorization)

import { Router } from 'express';
import {
  createTaskTemplateHandler,
  deleteTaskTemplateHandler,
  getTaskTemplatesByTenantHandler,
  updateTaskTemplateHandler,
} from './tasks.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const tasksRouter = Router();

// Aplicamos la protecci√≥n y autorizaci√≥n a todas las rutas de este fichero.
// Solo los usuarios autenticados con rol de ADMIN pueden gestionar el cat√°logo.
tasksRouter.use(protect, authorize('ADMIN'));

tasksRouter.route('/')
  .get(getTaskTemplatesByTenantHandler)
  .post(createTaskTemplateHandler);

tasksRouter.route('/:id')
  .patch(updateTaskTemplateHandler)
  .delete(deleteTaskTemplateHandler);

export default tasksRouter;


// ====== [93] packages/server/src/api/tasks/tasks.service.ts ======
// filename: packages/server/src/api/tasks/tasks.service.ts
// Version: 2.0.0 (FEAT: Add tenantId validation for CUD operations)

import { PrismaClient } from '@prisma/client';
import type { ScheduledTaskTemplate } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateTaskTemplateInput = {
  name: string;
  tenantId: string; // Cada plantilla pertenece a un tenant
  description?: string;
};

export type UpdateTaskTemplateInput = Partial<Omit<CreateTaskTemplateInput, 'tenantId'>>;

// --- Funciones del Servicio ---

/**
 * Crea una nueva plantilla de tarea para un tenant espec√≠fico.
 * @param input - Datos de la nueva plantilla.
 * @returns La plantilla de tarea creada.
 */
export const createTaskTemplate = async (
  input: CreateTaskTemplateInput
): Promise<ScheduledTaskTemplate> => {
  return prisma.scheduledTaskTemplate.create({
    data: input,
  });
};

/**
 * Obtiene todas las plantillas de tareas para un tenant espec√≠fico.
 * @param tenantId - El ID del tenant.
 * @returns Un array de plantillas de tareas.
 */
export const getTaskTemplatesByTenant = async (
  tenantId: string
): Promise<ScheduledTaskTemplate[]> => {
  return prisma.scheduledTaskTemplate.findMany({
    where: { tenantId },
    orderBy: { name: 'asc' },
  });
};

/**
 * Actualiza una plantilla de tarea existente, verificando la pertenencia al tenant.
 * @param id - El ID de la plantilla a actualizar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 * @param data - Los datos a actualizar.
 * @returns La plantilla de tarea actualizada.
 */
export const updateTaskTemplate = async (
  id: string,
  tenantId: string,
  data: UpdateTaskTemplateInput
): Promise<ScheduledTaskTemplate> => {
  const { count } = await prisma.scheduledTaskTemplate.updateMany({
    where: {
      id,
      tenantId, // <-- Condici√≥n de seguridad
    },
    data,
  });

  if (count === 0) {
    throw new Error('Plantilla de tarea no encontrada o sin permisos para modificar.');
  }

  return prisma.scheduledTaskTemplate.findUniqueOrThrow({ where: { id } });
};

/**
 * Elimina una plantilla de tarea, verificando la pertenencia al tenant.
 * @param id - El ID de la plantilla a eliminar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 */
export const deleteTaskTemplate = async (
  id: string,
  tenantId: string,
): Promise<void> => {
  // TODO: A√±adir l√≥gica para verificar que esta plantilla no est√° siendo
  // usada en ninguna PoolConfiguration antes de permitir el borrado.
  const { count } = await prisma.scheduledTaskTemplate.deleteMany({
    where: {
      id,
      tenantId, // <-- Condici√≥n de seguridad
    },
  });

  if (count === 0) {
    throw new Error('Plantilla de tarea no encontrada o sin permisos para eliminar.');
  }
};


// ====== [94] packages/server/src/api/tenants/tenants.controller.ts ======
import type { Request, Response, NextFunction } from 'express';
import {
  createTenant,
  getAllTenants,
  getTenantById,
  updateTenantStatus,
  deleteTenant,
} from './tenants.service.js';

/**
 * Maneja la creaci√≥n de un nuevo tenant.
 */
export const createTenantHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenant = await createTenant(req.body);
    res.status(201).json({ success: true, data: tenant });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todos los tenants.
 */
export const getAllTenantsHandler = async (
  _req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenants = await getAllTenants();
    res.status(200).json({ success: true, data: tenants });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de un tenant por su ID.
 */
export const getTenantByIdHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID del tenant es requerido.' });
    }

    const tenant = await getTenantById(id);

    if (!tenant) {
      const error: any = new Error('Tenant no encontrado.');
      error.statusCode = 404;
      return next(error);
    }

    res.status(200).json({ success: true, data: tenant });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n del estado de un tenant.
 */
export const updateTenantStatusHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID del tenant es requerido.' });
    }

    const { status } = req.body;
    // TODO: A√±adir validaci√≥n para asegurar que 'status' es un valor v√°lido del enum SubscriptionStatus

    const updatedTenant = await updateTenantStatus(id, status);
    res.status(200).json({ success: true, data: updatedTenant });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de un tenant.
 */
export const deleteTenantHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID del tenant es requerido.' });
    }

    await deleteTenant(id);

    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [95] packages/server/src/api/tenants/tenants.routes.ts ======
// filename: packages/server/src/api/tenants/tenants.routes.ts
// version: 2.0.0 (FEAT: Protect routes with SUPER_ADMIN authorization)

import { Router } from 'express';
import {
  createTenantHandler,
  getAllTenantsHandler,
  getTenantByIdHandler,
  updateTenantStatusHandler,
  deleteTenantHandler,
} from './tenants.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const tenantsRouter = Router();

// Aplicamos la protecci√≥n en dos niveles a TODAS las rutas de este enrutador:
// 1. `protect`: Asegura que el usuario est√© autenticado.
// 2. `authorize('SUPER_ADMIN')`: Asegura que el usuario autenticado tenga el rol de SUPER_ADMIN.
tenantsRouter.use(protect, authorize('SUPER_ADMIN'));


/**
 * @route   GET /api/tenants
 * @desc    Obtiene todos los tenants
 * @access  Private (SuperAdmin)
 */
tenantsRouter.get('/', getAllTenantsHandler);

/**
 * @route   POST /api/tenants
 * @desc    Crea un nuevo tenant y su primer usuario admin
 * @access  Private (SuperAdmin)
 */
tenantsRouter.post('/', createTenantHandler);

/**
 * @route   GET /api/tenants/:id
 * @desc    Obtiene un tenant espec√≠fico por su ID
 * @access  Private (SuperAdmin)
 */
tenantsRouter.get('/:id', getTenantByIdHandler);

/**
 * @route   PATCH /api/tenants/:id/status
 * @desc    Actualiza el estado de la suscripci√≥n de un tenant
 * @access  Private (SuperAdmin)
 */
tenantsRouter.patch('/:id/status', updateTenantStatusHandler);

/**
 * @route   DELETE /api/tenants/:id
 * @desc    Elimina un tenant y toda su informaci√≥n asociada
 * @access  Private (SuperAdmin)
 */
tenantsRouter.delete('/:id', deleteTenantHandler);

export default tenantsRouter;


// ====== [96] packages/server/src/api/tenants/tenants.service.ts ======
import { PrismaClient } from '@prisma/client';
import type { Tenant, SubscriptionStatus } from '@prisma/client';
import { hashPassword } from '../../utils/password.utils.js';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
type AdminUserInput = {
  name: string;
  email: string;
  password: string;
};

export type CreateTenantInput = {
  companyName: string;
  subdomain: string;
  adminUser: AdminUserInput;
};

// --- Funciones del Servicio ---

/**
 * Crea un nuevo Tenant y su primer usuario Administrador de forma at√≥mica.
 * @param input - Datos para el nuevo tenant y su admin.
 * @returns El objeto del Tenant reci√©n creado.
 */
export const createTenant = async (input: CreateTenantInput): Promise<Tenant> => {
  const { companyName, subdomain, adminUser } = input;

  const newTenant = await prisma.$transaction(async (tx) => {
    const existingSubdomain = await tx.tenant.findUnique({ where: { subdomain } });
    if (existingSubdomain) {
      throw new Error('El subdominio ya est√° en uso.');
    }

    const existingEmail = await tx.user.findUnique({ where: { email: adminUser.email } });
    if (existingEmail) {
      throw new Error('El correo electr√≥nico ya est√° en uso por otro usuario.');
    }

    const tenant = await tx.tenant.create({
      data: {
        companyName,
        subdomain,
      },
    });

    const hashedPassword = await hashPassword(adminUser.password);
    await tx.user.create({
      data: {
        name: adminUser.name,
        email: adminUser.email,
        password: hashedPassword,
        role: 'ADMIN',
        tenantId: tenant.id,
      },
    });

    return tenant;
  });

  return newTenant;
};

/**
 * Obtiene un listado de todos los tenants.
 * @returns Un array de todos los tenants.
 */
export const getAllTenants = async (): Promise<Tenant[]> => {
  return prisma.tenant.findMany({
    orderBy: {
      createdAt: 'desc',
    },
  });
};

/**
 * Busca un tenant espec√≠fico por su ID.
 * @param id - El ID del tenant a buscar.
 * @returns El objeto del tenant o null si no se encuentra.
 */
export const getTenantById = async (id: string): Promise<Tenant | null> => {
  return prisma.tenant.findUnique({
    where: { id },
  });
};

/**
 * Actualiza el estado de la suscripci√≥n de un tenant.
 * @param id - El ID del tenant a actualizar.
 * @param status - El nuevo estado de la suscripci√≥n.
 * @returns El objeto del tenant actualizado.
 */
export const updateTenantStatus = async (
  id: string,
  status: SubscriptionStatus
): Promise<Tenant> => {
  return prisma.tenant.update({
    where: { id },
    data: {
      subscriptionStatus: status,
    },
  });
};

/**
 * Elimina un tenant y toda su informaci√≥n asociada (cascade).
 * @param id - El ID del tenant a eliminar.
 * @returns El objeto del tenant que fue eliminado.
 */
export const deleteTenant = async (id: string): Promise<Tenant> => {
  // Gracias a 'onDelete: Cascade' en el schema, al borrar un tenant,
  // se borrar√°n en cascada todos sus usuarios, clientes, piscinas, etc.
  return prisma.tenant.delete({
    where: { id },
  });
};


// ====== [97] packages/server/src/api/uploads/uploads.controller.ts ======
// filename: packages/server/src/api/uploads/uploads.controller.ts
// version: 1.0.0
// description: Controlador para manejar las peticiones HTTP de firma de subidas.

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { generateUploadSignature } from './uploads.service.js';

/**
 * Maneja la petici√≥n del frontend para obtener una firma de subida.
 * Llama al servicio, obtiene la firma y la devuelve como respuesta JSON.
 */
export const getUploadSignatureHandler = (
  _req: AuthRequest, // No necesitamos la request, pero la incluimos por consistencia
  res: Response,
  next: NextFunction
) => {
  try {
    const signatureData = generateUploadSignature();
    res.status(200).json({ success: true, data: signatureData });
  } catch (error) {
    // Aunque es poco probable que la generaci√≥n de la firma falle si la config es correcta,
    // es buena pr√°ctica tener el manejo de errores.
    next(error);
  }
};


// ====== [98] packages/server/src/api/uploads/uploads.routes.ts ======
// filename: packages/server/src/api/uploads/uploads.routes.ts
// version: 1.0.0
// description: Define el endpoint para obtener la firma de subida.

import { Router } from 'express';
import { getUploadSignatureHandler } from './uploads.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const uploadsRouter = Router();

// Protegemos la ruta para que solo los usuarios autenticados (ej. un t√©cnico logueado)
// puedan obtener firmas y subir archivos. Esto previene el abuso del servicio.
uploadsRouter.use(protect);

/**
 * @route   GET /api/uploads/signature
 * @desc    Obtiene una firma y timestamp para autorizar una subida a Cloudinary.
 * @access  Private
 */
uploadsRouter.get('/signature', getUploadSignatureHandler);

export default uploadsRouter;


// ====== [99] packages/server/src/api/uploads/uploads.service.ts ======
// filename: packages/server/src/api/uploads/uploads.service.ts
// version: 1.0.0
// description: Servicio para generar firmas seguras para la subida de archivos a Cloudinary.

import { v2 as cloudinary } from 'cloudinary';
import config from '../../config/index.js';

// --- Configuraci√≥n del SDK de Cloudinary ---
// Se configura una √∫nica vez al cargar el m√≥dulo, utilizando las credenciales
// de nuestro archivo de configuraci√≥n centralizado.
cloudinary.config({
  cloud_name: config.CLOUDINARY_CLOUD_NAME,
  api_key: config.CLOUDINARY_API_KEY,
  api_secret: config.CLOUDINARY_API_SECRET,
  secure: true, // Siempre usar https para las URLs
});

/**
 * Genera una firma segura para autorizar una subida desde el cliente.
 * Este m√©todo no sube ning√∫n archivo, solo crea las credenciales temporales.
 * @returns Un objeto que contiene la firma, el timestamp y la api_key.
 */
export const generateUploadSignature = () => {
  // El timestamp es necesario para que Cloudinary pueda verificar que la firma
  // no es demasiado antigua y prevenir ataques de repetici√≥n.
  const timestamp = Math.round(new Date().getTime() / 1000);

  // Utilizamos la utilidad de Cloudinary para firmar los par√°metros.
  // En este caso, solo necesitamos firmar el timestamp, pero se podr√≠an
  // a√±adir m√°s par√°metros como transformaciones, carpetas, etc.
  const signature = cloudinary.utils.api_sign_request(
    {
      timestamp: timestamp,
    },
    config.CLOUDINARY_API_SECRET
  );

  // El frontend necesitar√° estos tres datos para poder autenticar
  // la petici√≥n de subida directamente contra la API de Cloudinary.
  return {
    timestamp,
    signature,
    apiKey: config.CLOUDINARY_API_KEY,
    cloudName: config.CLOUDINARY_CLOUD_NAME,
  };
};


// ====== [100] packages/server/src/api/users/users.controller.ts ======
// filename: packages/server/src/api/users/users.controller.ts
// Version: 1.0.0 (Initial creation of the controller for User queries)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { getTechniciansByTenant } from './users.service.js';

/**
 * Maneja la obtenci√≥n de todos los t√©cnicos de un tenant.
 */
export const getTechniciansByTenantHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acci√≥n no permitida.' });
    }

    const technicians = await getTechniciansByTenant(tenantId);
    res.status(200).json({ success: true, data: technicians });
  } catch (error) {
    next(error);
  }
};


// ====== [101] packages/server/src/api/users/users.routes.ts ======
// filename: packages/server/src/api/users/users.routes.ts
// Version: 2.0.0 (FEAT: Protect routes with ADMIN/MANAGER authorization)

import { Router } from 'express';
import { getTechniciansByTenantHandler } from './users.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const usersRouter = Router();

// Aplicamos el middleware 'protect' a TODAS las rutas de este enrutador.
usersRouter.use(protect);

/**
 * @route   GET /api/users/technicians
 * @desc    Obtiene una lista de todos los t√©cnicos del tenant.
 * @access  Private (Admin, Manager)
 */
usersRouter.get('/technicians', authorize('ADMIN', 'MANAGER'), getTechniciansByTenantHandler);


export default usersRouter;


// ====== [102] packages/server/src/api/users/users.service.ts ======
// filename: packages/server/src/api/users/users.service.ts
// Version: 1.0.0 (Initial creation of the service for User queries)
import { PrismaClient } from '@prisma/client';
import type { User } from '@prisma/client';

const prisma = new PrismaClient();

// --- Funciones del Servicio ---

/**
 * Obtiene todos los usuarios con el rol de TECHNICIAN para un tenant espec√≠fico.
 * @param tenantId - El ID del tenant.
 * @returns Un array de usuarios t√©cnicos (sin la contrase√±a).
 */
export const getTechniciansByTenant = async (
  tenantId: string
): Promise<Omit<User, 'password'>[]> => {
  return prisma.user.findMany({
    where: {
      tenantId,
      role: 'TECHNICIAN',
    },
    select: {
      id: true,
      email: true,
      name: true,
      role: true,
      tenantId: true,
      createdAt: true,
      updatedAt: true,
    },
    orderBy: {
      name: 'asc',
    },
  });
};


// ====== [103] packages/server/src/api/visits/visits.controller.ts ======
// filename: packages/server/src/api/visits/visits.controller.ts
// Version: 1.7.0 (Adapt assignTechnicianHandler to new logic)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { 
  getScheduledVisitsForWeek, 
  assignTechnicianToVisit,
  getVisitsForTechnicianOnDate,
  getVisitDetails,
  submitWorkOrder,
} from './visits.service.js';

/**
 * Maneja la obtenci√≥n de las visitas programadas para una semana.
 */
export const getScheduledVisitsForWeekHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acci√≥n no permitida.' });
    }

    const { date } = req.query;
    if (!date || typeof date !== 'string') {
      return res.status(400).json({ message: 'Se requiere un par√°metro de fecha v√°lido.' });
    }

    const weekDate = new Date(date);
    const visits = await getScheduledVisitsForWeek(tenantId, weekDate);

    res.status(200).json({ success: true, data: visits });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la asignaci√≥n de un t√©cnico a una visita.
 */
export const assignTechnicianHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { visitId, technicianId } = req.body;
    if (!visitId) {
      return res.status(400).json({ message: 'visitId es requerido.' });
    }
    
    // TODO: Verificar que la visita pertenece al tenant del admin
    
    const assignedVisit = await assignTechnicianToVisit(visitId, technicianId);
    
    res.status(200).json({ success: true, data: assignedVisit });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de la ruta diaria para el t√©cnico autenticado.
 */
export const getMyRouteHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const technicianId = req.user?.id;
    if (!technicianId || req.user?.role !== 'TECHNICIAN') {
      return res.status(403).json({ message: 'Acceso denegado.' });
    }
    
    const today = new Date();
    const visits = await getVisitsForTechnicianOnDate(technicianId, today);
    
    res.status(200).json({ success: true, data: visits });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de los detalles de una visita espec√≠fica.
 */
export const getVisitDetailsHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la visita es requerido.' });
    }
    
    const visitDetails = await getVisitDetails(id);
    if (!visitDetails) {
      return res.status(404).json({ message: 'Visita no encontrada.' });
    }

    res.status(200).json({ success: true, data: visitDetails });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja el env√≠o de un parte de trabajo.
 */
export const submitWorkOrderHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la visita es requerido.' });
    }
    
    await submitWorkOrder(id, req.body);

    res.status(200).json({ success: true, message: 'Parte de trabajo guardado con √©xito.' });
  } catch (error) {
    console.error('ERROR AL PROCESAR PARTE DE TRABAJO:', error); 
    next(error);
  }
};


// ====== [104] packages/server/src/api/visits/visits.routes.ts ======
// filename: packages/server/src/api/visits/visits.routes.ts
// Version: 2.0.0 (FEAT: Protect routes with granular ADMIN/TECHNICIAN authorization)

import { Router } from 'express';
import { 
  getScheduledVisitsForWeekHandler,
  assignTechnicianHandler,
  getMyRouteHandler,
  getVisitDetailsHandler,
  submitWorkOrderHandler,
} from './visits.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const visitsRouter = Router();

// Todas las rutas de visitas requieren que el usuario est√© autenticado.
visitsRouter.use(protect);

// --- Rutas exclusivas para ADMIN (y MANAGER en vista de Admin) ---
visitsRouter.get('/scheduled', authorize('ADMIN'), getScheduledVisitsForWeekHandler);
visitsRouter.post('/assign', authorize('ADMIN'), assignTechnicianHandler);

// --- Rutas exclusivas para TECHNICIAN (y MANAGER en vista de T√©cnico) ---
visitsRouter.get('/my-route', authorize('TECHNICIAN'), getMyRouteHandler);
visitsRouter.post('/:id/complete', authorize('TECHNICIAN'), submitWorkOrderHandler);


// --- Rutas compartidas por ADMIN y TECHNICIAN ---

/**
 * @route   GET /api/visits/:id
 * @desc    Obtiene los detalles de una visita espec√≠fica (para el Parte de Trabajo)
 * @access  Private (Admin, Technician)
 */
// El ADMIN necesita ver los partes completados, el TECHNICIAN necesita ver los pendientes para rellenarlos.
visitsRouter.get('/:id', authorize('ADMIN', 'TECHNICIAN'), getVisitDetailsHandler);

export default visitsRouter;


// ====== [105] packages/server/src/api/visits/visits.service.ts ======
// filename: packages/server/src/api/visits/visits.service.ts
// version: 2.1.0 (FEAT: Add threshold-based alerts on work order submission)

import { PrismaClient } from '@prisma/client';
import type { Visit } from '@prisma/client';
import { 
  startOfWeek, endOfWeek, eachDayOfInterval, isSameDay, startOfDay, endOfDay,
} from 'date-fns';

const prisma = new PrismaClient();

// --- Tipos ---
export type WorkOrderInput = {
  results: Record<string, string | number | boolean>;
  completedTasks: Record<string, boolean>;
  consumptions?: { productId: string; quantity: number }[];
  notes?: string;
  hasIncident?: boolean;
  imageUrls?: string[]; 
};


export const getScheduledVisitsForWeek = async (tenantId: string, weekDate: Date): Promise<Visit[]> => {
  const start = startOfWeek(weekDate, { weekStartsOn: 1 });
  const end = endOfWeek(weekDate, { weekStartsOn: 1 });
  const weekDays = eachDayOfInterval({ start, end });

  const pools = await prisma.pool.findMany({
    where: { tenantId, configurations: { some: {} } },
    include: { configurations: true },
  });

  const existingVisits = await prisma.visit.findMany({
    where: { pool: { tenantId }, timestamp: { gte: start, lte: end } },
  });

  const visitsToCreate: { poolId: string; timestamp: Date }[] = [];

  for (const day of weekDays) {
    for (const pool of pools) {
      
      const shouldVisitToday = pool.configurations.some(config => {
        if (config.frequency === 'DIARIA') return true;
        if (config.frequency === 'SEMANAL' && day.getDay() === 1) return true;
        return false;
      });

      if (shouldVisitToday) {
        const alreadyExists = existingVisits.some(
          (v) => v.poolId === pool.id && isSameDay(v.timestamp, day)
        );
        const alreadyInQueue = visitsToCreate.some(
          (v) => v.poolId === pool.id && isSameDay(v.timestamp, day)
        );

        if (!alreadyExists && !alreadyInQueue) {
          visitsToCreate.push({ poolId: pool.id, timestamp: day });
        }
      }
    }
  }

  if (visitsToCreate.length > 0) {
    await prisma.visit.createMany({
      data: visitsToCreate.map(v => ({ ...v, status: 'PENDING' })),
      skipDuplicates: true,
    });
  }

  return prisma.visit.findMany({
    where: { pool: { tenantId }, timestamp: { gte: start, lte: end } },
    include: { 
      pool: { include: { client: true } },
      technician: { select: { name: true } },
    },
    orderBy: { timestamp: 'asc' },
  });
};

export const assignTechnicianToVisit = async (visitId: string, technicianId: string | null) => {
    return prisma.visit.update({
        where: { id: visitId },
        data: { technicianId },
    });
};

export const getVisitsForTechnicianOnDate = async (
  technicianId: string,
  date: Date
): Promise<Visit[]> => {
  const dayStart = startOfDay(date);
  const dayEnd = endOfDay(date);

  return prisma.visit.findMany({
    where: {
      technicianId,
      status: 'PENDING',
      timestamp: {
        gte: dayStart,
        lte: dayEnd,
      },
    },
    include: {
      pool: {
        include: {
          client: true,
        },
      },
    },
    orderBy: {
      timestamp: 'asc',
    },
  });
};

export const getVisitDetails = async (visitId: string) => {
  return prisma.visit.findUnique({
    where: { id: visitId },
    include: {
      results: true, 
      notifications: {
        include: {
          images: true,
        }
      },
      consumptions: {
        include: {
          product: true,
        }
      },
      pool: {
        include: {
          client: true,
          configurations: {
            include: {
              parameterTemplate: true,
              taskTemplate: true,
            },
          },
        },
      },
    },
  });
};

export const submitWorkOrder = async (visitId: string, data: WorkOrderInput) => {
  return prisma.$transaction(async (tx) => {
    const visit = await tx.visit.findUnique({
      where: { id: visitId },
      include: { 
        pool: { 
          include: { 
            configurations: { include: { parameterTemplate: true, taskTemplate: true } } 
          } 
        },
        technician: true
      },
    });
    if (!visit || !visit.technicianId) throw new Error('Visita o t√©cnico no encontrados');
    
    const { results, completedTasks, notes, hasIncident, consumptions = [], imageUrls = [] } = data;

    if (consumptions && consumptions.length > 0) {
        const validConsumptions = consumptions
            .filter(c => c.productId && c.quantity && c.quantity > 0)
            .map(c => ({
                quantity: c.quantity,
                productId: c.productId,
                visitId: visitId,
            }));

        if (validConsumptions.length > 0) {
            await tx.consumption.createMany({
                data: validConsumptions,
            });
        }
    }

    // --- ‚úÖ INICIO DE LA NUEVA L√ìGICA DE UMBRALES ---
    const usersToNotify = await tx.user.findMany({
      where: {
        tenantId: visit.pool.tenantId,
        role: { in: ['ADMIN', 'MANAGER'] }
      },
      select: { id: true }
    });
    const notificationsToCreate: { message: string; tenantId: string; userId: string; visitId: string; priority: 'HIGH' }[] = [];

    for (const [configId, value] of Object.entries(results)) {
      if(value === '' || value === null || typeof value !== 'number') continue;
      
      const config = visit.pool.configurations.find(c => c.id === configId);
      if (config?.parameterTemplate) {
        await tx.visitResult.create({
          data: { visitId, value: String(value), parameterName: config.parameterTemplate.name, parameterUnit: config.parameterTemplate.unit, },
        });

        const { minThreshold, maxThreshold, parameterTemplate: { name: paramName, unit } } = config;
        let alertMessage = '';

        if (minThreshold !== null && value < minThreshold) {
            alertMessage = `Alerta en ${visit.pool.name}: ${paramName} est√° bajo (${value} ${unit || ''}). L√≠mite inferior: ${minThreshold}.`;
        } else if (maxThreshold !== null && value > maxThreshold) {
            alertMessage = `Alerta en ${visit.pool.name}: ${paramName} est√° alto (${value} ${unit || ''}). L√≠mite superior: ${maxThreshold}.`;
        }

        if (alertMessage) {
          for (const user of usersToNotify) {
            notificationsToCreate.push({
              message: alertMessage,
              tenantId: visit.pool.tenantId,
              userId: user.id,
              visitId: visit.id,
              priority: 'HIGH'
            });
          }
        }
      }
    }
    // --- ‚úÖ FIN DE LA NUEVA L√ìGICA DE UMBRALES ---
    
    const completedTaskNames = Object.entries(completedTasks)
      .filter(([, completed]) => completed)
      .map(([configId]) => {
        const config = visit.pool.configurations.find(c => c.id === configId);
        return config?.taskTemplate?.name || 'Tarea desconocida';
      });
    
    await tx.visit.update({
      where: { id: visitId },
      data: { notes, hasIncident: hasIncident || false, completedTasks: completedTaskNames, status: 'COMPLETED', },
    });

    if (hasIncident && usersToNotify.length > 0) {
      const notificationMessage = notes && notes.trim().length > 0 
            ? notes 
            : `Incidencia reportada en ${visit.pool.name} por ${visit.technician?.name || 'un t√©cnico'}`;

      for (const user of usersToNotify) {
        notificationsToCreate.push({
            message: notificationMessage,
            tenantId: visit.pool.tenantId,
            userId: user.id,
            visitId: visit.id,
            priority: 'HIGH' // Incidencias manuales son siempre de alta prioridad
        });
      }
    }
    
    if (notificationsToCreate.length > 0) {
      const uniqueNotifications = Array.from(new Map(notificationsToCreate.map(item => [item.message, item])).values());
      
      const mainNotification = uniqueNotifications.find(n => n.message.startsWith('Incidencia reportada'));
      let mainNotificationId: string | undefined;

      if(mainNotification) {
        const createdMainNotification = await tx.notification.create({ data: mainNotification });
        mainNotificationId = createdMainNotification.id;
      }
      
      const otherNotifications = uniqueNotifications.filter(n => !n.message.startsWith('Incidencia reportada'));
      if (otherNotifications.length > 0) {
          await tx.notification.createMany({ data: otherNotifications });
      }

      if (mainNotificationId && imageUrls.length > 0) {
        await tx.incidentImage.createMany({
          data: imageUrls.map(url => ({
            url: url,
            notificationId: mainNotificationId!,
            uploaderId: visit.technicianId!,
          })),
        });
      }
    }
    
    const configIdsToUpdate = [...Object.keys(results).filter(k => results[k] !== ''), ...Object.keys(completedTasks).filter(k => completedTasks[k])];
    if(configIdsToUpdate.length > 0) {
        await tx.poolConfiguration.updateMany({
            where: { id: { in: configIdsToUpdate } },
            data: { lastCompleted: new Date() },
        });
    }
  });
};


// ====== [106] packages/server/src/app.ts ======
// filename: packages/server/src/app.ts
// version: 2.7.0 (FEAT: Mount reportsRouter)
import express from 'express';
import type { Request, Response } from 'express';
import cors from 'cors';
import cookieParser from 'cookie-parser';

import { errorHandler } from './middleware/error.middleware.js';
import authRouter from './api/auth/auth.routes.js';
import tenantsRouter from './api/tenants/tenants.routes.js';
import parametersRouter from './api/parameters/parameters.routes.js';
import tasksRouter from './api/tasks/tasks.routes.js';
import clientsRouter from './api/clients/clients.routes.js';
import poolsRouter from './api/pools/pools.routes.js';
import poolConfigurationsRouter from './api/pool-configurations/pool-configurations.routes.js';
import visitsRouter from './api/visits/visits.routes.js';
import usersRouter from './api/users/users.routes.js';
import notificationsRouter from './api/notifications/notifications.routes.js';
import productsRouter from './api/products/products.routes.js';
import incidentTasksRouter from './api/incident-tasks/incident-tasks.routes.js';
import uploadsRouter from './api/uploads/uploads.routes.js';
import productCategoriesRouter from './api/product-categories/product-categories.routes.js';
import clientProductPricingRouter from './api/client-product-pricing/client-product-pricing.routes.js';
import paymentsRouter from './api/payments/payments.routes.js';
import expensesRouter from './api/expenses/expenses.routes.js';
import dashboardRouter from './api/dashboard/dashboard.routes.js';
// --- ‚úÖ 1. Importar el enrutador de informes ---
import reportsRouter from './api/reports/reports.routes.js';

// --- Instancia de la App ---
const app = express();

// --- Middlewares Esenciales ---
app.use(cors({
  origin: 'http://localhost:5173',
  credentials: true,
}));
app.use(cookieParser());
app.use(express.json());


// --- Rutas de la API ---

app.get('/api/health', (_req: Request, res: Response) => {
  res.status(200).json({ status: 'UP' });
});

app.use('/api/auth', authRouter);
app.use('/api/tenants', tenantsRouter);
app.use('/api/parameters', parametersRouter);
app.use('/api/tasks', tasksRouter);
app.use('/api/clients', clientsRouter);
app.use('/api/pools', poolsRouter);
app.use('/api/pool-configurations', poolConfigurationsRouter);
app.use('/api/visits', visitsRouter);
app.use('/api/users', usersRouter);
app.use('/api/notifications', notificationsRouter);
app.use('/api/products', productsRouter);
app.use('/api/incident-tasks', incidentTasksRouter);
app.use('/api/uploads', uploadsRouter);
app.use('/api/product-categories', productCategoriesRouter);
app.use('/api/client-product-pricing', clientProductPricingRouter);
app.use('/api/payments', paymentsRouter);
app.use('/api/expenses', expensesRouter);
app.use('/api/dashboard', dashboardRouter);
// --- ‚úÖ 2. Montar el enrutador de informes ---
app.use('/api/reports', reportsRouter);


// --- Gestor de Errores ---
app.use(errorHandler);

export default app;


// ====== [107] packages/server/src/config/index.ts ======
// filename: packages/server/src/config/index.ts
// version: 2.0.0 (Add Cloudinary credentials)

import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

// --- Recreaci√≥n de __dirname para ES Modules ---
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
// ---------------------------------------------

dotenv.config({ path: path.resolve(__dirname, '../../.env') });

const getEnvVar = (key: string): string => {
  const value = process.env[key];
  if (!value) {
    throw new Error(`Falta la variable de entorno requerida: ${key}`);
  }
  return value;
};

const config = {
  PORT: parseInt(getEnvVar('PORT'), 10),
  JWT_SECRET: getEnvVar('JWT_SECRET'),
  JWT_EXPIRES_IN: parseInt(getEnvVar('JWT_EXPIRES_IN'), 10),
  DATABASE_URL: getEnvVar('DATABASE_URL'),

  // --- Nuevas credenciales de Cloudinary ---
  CLOUDINARY_CLOUD_NAME: getEnvVar('CLOUDINARY_CLOUD_NAME'),
  CLOUDINARY_API_KEY: getEnvVar('CLOUDINARY_API_KEY'),
  CLOUDINARY_API_SECRET: getEnvVar('CLOUDINARY_API_SECRET'),
};

export default config;


// ====== [108] packages/server/src/middleware/auth.middleware.ts ======
// filename: packages/server/src/middleware/auth.middleware.ts
// version: 2.0.0 (FEAT: Implement 'View As' logic for Manager role)

import type { Request, Response, NextFunction } from 'express';
import { PrismaClient, UserRole } from '@prisma/client';
import type { User } from '@prisma/client';
import { verifyToken } from '../utils/jwt.utils.js';

const prisma = new PrismaClient();

type SafeUser = Omit<User, 'password'>;

export interface AuthRequest extends Request {
  user?: SafeUser;
}

/**
 * Middleware para proteger rutas. Verifica el token JWT y maneja la suplantaci√≥n de rol.
 */
export const protect = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  const token = req.cookies.token;

  if (!token) {
    return res.status(401).json({ message: 'No autenticado: no hay token.' });
  }

  try {
    const decoded = verifyToken<{ id: string }>(token);

    if (!decoded) {
      return res.status(401).json({ message: 'No autenticado: token inv√°lido.' });
    }

    const user = await prisma.user.findUnique({
      where: { id: decoded.id },
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        tenantId: true,
        createdAt: true,
        updatedAt: true,
      },
    });

    if (!user) {
      return res.status(401).json({ message: 'No autenticado: usuario no encontrado.' });
    }
    
    // --- ‚úÖ INICIO DE LA L√ìGICA DEL "ROL CAMALE√ìN" ---
    
    const viewAsRoleHeader = req.headers['x-view-as-role'] as UserRole | undefined;

    // Solo un MANAGER puede cambiar de vista.
    if (user.role === 'MANAGER' && viewAsRoleHeader) {
      // Validamos que el rol que se quiere simular sea uno de los permitidos.
      const allowedViews: UserRole[] = ['ADMIN', 'TECHNICIAN'];
      if (allowedViews.includes(viewAsRoleHeader)) {
        // Modificamos el rol del usuario EN LA REQUEST ACTUAL.
        // La base de datos no se altera.
        user.role = viewAsRoleHeader;
      }
    }
    
    // --- ‚úÖ FIN DE LA L√ìGICA ---

    req.user = user;
    next();
  } catch (error) {
    return res.status(401).json({ message: 'No autenticado: error en la validaci√≥n.' });
  }
};


// ====== [109] packages/server/src/middleware/authorize.middleware.ts ======
// filename: packages/server/src/middleware/authorize.middleware.ts
// version: 1.0.0
// description: Middleware para la autorizaci√≥n basada en roles.

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from './auth.middleware.js';
import type { UserRole } from '@prisma/client';

/**
 * Crea un middleware de Express que verifica si el rol del usuario autenticado
 * est√° incluido en la lista de roles permitidos.
 *
 * @param {...UserRole} allowedRoles - Una lista de roles que tienen permiso para acceder a la ruta.
 * @returns Un middleware de Express.
 */
export const authorize = (...allowedRoles: UserRole[]) => {
  return (req: AuthRequest, res: Response, next: NextFunction) => {
    // El middleware 'protect' debe haberse ejecutado antes, por lo que 'req.user' deber√≠a existir.
    if (!req.user) {
      return res.status(401).json({
        success: false,
        message: 'No autenticado. Imposible realizar la autorizaci√≥n.',
      });
    }

    const { role } = req.user;

    // Comprobamos si el rol del usuario est√° en la lista de roles permitidos.
    // Importante: Esto comprueba el rol REAL del usuario en la DB, no el de la vista "Camale√≥n".
    // La l√≥gica de la vista "Camale√≥n" ya se ha aplicado en el middleware `protect`.
    if (!allowedRoles.includes(role)) {
      return res.status(403).json({
        success: false,
        message: `Acceso denegado. Tu rol ('${role}') no tiene permiso para este recurso. Roles permitidos: ${allowedRoles.join(', ')}.`,
      });
    }

    // Si el rol es v√°lido, pasamos al siguiente middleware o al controlador de la ruta.
    next();
  };
};


// ====== [110] packages/server/src/middleware/error.middleware.ts ======
import type { Request, Response, NextFunction } from 'express';

// Interfaz para asegurar que nuestros errores puedan tener un c√≥digo de estado
interface HttpError extends Error {
  statusCode?: number;
}

export const errorHandler = (
  err: HttpError,
  _req: Request,
  res: Response,
  _next: NextFunction
) => {
  // Guardamos el error en la consola para depuraci√≥n
  console.error(err);

  const statusCode = err.statusCode || 500;
  const message = err.message || 'Ha ocurrido un error inesperado en el servidor.';

  res.status(statusCode).json({
    success: false,
    statusCode: statusCode,
    message: message,
  });
};


// ====== [111] packages/server/src/server.ts ======
import app from './app.js';
import config from './config/index.js';

const PORT = config.PORT || 3001;

app.listen(PORT, () => {
  console.log(`üöÄ Servidor escuchando en http://localhost:${PORT}`);
});


// ====== [112] packages/server/src/utils/jwt.utils.ts ======
import jwt from 'jsonwebtoken';
import type { SignOptions } from 'jsonwebtoken';
import config from '../config/index.js';

/**
 * Firma un payload para crear un token JWT.
 * @param payload El objeto que se incluir√° en el token (ej. { userId: '...' }).
 * @returns El token JWT como una cadena de texto.
 */
export const signToken = (payload: object): string => {
  const options: SignOptions = {
    expiresIn: config.JWT_EXPIRES_IN,
  };

  return jwt.sign(payload, config.JWT_SECRET, options);
};

/**
 * Verifica un token JWT y devuelve su payload si es v√°lido.
 * @template T El tipo esperado del payload.
 * @param token El token JWT a verificar.
 * @returns El payload decodificado si el token es v√°lido; de lo contrario, null.
 */
export const verifyToken = <T>(token: string): T | null => {
  try {
    const decoded = jwt.verify(token, config.JWT_SECRET) as T;
    return decoded;
  } catch (error) {
    return null;
  }
};


// ====== [113] packages/server/src/utils/password.utils.ts ======
import bcrypt from 'bcryptjs';

const SALT_ROUNDS = 12;

/**
 * Genera el hash de una contrase√±a en texto plano.
 * @param password La contrase√±a en texto plano.
 * @returns Una promesa que resuelve en el hash de la contrase√±a.
 */
export const hashPassword = (password: string): Promise<string> => {
  return bcrypt.hash(password, SALT_ROUNDS);
};

/**
 * Compara una contrase√±a en texto plano con un hash.
 * @param password La contrase√±a en texto plano a comparar.
 * @param hash El hash almacenado en la base de datos.
 * @returns Una promesa que resuelve en `true` si las contrase√±as coinciden, `false` en caso contrario.
 */
export const comparePassword = (password: string, hash: string): Promise<boolean> => {
  return bcrypt.compare(password, hash);
};


// ====== [114] packages/server/tsconfig.json ======
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist"
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules"]
}


// ====== [115] tsconfig.json ======
{
  "compilerOptions": {
    /* Base Options */
    "esModuleInterop": true,
    "skipLibCheck": true,
    "target": "ES2022",
    "allowJs": true,
    "resolveJsonModule": true,
    "moduleDetection": "force",
    "isolatedModules": true,
    "verbatimModuleSyntax": true,

    /* Strictness */
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitAny": true,

    /* Module Resolution */
    "moduleResolution": "NodeNext",
    "module": "NodeNext",

    /* Linter */
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true
  },
  "exclude": ["node_modules"]
}

