# ÍNDICE DE ARCHIVOS (ESTRUCTURA REFACTORIZADA)

1. DEVELOPMENT_PLAN.md
2. PROJECT_STATUS.md
3. README.md
4. package.json
5. packages/client/index.html
6. packages/client/package.json
7. packages/client/src/App.tsx
8. packages/client/src/api/apiClient.ts
9. packages/client/src/features/admin/pages/ParameterCatalogPage.tsx
10. packages/client/src/features/admin/pages/TaskCatalogPage.tsx
11. packages/client/src/features/admin/pages/clients/ClientDetailPage.tsx
12. packages/client/src/features/admin/pages/clients/ClientsPage.tsx
13. packages/client/src/features/admin/pages/planner/PlannerPage.tsx
14. packages/client/src/features/admin/pages/pools/PoolDetailPage.tsx
15. packages/client/src/features/auth/pages/LoginPage.tsx
16. packages/client/src/features/superadmin/pages/TenantsPage.tsx
17. packages/client/src/features/technician/pages/MyRoutePage.tsx
18. packages/client/src/features/technician/pages/WorkOrderPage.tsx
19. packages/client/src/main.tsx
20. packages/client/src/providers/AuthProvider.tsx
21. packages/client/src/router/components.tsx
22. packages/client/src/router/index.tsx
23. packages/client/src/styles/theme.ts
24. packages/client/tsconfig.json
25. packages/client/tsconfig.node.json
26. packages/client/vite.config.ts
27. packages/server/package.json
28. packages/server/prisma/seed.ts
29. packages/server/src/api/auth/auth.controller.ts
30. packages/server/src/api/auth/auth.routes.ts
31. packages/server/src/api/auth/auth.service.ts
32. packages/server/src/api/clients/clients.controller.ts
33. packages/server/src/api/clients/clients.routes.ts
34. packages/server/src/api/clients/clients.service.ts
35. packages/server/src/api/parameters/parameters.controller.ts
36. packages/server/src/api/parameters/parameters.routes.ts
37. packages/server/src/api/parameters/parameters.service.ts
38. packages/server/src/api/pool-configurations/pool-configurations.controller.ts
39. packages/server/src/api/pool-configurations/pool-configurations.routes.ts
40. packages/server/src/api/pool-configurations/pool-configurations.service.ts
41. packages/server/src/api/pools/pools.controller.ts
42. packages/server/src/api/pools/pools.routes.ts
43. packages/server/src/api/pools/pools.service.ts
44. packages/server/src/api/tasks/tasks.controller.ts
45. packages/server/src/api/tasks/tasks.routes.ts
46. packages/server/src/api/tasks/tasks.service.ts
47. packages/server/src/api/tenants/tenants.controller.ts
48. packages/server/src/api/tenants/tenants.routes.ts
49. packages/server/src/api/tenants/tenants.service.ts
50. packages/server/src/api/users/users.controller.ts
51. packages/server/src/api/users/users.routes.ts
52. packages/server/src/api/users/users.service.ts
53. packages/server/src/api/visits/visits.controller.ts
54. packages/server/src/api/visits/visits.routes.ts
55. packages/server/src/api/visits/visits.service.ts
56. packages/server/src/app.ts
57. packages/server/src/config/index.ts
58. packages/server/src/middleware/auth.middleware.ts
59. packages/server/src/middleware/error.middleware.ts
60. packages/server/src/server.ts
61. packages/server/src/utils/jwt.utils.ts
62. packages/server/src/utils/password.utils.ts
63. packages/server/tsconfig.json
64. tsconfig.json


# CONTENIDO DE ARCHIVOS


// ====== [1] DEVELOPMENT_PLAN.md ======
# Plan de Desarrollo y Arquitectura: Pool-Control Professional

Este documento es la hoja de ruta arquitectónica y el registro de implementación para el proyecto. Sirve tanto de guía para el trabajo futuro como de crónica de las decisiones tomadas, garantizando un entendimiento profundo del sistema en cualquier punto de su ciclo de vida.

---

## ✅ FASE 0: Fundación del Entorno y Monorepo

- **Estado:** `COMPLETADA`
- **Intención Arquitectónica:** Establecer una base de desarrollo moderna, escalable y mantenible, donde el backend y el frontend, aunque desacoplados, pudieran ser gestionados desde un único repositorio para agilizar el desarrollo.
- **Entregables Clave:**
  - **Monorepo con PNPM:** Se adoptó `pnpm` con `workspaces` para una gestión de dependencias ultra-eficiente y la capacidad de ejecutar scripts de forma centralizada.
  - **Configuración Maestra de TypeScript:** Se definió un `tsconfig.json` raíz con reglas estrictas (`strict: true`) y configuración para ES Modules (`module: NodeNext`), forzando un código de alta calidad y moderno desde el inicio.

---

## ✅ FASE 1: Fundación del Backend

- **Estado:** `COMPLETADA`
- **Intención Arquitectónica:** Construir un servidor API robusto, seguro y preparado para crecer. El objetivo era tener una base sólida sobre la cual construir todos los módulos de negocio.
- **Entregables Clave:**
  - **Servidor Express.js:** Se montó un servidor con una estructura modular (`app.ts` para configuración, `server.ts` para arranque), usando ES Modules nativos.
  - **Persistencia con Prisma:** Se definió el `schema.prisma` como la "única fuente de verdad" para el modelo de datos y se estableció la conexión con PostgreSQL.
  - **Seguridad y Autenticación:** Se implementó un sistema de autenticación completo y seguro:
    - **Middleware `protect`:** Un guardián para nuestras rutas, que verifica la validez de los tokens JWT enviados a través de cookies `httpOnly`.
    - **Endpoints de Autenticación:** Se crearon las rutas `/api/auth/login`, `/logout`, `/register` y `/me`, que constituyen el portal de entrada a la aplicación.
  - **Script de `seed`:** Se creó un script para poblar la base de datos con datos esenciales (como el `SUPER_ADMIN`), permitiendo un entorno de desarrollo consistente y eliminando la necesidad de creación manual de datos críticos.

---

## ✅ FASE 2: Fundación del Frontend

- **Estado:** `COMPLETADA`
- **Intención Arquitectónica:** Crear una aplicación de cliente reactiva, rápida y con una excelente experiencia de usuario, estableciendo los patrones de diseño que se usarían en todo el frontend.
- **Entregables Clave:**
  - **Aplicación React con Vite:** Se eligió Vite por su velocidad y su excelente experiencia de desarrollo.
  - **Gestión de Estado Global (`AuthProvider`):** Se implementó un `React Context` para gestionar el estado de autenticación del usuario. Este provider es el responsable de mantener la sesión activa entre recargas de página, comunicándose con el endpoint `/api/auth/me`.
  - **Enrutamiento Protegido:** Se creó un sistema de enrutamiento con `react-router-dom`, definiendo el concepto de `ProtectedRoute` y rutas específicas por rol (`AdminRoute`, `SuperAdminRoute`), un pilar de la seguridad de la interfaz.
  - **Base de UI con Mantine:** Se estableció Mantine UI como la librería de componentes y se configuró un `theme` personalizado para una estética coherente.

---

## ✅ FASE 3: Módulo de Gestión (SuperAdmin y Admin)

- **Estado:** `COMPLETADA`
- **Intención de Negocio:** Digitalizar y automatizar por completo las tareas de configuración y planificación, empoderando al `ADMIN` para que sea 100% autónomo.
- **Entregables Clave:**
  - **CRUD de Tenants (SuperAdmin):** API y UI para que el SuperAdmin gestione el ciclo de vida de sus clientes.
  - **CRUD de Catálogos (Admin):** API y UI para que el Admin defina sus `Parámetros` y `Tareas` de servicio.
  - **CRUD de Clientes y Piscinas (Admin):** API y UI para gestionar la cartera de clientes y sus piscinas.
  - **Constructor de Fichas (Admin):** Lógica de negocio y UI para asociar ítems del catálogo a piscinas, definiendo `frecuencia` y `umbrales`.
  - **Planificador de Rutas (Admin):** Una de las funcionalidades más complejas. Se implementó una lógica de backend que genera visitas y una interfaz `Drag and Drop` para la asignación a técnicos.

---

## ✅ FASE 4: Módulo de Ejecución (Técnico)

- **Estado:** `COMPLETADA`
- **Intención de Negocio:** Optimizar al máximo el trabajo de campo del técnico, proporcionándole una herramienta clara, rápida y que elimina la necesidad de partes de trabajo en papel.
- **Entregables Clave:**
  - **"Mi Ruta de Hoy":** API y UI que presentan al técnico una lista clara de sus visitas pendientes para el día actual.
  - **"Parte de Trabajo Dinámico":** La funcionalidad estrella.
    - **Backend:** Se implementó la lógica `submitWorkOrder` dentro de una transacción de Prisma para garantizar la atomicidad de los datos. Guarda resultados, tareas completadas, notas, e incidencias.
    - **Frontend:** La `WorkOrderPage` renderiza un formulario a medida para cada visita, basándose en la configuración definida por el `ADMIN`.
  - **Reporte de Incidencias:** Se implementó el flujo completo, desde el `Checkbox` en el parte del técnico hasta la creación de un registro `Notification` en la base de datos.

---

## ▶️ FASE 5: Cierre de Bucles y Experiencia de Usuario

- **Estado:** `EN CURSO`
- **Intención de Negocio:** Conectar los flujos de información y mejorar la interfaz para proporcionar una experiencia de usuario cohesiva y completa.
- **Plan de Acción Detallado:**
  1.  **Sistema de Notificaciones (Admin):**
      - **Propósito:** Hacer visibles las incidencias reportadas por los técnicos.
      - **Tareas:**
        - **Backend:** Crear la API CRUD para `/api/notifications`.
        - **Frontend:** Añadir un componente "campana" en el `AppLayout` que muestre un indicador y un menú desplegable con las notificaciones.
  2.  **Dashboard Principal (Admin):**
      - **Propósito:** Dar al `ADMIN` una vista rápida del estado de la operativa diaria.
      - **Tareas:** Reemplazar el `div` actual por un panel que muestre "Visitas de hoy" y "Últimas Incidencias".
  3.  **Mejoras en el Planificador (Admin):**
      - **Propósito:** Proporcionar más información visual al `ADMIN`.
      - **Tareas:** Diferenciar visualmente las visitas `PENDING` de las `COMPLETED` en el planificador (ej. con colores o transparencia).
  4.  **Gestión de Consumo de Productos (Técnico y Admin):**
      - **Propósito:** Empezar a registrar los costes asociados a cada visita.
      - **Tareas:**
        - **Backend y Frontend:** Implementar el CRUD para el catálogo de `Product`.
        - **Frontend:** Añadir una sección en el `WorkOrderPage` para que el técnico pueda registrar los productos consumidos.
        - **Backend:** Modificar `submitWorkOrder` para guardar los registros `Consumption`.

---

## 🔮 FASE 6 Y POSTERIORES: Funcionalidades Avanzadas

- **Estado:** `PLANIFICADO`
- **Intención de Negocio:** Añadir capas de inteligencia de negocio y expandir las capacidades de la plataforma.
- **Ideas Clave:**
  - **Modo Offline (PWA):** Implementar la capacidad de trabajo sin conexión para el técnico.
  - **Dashboard de Gerencia (`MANAGER`):** Desarrollar los KPIs y gráficos.
  - **Sistema de Facturación:** Generar informes de consumo por cliente.



// ====== [2] PROJECT_STATUS.md ======
# Estado del Proyecto: Pool-Control Professional

_Última actualización: 9 de julio de 2025, 11:30 CEST_

---

## 1. Resumen Ejecutivo

El proyecto ha alcanzado un hito crítico: la finalización del **flujo operativo principal completo**. Desde la configuración inicial por parte del Administrador hasta la ejecución en campo por parte del Técnico, la aplicación ahora soporta el ciclo de vida completo de una visita de mantenimiento. Se ha validado con éxito la creación, asignación, ejecución y finalización de tareas, incluyendo el reporte de incidencias.

La infraestructura de backend y frontend ha demostrado ser robusta y escalable. Los módulos de `SUPER_ADMIN` y `ADMIN` están completos, y el módulo de `TECHNICIAN` tiene su funcionalidad esencial implementada.

Con el "camino feliz" del flujo de trabajo ya construido, el proyecto entra en una nueva fase centrada en **enriquecer la experiencia del usuario y cerrar los bucles de comunicación**, comenzando por el desarrollo del sistema de notificaciones para el Administrador.

---

## 2. Hitos Completados y Entregables

### ✅ **Módulo de Ejecución (Técnico): Parte de Trabajo**

- **Estado:** `COMPLETADO Y VALIDADO`.
- **Descripción Detallada:** Se ha construido la funcionalidad más importante de la aplicación, que permite al técnico registrar su trabajo de forma digital.
  - **API de Soporte:** Se implementaron los endpoints necesarios en el backend (`GET /api/visits/:id` para obtener los detalles y `POST /api/visits/:id/complete` para guardar el trabajo).
  - **Página del Parte de Trabajo:** Se creó la `WorkOrderPage.tsx`, que se enlaza desde la ruta del día.
  - **Renderizado Dinámico:** La página es "inteligente": lee la configuración específica de la piscina (definida por el `ADMIN`) y construye el formulario sobre la marcha, mostrando únicamente los parámetros y tareas que corresponden.
  - **Gestión de Estado:** Se utiliza el hook `useForm` de Mantine para gestionar de forma eficiente todos los datos introducidos por el técnico.
  - **Lógica de Finalización:** Al guardar, la API procesa todos los datos, crea los registros de `VisitResult` en la base de datos, actualiza el estado de la `Visit` a `COMPLETED` y, crucialmente, la visita desaparece de la lista de tareas pendientes del técnico, confirmando que el ciclo se ha cerrado correctamente.

### ✅ **Sistema de Reporte de Incidencias (Backend)**

- **Estado:** `COMPLETADO Y VALIDADO`.
- **Descripción Detallada:** Se ha implementado la mecánica para que un técnico pueda escalar un problema al administrador.
  - **Modificación del Schema:** Se añadió el campo `hasIncident` al modelo `Visit` y se creó el nuevo modelo `Notification`.
  - **Lógica en el Servidor:** La función `submitWorkOrder` ahora comprueba si el `Checkbox` de incidencia fue marcado. Si es `true`, crea un nuevo registro en la tabla `Notification` asignado al `ADMIN` de ese tenant, con un mensaje descriptivo.
  - **Próximos Pasos:** La creación de la notificación funciona, pero el `ADMIN` todavía no tiene una forma de verla en la interfaz.

### ✅ **Refactorización de la Lógica del Planificador**

- **Estado:** `COMPLETADO Y VALIDADO`.
- **Descripción Detallada:** Tras detectar inconsistencias en la generación de visitas, se ha reescrito por completo la lógica del servicio `getScheduledVisitsForWeek`. El nuevo sistema es más robusto y predecible:
  - **Generación Proactiva:** El sistema ahora crea registros `Visit` con estado `PENDING` si detecta que una visita debería ocurrir en un día de la semana y aún no existe un registro para ella.
  - **Consistencia:** Esto asegura que tanto el Planificador del `ADMIN` como la "Ruta de Hoy" del `TECHNICIAN` operen sobre la misma fuente de datos (la tabla `Visit`), eliminando la fuente de errores anterior. Se ha validado que ahora el planificador muestra la semana completa correctamente.

---

## 3. Decisiones Arquitectónicas y Funcionales Clave

- **Flujo de Datos del Planificador:** Se ha decidido que el Planificador no solo "visualiza" eventos futuros, sino que **materializa las visitas** creando registros en la base de datos con estado `PENDING`. Esto simplifica enormemente la lógica de asignación y seguimiento.
- **Modelo de Notificaciones:** Se optó por un sistema de notificaciones **interno y basado en la base de datos**, en lugar de depender de servicios externos como el email. Esto nos da un control total sobre el flujo y la presentación de las alertas.
- **Modo Offline (PWA):** Sigue siendo una funcionalidad clave planificada para una fase posterior, utilizando Service Workers e IndexedDB.

---

## 4. Próximo Paso Inmediato: Interfaz de Notificaciones

La siguiente tarea es cerrar el bucle del "Reporte de Incidencias", haciendo que sean visibles para el `ADMIN`.

- **Objetivo:** Añadir un indicador visual de notificaciones en la interfaz del `ADMIN` y una vista para leerlas.
- **Plan de Acción:**
  1.  **Backend - API para Notificaciones:**
      - **Archivo:** Crear `packages/server/src/api/notifications/notifications.service.ts` y sus correspondientes controlador y rutas.
      - **Tarea:** Implementar un endpoint `GET /api/notifications` que devuelva las notificaciones del usuario logueado. Implementar otro endpoint `POST /api/notifications/:id/read` para marcarlas como leídas.
  2.  **Frontend - Componente de Notificaciones:**
      - **Archivo:** Modificar `packages/client/src/router/components.tsx` (`AppLayout`).
      - **Tarea:** Añadir un icono de "campana" en la cabecera. Este icono hará una llamada a la API de notificaciones y mostrará un punto rojo si hay notificaciones sin leer.
      - **Tarea:** Al hacer clic en la campana, se mostrará un `Popover` o `Menu` con la lista de mensajes. Al hacer clic en un mensaje, se marcará como leído.

---

## 5. Bloqueos Actuales

- **Ninguno.** El proyecto está completamente desbloqueado y en un estado excelente para continuar.



// ====== [3] README.md ======
# Documento de Especificación Funcional v2.1: Sistema "Pool-Control Professional"

**Documentos del Proyecto:**
[Ver Plan de Desarrollo](./DEVELOPMENT_PLAN.md) | [Ver Estado del Proyecto](./PROJECT_STATUS.md)

---

**Fecha:** 9 de julio de 2025
**Proyecto:** Plataforma Integral de Gestión para Empresas de Mantenimiento de Piscinas.

---

## 1. Visión y Objetivos de Negocio

**Pool-Control Professional** es una plataforma SaaS multi-tenant diseñada para ser el sistema nervioso central de una empresa de mantenimiento de piscinas. Su propósito es erradicar la ineficiencia, eliminar el papel, controlar los costes y elevar la calidad del servicio a través de la digitalización y automatización de todos los procesos operativos.

#### Objetivos Clave:

- **Eficiencia Operativa Absoluta:** Transformar horas de trabajo administrativo en minutos. La planificación de rutas, la generación de partes de trabajo y la recopilación de datos deben ser procesos automáticos o semi-automáticos.
- **Control Total de la Rentabilidad:** Proporcionar una visión clara y en tiempo real del consumo de productos por visita, por piscina y por cliente, permitiendo un control de costes y una facturación precisa.
- **Calidad de Servicio Estandarizada y Proactiva:** Garantizar que cada técnico realice exactamente los mismos procedimientos definidos para cada piscina y que cualquier desviación o incidencia sea notificada al instante, pasando de un modelo reactivo a uno proactivo.
- **Toma de Decisiones Basada en Datos:** Ofrecer a la gerencia KPIs y métricas fiables sobre la operativa del negocio para identificar puntos de mejora, clientes más rentables y técnicos más eficientes.

---

## 2. Definición de Roles y Flujos de Autorización

El sistema se estructura en torno a roles con permisos estrictos para garantizar la seguridad y la focalización de cada usuario en sus responsabilidades.

| Rol                  | Misión Principal                                  | Capacidades Clave                                                                                                                                                                                                                                                                                |
| -------------------- | ------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **SuperAdmin**       | Gestionar la plataforma y sus clientes (tenants). | CRUD completo sobre los **Tenants**. Gestión de suscripciones y ciclo de vida de las empresas que usan el software. No tiene visibilidad sobre los datos operativos (clientes, piscinas) de los tenants.                                                                                         |
| **Admin (Isa)**      | Configurar y dirigir la operativa de su empresa.  | Control absoluto sobre la configuración del tenant: **definir el catálogo de servicios**, gestionar clientes y piscinas, **diseñar las fichas de mantenimiento**, planificar rutas, y supervisar toda la operativa a través de un **centro de notificaciones**. Es el "arquitecto" del servicio. |
| **Técnico**          | Ejecutar el trabajo en campo de forma eficiente.  | Acceso exclusivo a su **ruta de trabajo del día**. Su única misión es ejecutar las visitas asignadas y rellenar los **partes de trabajo** con los datos requeridos. Interfaz 100% optimizada para móvil y diseñada para funcionar incluso en condiciones de baja conectividad (futuro).          |
| **Gerencia (Jorge)** | Supervisar la salud y rendimiento del negocio.    | Acceso de **solo lectura** a toda la configuración y datos operativos del `ADMIN`. Su objetivo es el análisis a través de dashboards y reportes, sin la capacidad de alterar ningún dato, garantizando la integridad de la información.                                                          |

---

## 3. Flujo de Trabajo y Especificación Funcional Detallada

El sistema está diseñado como un ciclo continuo donde la configuración define la ejecución y la ejecución retroalimenta la supervisión.

### **ETAPA 1: Configuración del Servicio (Rol: Admin)**

Esta etapa es el corazón del sistema. El `ADMIN` define "el qué, cómo y cuándo" del servicio que ofrece su empresa.

#### **Pantalla: Catálogo de Servicios (Parámetros y Tareas)**

- **Propósito:** Crear una librería centralizada de todas las acciones y mediciones que la empresa puede realizar. Este es el primer paso y la base de todo.
- **Funcionalidad:**
  - **Gestión de Parámetros:** El `ADMIN` crea plantillas para cada medición (ej. "Nivel de pH"). Para cada una, define su `Nombre`, `Unidad` y `Tipo de Input` (`NUMBER`, `BOOLEAN`, `TEXT` o `SELECT` con opciones).
  - **Gestión de Tareas:** El `ADMIN` crea plantillas para cada acción física (ej. "Limpieza de cestos de skimmers").

#### **Pantalla: Gestión de Clientes y Piscinas**

- **Propósito:** Gestionar la cartera de clientes y sus activos (las piscinas).
- **Funcionalidad:**
  - **CRUD de Clientes:** El `ADMIN` gestiona la base de datos de clientes.
  - **CRUD de Piscinas:** Dentro de la ficha de cada cliente, el `ADMIN` puede añadir múltiples piscinas.

#### **Pantalla: Constructor de Fichas de Mantenimiento (Pool Detail Page)**

- **Propósito:** Definir el "contrato de servicio" específico y único para **cada piscina**.
- **Flujo de Trabajo:** El `ADMIN` asocia ítems de los catálogos a la ficha de esa piscina y, para cada uno, establece las reglas de negocio: `Frecuencia` (¿Cada cuánto?) y `Umbrales de Alerta` (¿Cuál es el rango aceptable?).

### **ETAPA 2: Planificación y Ejecución (Roles: Admin y Técnico)**

#### **Pantalla: Planificador Semanal (Rol: Admin)**

- **Propósito:** Organizar la carga de trabajo de la semana y asignarla al equipo.
- **Flujo de Trabajo:** El sistema genera automáticamente las visitas pendientes según la frecuencia. El `ADMIN` las arrastra y suelta sobre el técnico y día deseado.

#### **Pantalla: Mi Ruta de Hoy (Rol: Técnico)**

- **Propósito:** Proporcionar al técnico un plan de acción diario, claro y directo.
- **Estado de Implementación:** `COMPLETADA Y OPERATIVA`.
- **Flujo de Trabajo:** Al iniciar sesión, el técnico ve una lista ordenada de sus visitas `PENDIENTES` para el día. La dirección es un enlace a Google Maps/Apple Maps y cada tarjeta de visita conduce al "Parte de Trabajo".

#### **Pantalla: Parte de Trabajo Dinámico (Rol: Técnico)**

- **Propósito:** Registrar los datos de la visita de forma rápida, estructurada y a prueba de errores.
- **Estado de Implementación:** `COMPLETADA Y OPERATIVA`.
- **Flujo de Trabajo:**
  1.  Al entrar, la página construye un **formulario dinámico** basado en la configuración de la piscina.
  2.  El técnico rellena los valores. La UI le proporciona feedback instantáneo si un valor está fuera de los umbrales.
  3.  **Reporte de Incidencias:** Junto a un campo de "Observaciones", el técnico dispone de un **checkbox "Reportar como Incidencia"**. Si lo marca, al guardar el parte se generará una notificación interna automática para el `ADMIN`, informándole del problema.
  4.  Al guardar, los datos se envían a la API, la visita se marca como `COMPLETED` y desaparece de la lista de tareas pendientes del técnico.
- **Mejora Futura Planificada:** Implementación de un **Modo Offline** (PWA) que permitirá rellenar y guardar el parte sin conexión a internet, sincronizándose automáticamente al recuperar la señal.

### **ETAPA 3: Supervisión y Análisis (Roles: Admin y Gerencia)**

#### **Pantalla: Centro de Notificaciones (Rol: Admin)**

- **Propósito:** Centralizar y gestionar las incidencias reportadas por los técnicos.
- **Estado de Implementación:** `EN DESARROLLO`.
- **Funcionalidad Prevista:** El `ADMIN` tendrá un icono de "campana" en la interfaz. Un indicador le avisará de nuevas notificaciones. Al hacer clic, podrá ver una lista de las incidencias, acceder a los detalles de la visita asociada y marcarlas como leídas o gestionadas.

#### **Pantalla: Dashboards y Reportes (Rol: Gerencia)**

- **Propósito:** Ofrecer una visión de alto nivel para la toma de decisiones estratégicas.
- **Funcionalidad Prevista:** Jorge, en modo **solo lectura**, accederá a paneles con KPIs sobre rentabilidad, costes, incidencias y rendimiento de los técnicos.



// ====== [4] package.json ======
{
  "name": "pool-control-professional",
  "private": true,
  "version": "1.0.0",
  "description": "SaaS para la gestión integral de empresas de mantenimiento de piscinas.",
  "author": "",
  "license": "ISC",
  "scripts": {
    "dev:server": "pnpm --filter @pool-control/server dev",
    "dev:client": "pnpm --filter @pool-control/client dev",
    "build": "pnpm --filter \"./packages/**\" build",
    "prisma:generate": "pnpm --filter @pool-control/server prisma:generate",
    "prisma:migrate": "pnpm --filter @pool-control/server prisma:migrate",
    "prisma:studio": "pnpm --filter @pool-control/server prisma:studio"
  },
  "devDependencies": {
    "typescript": "^5.4.5"
  },
  "engines": {
    "node": ">=20.0.0",
    "pnpm": ">=9.0.0"
  }
}


// ====== [5] packages/client/index.html ======
<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pool-Control Professional</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


// ====== [6] packages/client/package.json ======
{
  "name": "@pool-control/client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite --host",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "@dnd-kit/core": "^6.3.1",
    "@mantine/core": "^7.10.1",
    "@mantine/form": "^8.1.3",
    "@mantine/hooks": "^7.10.1",
    "axios": "^1.7.2",
    "date-fns": "^4.1.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.23.1"
  },
  "devDependencies": {
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@typescript-eslint/eslint-plugin": "^7.13.0",
    "@typescript-eslint/parser": "^7.13.0",
    "@vitejs/plugin-react": "^4.3.1",
    "eslint": "^8.57.0",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-react-refresh": "0.4.7",
    "typescript": "^5.4.5",
    "vite": "^5.3.1"
  }
}


// ====== [7] packages/client/src/App.tsx ======
import { MantineProvider } from '@mantine/core';
import { RouterProvider } from 'react-router-dom';
import { theme } from './styles/theme.js';
import { router } from './router/index.js';
import { AuthProvider } from './providers/AuthProvider.js';

// Importa los estilos base de Mantine
import '@mantine/core/styles.css';

function App() {
  return (
    <MantineProvider theme={theme}>
      <AuthProvider>
        <RouterProvider router={router} />
      </AuthProvider>
    </MantineProvider>
  );
}

export default App;


// ====== [8] packages/client/src/api/apiClient.ts ======
import axios from 'axios';

const apiClient = axios.create({
  // La URL base para todas las peticiones al API.
  // Gracias al proxy configurado en vite.config.ts, esto se
  // redirigirá a http://localhost:3001/api en desarrollo.
  baseURL: '/api',

  // Permite que axios envíe y reciba cookies (como nuestro token JWT)
  // en las peticiones a dominios diferentes.
  withCredentials: true,
});

export default apiClient;


// ====== [9] packages/client/src/features/admin/pages/ParameterCatalogPage.tsx ======
// filename: packages/client/src/features/admin/pages/ParameterCatalogPage.tsx
// Version: 1.2.0 (Implement TagsInput for SELECT options in the form)
import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  Select,
  TagsInput,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient.js';

// --- Tipos ---
const InputTypes = ['NUMBER', 'BOOLEAN', 'TEXT', 'SELECT'] as const;
type InputType = (typeof InputTypes)[number];

interface ParameterTemplate {
  id: string;
  name: string;
  unit: string | null;
  type: InputType;
  selectOptions: string[];
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function ParameterCatalogPage() {
  const [templates, setTemplates] = useState<ParameterTemplate[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingTemplate, setEditingTemplate] = useState<ParameterTemplate | null>(null);

  const form = useForm({
    initialValues: {
      name: '',
      unit: '',
      type: 'NUMBER' as InputType,
      selectOptions: [] as string[],
    },
    validate: {
      name: (value: string) => (value.trim().length < 2 ? 'El nombre es demasiado corto' : null),
      type: (value: string) => (InputTypes.includes(value as InputType) ? null : 'Tipo inválido'),
      selectOptions: (value: string[], values) => {
        if (values.type === 'SELECT' && value.length === 0) {
          return 'Debe definir al menos una opción para el tipo SELECT';
        }
        return null;
      }
    },
  });

  const fetchTemplates = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<ParameterTemplate[]>>('/parameters');
      setTemplates(response.data.data);
    } catch (err) {
      setError('No se pudo cargar el catálogo de parámetros.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchTemplates();
  }, []);

  const handleOpenModal = (template: ParameterTemplate | null = null) => {
    setEditingTemplate(template);
    if (template) {
      form.setValues({
        name: template.name,
        unit: template.unit || '',
        type: template.type,
        selectOptions: template.selectOptions || [],
      });
    } else {
      form.reset();
    }
    openModal();
  };

  const handleSubmit = async (values: typeof form.values) => {
    const payload = {
      ...values,
      selectOptions: values.type === 'SELECT' ? values.selectOptions : [],
    };
    try {
      if (editingTemplate) {
        await apiClient.patch(`/parameters/${editingTemplate.id}`, payload);
      } else {
        await apiClient.post('/parameters', payload);
      }
      await fetchTemplates();
      closeModal();
    } catch (err: any) {
      form.setErrors({ name: err.response?.data?.message || 'Error al guardar el parámetro' });
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('¿Estás seguro de que quieres eliminar este parámetro?')) {
      try {
        await apiClient.delete(`/parameters/${id}`);
        setTemplates((current) => current.filter((t) => t.id !== id));
      } catch (err) {
        // TODO: Mostrar notificación de error
        console.error('Failed to delete parameter', err);
      }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = templates.map((template) => (
    <Table.Tr key={template.id}>
      <Table.Td>{template.name}</Table.Td>
      <Table.Td>{template.unit || '-'}</Table.Td>
      <Table.Td>{template.type}</Table.Td>
      <Table.Td>
        <Group gap="xs">
          <Button variant="subtle" size="xs" onClick={() => handleOpenModal(template)}>Editar</Button>
          <Button variant="subtle" size="xs" color="red" onClick={() => handleDelete(template.id)}>Eliminar</Button>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingTemplate ? 'Editar Parámetro' : 'Crear Nuevo Parámetro'}
        centered
      >
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="Nombre del Parámetro" {...form.getInputProps('name')} />
            <TextInput label="Unidad (ej. ppm, pH, °C)" {...form.getInputProps('unit')} />
            <Select
              label="Tipo de Input"
              required
              data={InputTypes as unknown as string[]}
              {...form.getInputProps('type')}
            />
            {form.values.type === 'SELECT' && (
              <TagsInput
                label="Opciones del Select"
                placeholder="Añade opciones y presiona Enter"
                description="Escribe una opción y presiona Enter para añadirla a la lista."
                required
                {...form.getInputProps('selectOptions')}
              />
            )}
            <Button type="submit" mt="md">{editingTemplate ? 'Guardar Cambios' : 'Crear Parámetro'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Catálogo de Parámetros</Title>
          <Button onClick={() => handleOpenModal()}>Crear Nuevo Parámetro</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Unidad</Table.Th>
              <Table.Th>Tipo</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={4}>No hay parámetros definidos en el catálogo.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [10] packages/client/src/features/admin/pages/TaskCatalogPage.tsx ======
// filename: packages/client/src/features/admin/pages/TaskCatalogPage.tsx
// Version: 1.0.0 (Initial implementation of the task template catalog page with full CRUD)
import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  Textarea,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient.js';

// --- Tipos ---
interface TaskTemplate {
  id: string;
  name: string;
  description: string | null;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function TaskCatalogPage() {
  const [templates, setTemplates] = useState<TaskTemplate[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingTemplate, setEditingTemplate] = useState<TaskTemplate | null>(null);

  const form = useForm({
    initialValues: {
      name: '',
      description: '',
    },
    validate: {
      name: (value: string) => (value.trim().length < 2 ? 'El nombre es demasiado corto' : null),
    },
  });

  const fetchTemplates = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<TaskTemplate[]>>('/tasks');
      setTemplates(response.data.data);
    } catch (err) {
      setError('No se pudo cargar el catálogo de tareas.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchTemplates();
  }, []);

  const handleOpenModal = (template: TaskTemplate | null = null) => {
    setEditingTemplate(template);
    if (template) {
      form.setValues({
        name: template.name,
        description: template.description || '',
      });
    } else {
      form.reset();
    }
    openModal();
  };

  const handleSubmit = async (values: typeof form.values) => {
    try {
      if (editingTemplate) {
        await apiClient.patch(`/tasks/${editingTemplate.id}`, values);
      } else {
        await apiClient.post('/tasks', values);
      }
      await fetchTemplates();
      closeModal();
    } catch (err: any) {
      form.setErrors({ name: err.response?.data?.message || 'Error al guardar la tarea' });
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('¿Estás seguro de que quieres eliminar esta tarea?')) {
      try {
        await apiClient.delete(`/tasks/${id}`);
        setTemplates((current) => current.filter((t) => t.id !== id));
      } catch (err) {
        // TODO: Mostrar notificación de error
        console.error('Failed to delete task', err);
      }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = templates.map((template) => (
    <Table.Tr key={template.id}>
      <Table.Td>{template.name}</Table.Td>
      <Table.Td>{template.description || '-'}</Table.Td>
      <Table.Td>
        <Group gap="xs">
          <Button variant="subtle" size="xs" onClick={() => handleOpenModal(template)}>Editar</Button>
          <Button variant="subtle" size="xs" color="red" onClick={() => handleDelete(template.id)}>Eliminar</Button>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingTemplate ? 'Editar Tarea' : 'Crear Nueva Tarea'}
        centered
      >
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="Nombre de la Tarea" {...form.getInputProps('name')} />
            <Textarea label="Descripción (opcional)" {...form.getInputProps('description')} />
            <Button type="submit" mt="md">{editingTemplate ? 'Guardar Cambios' : 'Crear Tarea'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Catálogo de Tareas</Title>
          <Button onClick={() => handleOpenModal()}>Crear Nueva Tarea</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Descripción</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={3}>No hay tareas definidas en el catálogo.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [11] packages/client/src/features/admin/pages/clients/ClientDetailPage.tsx ======
// filename: packages/client/src/features/admin/pages/clients/ClientDetailPage.tsx
// Version: 1.2.0 (Make pool names link to their future detail page)
import { useEffect, useState } from 'react';
import { useParams, Link } from 'react-router-dom';
import {
  Container,
  Title,
  Loader,
  Alert,
  Button,
  Group,
  Paper,
  Text,
  Table,
  Breadcrumbs,
  Modal,
  TextInput,
  Stack,
  NumberInput,
  Select,
  Anchor,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../../api/apiClient.js';

// --- Tipos ---
interface Pool {
  id: string;
  name: string;
  address: string;
  volume: number | null;
  type: string | null;
}

interface Client {
  id: string;
  name: string;
  contactPerson: string | null;
  email: string | null;
  phone: string | null;
  address: string | null;
  pools: Pool[];
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function ClientDetailPage() {
  const { id: clientId } = useParams<{ id: string }>();
  const [client, setClient] = useState<Client | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingPool, setEditingPool] = useState<Pool | null>(null);

  const poolForm = useForm({
    initialValues: {
      name: '',
      address: '',
      volume: null as number | null,
      type: '',
    },
    validate: {
      name: (value) => (value.trim().length < 2 ? 'El nombre es demasiado corto' : null),
      address: (value) => (value.trim().length < 5 ? 'La dirección es demasiado corta' : null),
    },
  });

  const fetchClient = async () => {
    if (!clientId) return;
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<Client>>(`/clients/${clientId}`);
      setClient(response.data.data);
    } catch (err) {
      setError('No se pudo cargar la información del cliente.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchClient();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [clientId]);

  const handleOpenModal = (pool: Pool | null = null) => {
    setEditingPool(pool);
    if (pool) {
      poolForm.setValues({
        name: pool.name,
        address: pool.address,
        volume: pool.volume,
        type: pool.type || '',
      });
    } else {
      poolForm.reset();
    }
    openModal();
  };

  const handlePoolSubmit = async (values: typeof poolForm.values) => {
    if (!clientId) return;
    try {
      const payload = { ...values, clientId };
      if (editingPool) {
        await apiClient.patch(`/pools/${editingPool.id}`, payload);
      } else {
        await apiClient.post('/pools', payload);
      }
      await fetchClient();
      closeModal();
    } catch (err: any) {
      poolForm.setErrors({ name: err.response?.data?.message || 'Error al guardar la piscina' });
    }
  };

  const handlePoolDelete = async (poolId: string) => {
    if (window.confirm('¿Estás seguro de que quieres eliminar esta piscina?')) {
      try {
        await apiClient.delete(`/pools/${poolId}`);
        await fetchClient();
      } catch (err) {
        console.error('Failed to delete pool', err);
      }
    }
  };


  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;
  if (!client) return <Alert color="yellow" title="Aviso">Cliente no encontrado.</Alert>;

  const breadcrumbs = (
    <Breadcrumbs>
      <Link to="/clients">Clientes</Link>
      <Text>{client.name}</Text>
    </Breadcrumbs>
  );

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingPool ? 'Editar Piscina' : 'Crear Nueva Piscina'}
        centered
      >
        <form onSubmit={poolForm.onSubmit(handlePoolSubmit)}>
          <Stack>
            <TextInput required label="Nombre de la Piscina" placeholder="Ej. Piscina Principal" {...poolForm.getInputProps('name')} />
            <TextInput required label="Dirección de la Piscina" {...poolForm.getInputProps('address')} />
            <NumberInput label="Volumen (m³)" placeholder="Ej. 50" min={0} {...poolForm.getInputProps('volume')} />
            <Select label="Tipo de Piscina" data={['Cloro', 'Sal']} {...poolForm.getInputProps('type')} />
            <Button type="submit" mt="md">{editingPool ? 'Guardar Cambios' : 'Crear Piscina'}</Button>
          </Stack>
        </form>
      </Modal>
    
      <Container fluid>
        {breadcrumbs}
        <Title order={2} my="lg">{client.name}</Title>
        <Paper withBorder p="md" mb="xl">
          <Title order={4} mb="xs">Información de Contacto</Title>
          <Text><strong>Persona de contacto:</strong> {client.contactPerson || '-'}</Text>
          <Text><strong>Email:</strong> {client.email || '-'}</Text>
          <Text><strong>Teléfono:</strong> {client.phone || '-'}</Text>
          <Text><strong>Dirección de facturación:</strong> {client.address || '-'}</Text>
        </Paper>
        
        <Group justify="space-between" align="center" mb="md">
          <Title order={3}>Piscinas</Title>
          <Button onClick={() => handleOpenModal()}>Crear Nueva Piscina</Button>
        </Group>

        <Table striped withTableBorder>
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Dirección</Table.Th>
              <Table.Th>Volumen (m³)</Table.Th>
              <Table.Th>Tipo</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>
            {client.pools.length > 0 ? (
              client.pools.map(pool => (
                <Table.Tr key={pool.id}>
                  <Table.Td>
                    <Anchor component={Link} to={`/pools/${pool.id}`}>
                      {pool.name}
                    </Anchor>
                  </Table.Td>
                  <Table.Td>{pool.address}</Table.Td>
                  <Table.Td>{pool.volume || '-'}</Table.Td>
                  <Table.Td>{pool.type || '-'}</Table.Td>
                  <Table.Td>
                    <Group gap="xs">
                      <Button variant="subtle" size="xs" onClick={() => handleOpenModal(pool)}>Editar</Button>
                      <Button variant="subtle" size="xs" color="red" onClick={() => handlePoolDelete(pool.id)}>Eliminar</Button>
                    </Group>
                  </Table.Td>
                </Table.Tr>
              ))
            ) : (
              <Table.Tr><Table.Td colSpan={5}>Este cliente no tiene piscinas asociadas.</Table.Td></Table.Tr>
            )}
          </Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [12] packages/client/src/features/admin/pages/clients/ClientsPage.tsx ======
// filename: packages/client/src/features/admin/pages/clients/ClientsPage.tsx
// Version: 1.1.0 (Make client names link to their detail page)
import { useEffect, useState } from 'react';
import { Link } from 'react-router-dom';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  NumberInput,
  Anchor,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../../api/apiClient.js';

// --- Tipos ---
interface Client {
  id: string;
  name: string;
  contactPerson: string | null;
  email: string | null;
  phone: string | null;
  address: string | null;
  priceModifier: number;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function ClientsPage() {
  const [clients, setClients] = useState<Client[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingClient, setEditingClient] = useState<Client | null>(null);

  const form = useForm({
    initialValues: {
      name: '',
      contactPerson: '',
      email: '',
      phone: '',
      address: '',
      priceModifier: 1.0,
    },
    validate: {
      name: (value) => (value.trim().length < 2 ? 'El nombre es demasiado corto' : null),
      email: (value) => (value && !/^\S+@\S+$/.test(value) ? 'Email inválido' : null),
      priceModifier: (value) => (value <= 0 ? 'El modificador debe ser mayor que 0' : null),
    },
  });

  const fetchClients = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<Client[]>>('/clients');
      setClients(response.data.data);
    } catch (err) {
      setError('No se pudo cargar la lista de clientes.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchClients();
  }, []);

  const handleOpenModal = (client: Client | null = null) => {
    setEditingClient(client);
    if (client) {
      form.setValues({
        name: client.name,
        contactPerson: client.contactPerson || '',
        email: client.email || '',
        phone: client.phone || '',
        address: client.address || '',
        priceModifier: client.priceModifier,
      });
    } else {
      form.reset();
    }
    openModal();
  };

  const handleSubmit = async (values: typeof form.values) => {
    try {
      if (editingClient) {
        await apiClient.patch(`/clients/${editingClient.id}`, values);
      } else {
        await apiClient.post('/clients', values);
      }
      await fetchClients();
      closeModal();
    } catch (err: any) {
      form.setErrors({ name: err.response?.data?.message || 'Error al guardar el cliente' });
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('¿Estás seguro de que quieres eliminar este cliente? Se borrarán también todas sus piscinas asociadas.')) {
      try {
        await apiClient.delete(`/clients/${id}`);
        setClients((current) => current.filter((c) => c.id !== id));
      } catch (err) {
        console.error('Failed to delete client', err);
      }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = clients.map((client) => (
    <Table.Tr key={client.id}>
      <Table.Td>
        <Anchor component={Link} to={`/clients/${client.id}`}>
          {client.name}
        </Anchor>
      </Table.Td>
      <Table.Td>{client.contactPerson || '-'}</Table.Td>
      <Table.Td>{client.phone || '-'}</Table.Td>
      <Table.Td>{client.email || '-'}</Table.Td>
      <Table.Td>
        <Group gap="xs">
          <Button variant="subtle" size="xs" onClick={() => handleOpenModal(client)}>Editar</Button>
          <Button variant="subtle" size="xs" color="red" onClick={() => handleDelete(client.id)}>Eliminar</Button>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingClient ? 'Editar Cliente' : 'Crear Nuevo Cliente'}
        centered
      >
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="Nombre del Cliente" {...form.getInputProps('name')} />
            <TextInput label="Persona de Contacto" {...form.getInputProps('contactPerson')} />
            <TextInput label="Email" type="email" {...form.getInputProps('email')} />
            <TextInput label="Teléfono" {...form.getInputProps('phone')} />
            <TextInput label="Dirección" {...form.getInputProps('address')} />
            <NumberInput 
              label="Modificador de Precio" 
              description="1.0 es normal, 0.9 es 10% dto, 1.1 es 10% recargo." 
              defaultValue={1.0} 
              step={0.05} 
              min={0} 
              decimalScale={2} 
              {...form.getInputProps('priceModifier')} 
            />
            <Button type="submit" mt="md">{editingClient ? 'Guardar Cambios' : 'Crear Cliente'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Gestión de Clientes</Title>
          <Button onClick={() => handleOpenModal()}>Crear Nuevo Cliente</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Contacto</Table.Th>
              <Table.Th>Teléfono</Table.Th>
              <Table.Th>Email</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={5}>No hay clientes creados.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [13] packages/client/src/features/admin/pages/planner/PlannerPage.tsx ======
// filename: packages/client/src/features/admin/pages/planner/PlannerPage.tsx
// Version: 1.4.1 (Fix typing errors and clean up unused variables)
import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Loader,
  Alert,
  Paper,
  Text,
  Grid,
  Card,
  Group,
  ActionIcon,
  Stack,
  Badge,
} from '@mantine/core';
import { useAuth } from '../../../../providers/AuthProvider.js';
import apiClient from '../../../../api/apiClient.js';
import { startOfWeek, endOfWeek, format, addDays, subDays } from 'date-fns';
import { es } from 'date-fns/locale';
import { DndContext, useDraggable, useDroppable } from '@dnd-kit/core';
import type { DragEndEvent } from '@dnd-kit/core';

// --- Tipos ---
interface Visit {
  id: string;
  timestamp: string;
  status: 'PENDING' | 'COMPLETED' | 'CANCELLED';
  pool: { name: string; client: { name: string; }; };
  technicianId: string | null;
}
interface Technician { id: string; name: string; }
interface ApiResponse<T> { success: boolean; data: T; }

// --- Componentes de Drag and Drop ---
function DraggableVisit({ visit }: { visit: Visit }) {
  const { attributes, listeners, setNodeRef, transform } = useDraggable({ id: visit.id, data: visit });
  const style = transform ? { transform: `translate3d(${transform.x}px, ${transform.y}px, 0)`, zIndex: 100 } : undefined;
  const visitDate = new Date(visit.timestamp);

  return (
    <div ref={setNodeRef} style={style} {...listeners} {...attributes}>
      <Card shadow="sm" p="xs" withBorder>
        <Group justify="space-between">
          <Text fw={500}>{visit.pool.name}</Text>
          {visit.status === 'COMPLETED' && <Badge size="sm" color="green">OK</Badge>}
        </Group>
        <Text size="sm" c="dimmed">{visit.pool.client.name}</Text>
        <Text size="xs" mt={4}>{format(visitDate, 'eeee d', { locale: es })}</Text>
      </Card>
    </div>
  );
}

function DroppableArea({ id, children, title }: { id: string; children: React.ReactNode; title: string }) {
  const { setNodeRef, isOver } = useDroppable({ id });
  return (
    <Paper ref={setNodeRef} withBorder p="sm" style={{ minHeight: 400, backgroundColor: isOver ? '#e7f5ff' : '#f1f3f5', transition: 'background-color 0.2s ease' }}>
      <Title order={5} ta="center" mb="md">{title}</Title>
      <Stack>{children}</Stack>
    </Paper>
  );
}

// --- Componente Principal ---
export function PlannerPage() {
  const { user } = useAuth();
  const [visits, setVisits] = useState<Visit[]>([]);
  const [technicians, setTechnicians] = useState<Technician[]>([]);
  const [currentDate, setCurrentDate] = useState(new Date());
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const weekStart = startOfWeek(currentDate, { weekStartsOn: 1 });
  const weekEnd = endOfWeek(currentDate, { weekStartsOn: 1 });

  const fetchData = async () => {
    if (!user) return;
    setIsLoading(true);
    try {
      const [visitsRes, techsRes] = await Promise.all([
        apiClient.get<ApiResponse<Visit[]>>('/visits/scheduled', { params: { date: currentDate.toISOString() } }),
        apiClient.get<ApiResponse<Technician[]>>('/users/technicians'),
      ]);
      setVisits(visitsRes.data.data);
      setTechnicians(techsRes.data.data);
    } catch (err) { setError('No se pudo cargar la planificación.'); } finally { setIsLoading(false); }
  };

  useEffect(() => { fetchData(); // eslint-disable-next-line
  }, [currentDate, user]);

  const handleDragEnd = async (event: DragEndEvent) => {
    const { over, active } = event;
    if (!over) return;

    const visitId = active.id as string;
    const targetId = String(over.id);
    const [type, id] = targetId.split('-');

    let technicianId: string | null = null;
    
    // CORRECCIÓN: Aseguramos que technicianId sea siempre string o null.
    if (type === 'tech' && id) {
        technicianId = id;
    }

    const originalVisits = [...visits];
    const visitToUpdate = visits.find(v => v.id === visitId);
    if (!visitToUpdate || visitToUpdate.technicianId === technicianId) return;

    setVisits(prev => prev.map(v => v.id === visitId ? { ...v, technicianId } : v));

    try {
      await apiClient.post('/visits/assign', { visitId, technicianId });
    } catch (err) {
      setError('No se pudo asignar la visita.');
      setVisits(originalVisits);
    }
  };

  if (isLoading) return <Loader size="xl" />;
  
  const weekRange = `${format(weekStart, 'd')} - ${format(weekEnd, 'd MMMM yyyy', { locale: es })}`;

  return (
    <DndContext onDragEnd={handleDragEnd}>
      <Container fluid>
        {error && <Alert color="red" title="Error" mb="md">{error}</Alert>}
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Planificador Semanal</Title>
          <Group>
            <ActionIcon variant="default" onClick={() => setCurrentDate(subDays(currentDate, 7))}>{'<'}</ActionIcon>
            <Text size="lg" fw={500}>{weekRange}</Text>
            <ActionIcon variant="default" onClick={() => setCurrentDate(addDays(currentDate, 7))}>{'<'}</ActionIcon>
          </Group>
        </Group>

        <Grid grow>
          <Grid.Col span={{ base: 12, md: 2 }}>
            <DroppableArea id="tech-null" title="Visitas Pendientes">
              {visits.filter(v => !v.technicianId).map(visit => <DraggableVisit key={visit.id} visit={visit} />)}
            </DroppableArea>
          </Grid.Col>

          <Grid.Col span={{ base: 12, md: 10 }}>
            <Grid>
              {technicians.map(tech => (
                <Grid.Col key={tech.id} span={{ base: 12, md: 6, lg: 4 }}>
                   <DroppableArea id={`tech-${tech.id}`} title={tech.name}>
                    {visits
                      .filter(v => v.technicianId === tech.id)
                      .map(visit => <DraggableVisit key={visit.id} visit={visit} />)
                    }
                   </DroppableArea>
                </Grid.Col>
              ))}
            </Grid>
          </Grid.Col>
        </Grid>
      </Container>
    </DndContext>
  );
}


// ====== [14] packages/client/src/features/admin/pages/pools/PoolDetailPage.tsx ======
// filename: packages/client/src/features/admin/pages/pools/PoolDetailPage.tsx
// Version: 1.2.0 (Implement Edit functionality for Pool Configurations)
import { useEffect, useState } from 'react';
import { useParams, Link } from 'react-router-dom';
import {
  Container,
  Title,
  Loader,
  Alert,
  Paper,
  Text,
  Table,
  Breadcrumbs,
  Grid,
  Card,
  Button,
  Group,
  Modal,
  Select,
  NumberInput,
  Stack,
  Menu,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../../api/apiClient.js';

// --- Tipos ---
const Frequencies = ['DIARIA', 'SEMANAL', 'QUINCENAL', 'MENSUAL', 'TRIMESTRAL', 'SEMESTRAL', 'ANUAL'] as const;
type Frequency = (typeof Frequencies)[number];

interface Pool { id: string; name: string; clientId: string; }
interface ParameterTemplate { id: string; name: string; unit: string | null; type: 'NUMBER' | 'BOOLEAN' | 'TEXT' | 'SELECT'; }
interface TaskTemplate { id: string; name: string; }
interface PoolConfiguration {
  id: string;
  frequency: Frequency;
  minThreshold: number | null;
  maxThreshold: number | null;
  parameterTemplate?: ParameterTemplate;
  taskTemplate?: TaskTemplate;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function PoolDetailPage() {
  const { id: poolId } = useParams<{ id: string }>();
  const [pool, ] = useState<Pool | null>(null);
  const [configurations, setConfigurations] = useState<PoolConfiguration[]>([]);
  const [parameterCatalog, setParameterCatalog] = useState<ParameterTemplate[]>([]);
  const [taskCatalog, setTaskCatalog] = useState<TaskTemplate[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  // Estado para saber qué estamos configurando (un nuevo ítem o editando uno existente)
  const [editingConfig, setEditingConfig] = useState<PoolConfiguration | null>(null);
  const [itemToAdd, setItemToAdd] = useState<{ id: string; name: string; type: 'parameter' | 'task' } | null>(null);

  const configForm = useForm({
    initialValues: {
      frequency: 'SEMANAL' as Frequency,
      minThreshold: null as number | null,
      maxThreshold: null as number | null,
    },
    validate: {
      frequency: (value) => (Frequencies.includes(value) ? null : 'Frecuencia inválida'),
    },
  });

  const fetchData = async () => {
    if (!poolId) return;
    setIsLoading(true);
    try {
      const [configsRes, paramsRes, tasksRes] = await Promise.all([
        apiClient.get<ApiResponse<PoolConfiguration[]>>(`/pool-configurations/by-pool/${poolId}`),
        apiClient.get<ApiResponse<ParameterTemplate[]>>('/parameters'),
        apiClient.get<ApiResponse<TaskTemplate[]>>('/tasks'),
      ]);
      setConfigurations(configsRes.data.data);
      setParameterCatalog(paramsRes.data.data);
      setTaskCatalog(tasksRes.data.data);
    } catch (err) {
      setError('No se pudo cargar la configuración de la piscina.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [poolId]);

  const handleOpenModal = (config: PoolConfiguration | null, item: { id: string; name: string; } | null, type: 'parameter' | 'task' | null) => {
    setEditingConfig(config);
    setItemToAdd(item ? { ...item, type: type as 'parameter' | 'task' } : null);
    
    if (config) { // Estamos editando
      configForm.setValues({
        frequency: config.frequency,
        minThreshold: config.minThreshold,
        maxThreshold: config.maxThreshold,
      });
    } else { // Estamos creando
      configForm.reset();
    }
    openModal();
  };

  const handleConfigSubmit = async (values: typeof configForm.values) => {
    if (!poolId) return;
    try {
      if (editingConfig) { // Lógica para actualizar
        const payload = { frequency: values.frequency, minThreshold: values.minThreshold, maxThreshold: values.maxThreshold };
        await apiClient.patch(`/pool-configurations/${editingConfig.id}`, payload);
      } else if (itemToAdd) { // Lógica para crear
        const payload = {
          poolId,
          frequency: values.frequency,
          ...(itemToAdd.type === 'parameter' && { parameterTemplateId: itemToAdd.id, minThreshold: values.minThreshold, maxThreshold: values.maxThreshold }),
          ...(itemToAdd.type === 'task' && { taskTemplateId: itemToAdd.id }),
        };
        await apiClient.post('/pool-configurations', payload);
      }
      await fetchData();
      closeModal();
    } catch (err: any) {
      configForm.setErrors({ frequency: err.response?.data?.message || 'Error al guardar la configuración' });
    }
  };
  
  const handleConfigDelete = async (configId: string) => {
    if (window.confirm('¿Estás seguro de que quieres quitar este ítem de la ficha?')) {
      try {
        await apiClient.delete(`/pool-configurations/${configId}`);
        await fetchData();
      } catch (err) {}
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const currentItem = editingConfig?.parameterTemplate || editingConfig?.taskTemplate || itemToAdd;
  const modalTitle = editingConfig ? `Editar: ${currentItem?.name}` : `Añadir: ${currentItem?.name}`;
  const isParameter = (editingConfig && editingConfig.parameterTemplate) || (itemToAdd?.type === 'parameter');
  
  const breadcrumbs = (
    <Breadcrumbs>
      <Link to="/clients">Clientes</Link>
      <Text>Cliente (TODO)</Text>
      <Text>{pool?.name || 'Piscina'}</Text>
    </Breadcrumbs>
  );

  return (
    <>
      <Modal opened={modalOpened} onClose={closeModal} title={modalTitle} centered>
        <form onSubmit={configForm.onSubmit(handleConfigSubmit)}>
          <Stack>
            <Select label="Frecuencia" required data={[...Frequencies]} {...configForm.getInputProps('frequency')} />
            {isParameter && (
              <>
                <NumberInput label="Umbral Mínimo (opcional)" {...configForm.getInputProps('minThreshold')} />
                <NumberInput label="Umbral Máximo (opcional)" {...configForm.getInputProps('maxThreshold')} />
              </>
            )}
            <Button type="submit" mt="md">{editingConfig ? 'Guardar Cambios' : 'Añadir a la Ficha'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        {breadcrumbs}
        <Title order={2} my="lg">Constructor de Ficha: {pool?.name || ''}</Title>
        <Grid>
          <Grid.Col span={{ base: 12, md: 6 }}>
            <Paper withBorder p="md">
              <Title order={4} mb="md">Ficha de Mantenimiento Actual</Title>
              <Table>
                <Table.Thead><Table.Tr><Table.Th>Ítem</Table.Th><Table.Th>Frecuencia</Table.Th><Table.Th>Acciones</Table.Th></Table.Tr></Table.Thead>
                <Table.Tbody>
                  {configurations.length > 0 ? configurations.map(config => (
                    <Table.Tr key={config.id}>
                      <Table.Td>{config.parameterTemplate?.name || config.taskTemplate?.name}</Table.Td>
                      <Table.Td>{config.frequency}</Table.Td>
                      <Table.Td>
                        <Menu shadow="md" width={200}>
                          <Menu.Target><Button variant="outline" size="xs">Acciones</Button></Menu.Target>
                          <Menu.Dropdown>
                            <Menu.Item onClick={() => handleOpenModal(config, null, null)}>Editar</Menu.Item>
                            <Menu.Item color="red" onClick={() => handleConfigDelete(config.id)}>Quitar</Menu.Item>
                          </Menu.Dropdown>
                        </Menu>
                      </Table.Td>
                    </Table.Tr>
                  )) : <Table.Tr><Table.Td colSpan={3}>La ficha está vacía. Añade ítems desde los catálogos.</Table.Td></Table.Tr>}
                </Table.Tbody>
              </Table>
            </Paper>
          </Grid.Col>

          <Grid.Col span={{ base: 12, md: 6 }}>
            <Paper withBorder p="md" mb="md">
              <Title order={4} mb="md">Catálogo de Parámetros Disponibles</Title>
              {parameterCatalog.map(param => (
                <Card key={param.id} shadow="sm" p="sm" mb="xs" withBorder>
                  <Group justify="space-between">
                    <Text>{param.name} {param.unit ? `(${param.unit})` : ''}</Text>
                    <Button size="xs" onClick={() => handleOpenModal(null, param, 'parameter')}>Añadir</Button>
                  </Group>
                </Card>
              ))}
            </Paper>
            <Paper withBorder p="md">
              <Title order={4} mb="md">Catálogo de Tareas Disponibles</Title>
              {taskCatalog.map(task => (
                <Card key={task.id} shadow="sm" p="sm" mb="xs" withBorder>
                  <Group justify="space-between">
                    <Text>{task.name}</Text>
                    <Button size="xs" onClick={() => handleOpenModal(null, task, 'task')}>Añadir</Button>
                  </Group>
                </Card>
              ))}
            </Paper>
          </Grid.Col>
        </Grid>
      </Container>
    </>
  );
}


// ====== [15] packages/client/src/features/auth/pages/LoginPage.tsx ======
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Container,
  Title,
  Paper,
  TextInput,
  PasswordInput,
  Button,
  Stack,
  Alert,
} from '@mantine/core';
import { useAuth } from '../../../providers/AuthProvider.js';

export function LoginPage() {
  const { login } = useAuth();
  const navigate = useNavigate();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setError(null);
    try {
      await login({ email, password });
      navigate('/'); // Redirige al dashboard en un login exitoso
    } catch (err) {
      setError('El email o la contraseña son incorrectos.');
      console.error(err);
    }
  };

  return (
    <Container size={420} my={40}>
      <Title ta="center">¡Bienvenido!</Title>
      <Paper withBorder shadow="md" p={30} mt={30} radius="md">
        <form onSubmit={handleSubmit}>
          <Stack>
            <TextInput
              required
              label="Email"
              placeholder="tu@email.com"
              value={email}
              onChange={(event) => setEmail(event.currentTarget.value)}
              radius="md"
            />
            <PasswordInput
              required
              label="Contraseña"
              placeholder="Tu contraseña"
              value={password}
              onChange={(event) => setPassword(event.currentTarget.value)}
              radius="md"
            />
            {error && (
              <Alert title="Error de autenticación" color="red" withCloseButton onClose={() => setError(null)}>
                {error}
              </Alert>
            )}
            <Button type="submit" fullWidth mt="xl" radius="md">
              Iniciar Sesión
            </Button>
          </Stack>
        </form>
      </Paper>
    </Container>
  );
}


// ====== [16] packages/client/src/features/superadmin/pages/TenantsPage.tsx ======
import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Badge,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  PasswordInput,
  Menu,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient.js';

// --- Tipos ---
type SubscriptionStatus = 'TRIAL' | 'ACTIVE' | 'PAYMENT_PENDING' | 'INACTIVE';

interface Tenant {
  id: string;
  companyName: string;
  subdomain: string;
  subscriptionStatus: SubscriptionStatus;
  createdAt: string;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function TenantsPage() {
  const [tenants, setTenants] = useState<Tenant[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);

  const form = useForm({
    initialValues: {
      companyName: '',
      subdomain: '',
      adminUser: {
        name: '',
        email: '',
        password: '',
      },
    },
    validate: {
      companyName: (value: string) => (value.length < 2 ? 'El nombre debe tener al menos 2 caracteres' : null),
      subdomain: (value: string) => (/^[a-z0-9]+(?:-[a-z0-9]+)*$/.test(value) ? null : 'Subdominio inválido'),
      adminUser: {
        email: (value: string) => (/^\S+@\S+$/.test(value) ? null : 'Email inválido'),
        password: (value: string) => (value.length < 8 ? 'La contraseña debe tener al menos 8 caracteres' : null),
      },
    },
  });

  const fetchTenants = async () => {
    if (tenants.length === 0) setIsLoading(true);
    setError(null);
    try {
      const response = await apiClient.get<ApiResponse<Tenant[]>>('/tenants');
      setTenants(response.data.data);
    } catch (err) {
      setError('No se pudo obtener la lista de tenants.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchTenants();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handleCreateTenant = async (values: typeof form.values) => {
    try {
      await apiClient.post<ApiResponse<Tenant>>('/tenants', values);
      await fetchTenants();
      closeModal();
      form.reset();
    } catch (err: any) {
      form.setErrors({ companyName: err.response?.data?.message || 'Error al crear el tenant' });
    }
  };

  const handleUpdateStatus = async (tenantId: string, status: SubscriptionStatus) => {
    try {
      setTenants((current) =>
        current.map((t) => (t.id === tenantId ? { ...t, subscriptionStatus: status } : t))
      );
      await apiClient.patch(`/tenants/${tenantId}/status`, { status });
    } catch (err) {
      console.error('Failed to update tenant status', err);
      await fetchTenants();
    }
  };

  const handleDeleteTenant = async (tenantId: string) => {
    if (window.confirm('¿Estás seguro? Esta acción eliminará el tenant y todos sus datos (usuarios, clientes, piscinas, etc.) de forma irreversible.')) {
      try {
        await apiClient.delete(`/tenants/${tenantId}`);
        setTenants((current) => current.filter((t) => t.id !== tenantId));
      } catch (err) {
        console.error('Failed to delete tenant', err);
        // TODO: Mostrar notificación de error al usuario
      }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = tenants.map((tenant) => (
    <Table.Tr key={tenant.id}>
      <Table.Td>{tenant.companyName}</Table.Td>
      <Table.Td>{tenant.subdomain}.pool-control.pro</Table.Td>
      <Table.Td>
        <Badge
          color={
            {
              ACTIVE: 'green',
              TRIAL: 'blue',
              PAYMENT_PENDING: 'orange',
              INACTIVE: 'gray',
            }[tenant.subscriptionStatus]
          }
        >
          {tenant.subscriptionStatus}
        </Badge>
      </Table.Td>
      <Table.Td>{new Date(tenant.createdAt).toLocaleDateString()}</Table.Td>
      <Table.Td>
        <Menu shadow="md" width={200}>
          <Menu.Target>
            <Button variant="outline" size="xs">Acciones</Button>
          </Menu.Target>
          <Menu.Dropdown>
            <Menu.Label>Cambiar estado</Menu.Label>
            <Menu.Item onClick={() => handleUpdateStatus(tenant.id, 'ACTIVE')}>Activar</Menu.Item>
            <Menu.Item onClick={() => handleUpdateStatus(tenant.id, 'TRIAL')}>Poner en Trial</Menu.Item>
            <Menu.Item onClick={() => handleUpdateStatus(tenant.id, 'PAYMENT_PENDING')}>Pago Pendiente</Menu.Item>
            <Menu.Item onClick={() => handleUpdateStatus(tenant.id, 'INACTIVE')}>Desactivar</Menu.Item>
            <Menu.Divider />
            <Menu.Label>Zona de Peligro</Menu.Label>
            <Menu.Item color="red" onClick={() => handleDeleteTenant(tenant.id)}>
              Eliminar Tenant
            </Menu.Item>
          </Menu.Dropdown>
        </Menu>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal opened={modalOpened} onClose={closeModal} title="Crear Nuevo Tenant" centered>
        <form onSubmit={form.onSubmit(handleCreateTenant)}>
          <Stack>
            <TextInput required label="Nombre de la Empresa" placeholder="Ej. Piscinas Martínez" {...form.getInputProps('companyName')} />
            <TextInput required label="Subdominio" placeholder="ej. martinez" {...form.getInputProps('subdomain')} />
            <Title order={4} mt="md">Usuario Administrador</Title>
            <TextInput required label="Nombre del Admin" placeholder="Ej. Juan Martínez" {...form.getInputProps('adminUser.name')} />
            <TextInput required label="Email del Admin" placeholder="ej. juan@piscinasmartinez.com" {...form.getInputProps('adminUser.email')} />
            <PasswordInput required label="Contraseña del Admin" {...form.getInputProps('adminUser.password')} />
            <Button type="submit" mt="md">Crear Tenant</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Gestión de Tenants</Title>
          <Button onClick={openModal}>Crear Nuevo Tenant</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Empresa</Table.Th>
              <Table.Th>Subdominio</Table.Th>
              <Table.Th>Estado</Table.Th>
              <Table.Th>Fecha de Creación</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={5}>No hay tenants creados.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [17] packages/client/src/features/technician/pages/MyRoutePage.tsx ======
// filename: packages/client/src/features/technician/pages/MyRoutePage.tsx
// Version: 1.1.1 (Fix invalid HTML nesting and implement state-based refresh)
import { useEffect, useState } from 'react';
import { Link, useLocation } from 'react-router-dom';
import {
  Container,
  Title,
  Loader,
  Alert,
  Stack,
  Card,
  Text,
  Group,
  Anchor,
  ThemeIcon,
} from '@mantine/core';
import apiClient from '../../../api/apiClient';

// --- Tipos ---
interface Visit {
  id: string;
  timestamp: string;
  pool: {
    id: string;
    name: string;
    address: string;
    client: {
      name: string;
    };
  };
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function MyRoutePage() {
  const [visits, setVisits] = useState<Visit[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const location = useLocation(); // Hook para detectar cambios en la navegación

  const fetchMyRoute = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const response = await apiClient.get<ApiResponse<Visit[]>>('/visits/my-route');
      setVisits(response.data.data);
    } catch (err) {
      setError('No se pudo cargar tu ruta del día.');
      console.error(err);
    } finally {
      setIsLoading(false);
    }
  };

  // Este useEffect ahora se ejecutará al cargar la página Y cada vez que volvamos a ella
  // desde otra ruta, gracias a que "location.key" cambia.
  useEffect(() => {
    fetchMyRoute();
  }, [location.key]);

  if (isLoading) {
    return (
      <Container style={{ textAlign: 'center', paddingTop: '50px' }}>
        <Loader size="xl" />
        <Text mt="md">Cargando tu ruta...</Text>
      </Container>
    );
  }

  if (error) {
    return <Alert color="red" title="Error">{error}</Alert>;
  }

  const visitCards = visits.map((visit) => (
    // CORRECCIÓN: La Card es un div, y el contenido principal un Link para evitar anidamiento <a> en <a>.
    <Card key={visit.id} shadow="sm" padding="lg" radius="md" withBorder>
      <Link to={`/visits/${visit.id}`} style={{ textDecoration: 'none', color: 'inherit' }}>
        <Group justify="space-between" mt="md" mb="xs">
          <Text fw={500} size="lg">{visit.pool.name}</Text>
          <ThemeIcon variant="light" radius="md" size="lg">
            <span>📍</span>
          </ThemeIcon>
        </Group>
        <Text size="sm" c="dimmed">
          Cliente: {visit.pool.client.name}
        </Text>
      </Link>
      <Anchor
        href={`https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(visit.pool.address)}`}
        target="_blank"
        rel="noopener noreferrer"
        size="sm"
        mt="sm"
      >
        {visit.pool.address}
      </Anchor>
    </Card>
  ));

  return (
    <Container>
      <Title order={2} my="lg">Mi Ruta de Hoy</Title>
      {visits.length > 0 ? (
        <Stack gap="md">{visitCards}</Stack>
      ) : (
        <Text>No tienes visitas asignadas para hoy.</Text>
      )}
    </Container>
  );
}


// ====== [18] packages/client/src/features/technician/pages/WorkOrderPage.tsx ======
// filename: packages/client/src/features/technician/pages/WorkOrderPage.tsx
// Version: 1.2.2 (Remove window.location.reload and rely on router state)
import { useEffect, useState } from 'react';
import { useParams, Link, useNavigate } from 'react-router-dom';
import {
  Container,
  Title,
  Loader,
  Alert,
  Paper,
  Text,
  Breadcrumbs,
  Button,
  Stack,
  Checkbox,
  NumberInput,
  Switch,
  TextInput,
  Select,
  Textarea,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import apiClient from '../../../api/apiClient';

// --- Tipos ---
interface ParameterConfig {
  id: string;
  name: string;
  unit: string | null;
  type: 'NUMBER' | 'BOOLEAN' | 'TEXT' | 'SELECT';
  selectOptions: string[];
}
interface TaskConfig {
  id: string;
  name: string;
}
interface VisitDetails {
  id: string;
  pool: {
    configurations: {
      id: string;
      parameterTemplate?: ParameterConfig;
      taskTemplate?: TaskConfig;
    }[];
    name: string;
    address: string;
    client: { name: string };
  };
}
interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function WorkOrderPage() {
  const { visitId } = useParams<{ visitId: string }>();
  const navigate = useNavigate();
  const [visit, setVisit] = useState<VisitDetails | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const form = useForm({
    initialValues: {
      results: {} as Record<string, string | number | boolean>,
      completedTasks: {} as Record<string, boolean>,
      notes: '',
      hasIncident: false,
    },
  });

  useEffect(() => {
    if (!visitId) {
      setError('No se ha proporcionado un ID de visita.');
      setIsLoading(false);
      return;
    }
    const fetchVisitDetails = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const response = await apiClient.get<ApiResponse<VisitDetails>>(`/visits/${visitId}`);
        const visitData = response.data.data;
        setVisit(visitData);
        
        form.setInitialValues({
          results: visitData.pool.configurations
            .filter(c => c.parameterTemplate)
            .reduce((acc, c) => ({ ...acc, [c.id]: '' }), {}),
          completedTasks: visitData.pool.configurations
            .filter(c => c.taskTemplate)
            .reduce((acc, c) => ({ ...acc, [c.id]: false }), {}),
          notes: '',
          hasIncident: false,
        });
        form.reset();
      } catch (err) {
        setError('No se pudo cargar la información de la visita.');
      } finally {
        setIsLoading(false);
      }
    };
    fetchVisitDetails();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [visitId]);

  const handleSubmit = async (values: typeof form.values) => {
    if (!visitId) return;
    setIsSubmitting(true);
    try {
      await apiClient.post(`/visits/${visitId}/complete`, values);
      // Simplemente navegamos de vuelta.
      navigate('/my-route');
    } catch (err) {
      console.error('Error submitting work order', err);
      setIsSubmitting(false);
    }
  };

  if (isLoading) return <Container style={{ textAlign: 'center', paddingTop: '50px' }}><Loader size="xl" /></Container>;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;
  if (!visit) return <Alert color="yellow" title="Aviso">Visita no encontrada.</Alert>;
  
  const breadcrumbs = (
    <Breadcrumbs>
      <Link to="/my-route">Mi Ruta</Link>
      <Text>{visit.pool.name}</Text>
    </Breadcrumbs>
  );

  const parametersToMeasure = visit.pool.configurations.filter(c => c.parameterTemplate);
  const tasksToComplete = visit.pool.configurations.filter(c => c.taskTemplate);

  const renderParameterInput = (config: typeof parametersToMeasure[0]) => {
    const { parameterTemplate: param } = config;
    if (!param) return null;
    const label = `${param.name}${param.unit ? ` (${param.unit})` : ''}`;

    switch (param.type) {
      case 'NUMBER': return <NumberInput label={label} {...form.getInputProps(`results.${config.id}`)} />;
      case 'BOOLEAN': return <Switch mt="md" label={label} {...form.getInputProps(`results.${config.id}`, { type: 'checkbox' })} />;
      case 'TEXT': return <TextInput label={label} {...form.getInputProps(`results.${config.id}`)} />;
      case 'SELECT': return <Select label={label} data={param.selectOptions} {...form.getInputProps(`results.${config.id}`)} />;
      default: return <Text c="red">Tipo de parámetro no soportado: {param.type}</Text>;
    }
  };

  return (
    <Container>
      {breadcrumbs}
      <Title order={2} my="lg">Parte de Trabajo: {visit.pool.name}</Title>
      <Text c="dimmed">{visit.pool.client.name} - {visit.pool.address}</Text>

      <Paper withBorder p="md" mt="xl">
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            {parametersToMeasure.length > 0 && (
              <div>
                <Title order={4} mb="sm">Mediciones de Parámetros</Title>
                <Stack>{parametersToMeasure.map(p => <div key={p.id}>{renderParameterInput(p)}</div>)}</Stack>
              </div>
            )}
            {tasksToComplete.length > 0 && (
              <div>
                <Title order={4} mt="lg" mb="sm">Tareas a Realizar</Title>
                <Stack>{tasksToComplete.map(t => <Checkbox key={t.id} label={t.taskTemplate?.name} {...form.getInputProps(`completedTasks.${t.id}`, { type: 'checkbox' })} />)}</Stack>
              </div>
            )}
            
            <Title order={4} mt="lg" mb="sm">Observaciones e Incidencias</Title>
            <Textarea label="Notas de la visita (opcional)" placeholder="Cualquier observación relevante..." {...form.getInputProps('notes')} />
            <Checkbox label="Reportar como Incidencia" description="Marca esta casilla si hay un problema que requiera la atención del administrador." {...form.getInputProps('hasIncident', { type: 'checkbox' })} />
            
            <Button type="submit" mt="xl" size="lg" loading={isSubmitting}>
              Guardar y Finalizar Visita
            </Button>
          </Stack>
        </form>
      </Paper>
    </Container>
  );
}


// ====== [19] packages/client/src/main.tsx ======
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.js';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


// ====== [20] packages/client/src/providers/AuthProvider.tsx ======
import {
  createContext,
  useContext,
  useState,
  useEffect,
  useCallback,
} from 'react';
import type { PropsWithChildren } from 'react';
import apiClient from '../api/apiClient.js';

// --- Types ---
type LoginCredentials = {
  email: string;
  password: string;
};

interface User {
  id: string;
  name: string;
  email: string;
  role: string;
}

interface AuthContextType {
  user: User | null;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => Promise<void>;
  isLoading: boolean;
  isAuthenticated: boolean;
}

// --- Context ---
const AuthContext = createContext<AuthContextType | undefined>(undefined);

// --- Provider Component ---
export const AuthProvider = ({ children }: PropsWithChildren) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  const checkAuthStatus = useCallback(async () => {
    setIsLoading(true);
    try {
      // Este endpoint ahora existe y funciona gracias a los pasos anteriores
      const response = await apiClient.get('/auth/me');
      setUser(response.data.data);
    } catch (error) {
      setUser(null);
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    // Activamos la comprobación de la sesión al cargar la app
    checkAuthStatus();
  }, [checkAuthStatus]);

  const login = async (credentials: LoginCredentials) => {
    const response = await apiClient.post('/auth/login', credentials);
    setUser(response.data.data);
  };

  const logout = async () => {
    await apiClient.post('/auth/logout');
    setUser(null);
  };

  const value: AuthContextType = {
    user,
    login,
    logout,
    isLoading,
    isAuthenticated: !!user,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

// --- Custom Hook ---
export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};


// ====== [21] packages/client/src/router/components.tsx ======
// filename: packages/client/src/router/components.tsx
// Version: 1.5.0 (Add TechnicianRoute and navigation link)
import { AppShell, Burger, Group, NavLink, Title, Button } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { Navigate, Outlet, Link, useNavigate } from 'react-router-dom';
import { useAuth } from '../providers/AuthProvider.js';

/**
 * Componente de layout principal para las páginas autenticadas.
 */
export const AppLayout = () => {
  const [opened, { toggle }] = useDisclosure();
  const { user, logout } = useAuth();
  const navigate = useNavigate();

  const handleLogout = async () => {
    await logout();
    navigate('/login');
  };

  return (
    <AppShell
      header={{ height: 60 }}
      navbar={{ width: 300, breakpoint: 'sm', collapsed: { mobile: !opened } }}
      padding="md"
    >
      <AppShell.Header>
        <Group h="100%" px="md" justify="space-between">
          <Group>
            <Burger opened={opened} onClick={toggle} hiddenFrom="sm" size="sm" />
            <Title order={3}>Pool Control Professional</Title>
          </Group>
          <Button variant="light" onClick={handleLogout}>Cerrar Sesión</Button>
        </Group>
      </AppShell.Header>

      <AppShell.Navbar p="md">
        <NavLink
          component={Link}
          to="/"
          label="Dashboard"
          onClick={toggle}
        />
        
        {/* Enlaces solo para el rol ADMIN */}
        {user?.role === 'ADMIN' && (
          <>
            <NavLink
              component={Link}
              to="/planner"
              label="Planificador"
              onClick={toggle}
            />
            <NavLink
              component={Link}
              to="/clients"
              label="Clientes"
              onClick={toggle}
            />
            <NavLink label="Catálogos">
              <NavLink 
                component={Link} 
                to="/catalog/parameters" 
                label="Parámetros" 
                onClick={toggle} 
              />
              <NavLink 
                component={Link} 
                to="/catalog/tasks" 
                label="Tareas" 
                onClick={toggle} 
              />
            </NavLink>
          </>
        )}

        {/* Enlaces solo para el rol TECHNICIAN */}
        {user?.role === 'TECHNICIAN' && (
          <NavLink
            component={Link}
            to="/my-route"
            label="Mi Ruta de Hoy"
            onClick={toggle}
          />
        )}

        {/* Enlaces solo para el rol SUPER_ADMIN */}
        {user?.role === 'SUPER_ADMIN' && (
           <NavLink 
              component={Link} 
              to="/superadmin/tenants" 
              label="Gestión de Tenants" 
              onClick={toggle} 
            />
        )}
      </AppShell.Navbar>

      <AppShell.Main>
        <Outlet />
      </AppShell.Main>
    </AppShell>
  );
};

/**
 * Componente que protege rutas genéricas de usuarios no autenticados.
 */
export const ProtectedRoute = () => {
  const { isAuthenticated, isLoading } = useAuth();
  if (isLoading) return <div>Cargando...</div>;
  if (!isAuthenticated) return <Navigate to="/login" replace />;
  return <Outlet />;
};

/**
 * Componente que protege rutas específicas para el rol SUPER_ADMIN.
 */
export const SuperAdminRoute = () => {
  const { user, isLoading } = useAuth();
  if (isLoading) return <div>Cargando...</div>;
  if (user?.role !== 'SUPER_ADMIN') return <Navigate to="/" replace />;
  return <Outlet />;
};

/**
 * Componente que protege rutas específicas para los roles ADMIN y SUPER_ADMIN.
 */
export const AdminRoute = () => {
  const { user, isLoading } = useAuth();
  if (isLoading) return <div>Cargando...</div>;
  if (user?.role !== 'ADMIN' && user?.role !== 'SUPER_ADMIN') {
    return <Navigate to="/" replace />;
  }
  return <Outlet />;
};

/**
 * Componente que protege rutas específicas para el rol TECHNICIAN.
 */
export const TechnicianRoute = () => {
  const { user, isLoading } = useAuth();
  if (isLoading) return <div>Cargando...</div>;
  // Solo permite acceso si el rol es TECHNICIAN
  if (user?.role !== 'TECHNICIAN') {
    return <Navigate to="/" replace />;
  }
  return <Outlet />;
};


// ====== [22] packages/client/src/router/index.tsx ======
// filename: packages/client/src/router/index.tsx
// Version: 1.8.0 (Add WorkOrderPage route for Technician)
import { createBrowserRouter } from 'react-router-dom';
import { LoginPage } from '../features/auth/pages/LoginPage.js';
import { TenantsPage } from '../features/superadmin/pages/TenantsPage.js';
import { ParameterCatalogPage } from '../features/admin/pages/ParameterCatalogPage.js';
import { TaskCatalogPage } from '../features/admin/pages/TaskCatalogPage.js';
import { ClientsPage } from '../features/admin/pages/clients/ClientsPage.js';
import { ClientDetailPage } from '../features/admin/pages/clients/ClientDetailPage.js';
import { PoolDetailPage } from '../features/admin/pages/pools/PoolDetailPage.js';
import { PlannerPage } from '../features/admin/pages/planner/PlannerPage.js';
import { MyRoutePage } from '../features/technician/pages/MyRoutePage.js';
import { WorkOrderPage } from '../features/technician/pages/WorkOrderPage.js'; // <-- Importamos la nueva página
import {
  AppLayout,
  ProtectedRoute,
  SuperAdminRoute,
  AdminRoute,
  TechnicianRoute,
} from './components.js';

export const router = createBrowserRouter([
  {
    path: '/login',
    element: <LoginPage />,
  },
  {
    path: '/',
    element: <ProtectedRoute />,
    children: [
      {
        element: <AppLayout />,
        children: [
          {
            index: true,
            element: <div>Dashboard Principal</div>,
          },
          // --- Sección de SuperAdmin ---
          {
            path: 'superadmin',
            element: <SuperAdminRoute />,
            children: [
              {
                path: 'tenants',
                element: <TenantsPage />,
              },
            ],
          },
          // --- Sección de Administración ---
          {
            path: 'planner',
            element: <AdminRoute />,
            children: [
              {
                index: true,
                element: <PlannerPage />,
              },
            ],
          },
          {
            path: 'clients',
            element: <AdminRoute />,
            children: [
              {
                index: true,
                element: <ClientsPage />,
              },
              {
                path: ':id', 
                element: <ClientDetailPage />,
              },
            ],
          },
          {
            path: 'pools/:id', 
            element: <AdminRoute />,
            children: [
              {
                index: true,
                element: <PoolDetailPage />
              }
            ]
          },
          {
            path: 'catalog',
            element: <AdminRoute />,
            children: [
              {
                path: 'parameters',
                element: <ParameterCatalogPage />,
              },
              {
                path: 'tasks',
                element: <TaskCatalogPage />,
              },
            ],
          },
          // --- Sección de Técnico ---
          {
            path: 'my-route',
            element: <TechnicianRoute />,
            children: [
              {
                index: true,
                element: <MyRoutePage />,
              },
            ],
          },
          {
            path: 'visits/:visitId', // <-- Añadimos la nueva ruta
            element: <TechnicianRoute />,
            children: [
              {
                index: true,
                element: <WorkOrderPage />,
              },
            ],
          },
        ],
      },
    ],
  },
]);


// ====== [23] packages/client/src/styles/theme.ts ======
import { createTheme } from '@mantine/core';
import type { MantineColorsTuple } from '@mantine/core';

// Definimos una paleta de colores personalizada para nuestra marca.
// Puedes generar las tuyas en https://mantine.dev/colors-generator/
const brandBlue: MantineColorsTuple = [
  '#e7f5ff',
  '#d0ebff',
  '#a5d8ff',
  '#74c0fc',
  '#4dabf7',
  '#339af0',
  '#228be6',
  '#1c7ed6',
  '#1572c3',
  '#1068b1',
];

export const theme = createTheme({
  fontFamily: 'Inter, sans-serif',
  primaryColor: 'brandBlue',

  colors: {
    brandBlue,
  },

  headings: {
    fontFamily: 'Inter, sans-serif',
  },
});


// ====== [24] packages/client/tsconfig.json ======
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "allowJs": false,
    "skipLibCheck": true,
    "esModuleInterop": false,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}


// ====== [25] packages/client/tsconfig.node.json ======
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}


// ====== [26] packages/client/vite.config.ts ======
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    // Configuramos un proxy para evitar problemas de CORS en desarrollo.
    // Todas las peticiones del frontend a '/api' serán redirigidas
    // a nuestro servidor de backend en el puerto 3001.
    proxy: {
      '/api': {
        target: 'http://localhost:3001',
        changeOrigin: true,
      },
    },
  },
});


// ====== [27] packages/server/package.json ======
{
  "name": "@pool-control/server",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "main": "dist/server.js",
  "scripts": {
    "dev": "tsx watch src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev",
    "prisma:studio": "prisma studio",
    "db:seed": "tsx prisma/seed.ts"
  },
  "dependencies": {
    "@prisma/client": "^5.15.0",
    "bcryptjs": "^2.4.3",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "date-fns": "^4.1.0",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "jsonwebtoken": "^9.0.2",
    "ms": "^2.1.3"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cookie-parser": "^1.4.7",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.6",
    "@types/ms": "^0.7.34",
    "@types/node": "^20.14.2",
    "prisma": "^5.15.0",
    "tsx": "^4.15.4",
    "typescript": "^5.4.5"
  }
}


// ====== [28] packages/server/prisma/seed.ts ======
import { PrismaClient } from '@prisma/client';
import { hashPassword } from '../src/utils/password.utils.js';

const prisma = new PrismaClient();

async function main() {
  console.log('🌱 Empezando el proceso de seeding...');

  // 1. Eliminar datos antiguos para asegurar un estado limpio
  // La eliminación debe ser en el orden correcto para no violar las restricciones de clave foránea.
  await prisma.user.deleteMany({});
  await prisma.tenant.deleteMany({});
  console.log('🗑️ Datos antiguos eliminados.');

  // 2. Crear el Tenant del Sistema
  const systemTenant = await prisma.tenant.create({
    data: {
      companyName: 'SYSTEM_INTERNAL',
      subdomain: 'system',
      subscriptionStatus: 'ACTIVE',
    },
  });
  console.log(`🏢 Tenant del sistema creado: ${systemTenant.companyName}`);

  // 3. Hashear la contraseña del SuperAdmin
  const password = 'superadmin123';
  const hashedPassword = await hashPassword(password);
  console.log('🔑 Contraseña del SuperAdmin hasheada.');

  // 4. Crear el usuario SuperAdmin
  const superAdmin = await prisma.user.create({
    data: {
      email: 'super@admin.com',
      name: 'Super Admin',
      password: hashedPassword,
      role: 'SUPER_ADMIN',
      tenantId: systemTenant.id, // Se asigna al tenant del sistema
    },
  });
  console.log(`👤 Usuario SuperAdmin creado: ${superAdmin.email}`);

  console.log('✅ Seeding completado con éxito.');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });


// ====== [29] packages/server/src/api/auth/auth.controller.ts ======
import type { Response, NextFunction } from 'express';
import { register, login } from './auth.service.js';
import { signToken } from '../../utils/jwt.utils.js';
import config from '../../config/index.js';
import type { CookieOptions, Request } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';

const cookieOptions: CookieOptions = {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'lax',
  maxAge: config.JWT_EXPIRES_IN * 1000, // maxAge está en milisegundos
};

/**
 * Maneja la petición de registro de un nuevo usuario.
 */
export const registerHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const user = await register(req.body);
    res.status(201).json({
      success: true,
      data: user,
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la petición de login de un usuario.
 */
export const loginHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const user = await login(req.body);
    const token = signToken({ id: user.id, role: user.role });
    res.cookie('token', token, cookieOptions);
    res.status(200).json({
      success: true,
      data: user,
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtención del usuario actualmente autenticado (a través del token).
 */
export const getMeHandler = (req: AuthRequest, res: Response) => {
  // El middleware 'protect' se ejecuta antes que este manejador.
  // Si llega hasta aquí, significa que el token es válido y 'req.user' existe.
  res.status(200).json({
    success: true,
    data: req.user,
  });
};


// ====== [30] packages/server/src/api/auth/auth.routes.ts ======
import { Router } from 'express';
import type { Response } from 'express';
import {
  registerHandler,
  loginHandler,
  getMeHandler,
} from './auth.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const authRouter = Router();

/**
 * @route   POST /api/auth/register
 * @desc    Registra un nuevo usuario
 * @access  Public
 */
authRouter.post('/register', registerHandler);

/**
 * @route   POST /api/auth/login
 * @desc    Inicia sesión y devuelve un token en una cookie
 * @access  Public
 */
authRouter.post('/login', loginHandler);

/**
 * @route   GET /api/auth/me
 * @desc    Obtiene los datos del usuario logueado a partir de su token
 * @access  Private
 */
authRouter.get('/me', protect, getMeHandler);

/**
 * @route   POST /api/auth/logout
 * @desc    Cierra la sesión del usuario eliminando la cookie
 * @access  Public
 */
authRouter.post('/logout', (_req, res: Response) => {
  res.cookie('token', '', {
    httpOnly: true,
    expires: new Date(0),
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
  });
  res.status(200).json({ success: true, message: 'Sesión cerrada con éxito.' });
});

export default authRouter;


// ====== [31] packages/server/src/api/auth/auth.service.ts ======
import { PrismaClient } from '@prisma/client';
import type { User } from '@prisma/client';
import { hashPassword, comparePassword } from '../../utils/password.utils.js';

const prisma = new PrismaClient();

// Tipo para la entrada de datos del registro.
export type RegisterUserInput = Omit<User, 'id' | 'createdAt' | 'updatedAt'>;

// Tipo para la entrada de datos del login.
export type LoginUserInput = {
  email: string;
  password: string;
};

/**
 * Registra un nuevo usuario en la base de datos.
 * @param input - Datos del usuario para el registro.
 * @returns El objeto de usuario creado (sin la contraseña).
 */
export const register = async (input: RegisterUserInput) => {
  const { email, password, ...rest } = input;

  const existingUser = await prisma.user.findUnique({
    where: { email },
  });

  if (existingUser) {
    throw new Error('Ya existe un usuario con este correo electrónico.');
  }

  const hashedPassword = await hashPassword(password);

  const user = await prisma.user.create({
    data: {
      email,
      password: hashedPassword,
      ...rest,
    },
    select: {
      id: true,
      email: true,
      name: true,
      role: true,
      tenantId: true,
      createdAt: true,
      updatedAt: true,
    },
  });

  return user;
};

/**
 * Valida las credenciales de un usuario para el login.
 * @param input - Email y contraseña del usuario.
 * @returns El objeto de usuario autenticado (sin la contraseña).
 */
export const login = async (input: LoginUserInput): Promise<Omit<User, 'password'>> => {
  const user = await prisma.user.findUnique({
    where: { email: input.email },
  });

  if (!user) {
    throw new Error('El email o la contraseña son incorrectos.');
  }

  const isPasswordValid = await comparePassword(input.password, user.password);

  if (!isPasswordValid) {
    throw new Error('El email o la contraseña son incorrectos.');
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const { password, ...userWithoutPassword } = user;

  return userWithoutPassword;
};


// ====== [32] packages/server/src/api/clients/clients.controller.ts ======
// filename: packages/server/src/api/clients/clients.controller.ts
// Version: 1.0.0 (Initial creation of the controller for Client management)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createClient,
  deleteClient,
  getClientById,
  getClientsByTenant,
  updateClient,
} from './clients.service.js';

/**
 * Maneja la creación de un nuevo cliente.
 */
export const createClientHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acción no permitida.' });
    }

    const input = { ...req.body, tenantId };
    const newClient = await createClient(input);
    res.status(201).json({ success: true, data: newClient });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtención de todos los clientes de un tenant.
 */
export const getClientsByTenantHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acción no permitida.' });
    }

    const clients = await getClientsByTenant(tenantId);
    res.status(200).json({ success: true, data: clients });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtención de un cliente específico por ID.
 */
export const getClientByIdHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    const { id: clientId } = req.params;

    if (!tenantId) {
      return res.status(403).json({ message: 'Acción no permitida.' });
    }
    if (!clientId) {
      return res.status(400).json({ message: 'El ID del cliente es requerido.' });
    }

    const client = await getClientById(clientId, tenantId);
    if (!client) {
      return res.status(404).json({ message: 'Cliente no encontrado.' });
    }

    res.status(200).json({ success: true, data: client });
  } catch (error) {
    next(error);
  }
};


/**
 * Maneja la actualización de un cliente.
 */
export const updateClientHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID del cliente es requerido.' });
    }
    // TODO: Verificar que el cliente que se quiere editar pertenece al tenant del usuario logueado.
    
    const updatedClient = await updateClient(id, req.body);
    res.status(200).json({ success: true, data: updatedClient });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminación de un cliente.
 */
export const deleteClientHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID del cliente es requerido.' });
    }
    // TODO: Verificar que el cliente que se quiere eliminar pertenece al tenant del usuario logueado.

    await deleteClient(id);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [33] packages/server/src/api/clients/clients.routes.ts ======
// filename: packages/server/src/api/clients/clients.routes.ts
// Version: 1.0.0 (Initial creation of routes for Client management)
import { Router } from 'express';
import {
  createClientHandler,
  deleteClientHandler,
  getClientByIdHandler,
  getClientsByTenantHandler,
  updateClientHandler,
} from './clients.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const clientsRouter = Router();

// Aplicamos el middleware 'protect' a TODAS las rutas de este enrutador.
clientsRouter.use(protect);

// TODO: Añadir un middleware de autorización para asegurar que el rol sea 'ADMIN'.

clientsRouter.route('/')
  .get(getClientsByTenantHandler)
  .post(createClientHandler);

clientsRouter.route('/:id')
  .get(getClientByIdHandler)
  .patch(updateClientHandler)
  .delete(deleteClientHandler);

export default clientsRouter;


// ====== [34] packages/server/src/api/clients/clients.service.ts ======
// filename: packages/server/src/api/clients/clients.service.ts
// Version: 1.0.0 (Initial creation of the service for Client management)
import { PrismaClient } from '@prisma/client';
import type { Client } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateClientInput = Omit<Client, 'id' | 'createdAt' | 'updatedAt'>;
export type UpdateClientInput = Partial<CreateClientInput>;

// --- Funciones del Servicio ---

/**
 * Crea un nuevo cliente para un tenant específico.
 * @param data - Datos del nuevo cliente.
 * @returns El cliente creado.
 */
export const createClient = async (data: CreateClientInput): Promise<Client> => {
  return prisma.client.create({
    data,
  });
};

/**
 * Obtiene todos los clientes de un tenant específico.
 * @param tenantId - El ID del tenant.
 * @returns Un array de clientes.
 */
export const getClientsByTenant = async (tenantId: string): Promise<Client[]> => {
  return prisma.client.findMany({
    where: { tenantId },
    orderBy: { name: 'asc' },
    // Incluimos las piscinas asociadas a cada cliente
    include: {
      pools: true,
    },
  });
};

/**
 * Obtiene un cliente específico por su ID.
 * @param id - El ID del cliente a buscar.
 * @param tenantId - El ID del tenant para asegurar la pertenencia.
 * @returns El objeto del cliente o null si no se encuentra o no pertenece al tenant.
 */
export const getClientById = async (id: string, tenantId: string): Promise<Client | null> => {
  return prisma.client.findFirst({
    where: { id, tenantId },
     include: {
      pools: true,
    },
  });
};


/**
 * Actualiza un cliente existente.
 * @param id - El ID del cliente a actualizar.
 * @param data - Los datos a actualizar.
 * @returns El cliente actualizado.
 */
export const updateClient = async (id: string, data: UpdateClientInput): Promise<Client> => {
  return prisma.client.update({
    where: { id },
    data,
  });
};

/**
 * Elimina un cliente.
 * @param id - El ID del cliente a eliminar.
 * @returns El cliente que fue eliminado.
 */
export const deleteClient = async (id: string): Promise<Client> => {
  // Al borrar el cliente, se borrarán en cascada sus piscinas asociadas.
  return prisma.client.delete({
    where: { id },
  });
};


// ====== [35] packages/server/src/api/parameters/parameters.controller.ts ======
// filename: packages/server/src/api/parameters/parameters.controller.ts
// Version: 1.0.0 (Initial creation of the controller for Parameter Templates)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
createParameterTemplate,
deleteParameterTemplate,
getParameterTemplatesByTenant,
updateParameterTemplate,
} from './parameters.service.js';
/**
Maneja la creación de una nueva plantilla de parámetro.
*/
export const createParameterTemplateHandler = async (
req: AuthRequest,
res: Response,
next: NextFunction
) => {
try {
// Aseguramos que el usuario esté autenticado y tenga un tenantId
const tenantId = req.user?.tenantId;
if (!tenantId) {
return res.status(403).json({ message: 'Acción no permitida.' });
}
const input = { ...req.body, tenantId };
const newTemplate = await createParameterTemplate(input);
res.status(201).json({ success: true, data: newTemplate });
} catch (error) {
next(error);
}
};
/**
Maneja la obtención de todas las plantillas de un tenant.
*/
export const getParameterTemplatesByTenantHandler = async (
req: AuthRequest,
res: Response,
next: NextFunction
) => {
try {
const tenantId = req.user?.tenantId;
if (!tenantId) {
return res.status(403).json({ message: 'Acción no permitida.' });
}
const templates = await getParameterTemplatesByTenant(tenantId);
res.status(200).json({ success: true, data: templates });
} catch (error) {
next(error);
}
};
/**
Maneja la actualización de una plantilla de parámetro.
*/
export const updateParameterTemplateHandler = async (
req: AuthRequest,
res: Response,
next: NextFunction
) => {
try {
const { id } = req.params;
if (!id) {
return res.status(400).json({ message: 'El ID de la plantilla es requerido.' });
}
// TODO: Verificar que la plantilla que se quiere editar pertenece al tenant del usuario logueado.
const updatedTemplate = await updateParameterTemplate(id, req.body);
res.status(200).json({ success: true, data: updatedTemplate });
} catch (error) {
next(error);
}
};
/**
Maneja la eliminación de una plantilla de parámetro.
*/
export const deleteParameterTemplateHandler = async (
req: AuthRequest,
res: Response,
next: NextFunction
) => {
try {
const { id } = req.params;
if (!id) {
return res.status(400).json({ message: 'El ID de la plantilla es requerido.' });
}
// TODO: Verificar que la plantilla que se quiere eliminar pertenece al tenant del usuario logueado.
await deleteParameterTemplate(id);
res.status(204).send();
} catch (error) {
next(error);
}
};


// ====== [36] packages/server/src/api/parameters/parameters.routes.ts ======
// filename: packages/server/src/api/parameters/parameters.routes.ts
// Version: 1.0.0 (Initial creation of routes for Parameter Templates)
import { Router } from 'express';
import {
  createParameterTemplateHandler,
  deleteParameterTemplateHandler,
  getParameterTemplatesByTenantHandler,
  updateParameterTemplateHandler,
} from './parameters.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const parametersRouter = Router();

// Aplicamos el middleware 'protect' a TODAS las rutas definidas en este archivo.
// Esto asegura que solo los usuarios autenticados pueden gestionar el catálogo.
parametersRouter.use(protect);

// TODO: Añadir un middleware de autorización para asegurar que el rol sea 'ADMIN'.

parametersRouter.route('/')
  .get(getParameterTemplatesByTenantHandler)
  .post(createParameterTemplateHandler);

parametersRouter.route('/:id')
  .patch(updateParameterTemplateHandler)
  .delete(deleteParameterTemplateHandler);

export default parametersRouter;


// ====== [37] packages/server/src/api/parameters/parameters.service.ts ======
// filename: packages/server/src/api/parameters/parameters.service.ts
// Version: 1.0.0 (Initial creation of the service with CRUD functions)
import { PrismaClient } from '@prisma/client';
import type { ParameterTemplate, InputType } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateParameterTemplateInput = {
  name: string;
  tenantId: string; // Cada plantilla pertenece a un tenant
  unit?: string;
  type?: InputType;
  selectOptions?: string[];
};

export type UpdateParameterTemplateInput = Partial<Omit<CreateParameterTemplateInput, 'tenantId'>>;

// --- Funciones del Servicio ---

/**
 * Crea una nueva plantilla de parámetro para un tenant específico.
 * @param input - Datos de la nueva plantilla.
 * @returns La plantilla de parámetro creada.
 */
export const createParameterTemplate = async (
  input: CreateParameterTemplateInput
): Promise<ParameterTemplate> => {
  return prisma.parameterTemplate.create({
    data: input,
  });
};

/**
 * Obtiene todas las plantillas de parámetros para un tenant específico.
 * @param tenantId - El ID del tenant.
 * @returns Un array de plantillas de parámetros.
 */
export const getParameterTemplatesByTenant = async (
  tenantId: string
): Promise<ParameterTemplate[]> => {
  return prisma.parameterTemplate.findMany({
    where: { tenantId },
    orderBy: { name: 'asc' },
  });
};

/**
 * Actualiza una plantilla de parámetro existente.
 * @param id - El ID de la plantilla a actualizar.
 * @param data - Los datos a actualizar.
 * @returns La plantilla de parámetro actualizada.
 */
export const updateParameterTemplate = async (
  id: string,
  data: UpdateParameterTemplateInput
): Promise<ParameterTemplate> => {
  return prisma.parameterTemplate.update({
    where: { id },
    data,
  });
};

/**
 * Elimina una plantilla de parámetro.
 * @param id - El ID de la plantilla a eliminar.
 * @returns La plantilla de parámetro que fue eliminada.
 */
export const deleteParameterTemplate = async (
  id: string
): Promise<ParameterTemplate> => {
  // TODO: Añadir lógica para verificar que esta plantilla no está siendo
  // usada en ninguna PoolConfiguration antes de permitir el borrado.
  return prisma.parameterTemplate.delete({
    where: { id },
  });
};


// ====== [38] packages/server/src/api/pool-configurations/pool-configurations.controller.ts ======
// filename: packages/server/src/api/pool-configurations/pool-configurations.controller.ts
// Version: 1.1.0 (Add handler for update functionality)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createPoolConfiguration,
  deletePoolConfiguration,
  getConfigurationsByPool,
  updatePoolConfiguration,
} from './pool-configurations.service.js';

/**
 * Maneja la creación de una nueva configuración de mantenimiento.
 */
export const createPoolConfigurationHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acción no permitida.' });
    }
    const newConfig = await createPoolConfiguration(req.body);
    res.status(201).json({ success: true, data: newConfig });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtención de todas las configuraciones para una piscina.
 */
export const getConfigurationsByPoolHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { poolId } = req.params;
    if (!poolId) {
      return res.status(400).json({ message: 'El ID de la piscina es requerido.' });
    }
    const configs = await getConfigurationsByPool(poolId);
    res.status(200).json({ success: true, data: configs });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualización de una configuración de mantenimiento.
 */
export const updatePoolConfigurationHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la configuración es requerido.' });
    }
    // TODO: Verificar que la configuración que se quiere editar pertenece al tenant del usuario.
    const updatedConfig = await updatePoolConfiguration(id, req.body);
    res.status(200).json({ success: true, data: updatedConfig });
  } catch (error) {
    next(error);
  }
};


/**
 * Maneja la eliminación de una configuración de mantenimiento.
 */
export const deletePoolConfigurationHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la configuración es requerido.' });
    }
    await deletePoolConfiguration(id);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [39] packages/server/src/api/pool-configurations/pool-configurations.routes.ts ======
// filename: packages/server/src/api/pool-configurations/pool-configurations.routes.ts
// Version: 1.1.0 (Add PATCH route for update functionality)
import { Router } from 'express';
import {
  createPoolConfigurationHandler,
  deletePoolConfigurationHandler,
  getConfigurationsByPoolHandler,
  updatePoolConfigurationHandler,
} from './pool-configurations.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const poolConfigurationsRouter = Router();

poolConfigurationsRouter.use(protect);

// TODO: Añadir un middleware de autorización para asegurar que el rol sea 'ADMIN'.

poolConfigurationsRouter.route('/')
  .post(createPoolConfigurationHandler);

poolConfigurationsRouter.route('/by-pool/:poolId')
  .get(getConfigurationsByPoolHandler);

poolConfigurationsRouter.route('/:id')
  .patch(updatePoolConfigurationHandler) // Nueva ruta PATCH
  .delete(deletePoolConfigurationHandler);

export default poolConfigurationsRouter;


// ====== [40] packages/server/src/api/pool-configurations/pool-configurations.service.ts ======
// filename: packages/server/src/api/pool-configurations/pool-configurations.service.ts
// Version: 1.1.0 (Add update functionality)
import { PrismaClient } from '@prisma/client';
import type { PoolConfiguration, Frequency } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreatePoolConfigurationInput = {
  poolId: string;
  frequency: Frequency;
  minThreshold?: number;
  maxThreshold?: number;
  parameterTemplateId?: string;
  taskTemplateId?: string;
};

export type UpdatePoolConfigurationInput = Partial<Omit<CreatePoolConfigurationInput, 'poolId' | 'parameterTemplateId' | 'taskTemplateId'>>;


// --- Funciones del Servicio ---

/**
 * Crea una nueva configuración de mantenimiento para una piscina.
 */
export const createPoolConfiguration = async (
  data: CreatePoolConfigurationInput
): Promise<PoolConfiguration> => {
  if (data.parameterTemplateId && data.taskTemplateId) {
    throw new Error('Una configuración solo puede estar asociada a un parámetro O a una tarea, no a ambos.');
  }
  if (!data.parameterTemplateId && !data.taskTemplateId) {
    throw new Error('La configuración debe estar asociada a un parámetro o a una tarea.');
  }

  return prisma.poolConfiguration.create({
    data,
  });
};

/**
 * Obtiene todas las configuraciones para una piscina específica.
 */
export const getConfigurationsByPool = async (poolId: string): Promise<PoolConfiguration[]> => {
  return prisma.poolConfiguration.findMany({
    where: { poolId },
    include: {
      parameterTemplate: true,
      taskTemplate: true,
    },
  });
};

/**
 * Actualiza una configuración de mantenimiento existente.
 * @param id - El ID de la configuración a actualizar.
 * @param data - Los datos a actualizar.
 * @returns La configuración actualizada.
 */
export const updatePoolConfiguration = async (
  id: string,
  data: UpdatePoolConfigurationInput
): Promise<PoolConfiguration> => {
  return prisma.poolConfiguration.update({
    where: { id },
    data,
  });
};


/**
 * Elimina una configuración de mantenimiento de una piscina.
 */
export const deletePoolConfiguration = async (id: string): Promise<PoolConfiguration> => {
  return prisma.poolConfiguration.delete({
    where: { id },
  });
};


// ====== [41] packages/server/src/api/pools/pools.controller.ts ======
// filename: packages/server/src/api/pools/pools.controller.ts
// Version: 1.0.0 (Initial creation of the controller for Pool management)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { createPool, deletePool, updatePool } from './pools.service.js';

/**
 * Maneja la creación de una nueva piscina.
 */
export const createPoolHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acción no permitida.' });
    }

    // Aseguramos que la piscina se asigne al tenant del usuario.
    const input = { ...req.body, tenantId };
    const newPool = await createPool(input);
    res.status(201).json({ success: true, data: newPool });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualización de una piscina.
 */
export const updatePoolHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la piscina es requerido.' });
    }
    // TODO: Verificar que la piscina que se quiere editar pertenece al tenant del usuario logueado.

    const updatedPool = await updatePool(id, req.body);
    res.status(200).json({ success: true, data: updatedPool });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminación de una piscina.
 */
export const deletePoolHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la piscina es requerido.' });
    }
    // TODO: Verificar que la piscina que se quiere eliminar pertenece al tenant del usuario logueado.

    await deletePool(id);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [42] packages/server/src/api/pools/pools.routes.ts ======
// filename: packages/server/src/api/pools/pools.routes.ts
// Version: 1.0.0 (Initial creation of routes for Pool management)
import { Router } from 'express';
import {
  createPoolHandler,
  deletePoolHandler,
  updatePoolHandler,
} from './pools.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const poolsRouter = Router();

// Aplicamos el middleware 'protect' a TODAS las rutas de este enrutador.
poolsRouter.use(protect);

// TODO: Añadir un middleware de autorización para asegurar que el rol sea 'ADMIN'.

// No hay una ruta GET / aquí porque las piscinas se obtienen
// a través de la ruta del cliente (/api/clients/:id) para mantener el contexto.
poolsRouter.route('/')
  .post(createPoolHandler);

poolsRouter.route('/:id')
  .patch(updatePoolHandler)
  .delete(deletePoolHandler);

export default poolsRouter;


// ====== [43] packages/server/src/api/pools/pools.service.ts ======
// filename: packages/server/src/api/pools/pools.service.ts
// Version: 1.0.0 (Initial creation of the service for Pool management)
import { PrismaClient } from '@prisma/client';
import type { Pool } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
// Omitimos los campos autogenerados por la base de datos (id, qrCode, timestamps)
export type CreatePoolInput = Omit<Pool, 'id' | 'qrCode' | 'createdAt' | 'updatedAt'>;
export type UpdatePoolInput = Partial<CreatePoolInput>;

// --- Funciones del Servicio ---

/**
 * Crea una nueva piscina para un cliente y tenant específicos.
 * @param data - Datos de la nueva piscina.
 * @returns La piscina creada.
 */
export const createPool = async (data: CreatePoolInput): Promise<Pool> => {
  return prisma.pool.create({
    data,
  });
};

/**
 * Actualiza una piscina existente.
 * @param id - El ID de la piscina a actualizar.
 * @param data - Los datos a actualizar.
 * @returns La piscina actualizada.
 */
export const updatePool = async (id: string, data: UpdatePoolInput): Promise<Pool> => {
  return prisma.pool.update({
    where: { id },
    data,
  });
};

/**
 * Elimina una piscina.
 * @param id - El ID de la piscina a eliminar.
 * @returns La piscina que fue eliminada.
 */
export const deletePool = async (id: string): Promise<Pool> => {
  // Al borrar la piscina, se borrarán en cascada sus visitas, etc.
  return prisma.pool.delete({
    where: { id },
  });
};


// ====== [44] packages/server/src/api/tasks/tasks.controller.ts ======
// filename: packages/server/src/api/tasks/tasks.controller.ts
// Version: 1.0.0 (Initial creation of the controller for Scheduled Tasks)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createTaskTemplate,
  deleteTaskTemplate,
  getTaskTemplatesByTenant,
  updateTaskTemplate,
} from './tasks.service.js';

/**
 * Maneja la creación de una nueva plantilla de tarea.
 */
export const createTaskTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acción no permitida.' });
    }

    const input = { ...req.body, tenantId };
    const newTemplate = await createTaskTemplate(input);
    res.status(201).json({ success: true, data: newTemplate });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtención de todas las plantillas de tareas de un tenant.
 */
export const getTaskTemplatesByTenantHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acción no permitida.' });
    }

    const templates = await getTaskTemplatesByTenant(tenantId);
    res.status(200).json({ success: true, data: templates });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualización de una plantilla de tarea.
 */
export const updateTaskTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la plantilla es requerido.' });
    }
    // TODO: Verificar que la plantilla que se quiere editar pertenece al tenant del usuario logueado.

    const updatedTemplate = await updateTaskTemplate(id, req.body);
    res.status(200).json({ success: true, data: updatedTemplate });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminación de una plantilla de tarea.
 */
export const deleteTaskTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la plantilla es requerido.' });
    }
    // TODO: Verificar que la plantilla que se quiere eliminar pertenece al tenant del usuario logueado.

    await deleteTaskTemplate(id);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [45] packages/server/src/api/tasks/tasks.routes.ts ======
// filename: packages/server/src/api/tasks/tasks.routes.ts
// Version: 1.0.0 (Initial creation of routes for Scheduled Tasks)
import { Router } from 'express';
import {
  createTaskTemplateHandler,
  deleteTaskTemplateHandler,
  getTaskTemplatesByTenantHandler,
  updateTaskTemplateHandler,
} from './tasks.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const tasksRouter = Router();

// Aplicamos el middleware 'protect' a TODAS las rutas de este enrutador.
tasksRouter.use(protect);

// TODO: Añadir un middleware de autorización para asegurar que el rol sea 'ADMIN'.

tasksRouter.route('/')
  .get(getTaskTemplatesByTenantHandler)
  .post(createTaskTemplateHandler);

tasksRouter.route('/:id')
  .patch(updateTaskTemplateHandler)
  .delete(deleteTaskTemplateHandler);

export default tasksRouter;


// ====== [46] packages/server/src/api/tasks/tasks.service.ts ======
// filename: packages/server/src/api/tasks/tasks.service.ts
// Version: 1.0.0 (Initial creation of the service for Scheduled Tasks)
import { PrismaClient } from '@prisma/client';
import type { ScheduledTaskTemplate } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateTaskTemplateInput = {
  name: string;
  tenantId: string; // Cada plantilla pertenece a un tenant
  description?: string;
};

export type UpdateTaskTemplateInput = Partial<Omit<CreateTaskTemplateInput, 'tenantId'>>;

// --- Funciones del Servicio ---

/**
 * Crea una nueva plantilla de tarea para un tenant específico.
 * @param input - Datos de la nueva plantilla.
 * @returns La plantilla de tarea creada.
 */
export const createTaskTemplate = async (
  input: CreateTaskTemplateInput
): Promise<ScheduledTaskTemplate> => {
  return prisma.scheduledTaskTemplate.create({
    data: input,
  });
};

/**
 * Obtiene todas las plantillas de tareas para un tenant específico.
 * @param tenantId - El ID del tenant.
 * @returns Un array de plantillas de tareas.
 */
export const getTaskTemplatesByTenant = async (
  tenantId: string
): Promise<ScheduledTaskTemplate[]> => {
  return prisma.scheduledTaskTemplate.findMany({
    where: { tenantId },
    orderBy: { name: 'asc' },
  });
};

/**
 * Actualiza una plantilla de tarea existente.
 * @param id - El ID de la plantilla a actualizar.
 * @param data - Los datos a actualizar.
 * @returns La plantilla de tarea actualizada.
 */
export const updateTaskTemplate = async (
  id: string,
  data: UpdateTaskTemplateInput
): Promise<ScheduledTaskTemplate> => {
  return prisma.scheduledTaskTemplate.update({
    where: { id },
    data,
  });
};

/**
 * Elimina una plantilla de tarea.
 * @param id - El ID de la plantilla a eliminar.
 * @returns La plantilla de tarea que fue eliminada.
 */
export const deleteTaskTemplate = async (
  id: string
): Promise<ScheduledTaskTemplate> => {
  // TODO: Añadir lógica para verificar que esta plantilla no está siendo
  // usada en ninguna PoolConfiguration antes de permitir el borrado.
  return prisma.scheduledTaskTemplate.delete({
    where: { id },
  });
};


// ====== [47] packages/server/src/api/tenants/tenants.controller.ts ======
import type { Request, Response, NextFunction } from 'express';
import {
  createTenant,
  getAllTenants,
  getTenantById,
  updateTenantStatus,
  deleteTenant,
} from './tenants.service.js';

/**
 * Maneja la creación de un nuevo tenant.
 */
export const createTenantHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenant = await createTenant(req.body);
    res.status(201).json({ success: true, data: tenant });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtención de todos los tenants.
 */
export const getAllTenantsHandler = async (
  _req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenants = await getAllTenants();
    res.status(200).json({ success: true, data: tenants });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtención de un tenant por su ID.
 */
export const getTenantByIdHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID del tenant es requerido.' });
    }

    const tenant = await getTenantById(id);

    if (!tenant) {
      const error: any = new Error('Tenant no encontrado.');
      error.statusCode = 404;
      return next(error);
    }

    res.status(200).json({ success: true, data: tenant });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualización del estado de un tenant.
 */
export const updateTenantStatusHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID del tenant es requerido.' });
    }

    const { status } = req.body;
    // TODO: Añadir validación para asegurar que 'status' es un valor válido del enum SubscriptionStatus

    const updatedTenant = await updateTenantStatus(id, status);
    res.status(200).json({ success: true, data: updatedTenant });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminación de un tenant.
 */
export const deleteTenantHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID del tenant es requerido.' });
    }

    await deleteTenant(id);

    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [48] packages/server/src/api/tenants/tenants.routes.ts ======
import { Router } from 'express';
import {
  createTenantHandler,
  getAllTenantsHandler,
  getTenantByIdHandler,
  updateTenantStatusHandler,
  deleteTenantHandler,
} from './tenants.controller.js';

const tenantsRouter = Router();

// TODO: Proteger todas estas rutas para que solo sean accesibles por un SUPER_ADMIN.

/**
 * @route   GET /api/tenants
 * @desc    Obtiene todos los tenants
 * @access  Private (SuperAdmin)
 */
tenantsRouter.get('/', getAllTenantsHandler);

/**
 * @route   POST /api/tenants
 * @desc    Crea un nuevo tenant y su primer usuario admin
 * @access  Private (SuperAdmin)
 */
tenantsRouter.post('/', createTenantHandler);

/**
 * @route   GET /api/tenants/:id
 * @desc    Obtiene un tenant específico por su ID
 * @access  Private (SuperAdmin)
 */
tenantsRouter.get('/:id', getTenantByIdHandler);

/**
 * @route   PATCH /api/tenants/:id/status
 * @desc    Actualiza el estado de la suscripción de un tenant
 * @access  Private (SuperAdmin)
 */
tenantsRouter.patch('/:id/status', updateTenantStatusHandler);

/**
 * @route   DELETE /api/tenants/:id
 * @desc    Elimina un tenant y toda su información asociada
 * @access  Private (SuperAdmin)
 */
tenantsRouter.delete('/:id', deleteTenantHandler);

export default tenantsRouter;


// ====== [49] packages/server/src/api/tenants/tenants.service.ts ======
import { PrismaClient } from '@prisma/client';
import type { Tenant, SubscriptionStatus } from '@prisma/client';
import { hashPassword } from '../../utils/password.utils.js';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
type AdminUserInput = {
  name: string;
  email: string;
  password: string;
};

export type CreateTenantInput = {
  companyName: string;
  subdomain: string;
  adminUser: AdminUserInput;
};

// --- Funciones del Servicio ---

/**
 * Crea un nuevo Tenant y su primer usuario Administrador de forma atómica.
 * @param input - Datos para el nuevo tenant y su admin.
 * @returns El objeto del Tenant recién creado.
 */
export const createTenant = async (input: CreateTenantInput): Promise<Tenant> => {
  const { companyName, subdomain, adminUser } = input;

  const newTenant = await prisma.$transaction(async (tx) => {
    const existingSubdomain = await tx.tenant.findUnique({ where: { subdomain } });
    if (existingSubdomain) {
      throw new Error('El subdominio ya está en uso.');
    }

    const existingEmail = await tx.user.findUnique({ where: { email: adminUser.email } });
    if (existingEmail) {
      throw new Error('El correo electrónico ya está en uso por otro usuario.');
    }

    const tenant = await tx.tenant.create({
      data: {
        companyName,
        subdomain,
      },
    });

    const hashedPassword = await hashPassword(adminUser.password);
    await tx.user.create({
      data: {
        name: adminUser.name,
        email: adminUser.email,
        password: hashedPassword,
        role: 'ADMIN',
        tenantId: tenant.id,
      },
    });

    return tenant;
  });

  return newTenant;
};

/**
 * Obtiene un listado de todos los tenants.
 * @returns Un array de todos los tenants.
 */
export const getAllTenants = async (): Promise<Tenant[]> => {
  return prisma.tenant.findMany({
    orderBy: {
      createdAt: 'desc',
    },
  });
};

/**
 * Busca un tenant específico por su ID.
 * @param id - El ID del tenant a buscar.
 * @returns El objeto del tenant o null si no se encuentra.
 */
export const getTenantById = async (id: string): Promise<Tenant | null> => {
  return prisma.tenant.findUnique({
    where: { id },
  });
};

/**
 * Actualiza el estado de la suscripción de un tenant.
 * @param id - El ID del tenant a actualizar.
 * @param status - El nuevo estado de la suscripción.
 * @returns El objeto del tenant actualizado.
 */
export const updateTenantStatus = async (
  id: string,
  status: SubscriptionStatus
): Promise<Tenant> => {
  return prisma.tenant.update({
    where: { id },
    data: {
      subscriptionStatus: status,
    },
  });
};

/**
 * Elimina un tenant y toda su información asociada (cascade).
 * @param id - El ID del tenant a eliminar.
 * @returns El objeto del tenant que fue eliminado.
 */
export const deleteTenant = async (id: string): Promise<Tenant> => {
  // Gracias a 'onDelete: Cascade' en el schema, al borrar un tenant,
  // se borrarán en cascada todos sus usuarios, clientes, piscinas, etc.
  return prisma.tenant.delete({
    where: { id },
  });
};


// ====== [50] packages/server/src/api/users/users.controller.ts ======
// filename: packages/server/src/api/users/users.controller.ts
// Version: 1.0.0 (Initial creation of the controller for User queries)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { getTechniciansByTenant } from './users.service.js';

/**
 * Maneja la obtención de todos los técnicos de un tenant.
 */
export const getTechniciansByTenantHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acción no permitida.' });
    }

    const technicians = await getTechniciansByTenant(tenantId);
    res.status(200).json({ success: true, data: technicians });
  } catch (error) {
    next(error);
  }
};


// ====== [51] packages/server/src/api/users/users.routes.ts ======
// filename: packages/server/src/api/users/users.routes.ts
// Version: 1.0.0 (Initial creation of routes for User queries)
import { Router } from 'express';
import { getTechniciansByTenantHandler } from './users.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const usersRouter = Router();

// Aplicamos el middleware 'protect' a TODAS las rutas de este enrutador.
usersRouter.use(protect);

// TODO: Añadir un middleware de autorización para asegurar que el rol sea 'ADMIN'.

/**
 * @route   GET /api/users/technicians
 * @desc    Obtiene una lista de todos los técnicos del tenant.
 * @access  Private (Admin)
 */
usersRouter.get('/technicians', getTechniciansByTenantHandler);


export default usersRouter;


// ====== [52] packages/server/src/api/users/users.service.ts ======
// filename: packages/server/src/api/users/users.service.ts
// Version: 1.0.0 (Initial creation of the service for User queries)
import { PrismaClient } from '@prisma/client';
import type { User } from '@prisma/client';

const prisma = new PrismaClient();

// --- Funciones del Servicio ---

/**
 * Obtiene todos los usuarios con el rol de TECHNICIAN para un tenant específico.
 * @param tenantId - El ID del tenant.
 * @returns Un array de usuarios técnicos (sin la contraseña).
 */
export const getTechniciansByTenant = async (
  tenantId: string
): Promise<Omit<User, 'password'>[]> => {
  return prisma.user.findMany({
    where: {
      tenantId,
      role: 'TECHNICIAN',
    },
    select: {
      id: true,
      email: true,
      name: true,
      role: true,
      tenantId: true,
      createdAt: true,
      updatedAt: true,
    },
    orderBy: {
      name: 'asc',
    },
  });
};


// ====== [53] packages/server/src/api/visits/visits.controller.ts ======
// filename: packages/server/src/api/visits/visits.controller.ts
// Version: 1.7.0 (Adapt assignTechnicianHandler to new logic)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { 
  getScheduledVisitsForWeek, 
  assignTechnicianToVisit,
  getVisitsForTechnicianOnDate,
  getVisitDetails,
  submitWorkOrder,
} from './visits.service.js';

/**
 * Maneja la obtención de las visitas programadas para una semana.
 */
export const getScheduledVisitsForWeekHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acción no permitida.' });
    }

    const { date } = req.query;
    if (!date || typeof date !== 'string') {
      return res.status(400).json({ message: 'Se requiere un parámetro de fecha válido.' });
    }

    const weekDate = new Date(date);
    const visits = await getScheduledVisitsForWeek(tenantId, weekDate);

    res.status(200).json({ success: true, data: visits });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la asignación de un técnico a una visita.
 */
export const assignTechnicianHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { visitId, technicianId } = req.body;
    if (!visitId) {
      return res.status(400).json({ message: 'visitId es requerido.' });
    }
    
    // TODO: Verificar que la visita pertenece al tenant del admin
    
    const assignedVisit = await assignTechnicianToVisit(visitId, technicianId);
    
    res.status(200).json({ success: true, data: assignedVisit });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtención de la ruta diaria para el técnico autenticado.
 */
export const getMyRouteHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const technicianId = req.user?.id;
    if (!technicianId || req.user?.role !== 'TECHNICIAN') {
      return res.status(403).json({ message: 'Acceso denegado.' });
    }
    
    const today = new Date();
    const visits = await getVisitsForTechnicianOnDate(technicianId, today);
    
    res.status(200).json({ success: true, data: visits });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtención de los detalles de una visita específica.
 */
export const getVisitDetailsHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la visita es requerido.' });
    }
    
    const visitDetails = await getVisitDetails(id);
    if (!visitDetails) {
      return res.status(404).json({ message: 'Visita no encontrada.' });
    }

    res.status(200).json({ success: true, data: visitDetails });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja el envío de un parte de trabajo.
 */
export const submitWorkOrderHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la visita es requerido.' });
    }
    
    await submitWorkOrder(id, req.body);

    res.status(200).json({ success: true, message: 'Parte de trabajo guardado con éxito.' });
  } catch (error) {
    console.error('ERROR AL PROCESAR PARTE DE TRABAJO:', error); 
    next(error);
  }
};


// ====== [54] packages/server/src/api/visits/visits.routes.ts ======
// filename: packages/server/src/api/visits/visits.routes.ts
// Version: 1.4.4 (Clean up unused imports and finalize route order)
import { Router } from 'express';
import { 
  getScheduledVisitsForWeekHandler,
  assignTechnicianHandler,
  getMyRouteHandler,
  getVisitDetailsHandler,
  submitWorkOrderHandler,
} from './visits.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const visitsRouter = Router();

visitsRouter.use(protect);

// --- Rutas para ADMIN ---
visitsRouter.get('/scheduled', getScheduledVisitsForWeekHandler);
visitsRouter.post('/assign', assignTechnicianHandler);

// --- Rutas para TECHNICIAN ---
visitsRouter.get('/my-route', getMyRouteHandler);

/**
 * @route   POST /api/visits/:id/complete
 * @desc    Envía y procesa los datos de un Parte de Trabajo.
 * @access  Private (Technician)
 */
visitsRouter.post('/:id/complete', submitWorkOrderHandler);

/**
 * @route   GET /api/visits/:id
 * @desc    Obtiene los detalles de una visita específica (para el Parte de Trabajo)
 * @access  Private (Technician/Admin)
 */
visitsRouter.get('/:id', getVisitDetailsHandler);

export default visitsRouter;


// ====== [55] packages/server/src/api/visits/visits.service.ts ======
// filename: packages/server/src/api/visits/visits.service.ts
// Version: 1.7.7 (Clean up unused imports after frequency logic fix)
import { PrismaClient } from '@prisma/client';
import type { Visit } from '@prisma/client'; // <-- Frequency eliminado
import { 
  startOfWeek, endOfWeek, eachDayOfInterval, isSameDay, startOfDay, endOfDay,
} from 'date-fns';

const prisma = new PrismaClient();

// --- Tipos ---
export type WorkOrderInput = {
  results: Record<string, string | number | boolean>;
  completedTasks: Record<string, boolean>;
  notes?: string;
  hasIncident?: boolean;
};


export const getScheduledVisitsForWeek = async (tenantId: string, weekDate: Date): Promise<Visit[]> => {
  const start = startOfWeek(weekDate, { weekStartsOn: 1 }); // Lunes
  const end = endOfWeek(weekDate, { weekStartsOn: 1 });   // Domingo
  const weekDays = eachDayOfInterval({ start, end });

  const pools = await prisma.pool.findMany({
    where: { tenantId, configurations: { some: {} } },
    include: { configurations: true },
  });

  const existingVisits = await prisma.visit.findMany({
    where: { pool: { tenantId }, timestamp: { gte: start, lte: end } },
  });

  const visitsToCreate: { poolId: string; timestamp: Date }[] = [];

  for (const day of weekDays) {
    for (const pool of pools) {
      
      const shouldVisitToday = pool.configurations.some(config => {
        if (config.frequency === 'DIARIA') return true;
        if (config.frequency === 'SEMANAL' && day.getDay() === 1) return true;
        return false;
      });

      if (shouldVisitToday) {
        const alreadyExists = existingVisits.some(
          (v) => v.poolId === pool.id && isSameDay(v.timestamp, day)
        );
        const alreadyInQueue = visitsToCreate.some(
          (v) => v.poolId === pool.id && isSameDay(v.timestamp, day)
        );

        if (!alreadyExists && !alreadyInQueue) {
          visitsToCreate.push({ poolId: pool.id, timestamp: day });
        }
      }
    }
  }

  if (visitsToCreate.length > 0) {
    await prisma.visit.createMany({
      data: visitsToCreate.map(v => ({ ...v, status: 'PENDING' })),
      skipDuplicates: true,
    });
  }

  return prisma.visit.findMany({
    where: { pool: { tenantId }, timestamp: { gte: start, lte: end } },
    include: { pool: { include: { client: true } } },
    orderBy: { timestamp: 'asc' },
  });
};

export const assignTechnicianToVisit = async (visitId: string, technicianId: string | null) => {
    return prisma.visit.update({
        where: { id: visitId },
        data: { technicianId },
    });
};

export const getVisitsForTechnicianOnDate = async (
  technicianId: string,
  date: Date
): Promise<Visit[]> => {
  const dayStart = startOfDay(date);
  const dayEnd = endOfDay(date);

  return prisma.visit.findMany({
    where: {
      technicianId,
      status: 'PENDING',
      timestamp: {
        gte: dayStart,
        lte: dayEnd,
      },
    },
    include: {
      pool: {
        include: {
          client: true,
        },
      },
    },
    orderBy: {
      timestamp: 'asc',
    },
  });
};

export const getVisitDetails = async (visitId: string) => {
  return prisma.visit.findUnique({
    where: { id: visitId },
    include: {
      pool: {
        include: {
          client: true,
          configurations: {
            include: {
              parameterTemplate: true,
              taskTemplate: true,
            },
          },
        },
      },
    },
  });
};

export const submitWorkOrder = async (visitId: string, data: WorkOrderInput) => {
  return prisma.$transaction(async (tx) => {
    const visit = await tx.visit.findUnique({
      where: { id: visitId },
      include: { 
        pool: { 
          include: { 
            configurations: { include: { parameterTemplate: true, taskTemplate: true } } 
          } 
        },
        technician: true
      },
    });
    if (!visit) throw new Error('Visita no encontrada');
    
    const { results, completedTasks, notes, hasIncident } = data;

    for (const [configId, value] of Object.entries(results)) {
      if(value === '' || value === null) continue;
      const config = visit.pool.configurations.find(c => c.id === configId);
      if (config?.parameterTemplate) {
        await tx.visitResult.create({
          data: {
            visitId,
            value: String(value),
            parameterName: config.parameterTemplate.name,
            parameterUnit: config.parameterTemplate.unit,
          },
        });
      }
    }
    
    const completedTaskNames = Object.entries(completedTasks)
      .filter(([, completed]) => completed)
      .map(([configId]) => {
        const config = visit.pool.configurations.find(c => c.id === configId);
        return config?.taskTemplate?.name || 'Tarea desconocida';
      });
    
    await tx.visit.update({
      where: { id: visitId },
      data: {
        notes,
        hasIncident: hasIncident || false,
        completedTasks: completedTaskNames,
        status: 'COMPLETED',
      },
    });

    if (hasIncident) {
      const admin = await tx.user.findFirst({
        where: { tenantId: visit.pool.tenantId, role: 'ADMIN' },
      });
      if (admin) {
        const technicianName = visit.technician ? visit.technician.name : 'Un técnico';
        await tx.notification.create({
          data: {
            message: `Nueva incidencia reportada por ${technicianName} en la piscina ${visit.pool.name}.`,
            tenantId: visit.pool.tenantId,
            userId: admin.id,
          },
        });
      }
    }
    
    const configIdsToUpdate = [...Object.keys(results).filter(k => results[k] !== ''), ...Object.keys(completedTasks).filter(k => completedTasks[k])];
    if(configIdsToUpdate.length > 0) {
        await tx.poolConfiguration.updateMany({
            where: { id: { in: configIdsToUpdate } },
            data: { lastCompleted: new Date() },
        });
    }
  });
};


// ====== [56] packages/server/src/app.ts ======
// filename: packages/server/src/app.ts
// Version: 1.7.0 (Mount usersRouter for Admin module)
import express from 'express';
import type { Request, Response } from 'express';
import cors from 'cors';
import cookieParser from 'cookie-parser';

import { errorHandler } from './middleware/error.middleware.js';
import authRouter from './api/auth/auth.routes.js';
import tenantsRouter from './api/tenants/tenants.routes.js';
import parametersRouter from './api/parameters/parameters.routes.js';
import tasksRouter from './api/tasks/tasks.routes.js';
import clientsRouter from './api/clients/clients.routes.js';
import poolsRouter from './api/pools/pools.routes.js';
import poolConfigurationsRouter from './api/pool-configurations/pool-configurations.routes.js';
import visitsRouter from './api/visits/visits.routes.js';
import usersRouter from './api/users/users.routes.js';

// --- Instancia de la App ---
const app = express();

// --- Middlewares Esenciales ---
app.use(cors({
  origin: 'http://localhost:5173',
  credentials: true,
}));
app.use(cookieParser());
app.use(express.json());


// --- Rutas de la API ---

// Ruta de health-check para verificar que el servidor está vivo.
app.get('/api/health', (_req: Request, res: Response) => {
  res.status(200).json({ status: 'UP' });
});

// Montamos los enrutadores de cada módulo
app.use('/api/auth', authRouter);
app.use('/api/tenants', tenantsRouter);
app.use('/api/parameters', parametersRouter);
app.use('/api/tasks', tasksRouter);
app.use('/api/clients', clientsRouter);
app.use('/api/pools', poolsRouter);
app.use('/api/pool-configurations', poolConfigurationsRouter);
app.use('/api/visits', visitsRouter);
app.use('/api/users', usersRouter);


// --- Gestor de Errores ---
app.use(errorHandler);

export default app;


// ====== [57] packages/server/src/config/index.ts ======
import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

// --- Recreación de __dirname para ES Modules ---
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
// ---------------------------------------------

dotenv.config({ path: path.resolve(__dirname, '../../.env') });

const getEnvVar = (key: string): string => {
  const value = process.env[key];
  if (!value) {
    throw new Error(`Falta la variable de entorno requerida: ${key}`);
  }
  return value;
};

const config = {
  PORT: parseInt(getEnvVar('PORT'), 10),
  JWT_SECRET: getEnvVar('JWT_SECRET'),
  JWT_EXPIRES_IN: parseInt(getEnvVar('JWT_EXPIRES_IN'), 10),
  DATABASE_URL: getEnvVar('DATABASE_URL'),
};

export default config;


// ====== [58] packages/server/src/middleware/auth.middleware.ts ======
import type { Request, Response, NextFunction } from 'express';
import { PrismaClient } from '@prisma/client';
import type { User } from '@prisma/client';
import { verifyToken } from '../utils/jwt.utils.js';

const prisma = new PrismaClient();

// Creamos un tipo "seguro" para el usuario, omitiendo la contraseña.
type SafeUser = Omit<User, 'password'>;

// Extendemos la interfaz Request de Express para que use nuestro tipo SafeUser.
export interface AuthRequest extends Request {
  user?: SafeUser;
}

/**
 * Middleware para proteger rutas. Verifica el token JWT de la cookie.
 * Si el token es válido, adjunta el usuario a la request y pasa al siguiente middleware.
 * Si no, devuelve un error 401 (No autorizado).
 */
export const protect = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  const token = req.cookies.token;

  if (!token) {
    return res.status(401).json({ message: 'No autenticado: no hay token.' });
  }

  try {
    const decoded = verifyToken<{ id: string }>(token);

    if (!decoded) {
      return res.status(401).json({ message: 'No autenticado: token inválido.' });
    }

    const user = await prisma.user.findUnique({
      where: { id: decoded.id },
      // Seleccionamos todos los campos EXCEPTO la contraseña.
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        tenantId: true,
        createdAt: true,
        updatedAt: true,
      },
    });

    if (!user) {
      return res.status(401).json({ message: 'No autenticado: usuario no encontrado.' });
    }

    // Ahora `user` coincide con el tipo `SafeUser`, por lo que la asignación es válida.
    req.user = user;
    next();
  } catch (error) {
    return res.status(401).json({ message: 'No autenticado: error en la validación.' });
  }
};


// ====== [59] packages/server/src/middleware/error.middleware.ts ======
import type { Request, Response, NextFunction } from 'express';

// Interfaz para asegurar que nuestros errores puedan tener un código de estado
interface HttpError extends Error {
  statusCode?: number;
}

export const errorHandler = (
  err: HttpError,
  _req: Request,
  res: Response,
  _next: NextFunction
) => {
  // Guardamos el error en la consola para depuración
  console.error(err);

  const statusCode = err.statusCode || 500;
  const message = err.message || 'Ha ocurrido un error inesperado en el servidor.';

  res.status(statusCode).json({
    success: false,
    statusCode: statusCode,
    message: message,
  });
};


// ====== [60] packages/server/src/server.ts ======
import app from './app.js';
import config from './config/index.js';

const PORT = config.PORT || 3001;

app.listen(PORT, () => {
  console.log(`🚀 Servidor escuchando en http://localhost:${PORT}`);
});


// ====== [61] packages/server/src/utils/jwt.utils.ts ======
import jwt from 'jsonwebtoken';
import type { SignOptions } from 'jsonwebtoken';
import config from '../config/index.js';

/**
 * Firma un payload para crear un token JWT.
 * @param payload El objeto que se incluirá en el token (ej. { userId: '...' }).
 * @returns El token JWT como una cadena de texto.
 */
export const signToken = (payload: object): string => {
  const options: SignOptions = {
    expiresIn: config.JWT_EXPIRES_IN,
  };

  return jwt.sign(payload, config.JWT_SECRET, options);
};

/**
 * Verifica un token JWT y devuelve su payload si es válido.
 * @template T El tipo esperado del payload.
 * @param token El token JWT a verificar.
 * @returns El payload decodificado si el token es válido; de lo contrario, null.
 */
export const verifyToken = <T>(token: string): T | null => {
  try {
    const decoded = jwt.verify(token, config.JWT_SECRET) as T;
    return decoded;
  } catch (error) {
    return null;
  }
};


// ====== [62] packages/server/src/utils/password.utils.ts ======
import bcrypt from 'bcryptjs';

const SALT_ROUNDS = 12;

/**
 * Genera el hash de una contraseña en texto plano.
 * @param password La contraseña en texto plano.
 * @returns Una promesa que resuelve en el hash de la contraseña.
 */
export const hashPassword = (password: string): Promise<string> => {
  return bcrypt.hash(password, SALT_ROUNDS);
};

/**
 * Compara una contraseña en texto plano con un hash.
 * @param password La contraseña en texto plano a comparar.
 * @param hash El hash almacenado en la base de datos.
 * @returns Una promesa que resuelve en `true` si las contraseñas coinciden, `false` en caso contrario.
 */
export const comparePassword = (password: string, hash: string): Promise<boolean> => {
  return bcrypt.compare(password, hash);
};


// ====== [63] packages/server/tsconfig.json ======
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist"
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules"]
}


// ====== [64] tsconfig.json ======
{
  "compilerOptions": {
    /* Base Options */
    "esModuleInterop": true,
    "skipLibCheck": true,
    "target": "ES2022",
    "allowJs": true,
    "resolveJsonModule": true,
    "moduleDetection": "force",
    "isolatedModules": true,
    "verbatimModuleSyntax": true,

    /* Strictness */
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitAny": true,

    /* Module Resolution */
    "moduleResolution": "NodeNext",
    "module": "NodeNext",

    /* Linter */
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true
  },
  "exclude": ["node_modules"]
}

