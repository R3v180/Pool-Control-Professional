# √çNDICE DE ARCHIVOS (ESTRUCTURA REFACTORIZADA)

1. DEVELOPMENT_PLAN.md
2. PROJECT_STATUS.md
3. README.md
4. package.json
5. packages/client/index.html
6. packages/client/package.json
7. packages/client/src/App.tsx
8. packages/client/src/api/apiClient.ts
9. packages/client/src/features/admin/pages/AdminDashboard.tsx
10. packages/client/src/features/admin/pages/IncidentsHistoryPage.tsx
11. packages/client/src/features/admin/pages/ParameterCatalogPage.tsx
12. packages/client/src/features/admin/pages/ProductCatalogPage.tsx
13. packages/client/src/features/admin/pages/ProductCategoryCatalogPage.tsx
14. packages/client/src/features/admin/pages/TaskCatalogPage.tsx
15. packages/client/src/features/admin/pages/clients/ClientDetailPage.tsx
16. packages/client/src/features/admin/pages/clients/ClientsPage.tsx
17. packages/client/src/features/admin/pages/incidents/IncidentDetailPage.tsx
18. packages/client/src/features/admin/pages/planner/PlannerPage.tsx
19. packages/client/src/features/admin/pages/planner/components/ControlPanel.tsx
20. packages/client/src/features/admin/pages/planner/components/PendingWorkSidebar.tsx
21. packages/client/src/features/admin/pages/planner/planner-styles.css
22. packages/client/src/features/admin/pages/planning/AvailabilityPage.tsx
23. packages/client/src/features/admin/pages/planning/RouteTemplateFormPage.tsx
24. packages/client/src/features/admin/pages/planning/RouteTemplatesPage.tsx
25. packages/client/src/features/admin/pages/pools/PoolDetailPage.tsx
26. packages/client/src/features/admin/pages/reports/ConsumptionReportPage.tsx
27. packages/client/src/features/admin/pages/zones/ZoneManagementPage.tsx
28. packages/client/src/features/auth/pages/LoginPage.tsx
29. packages/client/src/features/financials/pages/ExpensesPage.tsx
30. packages/client/src/features/financials/pages/PaymentsPage.tsx
31. packages/client/src/features/manager/pages/InvoicingReportPage.tsx
32. packages/client/src/features/manager/pages/ManagerDashboard.tsx
33. packages/client/src/features/superadmin/pages/TenantsPage.tsx
34. packages/client/src/features/technician/pages/MyRoutePage.tsx
35. packages/client/src/features/technician/pages/WorkOrderPage.tsx
36. packages/client/src/main.tsx
37. packages/client/src/providers/AuthProvider.tsx
38. packages/client/src/router/components.tsx
39. packages/client/src/router/index.tsx
40. packages/client/src/stores/auth.store.ts
41. packages/client/src/styles/theme.ts
42. packages/client/tsconfig.json
43. packages/client/tsconfig.node.json
44. packages/client/vite.config.ts
45. packages/server/package.json
46. packages/server/prisma/data/catalogs.ts
47. packages/server/prisma/data/clients.ts
48. packages/server/prisma/data/consumptions.ts
49. packages/server/prisma/data/financial-rules.ts
50. packages/server/prisma/data/incident-tasks.ts
51. packages/server/prisma/data/product-categories.ts
52. packages/server/prisma/data/products.ts
53. packages/server/prisma/data/route-templates.ts
54. packages/server/prisma/data/transactions.ts
55. packages/server/prisma/data/user-availabilities.ts
56. packages/server/prisma/data/users.ts
57. packages/server/prisma/data/zones.ts
58. packages/server/prisma/seed.ts
59. packages/server/src/api/auth/auth.controller.ts
60. packages/server/src/api/auth/auth.routes.ts
61. packages/server/src/api/auth/auth.service.ts
62. packages/server/src/api/client-product-pricing/client-product-pricing.controller.ts
63. packages/server/src/api/client-product-pricing/client-product-pricing.routes.ts
64. packages/server/src/api/client-product-pricing/client-product-pricing.service.ts
65. packages/server/src/api/clients/clients.controller.ts
66. packages/server/src/api/clients/clients.routes.ts
67. packages/server/src/api/clients/clients.service.ts
68. packages/server/src/api/dashboard/dashboard.controller.ts
69. packages/server/src/api/dashboard/dashboard.routes.ts
70. packages/server/src/api/dashboard/dashboard.service.ts
71. packages/server/src/api/expenses/expenses.controller.ts
72. packages/server/src/api/expenses/expenses.routes.ts
73. packages/server/src/api/expenses/expenses.service.ts
74. packages/server/src/api/incident-tasks/incident-tasks.controller.ts
75. packages/server/src/api/incident-tasks/incident-tasks.routes.ts
76. packages/server/src/api/incident-tasks/incident-tasks.service.ts
77. packages/server/src/api/notifications/notifications.controller.ts
78. packages/server/src/api/notifications/notifications.routes.ts
79. packages/server/src/api/notifications/notifications.service.ts
80. packages/server/src/api/parameters/parameters.controller.ts
81. packages/server/src/api/parameters/parameters.routes.ts
82. packages/server/src/api/parameters/parameters.service.ts
83. packages/server/src/api/payments/payments.controller.ts
84. packages/server/src/api/payments/payments.routes.ts
85. packages/server/src/api/payments/payments.service.ts
86. packages/server/src/api/planning/planning.controller.ts
87. packages/server/src/api/planning/planning.routes.ts
88. packages/server/src/api/planning/planning.service.ts
89. packages/server/src/api/pool-configurations/pool-configurations.controller.ts
90. packages/server/src/api/pool-configurations/pool-configurations.routes.ts
91. packages/server/src/api/pool-configurations/pool-configurations.service.ts
92. packages/server/src/api/pools/pools.controller.ts
93. packages/server/src/api/pools/pools.routes.ts
94. packages/server/src/api/pools/pools.service.ts
95. packages/server/src/api/product-categories/product-categories.controller.ts
96. packages/server/src/api/product-categories/product-categories.routes.ts
97. packages/server/src/api/product-categories/product-categories.service.ts
98. packages/server/src/api/products/products.controller.ts
99. packages/server/src/api/products/products.routes.ts
100. packages/server/src/api/products/products.service.ts
101. packages/server/src/api/reports/reports.controller.ts
102. packages/server/src/api/reports/reports.routes.ts
103. packages/server/src/api/reports/reports.service.ts
104. packages/server/src/api/route-templates/route-templates.controller.ts
105. packages/server/src/api/route-templates/route-templates.routes.ts
106. packages/server/src/api/route-templates/route-templates.service.ts
107. packages/server/src/api/tasks/tasks.controller.ts
108. packages/server/src/api/tasks/tasks.routes.ts
109. packages/server/src/api/tasks/tasks.service.ts
110. packages/server/src/api/tenants/tenants.controller.ts
111. packages/server/src/api/tenants/tenants.routes.ts
112. packages/server/src/api/tenants/tenants.service.ts
113. packages/server/src/api/uploads/uploads.controller.ts
114. packages/server/src/api/uploads/uploads.routes.ts
115. packages/server/src/api/uploads/uploads.service.ts
116. packages/server/src/api/users/users.controller.ts
117. packages/server/src/api/users/users.routes.ts
118. packages/server/src/api/users/users.service.ts
119. packages/server/src/api/visits/visits.controller.ts
120. packages/server/src/api/visits/visits.routes.ts
121. packages/server/src/api/visits/visits.service.ts
122. packages/server/src/api/zones/zones.controller.ts
123. packages/server/src/api/zones/zones.routes.ts
124. packages/server/src/api/zones/zones.service.ts
125. packages/server/src/app.ts
126. packages/server/src/config/index.ts
127. packages/server/src/jobs/visit-generator.job.ts
128. packages/server/src/middleware/auth.middleware.ts
129. packages/server/src/middleware/authorize.middleware.ts
130. packages/server/src/middleware/error.middleware.ts
131. packages/server/src/server.ts
132. packages/server/src/utils/jwt.utils.ts
133. packages/server/src/utils/password.utils.ts
134. packages/server/tsconfig.json
135. tsconfig.json


# CONTENIDO DE ARCHIVOS


// ====== [1] DEVELOPMENT_PLAN.md ======
// ====== [1] DEVELOPMENT_PLAN.md ======

# Plan de Desarrollo y Arquitectura: Pool-Control Professional

**Filosof√≠a del Documento:** Este no es solo un plan, es la narrativa arquitect√≥nica y de negocio del proyecto. Sirve como la hoja de ruta para el trabajo futuro y, a la vez, como una cr√≥nica de las decisiones tomadas.

---

## ‚úÖ FASE 0 a 8: Fundaci√≥n, Operativa Inteligente y Business Intelligence

- **Estado:** `COMPLETADA`
- **Resumen:** Durante estas fases, se ha construido una plataforma operativa robusta y completa. Se ha digitalizado el flujo de trabajo, desde la gesti√≥n de cat√°logos y clientes hasta la ejecuci√≥n de partes de trabajo y un sistema de ticketing avanzado. La Fase 8 culmin√≥ con la implementaci√≥n de un **Dashboard de Gerencia Interactivo**, que proporciona KPIs din√°micos y navegables para un an√°lisis de negocio en tiempo real.

---

## üöß FASE 9: El Motor de Planificaci√≥n Avanzada (v2.0)

- **Estado:** `EN PROGRESO`
- **Intenci√≥n Estrat√©gica:** Transformar la planificaci√≥n de una tarea manual y diaria a un **proceso de dise√±o estrat√©gico y semi-automatizado**. El objetivo es reducir dr√°sticamente el tiempo de gesti√≥n del `ADMIN`, optimizar las rutas de los t√©cnicos y hacer el sistema escalable para manejar un gran volumen de clientes.

- **Plan de Acci√≥n Detallado para la v2.0:**

  1.  **Dise√±o de la Arquitectura de Datos:**

      - **Estado:** `COMPLETADO`
      - **Valor Aportado:** Se ha redise√±ado el `schema.prisma` para introducir los conceptos de **Zonas Geogr√°ficas** y **Rutas Maestras**. Esta nueva estructura permite una organizaci√≥n del trabajo mucho m√°s l√≥gica e intuitiva.

  2.  **M√≥dulo de Gesti√≥n de Zonas y Rutas:**

      - **Estado:** `PENDIENTE`
      - **Intenci√≥n Estrat√©gica:** Dotar al `ADMIN` de las herramientas para dise√±ar la operativa de la empresa.
      - **Capacidades a Implementar:**
        - **Gesti√≥n de Zonas:** Una interfaz para crear, editar y eliminar las √°reas de trabajo geogr√°ficas.
        - **Dise√±o de Rutas Maestras:** Una interfaz para crear rutas (ej. "Lunes-Arenal"), asignarlas a un t√©cnico habitual y a una o m√°s zonas.
        - **Gesti√≥n de Estacionalidad:** Permitir definir diferentes frecuencias de visita para una misma ruta seg√∫n el periodo del a√±o (ej. m√°s visitas en verano).

  3.  **Automatizaci√≥n y Planificador Inteligente:**

      - **Estado:** `PENDIENTE`
      - **Intenci√≥n Estrat√©gica:** Automatizar la generaci√≥n del plan de trabajo semanal y dar al `ADMIN` las herramientas para gestionar las excepciones de forma eficiente.
      - **Capacidades a Implementar:**
        - **Generador Autom√°tico de Visitas:** Un proceso en el backend que leer√° las Rutas Maestras y crear√° el calendario de visitas de forma autom√°tica.
        - **Gesti√≥n de "Deuda Operativa":** El `PlannerPage` mostrar√° de forma destacada las visitas de d√≠as anteriores no completadas, obligando a su reprogramaci√≥n.
        - **Gesti√≥n de Bajas:** El `ADMIN` podr√° marcar a un t√©cnico como no disponible, moviendo sus visitas a una "bolsa de trabajo" para ser reasignadas f√°cilmente.

  4.  **Gesti√≥n de Tareas no Planificadas:**
      - **Estado:** `PENDIENTE`
      - **Intenci√≥n Estrat√©gica:** Integrar las urgencias y tareas √∫nicas en el flujo de planificaci√≥n.
      - **Capacidades a Implementar:** Un sistema de **"√ìrdenes de Trabajo Especiales"** que pueden ser creadas y asignadas sobre la marcha en el `PlannerPage`.

---

## ‚ñ∂Ô∏è Visi√≥n Post-v2.0: Hacia el ERP Completo

Una vez consolidado el motor de planificaci√≥n, el desarrollo continuar√° con los siguientes grandes m√≥dulos.

- **M√≥dulo de Estado de Cuentas y Cobros:**

  - **Estado:** `PLANIFICADO`
  - **Prop√≥sito:** Ofrecer una visi√≥n clara mes a mes del estado de facturaci√≥n de cada cliente (Pagado, Pendiente, Atrasado) y facilitar la gesti√≥n de cobros.

- **Alertas Proactivas por Umbrales:**

  - **Estado:** `PLANIFICADO`
  - **Prop√≥sito:** Implementar un sistema de vigilancia autom√°tica para pasar de la correcci√≥n a la prevenci√≥n de problemas.

- **Gesti√≥n de Inventario y Compras:**

  - **Estado:** `PLANIFICADO`
  - **Prop√≥sito:** Optimizar la gesti√≥n de stock, definir m√≠nimos/m√°ximos y generar propuestas de compra.

- **Modo Offline (PWA) para T√©cnicos:**
  - **Estado:** `PLANIFICADO`
  - **Prop√≥sito:** Garantizar la continuidad del negocio en campo.



// ====== [2] PROJECT_STATUS.md ======
// ====== [2] PROJECT_STATUS.md ======

# Estado del Proyecto y Cr√≥nica de Desarrollo: Pool-Control Professional

**Filosof√≠a de este documento:** Este no es solo un registro de tareas, es el pulso del proyecto. Refleja nuestro compromiso con la excelencia, documentando no solo _qu√©_ hemos hecho, sino _por qu√©_ lo hemos hecho y el _valor_ que cada fase aporta al producto final.

_√öltima actualizaci√≥n: 15 de julio de 2025, 20:00 CEST_

---

## 1. Visi√≥n Estrat√©gica Actual: Hacia la Planificaci√≥n Inteligente v2.0

Tras una fase intensiva de desarrollo y estabilizaci√≥n, el proyecto se encuentra en un punto de inflexi√≥n. Se ha consolidado una base operativa robusta y se han implementado las primeras herramientas de inteligencia de negocio. El siguiente gran salto evolutivo es la implementaci√≥n de un sistema de **planificaci√≥n avanzada y semi-automatizada** que reducir√° dr√°sticamente la carga de trabajo administrativo y optimizar√° las operaciones de campo.

---

## 2. Hitos de Desarrollo Validados

### ‚úÖ **Dashboard de Gerencia Interactivo v1**

- **Estado:** `COMPLETADO Y VALIDADO`
- **Resumen:** Se ha implementado con √©xito un dashboard din√°mico para el rol de Gerente. Los widgets son interactivos, permitiendo la navegaci√≥n desde KPIs de alto nivel (coste de productos, incidencias abiertas) a las p√°ginas de detalle correspondientes para un an√°lisis en profundidad. Se ha a√±adido un selector de periodo para un an√°lisis hist√≥rico.

### ‚úÖ **Estabilizaci√≥n de la Plataforma y Refactorizaci√≥n del Backend**

- **Estado:** `COMPLETADO Y VALIDADO`
- **Resumen:** Se ha llevado a cabo una fase cr√≠tica de depuraci√≥n y refactorizaci√≥n. Se han resuelto inconsistencias entre el esquema de la base de datos y la l√≥gica de los servicios, asegurando que todas las funcionalidades existentes (gesti√≥n de incidencias, informes, etc.) operan de forma estable y predecible.

### ‚úÖ **Coherencia del "Rol Camale√≥n"**

- **Estado:** `COMPLETADO Y VALIDADO`
- **Resumen:** Se ha mejorado la l√≥gica de asignaci√≥n para permitir que los usuarios con rol `MANAGER` puedan ser asignatarios directos de visitas y tareas de incidencia, cerrando un hueco funcional clave en el concepto del "Rol Camale√≥n".

---

## 3. Plan de Acci√≥n y Tareas Pendientes (Sprint v2.0)

Esta es la m√°xima prioridad actual. El objetivo es construir el n√∫cleo del nuevo motor de planificaci√≥n.

### **Fase 1: El Nuevo N√∫cleo de Datos (Backend)**

- **Estado:** `COMPLETADO`
- **Objetivo:** Modificar la estructura de la base de datos para dar soporte a la planificaci√≥n avanzada.
- **Tareas T√©cnicas Validadas:**
  - **`schema.prisma`:** Se han a√±adido los nuevos modelos (`Zone`, `RouteTemplate`, `RouteTemplateSeason`, `SpecialWorkOrder`) y se han modificado los modelos existentes (`Pool`, `User`) para soportar la nueva l√≥gica.
  - **`seed.ts`:** El script de semillado ha sido completamente reescrito para poblar la base de datos con una estructura de datos coherente que incluye zonas, rutas maestras y visitas generadas autom√°ticamente.

### **Fase 2: Construcci√≥n de APIs y L√≥gica de Negocio (Backend)**

- **Estado:** `PENDIENTE (Prioridad M√°xima)`
- **Objetivo:** Desarrollar todos los endpoints de la API necesarios para gestionar la nueva estructura de planificaci√≥n.
- **Tareas T√©cnicas:**
  - **API de Zonas:** Crear el CRUD completo para `Zone`.
  - **API de Rutas Maestras:** Crear el CRUD para `RouteTemplate` y sus `RouteTemplateSeason`.
  - **Job de Generaci√≥n de Visitas:** Implementar el script (`visit-generator.job.ts`) que se ejecutar√° peri√≥dicamente para generar las visitas de forma autom√°tica.
  - **Evoluci√≥n de API de Visitas:** Refactorizar el endpoint `GET /api/visits/scheduled` para que lea las visitas pre-generadas y devuelva tambi√©n las visitas vencidas.

### **Fase 3: Marat√≥n de Frontend e Integraci√≥n**

- **Estado:** `PENDIENTE`
- **Objetivo:** Construir todas las interfaces de usuario para la gesti√≥n de la planificaci√≥n.
- **Tareas T√©cnicas:**
  - **P√°gina de Gesti√≥n de Zonas:** Crear la interfaz para el CRUD de Zonas.
  - **P√°ginas de Rutas Maestras:** Crear las interfaces para listar y configurar las `RouteTemplate`.
  - **Refactorizaci√≥n del Planificador (`PlannerPage.tsx`):** Redise√±ar la p√°gina para que visualice el plan generado, la columna de "Deuda Operativa" (visitas vencidas) y la de "Trabajo Hu√©rfano" (por bajas).
  - **Integrar √ìrdenes de Trabajo Especiales:** A√±adir la funcionalidad para crear y asignar visitas √∫nicas.

### **Tareas de Futuras Iteraciones (Post-v2.0)**

- **Alertas Proactivas por Umbrales.**
- **M√≥dulo de Estado de Cuentas por Cliente.**
- **Optimizaci√≥n de Rutas con API de Mapas.**
- **Gesti√≥n de Inventario.**



// ====== [3] README.md ======
// ====== [3] README.md ======

# Pool-Control Professional: Especificaci√≥n Funcional y Arquitect√≥nica v11.0

| **Documentos de Apoyo:** | [Ver Plan de Desarrollo Estrat√©gico](./DEVELOPMENT_PLAN.md) | [Ver Estado Actual del Proyecto](./PROJECT_STATUS.md) |
| :----------------------- | :---------------------------------------------------------- | :---------------------------------------------------- |

---

**Fecha de la Versi√≥n:** 15 de julio de 2025
**Proyecto:** Plataforma SaaS de Gesti√≥n Integral para Empresas de Mantenimiento de Piscinas.

---

## 1. üéØ Visi√≥n del Producto: El Sistema Nervioso Inteligente de su Negocio

**Pool-Control Professional** no es una aplicaci√≥n de gesti√≥n m√°s; es una plataforma SaaS (Software como Servicio) concebida para ser el **centro de operaciones digital, proactivo e inteligente** que impulsa a las empresas de mantenimiento de piscinas hacia una nueva era de eficiencia, control y rentabilidad.

Nuestra misi√≥n es erradicar las ineficiencias sist√©micas que lastran al sector. A trav√©s de la digitalizaci√≥n, la automatizaci√≥n y la **inteligencia de negocio**, transformamos la gesti√≥n reactiva en una **operativa estandarizada, medible y, fundamentalmente, m√°s rentable.**

---

## 2. üë• Definici√≥n de Roles: Un Ecosistema Conectado y Flexible

La plataforma se fundamenta en un sistema de roles dise√±ado para maximizar la eficiencia y la seguridad.

| Rol                  | Misi√≥n Principal                        | Capacidades Clave y Flujo de Trabajo Detallado                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| :------------------- | :-------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **SuperAdmin**       | **Gestionar la Plataforma SaaS.**       | Responsable del ciclo de vida de los tenants (las empresas clientes). Realiza el CRUD sobre los **Tenants** y crea el usuario `ADMIN` inicial para cada nueva empresa. Por dise√±o, no tiene visibilidad alguna sobre los datos operativos de sus clientes.                                                                                                                                                                                                                                  |
| **Admin (Isa)**      | **Orquestar la Operativa y Finanzas.**  | Es la "Arquitecta del Servicio". Su misi√≥n es **dise√±ar la operativa** y gestionar las excepciones. Define los cat√°logos, **Zonas geogr√°ficas**, y dise√±a las **Rutas Maestras** semanales. Supervisa la planificaci√≥n autom√°tica, gestiona las incidencias a trav√©s de un sistema de ticketing, y analiza la rentabilidad. En el d√≠a a d√≠a, su foco es **gestionar las excepciones**: reasignar trabajo por bajas, reprogramar visitas vencidas y gestionar √≥rdenes de trabajo especiales. |
| **T√©cnico**          | **Ejecutar con Precisi√≥n en Campo.**    | Su interfaz est√° 100% optimizada para la eficiencia en movilidad. Su flujo es simple y directo: consultar su **ruta de trabajo del d√≠a** (visitas y tareas especiales), rellenar el **parte de trabajo din√°mico** y reportar cualquier **incidencia** con notas y fotograf√≠as. Es notificado de cualquier actualizaci√≥n sobre sus tareas.                                                                                                                                                   |
| **Gerencia (Jorge)** | **Analizar y Actuar sobre el Negocio.** | üëë **El Rol "Camale√≥n"**. Este rol potente y flexible opera en un **Modo Supervisor** enfocado en el an√°lisis estrat√©gico a trav√©s de un **dashboard con KPIs interactivos**. Su caracter√≠stica clave es el **"Selector de Vista"**: puede asumir temporalmente la **Vista de Administraci√≥n** para ayudar a planificar o la **Vista de T√©cnico** para cubrir una ruta. Todas sus acciones quedan auditadas, y puede ser asignatario directo de visitas y tareas.                           |

---

## 3. ‚öôÔ∏è Especificaci√≥n Funcional: El Ciclo Virtuoso de Operaciones

El sistema opera bajo el ciclo: **DISE√ëAR ‚ûî PLANIFICAR (AUTOM√ÅTICO) ‚ûî EJECUTAR ‚ûî SUPERVISAR ‚ûî ANALIZAR**.

### **ETAPA 1: DISE√ëO DE LA OPERATIVA (El Cerebro del Negocio)**

_Rol: Admin_

- **Configuraci√≥n de Cat√°logos y Zonas:** Se define el ADN de la empresa: productos, servicios y **Zonas geogr√°ficas** de operaci√≥n.
- **Ficha del Cliente (`ClientDetailPage`):** Es el centro de la relaci√≥n comercial. Aqu√≠ se asigna el cliente a una **Zona** y se establecen sus condiciones financieras (`monthlyFee`, `billingModel`, reglas de precios).
- **Dise√±o de Rutas Maestras (`RouteTemplatesPage`):**
  - El `ADMIN` crea rutas (ej. "Lunes - Arenal") y les asocia **Zonas** y un **t√©cnico habitual**.
  - **Gesti√≥n de Estacionalidad:** Para cada ruta, se definen periodos (ej. Verano, Invierno) con distintas **frecuencias de visita**.

### **ETAPA 2: PLANIFICACI√ìN AUTOM√ÅTICA Y GESTI√ìN DE EXCEPCIONES**

_Rol: Admin_

- **Generaci√≥n Autom√°tica de Visitas:** Un proceso nocturno lee las Rutas Maestras y **genera autom√°ticamente el calendario de visitas** para la semana, asign√°ndolas al t√©cnico correspondiente.
- **Planificador Semanal (`PlannerPage`):** La torre de control del `ADMIN`.
  - **Visualizaci√≥n:** Muestra el plan semanal generado autom√°ticamente.
  - **Gesti√≥n de Deuda Operativa:** Una columna especial muestra las **visitas de d√≠as anteriores que quedaron pendientes**, forzando al `ADMIN` a reprogramarlas (arrastr√°ndolas a un nuevo d√≠a).
  - **Gesti√≥n de Bajas:** El `ADMIN` puede marcar a un t√©cnico como "no disponible", moviendo sus visitas a una columna de **"Trabajo Hu√©rfano"** para una f√°cil reasignaci√≥n a otros t√©cnicos.
  - **√ìrdenes de Trabajo Especiales:** Permite crear visitas √∫nicas y urgentes que no pertenecen a una ruta recurrente y asignarlas manualmente.

### **ETAPA 3: EJECUCI√ìN Y REPORTE EN CAMPO**

_Rol: T√©cnico_

- **Ruta del D√≠a Optimizada (`MyRoutePage`):** El t√©cnico ve su lista de visitas para hoy, en el orden definido por el `ADMIN`.
- **Parte de Trabajo Din√°mico (`WorkOrderPage`):** El t√©cnico registra mediciones, tareas, consumos y reporta incidencias con fotos. El sistema puede generar **alertas autom√°ticas** si un par√°metro est√° fuera de los umbrales de seguridad.

### **ETAPA 4: SUPERVISI√ìN Y AN√ÅLISIS**

_Roles: Admin, Gerencia_

- **Dashboard de Gerencia (`ManagerDashboard`):** Un centro de mando con KPIs din√°micos y widgets interactivos que permiten navegar desde una m√©trica general (ej. "Coste de Productos") hasta el detalle m√°s profundo (el parte de trabajo que gener√≥ ese coste).
- **Gesti√≥n de Incidencias (`IncidentDetailPage`):** Sistema de ticketing avanzado para la resoluci√≥n colaborativa de problemas.
- **Informes Financieros:** El sistema permite generar tanto informes de **Rentabilidad Interna** (basados en costes) como informes para **Facturaci√≥n** (basados en precios de venta y cuotas).
- **Estado de Cuentas por Cliente (Planificado):** Una vista para controlar los saldos pendientes de cada cliente mes a mes, identificando pagos atrasados.

---

## 4. üó∫Ô∏è Hoja de Ruta y Visi√≥n de Futuro

Nuestro enfoque se centra en consolidar la plataforma como una soluci√≥n ERP integral para el sector.

- **Sprint Actual:** Implementaci√≥n del n√∫cleo de la **Planificaci√≥n Avanzada (Zonas y Rutas Maestras)**.
- **Pr√≥ximos Pasos:**
  - **Alertas Proactivas por Umbrales:** Notificaciones autom√°ticas por mediciones fuera de rango.
  - **M√≥dulo de Estado de Cuentas:** Control de saldos y pagos pendientes.
  - **Gesti√≥n de Inventario y Compras.**
  - **Modo Offline (PWA) para T√©cnicos.**



// ====== [4] package.json ======
{
  "name": "pool-control-professional",
  "private": true,
  "version": "1.0.0",
  "description": "SaaS para la gesti√≥n integral de empresas de mantenimiento de piscinas.",
  "author": "",
  "license": "ISC",
  "scripts": {
    "dev:server": "pnpm --filter @pool-control/server dev",
    "dev:client": "pnpm --filter @pool-control/client dev",
    "build": "pnpm --filter \"./packages/**\" build",
    "prisma:generate": "pnpm --filter @pool-control/server prisma:generate",
    "prisma:migrate": "pnpm --filter @pool-control/server prisma:migrate --",
    "prisma:studio": "pnpm --filter @pool-control/server prisma:studio",
    "db:reset": "pnpm prisma:migrate reset --skip-seed --force && pnpm --filter @pool-control/server db:seed"
  },
  "devDependencies": {
    "typescript": "^5.4.5"
  },
  "engines": {
    "node": ">=20.0.0",
    "pnpm": ">=9.0.0"
  },
  "dependencies": {
    "@mantine/notifications": "^8.1.3",
    "@tabler/icons-react": "^3.34.0"
  }
}


// ====== [5] packages/client/index.html ======
<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pool-Control Professional</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


// ====== [6] packages/client/package.json ======
{
  "name": "@pool-control/client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite --host",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/sortable": "^10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "@fullcalendar/core": "^6.1.18",
    "@fullcalendar/daygrid": "^6.1.18",
    "@fullcalendar/interaction": "^6.1.18",
    "@fullcalendar/react": "^6.1.18",
    "@fullcalendar/resource-timeline": "^6.1.18",
    "@fullcalendar/timegrid": "^6.1.18",
    "@mantine/core": "^8.1.3",
    "@mantine/dates": "^8.1.3",
    "@mantine/form": "^8.1.3",
    "@mantine/hooks": "^8.1.3",
    "axios": "^1.7.2",
    "chart.js": "^4.5.0",
    "date-fns": "^4.1.0",
    "dayjs": "^1.11.13",
    "react": "^18.3.1",
    "react-chartjs-2": "^5.3.0",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.23.1",
    "zustand": "^5.0.6"
  },
  "devDependencies": {
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@typescript-eslint/eslint-plugin": "^7.13.0",
    "@typescript-eslint/parser": "^7.13.0",
    "@vitejs/plugin-react": "^4.3.1",
    "eslint": "^8.57.0",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-react-refresh": "0.4.7",
    "typescript": "^5.4.5",
    "vite": "^5.3.1"
  }
}


// ====== [7] packages/client/src/App.tsx ======
import { MantineProvider } from '@mantine/core';
import { RouterProvider } from 'react-router-dom';
import { theme } from './styles/theme.js';
import { router } from './router/index.js';
import { AuthProvider } from './providers/AuthProvider.js';

// Importa los estilos base de Mantine
import '@mantine/core/styles.css';

function App() {
  return (
    <MantineProvider theme={theme}>
      <AuthProvider>
        <RouterProvider router={router} />
      </AuthProvider>
    </MantineProvider>
  );
}

export default App;


// ====== [8] packages/client/src/api/apiClient.ts ======
// filename: packages/client/src/api/apiClient.ts
// version: 2.0.0 (FEAT: Add interceptor for Manager role view)

import axios from 'axios';

// Importamos el store de Zustand que crearemos a continuaci√≥n.
// Es una soluci√≥n m√°s limpia que importar el hook useAuth fuera de un componente.
import { useAuthStore } from '../stores/auth.store.js';

const apiClient = axios.create({
  baseURL: '/api',
  withCredentials: true,
});

// --- ‚úÖ NUEVO INTERCEPTOR ---
// Este c√≥digo se ejecuta antes de CADA petici√≥n que se haga con apiClient.
apiClient.interceptors.request.use(
  (config) => {
    // Obtenemos el estado actual del store de autenticaci√≥n.
    const { user, activeView } = useAuthStore.getState();

    // Si el usuario es un MANAGER y la vista activa NO es 'MANAGER',
    // a√±adimos la cabecera especial.
    if (user?.role === 'MANAGER' && activeView !== 'MANAGER') {
      config.headers['X-View-As-Role'] = activeView;
    }
    
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);


export default apiClient;


// ====== [9] packages/client/src/features/admin/pages/AdminDashboard.tsx ======
// filename: packages/client/src/features/admin/pages/AdminDashboard.tsx
// version: 2.0.1 (FIX: Align with new visits API)

import { useEffect, useState } from 'react';
import { Container, Title, Grid, Paper, Text, Badge, Loader, Alert, Stack } from '@mantine/core';
import { useNavigate } from 'react-router-dom';
import apiClient from '../../../api/apiClient';
// ‚úÖ 1. Importar las funciones de fecha necesarias
import { format, startOfDay, endOfDay } from 'date-fns';
import { es } from 'date-fns/locale';

// --- Tipos de Datos ---
interface Visit {
  id: string;
  timestamp: string;
  status: 'PENDING' | 'COMPLETED' | 'CANCELLED';
  pool: { name: string; client: { name:string } };
  technician: { name: string } | null;
}

interface Notification {
  id: string;
  message: string;
  visitId: string | null;
  isCritical: boolean;
}

// --- Componente Principal ---
export function AdminDashboard() {
  const [visits, setVisits] = useState<Visit[]>([]);
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const navigate = useNavigate();

  useEffect(() => {
    const fetchData = async () => {
      setIsLoading(true);
      setError(null);
      try {
        // ‚úÖ 2. Definir el rango de fechas para hoy
        const todayStart = startOfDay(new Date());
        const todayEnd = endOfDay(new Date());

        // ‚úÖ 3. Actualizar la llamada a la API para usar startDate y endDate
        const [visitsResponse, notificationsResponse] = await Promise.all([
          apiClient.get('/visits/scheduled', { 
            params: { 
              startDate: todayStart.toISOString(),
              endDate: todayEnd.toISOString(),
            } 
          }),
          apiClient.get('/notifications/history') 
        ]);
        
        // ‚úÖ 4. La respuesta ya viene filtrada por el backend, no necesitamos filtrar de nuevo en el cliente.
        const todayVisits = visitsResponse.data.data;
        
        const allNotifications = notificationsResponse.data.data.notifications;
        const pendingNotifications = allNotifications.filter((n: any) => n.status === 'PENDING');

        setVisits(todayVisits);
        setNotifications(pendingNotifications);
      } catch (err) {
        setError('No se pudo cargar la informaci√≥n del dashboard.');
        console.error(err);
      } finally {
        setIsLoading(false);
      }
    };

    fetchData();
  }, []);

  const handleCardClick = (path: string) => {
    navigate(path);
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  return (
    <Container fluid>
      <Title order={2} mb="xl">
        Dashboard - {format(new Date(), 'eeee, d MMMM yyyy', { locale: es })}
      </Title>

      <Grid>
        {/* Columna de Visitas de Hoy */}
        <Grid.Col span={{ base: 12, md: 7 }}>
          <Paper withBorder p="md" shadow="sm">
            <Title order={4} mb="md">Visitas de Hoy ({visits.length})</Title>
            <Stack>
              {visits.length > 0 ? (
                visits.map(visit => (
                  <Paper 
                    key={visit.id} 
                    withBorder p="sm" radius="md"
                    onClick={() => handleCardClick(`/visits/${visit.id}`)}
                    style={{ 
                      cursor: 'pointer',
                      opacity: visit.status === 'COMPLETED' ? 0.65 : 1,
                    }}
                    onMouseEnter={(e) => e.currentTarget.style.boxShadow = 'var(--mantine-shadow-md)'}
                    onMouseLeave={(e) => e.currentTarget.style.boxShadow = 'none'}
                  >
                    <Grid align="center">
                      <Grid.Col span={8}>
                        <Text fw={500}>{visit.pool.name}</Text>
                        <Text size="sm" c="dimmed">{visit.pool.client.name}</Text>
                        <Text size="xs" c="dimmed">T√©cnico: {visit.technician?.name || 'Sin asignar'}</Text>
                      </Grid.Col>
                      <Grid.Col span={4} ta="right">
                        <Badge 
                          color={visit.status === 'COMPLETED' ? 'green' : 'blue'}
                          variant="light"
                        >
                          {visit.status}
                        </Badge>
                      </Grid.Col>
                    </Grid>
                  </Paper>
                ))
              ) : (
                <Text c="dimmed">No hay visitas programadas para hoy.</Text>
              )}
            </Stack>
          </Paper>
        </Grid.Col>

        {/* Columna de Incidencias */}
        <Grid.Col span={{ base: 12, md: 5 }}>
          <Paper withBorder p="md" shadow="sm">
            <Title order={4} mb="md">Incidencias Activas</Title>
             <Stack>
              {notifications.length > 0 ? (
                notifications.map(notification => (
                  <Paper 
                    key={notification.id} 
                    withBorder p="sm" radius="md" 
                    onClick={() => notification.visitId && handleCardClick(`/incidents/${notification.id}`)}
                    style={{ 
                      cursor: notification.visitId ? 'pointer' : 'default',
                      borderLeft: notification.isCritical ? '4px solid var(--mantine-color-red-7)' : undefined,
                    }}
                    onMouseEnter={(e) => e.currentTarget.style.boxShadow = 'var(--mantine-shadow-md)'}
                    onMouseLeave={(e) => e.currentTarget.style.boxShadow = 'none'}
                  >
                    <Text size="sm">{notification.message}</Text>
                  </Paper>
                ))
              ) : (
                <Text c="dimmed">No hay incidencias activas.</Text>
              )}
            </Stack>
          </Paper>
        </Grid.Col>
      </Grid>
    </Container>
  );
}


// ====== [10] packages/client/src/features/admin/pages/IncidentsHistoryPage.tsx ======
// ====== [10] packages/client/src/features/admin/pages/IncidentsHistoryPage.tsx ======
// filename: packages/client/src/features/admin/pages/IncidentsHistoryPage.tsx
// version: 2.5.1 (FIX: Remove unused imports)
// description: Cleaned up unused imports after refactoring.

import { useEffect, useState } from 'react';
// ‚úÖ 1. Eliminar useRef
import { Container, Title, Table, Loader, Alert, Badge, ActionIcon, Tooltip, Select, Grid, Pagination, Center } from '@mantine/core';
// ‚úÖ 2. Eliminar Text
import { Link, useNavigate, useSearchParams } from 'react-router-dom';
import apiClient from '../../../api/apiClient';
import { } from 'date-fns';
// ‚úÖ 3. Eliminar es
import 'date-fns/locale/es';


// --- Tipos de Datos ---
type IncidentStatus = 'PENDING' | 'RESOLVED';
type IncidentPriority = 'LOW' | 'NORMAL' | 'HIGH' | 'CRITICAL';

interface IncidentHistoryItem {
  id: string;
  message: string;
  status: IncidentStatus;
  priority: IncidentPriority | null;
  resolutionNotes: string | null;
  isCritical: boolean;
  visit: {
    id: string;
    technician: { name: string } | null;
    pool: { name: string; client: { id: string; name: string } };
  } | null;
}

interface PaginatedResponse {
    notifications: IncidentHistoryItem[];
    total: number;
}

interface ApiResponse<T> {
    success: boolean;
    data: T;
}

// --- Mapeo de colores ---
const priorityColors: Record<IncidentPriority, string> = { LOW: 'gray', NORMAL: 'blue', HIGH: 'orange', CRITICAL: 'red' };
const statusColors: Record<IncidentStatus, string> = { PENDING: 'orange', RESOLVED: 'green' };

// --- Componente Principal ---
export function IncidentsHistoryPage() {
  const [incidents, setIncidents] = useState<IncidentHistoryItem[]>([]);
  const [clientOptions, setClientOptions] = useState<{ value: string; label: string; }[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const [searchParams, setSearchParams] = useSearchParams();

  const [activePage, setPage] = useState(parseInt(searchParams.get('page') || '1', 10));
  const [totalPages, setTotalPages] = useState(0);
  const PAGE_SIZE = 10;
  
  const [filterStatus, setFilterStatus] = useState<string | null>(searchParams.get('status') || 'PENDING');
  const [filterClient, setFilterClient] = useState<string | null>(searchParams.get('clientId') || null);

  const navigate = useNavigate();

  useEffect(() => {
    const params = new URLSearchParams();
    if (filterStatus) params.set('status', filterStatus);
    if (filterClient) params.set('clientId', filterClient);
    if (activePage > 1) params.set('page', activePage.toString());
    
    setSearchParams(params, { replace: true });

  }, [filterStatus, filterClient, activePage, setSearchParams]);

  useEffect(() => {
    const fetchHistory = async () => {
      setIsLoading(true);
      setError(null);
      
      const params: Record<string, any> = { page: activePage, pageSize: PAGE_SIZE, status: filterStatus, clientId: filterClient };
      Object.keys(params).forEach(key => (params[key] == null || params[key] === '') && delete params[key]);

      try {
        const response = await apiClient.get<ApiResponse<PaginatedResponse>>('/notifications/history', { params });
        const { notifications, total } = response.data.data;
        setIncidents(notifications);
        setTotalPages(Math.ceil(total / PAGE_SIZE));
      } catch (err) {
        setError('No se pudo cargar el historial de incidencias.');
      } finally {
        setIsLoading(false);
      }
    };

    fetchHistory();
  }, [activePage, filterStatus, filterClient]);

  useEffect(() => {
    const fetchClients = async () => {
        try {
            const response = await apiClient.get('/clients');
            const options = response.data.data.map((client: { id: string; name: string }) => ({
                value: client.id,
                label: client.name,
            }));
            setClientOptions(options);
        } catch (error) {
            console.error("Failed to fetch clients for filter");
        }
    };
    fetchClients();
  }, []);
  
  const handleRowClick = (notificationId: string) => {
    navigate(`/incidents/${notificationId}`);
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;
  
  const rows = incidents.map((item) => (
    <Table.Tr 
      key={item.id} 
      style={{ 
        backgroundColor: item.isCritical ? 'var(--mantine-color-red-0)' : 'transparent',
        cursor: 'pointer'
      }}
      onClick={() => handleRowClick(item.id)}
      onMouseEnter={(e) => e.currentTarget.style.backgroundColor = 'var(--mantine-color-gray-1)'}
      onMouseLeave={(e) => e.currentTarget.style.backgroundColor = item.isCritical ? 'var(--mantine-color-red-0)' : 'transparent'}
    >
      <Table.Td>{item.visit?.pool?.client?.name || 'N/A'}</Table.Td>
      <Table.Td>{item.visit?.pool?.name || 'N/A'}</Table.Td>
      <Table.Td>{item.visit?.technician?.name || 'N/A'}</Table.Td>
      <Table.Td>
        <Badge color={item.priority ? priorityColors[item.priority] : 'gray'}>
          {item.priority || 'SIN ASIGNAR'}
        </Badge>
      </Table.Td>
      <Table.Td>
        <Badge color={statusColors[item.status]}>
          {item.status}
        </Badge>
      </Table.Td>
      <Table.Td>
        {item.visit && (
          <Tooltip label="Ver Parte de Trabajo Original">
            <ActionIcon component={Link} to={`/visits/${item.visit.id}`} variant="subtle" onClick={(e) => e.stopPropagation()}>
              üìÑ
            </ActionIcon>
          </Tooltip>
        )}
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <Container fluid>
      <Title order={2} my="lg">Gesti√≥n de Incidencias</Title>
      
      <Grid align="flex-end" mb="md">
        <Grid.Col span={{ base: 12, sm: 4 }}>
          <Select
            label="Filtrar por Cliente" placeholder="Todos los clientes"
            value={filterClient} onChange={setFilterClient}
            data={clientOptions} clearable
          />
        </Grid.Col>
        <Grid.Col span={{ base: 12, sm: 4 }}>
          <Select
            label="Filtrar por Estado" placeholder="Todos los estados"
            value={filterStatus} onChange={(value) => { setFilterStatus(value); setPage(1); }}
            data={[ { value: 'PENDING', label: 'Pendientes' }, { value: 'RESOLVED', label: 'Resueltas' } ]}
            clearable
          />
        </Grid.Col>
      </Grid>
      
      <Table striped withTableBorder withColumnBorders mt="md">
        <Table.Thead>
            <Table.Tr>
              <Table.Th>Cliente</Table.Th>
              <Table.Th>Piscina</Table.Th>
              <Table.Th>T√©cnico</Table.Th>
              <Table.Th>Prioridad</Table.Th>
              <Table.Th>Estado</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
        </Table.Thead>
        <Table.Tbody>
            {rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={6}>No se han encontrado incidencias con los filtros seleccionados.</Table.Td></Table.Tr>}
        </Table.Tbody>
      </Table>
      
      {totalPages > 1 && (
          <Center mt="xl">
              <Pagination value={activePage} onChange={setPage} total={totalPages} />
          </Center>
      )}
    </Container>
  );
}


// ====== [11] packages/client/src/features/admin/pages/ParameterCatalogPage.tsx ======
// filename: packages/client/src/features/admin/pages/ParameterCatalogPage.tsx
// Version: 1.2.0 (Implement TagsInput for SELECT options in the form)
import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  Select,
  TagsInput,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient.js';

// --- Tipos ---
const InputTypes = ['NUMBER', 'BOOLEAN', 'TEXT', 'SELECT'] as const;
type InputType = (typeof InputTypes)[number];

interface ParameterTemplate {
  id: string;
  name: string;
  unit: string | null;
  type: InputType;
  selectOptions: string[];
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function ParameterCatalogPage() {
  const [templates, setTemplates] = useState<ParameterTemplate[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingTemplate, setEditingTemplate] = useState<ParameterTemplate | null>(null);

  const form = useForm({
    initialValues: {
      name: '',
      unit: '',
      type: 'NUMBER' as InputType,
      selectOptions: [] as string[],
    },
    validate: {
      name: (value: string) => (value.trim().length < 2 ? 'El nombre es demasiado corto' : null),
      type: (value: string) => (InputTypes.includes(value as InputType) ? null : 'Tipo inv√°lido'),
      selectOptions: (value: string[], values) => {
        if (values.type === 'SELECT' && value.length === 0) {
          return 'Debe definir al menos una opci√≥n para el tipo SELECT';
        }
        return null;
      }
    },
  });

  const fetchTemplates = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<ParameterTemplate[]>>('/parameters');
      setTemplates(response.data.data);
    } catch (err) {
      setError('No se pudo cargar el cat√°logo de par√°metros.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchTemplates();
  }, []);

  const handleOpenModal = (template: ParameterTemplate | null = null) => {
    setEditingTemplate(template);
    if (template) {
      form.setValues({
        name: template.name,
        unit: template.unit || '',
        type: template.type,
        selectOptions: template.selectOptions || [],
      });
    } else {
      form.reset();
    }
    openModal();
  };

  const handleSubmit = async (values: typeof form.values) => {
    const payload = {
      ...values,
      selectOptions: values.type === 'SELECT' ? values.selectOptions : [],
    };
    try {
      if (editingTemplate) {
        await apiClient.patch(`/parameters/${editingTemplate.id}`, payload);
      } else {
        await apiClient.post('/parameters', payload);
      }
      await fetchTemplates();
      closeModal();
    } catch (err: any) {
      form.setErrors({ name: err.response?.data?.message || 'Error al guardar el par√°metro' });
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar este par√°metro?')) {
      try {
        await apiClient.delete(`/parameters/${id}`);
        setTemplates((current) => current.filter((t) => t.id !== id));
      } catch (err) {
        // TODO: Mostrar notificaci√≥n de error
        console.error('Failed to delete parameter', err);
      }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = templates.map((template) => (
    <Table.Tr key={template.id}>
      <Table.Td>{template.name}</Table.Td>
      <Table.Td>{template.unit || '-'}</Table.Td>
      <Table.Td>{template.type}</Table.Td>
      <Table.Td>
        <Group gap="xs">
          <Button variant="subtle" size="xs" onClick={() => handleOpenModal(template)}>Editar</Button>
          <Button variant="subtle" size="xs" color="red" onClick={() => handleDelete(template.id)}>Eliminar</Button>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingTemplate ? 'Editar Par√°metro' : 'Crear Nuevo Par√°metro'}
        centered
      >
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="Nombre del Par√°metro" {...form.getInputProps('name')} />
            <TextInput label="Unidad (ej. ppm, pH, ¬∞C)" {...form.getInputProps('unit')} />
            <Select
              label="Tipo de Input"
              required
              data={InputTypes as unknown as string[]}
              {...form.getInputProps('type')}
            />
            {form.values.type === 'SELECT' && (
              <TagsInput
                label="Opciones del Select"
                placeholder="A√±ade opciones y presiona Enter"
                description="Escribe una opci√≥n y presiona Enter para a√±adirla a la lista."
                required
                {...form.getInputProps('selectOptions')}
              />
            )}
            <Button type="submit" mt="md">{editingTemplate ? 'Guardar Cambios' : 'Crear Par√°metro'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Cat√°logo de Par√°metros</Title>
          <Button onClick={() => handleOpenModal()}>Crear Nuevo Par√°metro</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Unidad</Table.Th>
              <Table.Th>Tipo</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={4}>No hay par√°metros definidos en el cat√°logo.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [12] packages/client/src/features/admin/pages/ProductCatalogPage.tsx ======
// filename: packages/client/src/features/admin/pages/ProductCatalogPage.tsx
// version: 1.0.0
// description: P√°gina para la gesti√≥n completa (CRUD) del cat√°logo de productos.

import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  Textarea,
  NumberInput,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient';

// --- Tipos de Datos ---
// Define la estructura de un producto, que coincide con el modelo de Prisma
interface Product {
  id: string;
  name: string;
  description: string | null;
  unit: string;
  cost: number;
}

// Define la estructura de la respuesta de nuestra API
interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente Principal ---
export function ProductCatalogPage() {
  // --- Estados del Componente ---
  const [products, setProducts] = useState<Product[]>([]); // Almacena la lista de productos
  const [isLoading, setIsLoading] = useState(true); // Controla el estado de carga
  const [error, setError] = useState<string | null>(null); // Almacena cualquier error de la API
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false); // Controla la visibilidad del modal
  const [editingProduct, setEditingProduct] = useState<Product | null>(null); // Guarda el producto que se est√° editando, o null si es una creaci√≥n

  // --- Formulario (Mantine Form) ---
  // Se encarga de la gesti√≥n de estado y validaci√≥n de los inputs del modal
  const form = useForm({
    initialValues: {
      name: '',
      description: '',
      unit: '',
      cost: 0,
    },
    validate: {
      name: (value) => (value.trim().length < 2 ? 'El nombre del producto es demasiado corto.' : null),
      unit: (value) => (value.trim().length === 0 ? 'La unidad de medida es obligatoria.' : null),
      cost: (value) => (value < 0 ? 'El coste no puede ser un valor negativo.' : null),
    },
  });

  // --- L√≥gica de Datos (API Calls) ---
  const fetchProducts = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<Product[]>>('/products');
      setProducts(response.data.data);
    } catch (err) {
      setError('No se pudo cargar el cat√°logo de productos.');
    } finally {
      setIsLoading(false);
    }
  };

  // Carga inicial de datos cuando el componente se monta
  useEffect(() => {
    fetchProducts();
  }, []);

  // --- Manejadores de Eventos ---

  // Se ejecuta al hacer clic en "A√±adir Producto" o "Editar"
  const handleOpenModal = (product: Product | null = null) => {
    setEditingProduct(product);
    if (product) {
      // Si estamos editando, llenamos el formulario con los datos del producto
      form.setValues({
        name: product.name,
        description: product.description || '',
        unit: product.unit,
        cost: product.cost,
      });
    } else {
      // Si estamos creando, reseteamos el formulario a sus valores iniciales
      form.reset();
      form.setFieldValue('cost', 0);
    }
    openModal();
  };

  // Se ejecuta al enviar el formulario del modal
  const handleSubmit = async (values: typeof form.values) => {
    try {
      if (editingProduct) {
        // Si est√°bamos editando, hacemos una petici√≥n PATCH
        await apiClient.patch(`/products/${editingProduct.id}`, values);
      } else {
        // Si est√°bamos creando, hacemos una petici√≥n POST
        await apiClient.post('/products', values);
      }
      // Despu√©s de la operaci√≥n, refrescamos la lista y cerramos el modal
      await fetchProducts();
      closeModal();
    } catch (err: any) {
      form.setErrors({ name: err.response?.data?.message || 'Error al guardar el producto.' });
    }
  };

  // Se ejecuta al hacer clic en el bot√≥n "Eliminar"
  const handleDelete = async (id: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar este producto? Esta acci√≥n no se puede deshacer.')) {
      try {
        await apiClient.delete(`/products/${id}`);
        // Actualizaci√≥n optimista de la UI: eliminamos el producto del estado local
        setProducts((current) => current.filter((p) => p.id !== id));
      } catch (err) {
        alert('No se pudo eliminar el producto. Es probable que ya est√© en uso en alguna visita.');
        console.error('Failed to delete product', err);
      }
    }
  };

  // --- Renderizado del Componente ---

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  // Mapeamos los datos de los productos para generar las filas de la tabla
  const rows = products.map((product) => (
    <Table.Tr key={product.id}>
      <Table.Td>{product.name}</Table.Td>
      <Table.Td>{product.description || '-'}</Table.Td>
      <Table.Td>{product.unit}</Table.Td>
      <Table.Td>{product.cost.toFixed(2)} ‚Ç¨</Table.Td>
      <Table.Td>
        <Group gap="xs">
          <Button variant="subtle" size="xs" onClick={() => handleOpenModal(product)}>Editar</Button>
          <Button variant="subtle" size="xs" color="red" onClick={() => handleDelete(product.id)}>Eliminar</Button>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingProduct ? 'Editar Producto' : 'Crear Nuevo Producto'}
        centered
      >
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="Nombre del Producto" placeholder="Ej: Hipoclorito S√≥dico 25L" {...form.getInputProps('name')} />
            <Textarea label="Descripci√≥n (opcional)" placeholder="Detalles adicionales del producto" {...form.getInputProps('description')} />
            <TextInput required label="Unidad de Medida" placeholder="Ej: L, Kg, Saco, Unidad" {...form.getInputProps('unit')} />
            <NumberInput
                required
                label="Coste por Unidad (‚Ç¨)"
                placeholder="15.50"
                decimalScale={2}
                fixedDecimalScale
                step={0.5}
                min={0}
                {...form.getInputProps('cost')}
            />
            <Button type="submit" mt="md">{editingProduct ? 'Guardar Cambios' : 'Crear Producto'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Cat√°logo de Productos</Title>
          <Button onClick={() => handleOpenModal()}>A√±adir Nuevo Producto</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Descripci√≥n</Table.Th>
              <Table.Th>Unidad</Table.Th>
              <Table.Th>Coste</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={5}>No hay productos definidos en el cat√°logo.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [13] packages/client/src/features/admin/pages/ProductCategoryCatalogPage.tsx ======
// filename: packages/client/src/features/admin/pages/ProductCategoryCatalogPage.tsx
// version: 1.0.0
// description: P√°gina para la gesti√≥n CRUD del cat√°logo de categor√≠as de productos.

import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient';

// --- Tipos de Datos ---
interface ProductCategory {
  id: string;
  name: string;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente Principal ---
export function ProductCategoryCatalogPage() {
  const [categories, setCategories] = useState<ProductCategory[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingCategory, setEditingCategory] = useState<ProductCategory | null>(null);

  const form = useForm({
    initialValues: {
      name: '',
    },
    validate: {
      name: (value) => (value.trim().length < 2 ? 'El nombre de la categor√≠a es demasiado corto.' : null),
    },
  });

  const fetchCategories = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<ProductCategory[]>>('/product-categories');
      setCategories(response.data.data);
    } catch (err) {
      setError('No se pudo cargar el cat√°logo de categor√≠as.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchCategories();
  }, []);

  const handleOpenModal = (category: ProductCategory | null = null) => {
    setEditingCategory(category);
    if (category) {
      form.setValues({ name: category.name });
    } else {
      form.reset();
    }
    openModal();
  };

  const handleSubmit = async (values: typeof form.values) => {
    try {
      if (editingCategory) {
        await apiClient.patch(`/product-categories/${editingCategory.id}`, values);
      } else {
        await apiClient.post('/product-categories', values);
      }
      await fetchCategories();
      closeModal();
    } catch (err: any) {
      form.setErrors({ name: err.response?.data?.message || 'Error al guardar la categor√≠a.' });
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar esta categor√≠a? Los productos asociados no se borrar√°n, pero quedar√°n sin categor√≠a.')) {
      try {
        await apiClient.delete(`/product-categories/${id}`);
        setCategories((current) => current.filter((c) => c.id !== id));
      } catch (err) {
        alert('No se pudo eliminar la categor√≠a.');
        console.error('Failed to delete category', err);
      }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = categories.map((category) => (
    <Table.Tr key={category.id}>
      <Table.Td>{category.name}</Table.Td>
      <Table.Td>
        <Group gap="xs">
          <Button variant="subtle" size="xs" onClick={() => handleOpenModal(category)}>Editar</Button>
          <Button variant="subtle" size="xs" color="red" onClick={() => handleDelete(category.id)}>Eliminar</Button>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingCategory ? 'Editar Categor√≠a' : 'Crear Nueva Categor√≠a'}
        centered
      >
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="Nombre de la Categor√≠a" placeholder="Ej: Qu√≠micos Reguladores" {...form.getInputProps('name')} />
            <Button type="submit" mt="md">{editingCategory ? 'Guardar Cambios' : 'Crear Categor√≠a'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Cat√°logo de Categor√≠as de Productos</Title>
          <Button onClick={() => handleOpenModal()}>Crear Nueva Categor√≠a</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={2}>No hay categor√≠as definidas en el cat√°logo.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [14] packages/client/src/features/admin/pages/TaskCatalogPage.tsx ======
// filename: packages/client/src/features/admin/pages/TaskCatalogPage.tsx
// Version: 1.0.0 (Initial implementation of the task template catalog page with full CRUD)
import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  Textarea,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient.js';

// --- Tipos ---
interface TaskTemplate {
  id: string;
  name: string;
  description: string | null;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function TaskCatalogPage() {
  const [templates, setTemplates] = useState<TaskTemplate[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingTemplate, setEditingTemplate] = useState<TaskTemplate | null>(null);

  const form = useForm({
    initialValues: {
      name: '',
      description: '',
    },
    validate: {
      name: (value: string) => (value.trim().length < 2 ? 'El nombre es demasiado corto' : null),
    },
  });

  const fetchTemplates = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<TaskTemplate[]>>('/tasks');
      setTemplates(response.data.data);
    } catch (err) {
      setError('No se pudo cargar el cat√°logo de tareas.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchTemplates();
  }, []);

  const handleOpenModal = (template: TaskTemplate | null = null) => {
    setEditingTemplate(template);
    if (template) {
      form.setValues({
        name: template.name,
        description: template.description || '',
      });
    } else {
      form.reset();
    }
    openModal();
  };

  const handleSubmit = async (values: typeof form.values) => {
    try {
      if (editingTemplate) {
        await apiClient.patch(`/tasks/${editingTemplate.id}`, values);
      } else {
        await apiClient.post('/tasks', values);
      }
      await fetchTemplates();
      closeModal();
    } catch (err: any) {
      form.setErrors({ name: err.response?.data?.message || 'Error al guardar la tarea' });
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar esta tarea?')) {
      try {
        await apiClient.delete(`/tasks/${id}`);
        setTemplates((current) => current.filter((t) => t.id !== id));
      } catch (err) {
        // TODO: Mostrar notificaci√≥n de error
        console.error('Failed to delete task', err);
      }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = templates.map((template) => (
    <Table.Tr key={template.id}>
      <Table.Td>{template.name}</Table.Td>
      <Table.Td>{template.description || '-'}</Table.Td>
      <Table.Td>
        <Group gap="xs">
          <Button variant="subtle" size="xs" onClick={() => handleOpenModal(template)}>Editar</Button>
          <Button variant="subtle" size="xs" color="red" onClick={() => handleDelete(template.id)}>Eliminar</Button>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingTemplate ? 'Editar Tarea' : 'Crear Nueva Tarea'}
        centered
      >
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="Nombre de la Tarea" {...form.getInputProps('name')} />
            <Textarea label="Descripci√≥n (opcional)" {...form.getInputProps('description')} />
            <Button type="submit" mt="md">{editingTemplate ? 'Guardar Cambios' : 'Crear Tarea'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Cat√°logo de Tareas</Title>
          <Button onClick={() => handleOpenModal()}>Crear Nueva Tarea</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Descripci√≥n</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={3}>No hay tareas definidas en el cat√°logo.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [15] packages/client/src/features/admin/pages/clients/ClientDetailPage.tsx ======
// filename: packages/client/src/features/admin/pages/clients/ClientDetailPage.tsx
// Version: 2.1.0 (FEAT: Add Zone assignment to Pool modal)
// description: Fetches available zones and adds a Select input to the pool form.

import { useEffect, useState } from 'react';
import { useParams, Link } from 'react-router-dom';
import {
  Container, Title, Loader, Alert, Button, Group, Paper, Text, Table, Breadcrumbs, Modal,
  TextInput, Stack, NumberInput, Select, Anchor, Tabs, Grid,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../../api/apiClient';

// --- Tipos ---
type BillingModel = 'SERVICE_ONLY' | 'FEE_PLUS_MATERIALS' | 'ALL_INCLUSIVE';
// ‚úÖ 1. A√±adido zoneId a la interfaz de la Piscina
interface Pool { id: string; name: string; address: string; volume: number | null; type: string | null; zoneId: string | null; }
interface Zone { id: string; name: string; } // ‚úÖ 2. Nueva interfaz para Zonas
interface Client {
  id: string; name: string; contactPerson: string | null; email: string | null;
  phone: string | null; address: string | null; pools: Pool[];
  monthlyFee: number;
  billingModel: BillingModel;
}
interface ProductCategory { id: string; name: string; }
interface Product { id: string; name: string; }
interface PricingRule {
    id: string;
    discountPercentage: number;
    product?: { name: string };
    productCategory?: { name: string };
}
interface ApiResponse<T> { success: boolean; data: T; }

// --- Componente Principal ---
export function ClientDetailPage() {
  const { id: clientId } = useParams<{ id: string }>();
  const [client, setClient] = useState<Client | null>(null);
  const [zones, setZones] = useState<Zone[]>([]); // ‚úÖ 3. Nuevo estado para las zonas
  const [pricingRules, setPricingRules] = useState<PricingRule[]>([]);
  const [products, setProducts] = useState<Product[]>([]);
  const [productCategories, setProductCategories] = useState<ProductCategory[]>([]);
  
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [poolModalOpened, { open: openPoolModal, close: closePoolModal }] = useDisclosure(false);
  const [ruleModalOpened, { open: openRuleModal, close: closeRuleModal }] = useDisclosure(false);
  const [editingPool, setEditingPool] = useState<Pool | null>(null);

  const clientInfoForm = useForm({
    initialValues: { monthlyFee: 0, billingModel: 'SERVICE_ONLY' as BillingModel },
  });

  // ‚úÖ 4. A√±adido zoneId al formulario de la piscina
  const poolForm = useForm({
    initialValues: { name: '', address: '', volume: null as number | null, type: '', zoneId: null as string | null },
    validate: {
      name: (value) => (value.trim().length < 2 ? 'El nombre es demasiado corto' : null),
      address: (value) => (value.trim().length < 5 ? 'La direcci√≥n es demasiado corta' : null),
    },
  });
  const ruleForm = useForm({
    initialValues: { type: 'product', targetId: '', discountPercentage: 0, },
    validate: {
        targetId: (value) => (!value ? 'Debe seleccionar un objetivo' : null),
        discountPercentage: (value) => (value <= 0 || value > 100 ? 'El descuento debe estar entre 1 y 100' : null),
    }
  });

  const fetchData = async () => {
    if (!clientId) return;
    setIsLoading(true);
    try {
      // ‚úÖ 5. Se a√±ade la petici√≥n de zonas al Promise.all
      const [clientRes, rulesRes, productsRes, categoriesRes, zonesRes] = await Promise.all([
        apiClient.get<ApiResponse<Client>>(`/clients/${clientId}`),
        apiClient.get<ApiResponse<PricingRule[]>>(`/client-product-pricing/by-client/${clientId}`),
        apiClient.get<ApiResponse<Product[]>>('/products'),
        apiClient.get<ApiResponse<ProductCategory[]>>('/product-categories'),
        apiClient.get<ApiResponse<Zone[]>>('/zones'),
      ]);
      setClient(clientRes.data.data);
      setZones(zonesRes.data.data); // Guardamos las zonas en el estado
      setPricingRules(rulesRes.data.data);
      setProducts(productsRes.data.data);
      setProductCategories(categoriesRes.data.data);
      clientInfoForm.setValues({
          monthlyFee: clientRes.data.data.monthlyFee,
          billingModel: clientRes.data.data.billingModel,
      });
    } catch (err) {
      setError('No se pudo cargar la informaci√≥n del cliente.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchData();
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [clientId]);

  const handleClientInfoSubmit = async (values: typeof clientInfoForm.values) => {
    try {
      await apiClient.patch(`/clients/${clientId}`, values);
      alert('Condiciones guardadas con √©xito');
      await fetchData();
    } catch {
      alert('Error al guardar las condiciones');
    }
  };

  const handleOpenPoolModal = (pool: Pool | null = null) => {
    setEditingPool(pool);
    if (pool) {
      // ‚úÖ 6. Se establece el valor de zoneId al abrir el modal para editar
      poolForm.setValues({
        name: pool.name,
        address: pool.address,
        volume: pool.volume,
        type: pool.type || '',
        zoneId: pool.zoneId || null,
      });
    } else {
      poolForm.reset();
    }
    openPoolModal();
  };

  // No se necesita cambiar handlePoolSubmit, ya que el zoneId se incluye autom√°ticamente en 'values'
  const handlePoolSubmit = async (values: typeof poolForm.values) => {
    if (!clientId) return;
    try {
      if (editingPool) {
        await apiClient.patch(`/pools/${editingPool.id}`, { ...values, clientId });
      } else {
        await apiClient.post('/pools', { ...values, clientId });
      }
      await fetchData();
      closePoolModal();
    } catch (err) { poolForm.setErrors({ name: 'Error al guardar la piscina' }); }
  };

  const handlePoolDelete = async (poolId: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar esta piscina?')) {
      try {
        await apiClient.delete(`/pools/${poolId}`);
        await fetchData();
      } catch (err) {
        console.error('Failed to delete pool', err);
      }
    }
  };

  const handleRuleSubmit = async (values: typeof ruleForm.values) => {
    if (!clientId) return;
    const payload = {
        clientId,
        discountPercentage: values.discountPercentage,
        ...(values.type === 'product' ? { productId: values.targetId } : { productCategoryId: values.targetId })
    };
    try {
        await apiClient.post('/client-product-pricing', payload);
        await fetchData();
        closeRuleModal();
        ruleForm.reset();
    } catch { ruleForm.setErrors({ targetId: 'Error al crear la regla. ¬øQuiz√°s ya existe?' }); }
  };
  
  const handleRuleDelete = async (ruleId: string) => {
    if (window.confirm('¬øEliminar esta regla de precio?')) {
        try {
            await apiClient.delete(`/client-product-pricing/${ruleId}`);
            await fetchData();
        } catch { alert('No se pudo eliminar la regla.'); }
    }
  };
  
  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;
  if (!client) return <Alert color="yellow">Cliente no encontrado.</Alert>;

  const breadcrumbs = (<Breadcrumbs><Link to="/clients">Clientes</Link><Text>{client.name}</Text></Breadcrumbs>);
  const productOptions = products.map(p => ({ value: p.id, label: p.name }));
  const categoryOptions = productCategories.map(c => ({ value: c.id, label: c.name }));
  // ‚úÖ 7. Se preparan las opciones para el Select de Zonas
  const zoneOptions = zones.map(z => ({ value: z.id, label: z.name }));

  return (
    <>
      <Modal opened={poolModalOpened} onClose={closePoolModal} title={editingPool ? 'Editar Piscina' : 'A√±adir Piscina'} centered>
        <form onSubmit={poolForm.onSubmit(handlePoolSubmit)}>
          <Stack>
            <TextInput required label="Nombre de la Piscina" {...poolForm.getInputProps('name')} />
            <TextInput required label="Direcci√≥n de la Piscina" {...poolForm.getInputProps('address')} />
            
            {/* ‚úÖ 8. Se a√±ade el campo Select para las zonas */}
            <Select
              label="Asignar Zona"
              placeholder="Sin asignar"
              data={zoneOptions}
              {...poolForm.getInputProps('zoneId')}
              clearable
            />

            <NumberInput label="Volumen (m¬≥)" min={0} {...poolForm.getInputProps('volume')} />
            <Select label="Tipo de Piscina" data={['Cloro', 'Sal']} {...poolForm.getInputProps('type')} />
            <Button type="submit" mt="md">{editingPool ? 'Guardar Cambios' : 'Crear Piscina'}</Button>
          </Stack>
        </form>
      </Modal>

      <Modal opened={ruleModalOpened} onClose={closeRuleModal} title="Nueva Regla de Precio" centered>
        <form onSubmit={ruleForm.onSubmit(handleRuleSubmit)}>
            <Stack>
                 <Select label="Tipo de Regla" data={[{value: 'product', label: 'A un Producto'}, {value: 'category', label: 'A una Categor√≠a'}]} {...ruleForm.getInputProps('type')} />
                {ruleForm.values.type === 'product' ? (
                    <Select label="Seleccione el Producto" data={productOptions} searchable required {...ruleForm.getInputProps('targetId')} />
                ) : (
                    <Select label="Seleccione la Categor√≠a" data={categoryOptions} searchable required {...ruleForm.getInputProps('targetId')} />
                )}
                 <NumberInput label="Porcentaje de Descuento (%)" min={1} max={100} required {...ruleForm.getInputProps('discountPercentage')} />
                <Button type="submit" mt="md">Crear Regla</Button>
            </Stack>
        </form>
      </Modal>

      <Container fluid>
        {breadcrumbs}
        <Title order={2} my="lg">{client.name}</Title>
        <Paper withBorder p="md" mb="xl">
           <Title order={4} mb="xs">Informaci√≥n de Contacto</Title>
          <Text><strong>Persona de contacto:</strong> {client.contactPerson || '-'}</Text>
          <Text><strong>Email:</strong> {client.email || '-'}</Text>
          <Text><strong>Tel√©fono:</strong> {client.phone || '-'}</Text>
        </Paper>
        
        <Tabs defaultValue="pools">
            <Tabs.List>
                <Tabs.Tab value="pools">Piscinas ({client.pools.length})</Tabs.Tab>
                <Tabs.Tab value="pricing">Condiciones y Precios</Tabs.Tab>
            </Tabs.List>

            <Tabs.Panel value="pools" pt="lg">
                <Group justify="space-between" align="center" mb="md">
                    <Title order={3}>Piscinas</Title>
                    <Button onClick={() => handleOpenPoolModal()}>A√±adir Piscina</Button>
                </Group>
                <Table striped withTableBorder>
                   <Table.Thead><Table.Tr><Table.Th>Nombre</Table.Th><Table.Th>Direcci√≥n</Table.Th><Table.Th>Acciones</Table.Th></Table.Tr></Table.Thead>
                  <Table.Tbody>
                    {client.pools.length > 0 ? (
                      client.pools.map(pool => (
                        <Table.Tr key={pool.id}>
                          <Table.Td><Anchor component={Link} to={`/pools/${pool.id}`}>{pool.name}</Anchor></Table.Td>
                           <Table.Td>{pool.address}</Table.Td>
                          <Table.Td>
                            <Group gap="xs">
                              <Button variant="subtle" size="xs" onClick={() => handleOpenPoolModal(pool)}>Editar</Button>
                               <Button variant="subtle" size="xs" color="red" onClick={() => handlePoolDelete(pool.id)}>Eliminar</Button>
                            </Group>
                          </Table.Td>
                         </Table.Tr>
                      ))
                    ) : (<Table.Tr><Table.Td colSpan={3}>Este cliente no tiene piscinas asociadas.</Table.Td></Table.Tr>)}
                  </Table.Tbody>
                </Table>
             </Tabs.Panel>

            <Tabs.Panel value="pricing" pt="lg">
                <Grid>
                    <Grid.Col span={{ base: 12, md: 5 }}>
                        <Paper withBorder p="md" shadow="sm">
                             <Title order={4} mb="md">Condiciones del Contrato</Title>
                            <form onSubmit={clientInfoForm.onSubmit(handleClientInfoSubmit)}>
                                <Stack>
                                     <NumberInput label="Cuota Mensual (‚Ç¨)" decimalScale={2} fixedDecimalScale {...clientInfoForm.getInputProps('monthlyFee')} />
                                     <Select label="Modelo de Facturaci√≥n" data={['SERVICE_ONLY', 'FEE_PLUS_MATERIALS', 'ALL_INCLUSIVE']} {...clientInfoForm.getInputProps('billingModel')} />
                                    <Button type="submit">Guardar Condiciones</Button>
                                </Stack>
                         </form>
                        </Paper>
                    </Grid.Col>
                    <Grid.Col span={{ base: 12, md: 7 }}>
                         <Group justify="space-between" align="center" mb="md">
                            <Title order={4}>Reglas de Precios Personalizadas</Title>
                            <Button size="xs" onClick={openRuleModal}>+ A√±adir Regla</Button>
                        </Group>
                         <Table striped withTableBorder>
                            <Table.Thead><Table.Tr><Table.Th>Objetivo</Table.Th><Table.Th>Tipo</Table.Th><Table.Th>Descuento</Table.Th><Table.Th>Acciones</Table.Th></Table.Tr></Table.Thead>
                            <Table.Tbody>
                                 {pricingRules.length > 0 ? pricingRules.map(rule => (
                                    <Table.Tr key={rule.id}>
                                        <Table.Td>{rule.product?.name || rule.productCategory?.name}</Table.Td>
                                          <Table.Td>{rule.product ? 'Producto' : 'Categor√≠a'}</Table.Td>
                                        <Table.Td>{rule.discountPercentage}%</Table.Td>
                                         <Table.Td><Button variant="subtle" color="red" size="xs" onClick={() => handleRuleDelete(rule.id)}>Eliminar</Button></Table.Td>
                                    </Table.Tr>
                                )) : <Table.Tr><Table.Td colSpan={4}>No hay reglas personalizadas.</Table.Td></Table.Tr>}
                               </Table.Tbody>
                        </Table>
                    </Grid.Col>
                </Grid>
            </Tabs.Panel>
         </Tabs>
      </Container>
    </>
  );
}


// ====== [16] packages/client/src/features/admin/pages/clients/ClientsPage.tsx ======
// filename: packages/client/src/features/admin/pages/clients/ClientsPage.tsx
// Version: 1.1.0 (Make client names link to their detail page)
import { useEffect, useState } from 'react';
import { Link } from 'react-router-dom';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  NumberInput,
  Anchor,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../../api/apiClient.js';

// --- Tipos ---
interface Client {
  id: string;
  name: string;
  contactPerson: string | null;
  email: string | null;
  phone: string | null;
  address: string | null;
  priceModifier: number;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function ClientsPage() {
  const [clients, setClients] = useState<Client[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingClient, setEditingClient] = useState<Client | null>(null);

  const form = useForm({
    initialValues: {
      name: '',
      contactPerson: '',
      email: '',
      phone: '',
      address: '',
      priceModifier: 1.0,
    },
    validate: {
      name: (value) => (value.trim().length < 2 ? 'El nombre es demasiado corto' : null),
      email: (value) => (value && !/^\S+@\S+$/.test(value) ? 'Email inv√°lido' : null),
      priceModifier: (value) => (value <= 0 ? 'El modificador debe ser mayor que 0' : null),
    },
  });

  const fetchClients = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<Client[]>>('/clients');
      setClients(response.data.data);
    } catch (err) {
      setError('No se pudo cargar la lista de clientes.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchClients();
  }, []);

  const handleOpenModal = (client: Client | null = null) => {
    setEditingClient(client);
    if (client) {
      form.setValues({
        name: client.name,
        contactPerson: client.contactPerson || '',
        email: client.email || '',
        phone: client.phone || '',
        address: client.address || '',
        priceModifier: client.priceModifier,
      });
    } else {
      form.reset();
    }
    openModal();
  };

  const handleSubmit = async (values: typeof form.values) => {
    try {
      if (editingClient) {
        await apiClient.patch(`/clients/${editingClient.id}`, values);
      } else {
        await apiClient.post('/clients', values);
      }
      await fetchClients();
      closeModal();
    } catch (err: any) {
      form.setErrors({ name: err.response?.data?.message || 'Error al guardar el cliente' });
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar este cliente? Se borrar√°n tambi√©n todas sus piscinas asociadas.')) {
      try {
        await apiClient.delete(`/clients/${id}`);
        setClients((current) => current.filter((c) => c.id !== id));
      } catch (err) {
        console.error('Failed to delete client', err);
      }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = clients.map((client) => (
    <Table.Tr key={client.id}>
      <Table.Td>
        <Anchor component={Link} to={`/clients/${client.id}`}>
          {client.name}
        </Anchor>
      </Table.Td>
      <Table.Td>{client.contactPerson || '-'}</Table.Td>
      <Table.Td>{client.phone || '-'}</Table.Td>
      <Table.Td>{client.email || '-'}</Table.Td>
      <Table.Td>
        <Group gap="xs">
          <Button variant="subtle" size="xs" onClick={() => handleOpenModal(client)}>Editar</Button>
          <Button variant="subtle" size="xs" color="red" onClick={() => handleDelete(client.id)}>Eliminar</Button>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingClient ? 'Editar Cliente' : 'Crear Nuevo Cliente'}
        centered
      >
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="Nombre del Cliente" {...form.getInputProps('name')} />
            <TextInput label="Persona de Contacto" {...form.getInputProps('contactPerson')} />
            <TextInput label="Email" type="email" {...form.getInputProps('email')} />
            <TextInput label="Tel√©fono" {...form.getInputProps('phone')} />
            <TextInput label="Direcci√≥n" {...form.getInputProps('address')} />
            <NumberInput 
              label="Modificador de Precio" 
              description="1.0 es normal, 0.9 es 10% dto, 1.1 es 10% recargo." 
              defaultValue={1.0} 
              step={0.05} 
              min={0} 
              decimalScale={2} 
              {...form.getInputProps('priceModifier')} 
            />
            <Button type="submit" mt="md">{editingClient ? 'Guardar Cambios' : 'Crear Cliente'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Gesti√≥n de Clientes</Title>
          <Button onClick={() => handleOpenModal()}>Crear Nuevo Cliente</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Contacto</Table.Th>
              <Table.Th>Tel√©fono</Table.Th>
              <Table.Th>Email</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={5}>No hay clientes creados.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [17] packages/client/src/features/admin/pages/incidents/IncidentDetailPage.tsx ======
// ====== [17] packages/client/src/features/admin/pages/incidents/IncidentDetailPage.tsx ======
// filename: packages/client/src/features/admin/pages/incidents/IncidentDetailPage.tsx
// version: 2.8.1 (FIX: Use existing visit timestamp instead of createdAt)

import { useEffect, useState } from 'react';
import { useParams, Link } from 'react-router-dom';
import {
  Container, Title, Loader, Alert, Paper, Text, Breadcrumbs, Button, Group,
  Modal, TextInput, Stack, Textarea, Select, Badge, Card, ActionIcon, Divider, SimpleGrid, Image, Tooltip
} from '@mantine/core';
import { DateTimePicker } from '@mantine/dates';
import 'dayjs/locale/es';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../../api/apiClient';
import { format, parse } from 'date-fns';
import { es } from 'date-fns/locale';
import { useAuth } from '../../../../providers/AuthProvider';

// --- Tipos, Interfaces y Mapeos ---
type IncidentStatus = 'PENDING' | 'RESOLVED';
type IncidentPriority = 'LOW' | 'NORMAL' | 'HIGH' | 'CRITICAL';
type IncidentTaskStatus = 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'CANCELLED';
type LogAction = 'CREATION' | 'STATUS_CHANGE' | 'COMMENT' | 'DEADLINE_REQUEST' | 'DEADLINE_UPDATE';

interface User { id: string; name: string; }
interface IncidentImage { id: string; url: string; }
interface IncidentTaskLog { id: string, action: LogAction, details: string, createdAt: string, user: { name: string } }
interface IncidentTask {
  id: string; title: string; description: string | null; status: IncidentTaskStatus;
  priority: IncidentPriority; deadline: string | null; assignedTo: User | null; resolutionNotes: string | null;
}
interface NotificationDetails {
  id:string; message: string; status: IncidentStatus; priority: IncidentPriority | null;
  // createdAt no existe, lo quitamos de la interfaz para ser precisos
  images: IncidentImage[];
  visit: { id: string; timestamp: string; pool: { name: string; }; technician: { name: string } | null; } | null;
}
interface ApiResponse<T> { success: boolean; data: T; }
const taskStatusColors: Record<IncidentTaskStatus, string> = { PENDING: 'gray', IN_PROGRESS: 'blue', COMPLETED: 'green', CANCELLED: 'red' };
const priorityColors: Record<IncidentPriority, string> = { LOW: 'gray', NORMAL: 'blue', HIGH: 'orange', CRITICAL: 'red' };

// ===================================================================
// --- VISTA PARA EL T√âCNICO ---
// (Componente sin cambios, se omite por brevedad)
// ===================================================================
const TechnicianTaskView = ({ tasks, onUpdate }: { tasks: IncidentTask[], onUpdate: () => void }) => {
  const { user } = useAuth();
  const myTask = tasks.find(t => t.assignedTo?.id === user?.id);

  const [comment, setComment] = useState('');
  const [newDeadline, setNewDeadline] = useState<Date | null>(null);
  const [logs, setLogs] = useState<IncidentTaskLog[]>([]);
  const [showHistory, setShowHistory] = useState(false);
  
  const handleStatusChange = async (status: IncidentTaskStatus, resolutionNotes?: string) => {
    if (!myTask) return;
    await apiClient.patch(`/incident-tasks/${myTask.id}/status`, { status, resolutionNotes });
    onUpdate();
  };

  const fetchLogs = async () => {
    if (!myTask) return;
    try {
      const response = await apiClient.get<ApiResponse<IncidentTaskLog[]>>(`/incident-tasks/${myTask.id}/logs`);
      setLogs(response.data.data);
    } catch {
      alert('No se pudo cargar el historial de la tarea.');
    }
  };

  const handleAddLog = async () => {
    if (!myTask || !comment) return;
    await apiClient.post(`/incident-tasks/${myTask.id}/log`, {
      details: comment,
      newDeadline: newDeadline instanceof Date ? newDeadline.toISOString() : undefined,
    });
    setComment('');
    setNewDeadline(null);
    if(showHistory) {
      fetchLogs();
    }
  };

  const toggleHistory = () => {
    const willBeOpen = !showHistory;
    setShowHistory(willBeOpen);
    if (willBeOpen && logs.length === 0) {
      fetchLogs();
    }
  };

  if (!myTask) {
    return <Alert color="orange">No tienes una tarea espec√≠fica asignada para esta incidencia.</Alert>
  }

  const isOverdue = myTask.deadline && new Date(myTask.deadline) < new Date() && myTask.status !== 'COMPLETED';

  return (
    <Stack>
      <Title order={3}>Tarea Asignada: {myTask.title}</Title>
      <Text c="dimmed">{myTask.description}</Text>
      <Group>
        <Badge color={taskStatusColors[myTask.status]}>{myTask.status}</Badge>
        <Badge color={priorityColors[myTask.priority]}>Prioridad: {myTask.priority}</Badge>
        <Button variant="subtle" size="xs" onClick={toggleHistory}>
          {showHistory ? 'Ocultar Historial' : 'Ver Historial'}
        </Button>
      </Group>

      {myTask.deadline && (
       <Text size="sm" c={isOverdue ? 'red' : 'dimmed'} fw={isOverdue ? 700 : 400} mt="xs">
          Plazo: {format(new Date(myTask.deadline), 'eeee, d MMMM yyyy, HH:mm', { locale: es })} {isOverdue && '(VENCIDA)'}
        </Text>
      )}

      {showHistory && (
        <Paper withBorder p="md" mt="sm">
            <Title order={5} mb="sm">Historial de la Tarea</Title>
            <Stack gap="xs">
                {logs.length > 0 
                    ? logs.map(log => (
                        <Paper key={log.id} p="xs" bg="gray.0" radius="sm">
                            <Text size="xs">
                                <strong>{log.user.name}</strong> ({format(new Date(log.createdAt), 'dd/MM HH:mm')})
                            </Text>
                            <Text size="sm" mt={4}>{log.details}</Text>
                        </Paper>
                    ))
                    : <Text size="sm" c="dimmed">No hay entradas en el historial.</Text>
                }
            </Stack>
        </Paper>
      )}

      <Paper withBorder p="md" mt="lg">
        <Title order={4} mb="md">Acciones</Title>
        <Group>
          <Button disabled={myTask.status !== 'PENDING'} onClick={() => handleStatusChange('IN_PROGRESS')}>Empezar Tarea</Button>
          <Button color="green" disabled={myTask.status === 'COMPLETED'} onClick={() => {
            const notes = prompt("A√±ade notas de resoluci√≥n para completar la tarea:");
            if (notes) handleStatusChange('COMPLETED', notes);
          }}>Completar Tarea</Button>
        </Group>

        <Divider my="lg" label="A√±adir Actualizaci√≥n o Solicitar Aplazamiento" />
        <Textarea
          placeholder="Ej: No hay stock de la pieza necesaria..."
          label="Comentario"
          value={comment}
          onChange={(e) => setComment(e.currentTarget.value)}
        />
        <DateTimePicker
          label="Sugerir nuevo plazo (opcional)"
          locale="es"
          clearable
          value={newDeadline}
          onChange={setNewDeadline as any}
          mt="sm"
        />
        <Button mt="md" onClick={handleAddLog} disabled={!comment}>Enviar Actualizaci√≥n</Button>
      </Paper>
    </Stack>
  );
};

// ===================================================================
// --- VISTA PARA EL ADMIN ---
// (Componente sin cambios, se omite por brevedad)
// ===================================================================
const AdminIncidentView = ({ notification, tasks, technicians, onUpdate }: { notification: NotificationDetails, tasks: IncidentTask[], technicians: User[], onUpdate: () => void }) => {
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingTask, setEditingTask] = useState<IncidentTask | null>(null);
  const [logs, setLogs] = useState<IncidentTaskLog[]>([]);
  const [selectedTaskForLogs, setSelectedTaskForLogs] = useState<IncidentTask | null>(null);
  const [adminComment, setAdminComment] = useState('');
  
  const form = useForm({
    initialValues: {
      title: '', description: '', priority: 'NORMAL' as IncidentPriority,
      assignedToId: null as string | null, deadline: null as Date | null,
    },
    validate: { title: (value) => (value.trim().length < 5 ? 'El t√≠tulo es demasiado corto.' : null) },
  });

  const handleOpenModal = (task: IncidentTask | null = null) => {
    setEditingTask(task);
    if (task) {
      const deadlineDate = task.deadline ? new Date(task.deadline) : null;
      form.setValues({
        title: task.title, description: task.description || '', priority: task.priority,
        assignedToId: task.assignedTo?.id || null, deadline: deadlineDate,
      });
    } else {
      form.reset();
      form.setFieldValue('priority', 'NORMAL');
    }
    openModal();
  };

  const handleSubmit = async (values: typeof form.values) => {
    const isNewTask = !editingTask;
    const taskId = isNewTask ? null : editingTask.id;

    const payload: { [key: string]: any } = {
      title: values.title,
      description: values.description,
      priority: values.priority,
      assignedToId: values.assignedToId,
      deadline: values.deadline instanceof Date ? values.deadline.toISOString() : null,
    };

    try {
      if (isNewTask) {
        await apiClient.post('/incident-tasks', { ...payload, notificationId: notification.id });
      } else {
        await apiClient.patch(`/incident-tasks/${taskId}`, payload);
      }
      onUpdate();
      closeModal();
    } catch (err: any) {
      form.setErrors({ title: err.response?.data?.message || 'Error al guardar la tarea.' });
    }
  };

  const handleDelete = async (taskId: string) => {
    if (window.confirm('¬øEst√°s seguro?')) { try { await apiClient.delete(`/incident-tasks/${taskId}`); onUpdate(); } catch (err) { alert('No se pudo eliminar la tarea.'); } }
  };

  const handleViewLogs = async (task: IncidentTask) => {
    if (selectedTaskForLogs?.id === task.id) {
      setSelectedTaskForLogs(null);
      setLogs([]);
      return;
    }
    setSelectedTaskForLogs(task);
    try {
      const response = await apiClient.get<ApiResponse<IncidentTaskLog[]>>(`/incident-tasks/${task.id}/logs`);
      setLogs(response.data.data);
    } catch {
      alert('No se pudo cargar el historial de la tarea.');
    }
  };

  useEffect(() => {
    if (tasks.length === 1 && !selectedTaskForLogs) {
      if (tasks[0]) {
        handleViewLogs(tasks[0]);
      }
    }
  }, [tasks]); 
  
  const handleAcceptDeadline = async (taskId: string, logDetails: string) => {
    const dateString = logDetails.split('para: ')[1];
    if (!dateString) return;
    const newDate = parse(dateString.replace(' a las', ''), "d MMMM yyyy HH:mm", new Date(), { locale: es });
    if (isNaN(newDate.getTime())) return;
    
    try {
      await apiClient.patch(`/incident-tasks/${taskId}/deadline`, { deadline: newDate.toISOString() });
      onUpdate();
    } catch {
      alert('No se pudo aceptar el nuevo plazo.');
    }
  };

  const handleAdminComment = async (taskId: string) => {
    if (!adminComment.trim()) return;
    try {
      await apiClient.post(`/incident-tasks/${taskId}/log`, { details: adminComment });
      setAdminComment('');
      const taskToUpdate = tasks.find(t => t.id === taskId);
      if (taskToUpdate) {
        handleViewLogs(taskToUpdate);
      }
      onUpdate();
    } catch {
      alert('No se pudo enviar el comentario.');
    }
  };
  
  const technicianOptions = technicians.map(t => ({ value: t.id, label: t.name }));

  const renderLogEntry = (log: IncidentTaskLog, taskId: string) => {
    const isRequest = log.action === 'DEADLINE_REQUEST';
    return (
        <Paper key={log.id} p="xs" withBorder={isRequest} shadow={isRequest ? "sm" : "none"} radius="md" bg={isRequest ? 'blue.0' : 'gray.0'}>
            <Text size="xs">
                <strong>{log.user.name}</strong> ({format(new Date(log.createdAt), 'dd/MM HH:mm', { locale: es })})
            </Text>
            <Text size="sm" mt={4}>{log.details}</Text>
            {isRequest && (
                <Group mt="xs">
                    <Button size="xs" color="green" onClick={() => handleAcceptDeadline(taskId, log.details)}>Aceptar Plazo</Button>
                </Group>
            )}
        </Paper>
    );
  };

  return (
    <>
      <Modal opened={modalOpened} onClose={closeModal} title={editingTask ? 'Editar Tarea' : 'Crear Tarea'} centered>
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="T√≠tulo" {...form.getInputProps('title')} />
            <Textarea label="Descripci√≥n" {...form.getInputProps('description')} />
            <Select label="Prioridad" data={['LOW', 'NORMAL', 'HIGH', 'CRITICAL']} required {...form.getInputProps('priority')} />
            <Select label="Asignar a" data={technicianOptions} clearable {...form.getInputProps('assignedToId')} />
            <DateTimePicker
              label="Plazo L√≠mite"
              locale="es"
              clearable
              value={form.values.deadline}
              onChange={(value) => form.setFieldValue('deadline', value ? new Date(value) : null)}
            />
            <Button type="submit" mt="md">{editingTask ? 'Guardar Cambios' : 'Crear Tarea'}</Button>
          </Stack>
        </form>
      </Modal>

      <Group justify="space-between" align="center" mb="md"><Title order={3}>Tareas de Seguimiento</Title><Button onClick={() => handleOpenModal()}>+ Crear Tarea</Button></Group>
      
      <Stack>
        {tasks.length > 0 ? (
          tasks.map(task => {
            const isOverdue = task.deadline && new Date(task.deadline) < new Date() && task.status !== 'COMPLETED';
            return (
              <Card key={task.id} withBorder shadow="sm" p="md" style={ isOverdue ? { borderLeft: '4px solid var(--mantine-color-red-7)' } : {}}>
                <Group justify="space-between" align="flex-start">
                  <Stack gap="xs" style={{ flex: 1 }}>
                    <Title order={5}>{task.title}</Title>
                    {task.description && <Text size="sm" c="dimmed">{task.description}</Text>}
                    <Divider />
                    <Group gap="sm">
                      <Badge color={taskStatusColors[task.status]} variant="light">{task.status}</Badge>
                      <Badge color={priorityColors[task.priority]} variant="light">Prioridad: {task.priority}</Badge>
                      {task.assignedTo && <Text size="xs">Asignado a: <strong>{task.assignedTo.name}</strong></Text>}
                    </Group>
                    {task.deadline && <Text size="xs" c={isOverdue ? 'red' : 'dimmed'} fw={isOverdue ? 700 : 400}>Plazo: {format(new Date(task.deadline), 'd MMM yyyy, HH:mm', { locale: es })} {isOverdue && '(VENCIDA)'}</Text>}
                    {task.resolutionNotes && <Textarea value={task.resolutionNotes} readOnly label="Notas de Resoluci√≥n" mt="xs" />}
                    
                    {selectedTaskForLogs?.id === task.id && (
                      <Stack mt="sm" gap="xs">
                        {logs.length > 0 
                            ? logs.map(log => renderLogEntry(log, task.id))
                            : <Text size="xs" c="dimmed">No hay historial para esta tarea.</Text>
                        }
                        <Textarea
                          placeholder="Escribe una respuesta o nueva instrucci√≥n para el t√©cnico..."
                          value={adminComment}
                          onChange={(e) => setAdminComment(e.currentTarget.value)}
                          minRows={2}
                        />
                        <Button size="xs" onClick={() => handleAdminComment(task.id)} disabled={!adminComment.trim()}>Enviar Comentario</Button>
                      </Stack>
                    )}

                  </Stack>
                  <Stack>
                    <Tooltip label="Editar detalles de la tarea">
                      <ActionIcon variant="default" onClick={() => handleOpenModal(task)}>‚úèÔ∏è</ActionIcon>
                    </Tooltip>
                    <Tooltip label="Ver/Ocultar di√°logo e historial">
                      <ActionIcon variant="default" onClick={() => handleViewLogs(task)}>üí¨</ActionIcon>
                    </Tooltip>
                    <Tooltip label="Eliminar tarea">
                      <ActionIcon color="red" variant="subtle" onClick={() => handleDelete(task.id)}>üóëÔ∏è</ActionIcon>
                    </Tooltip>
                  </Stack>
                </Group>
              </Card>
            )
          })
        ) : (<Text c="dimmed">No hay tareas de seguimiento para esta incidencia.</Text>)}
      </Stack>
    </>
  );
};


// ===================================================================
// --- COMPONENTE PRINCIPAL (DESPACHADOR) ---
// ===================================================================
export function IncidentDetailPage() {
  const { notificationId } = useParams<{ notificationId: string }>();
  const { user } = useAuth();
  
  const [notification, setNotification] = useState<NotificationDetails | null>(null);
  const [tasks, setTasks] = useState<IncidentTask[]>([]);
  const [technicians, setTechnicians] = useState<User[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [imageModalOpened, { open: openImageModal, close: closeImageModal }] = useDisclosure(false);
  const [selectedImage, setSelectedImage] = useState<string | null>(null);

  const fetchData = async () => {
    if (!notificationId) return;
    setIsLoading(true);
    setError(null);
    try {
      const [notificationRes, tasksRes, techniciansRes] = await Promise.all([
        apiClient.get<ApiResponse<NotificationDetails>>(`/notifications/${notificationId}`),
        apiClient.get<ApiResponse<IncidentTask[]>>(`/incident-tasks/by-notification/${notificationId}`),
        apiClient.get<ApiResponse<User[]>>('/users/technicians')
      ]);
      setNotification(notificationRes.data.data);
      setTasks(tasksRes.data.data);
      setTechnicians(techniciansRes.data.data.map(t => ({ id: t.id, name: t.name })));
    } catch (err) {
      setError('No se pudo cargar la informaci√≥n de la incidencia.');
    } finally { setIsLoading(false); }
  };

  const handleImageClick = (url: string) => { setSelectedImage(url); openImageModal(); };

  useEffect(() => { fetchData(); // eslint-disable-next-line
  }, [notificationId]);
  
  if (isLoading) return <Container p="xl" style={{ display: 'flex', justifyContent: 'center' }}><Loader /></Container>;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;
  if (!notification) return <Alert color="yellow">Incidencia no encontrada.</Alert>;

  const breadcrumbs = (<Breadcrumbs><Link to={user?.role === 'ADMIN' ? "/incidents-history" : "/my-route"}>{user?.role === 'ADMIN' ? "Gesti√≥n de Incidencias" : "Mi Trabajo de Hoy"}</Link><Text>Detalle</Text></Breadcrumbs>);

  return (
    <Container fluid>
      <Modal opened={imageModalOpened} onClose={closeImageModal} title="Imagen de la Incidencia" centered size="xl">{selectedImage && <Image src={selectedImage} />}</Modal>
      {breadcrumbs}
      <Title order={2} my="lg">Incidencia en {notification.visit?.pool.name}</Title>

      <Paper withBorder p="md" mb="xl">
        <Group justify="space-between"><Title order={4}>Reporte Original</Title><Badge color={notification.status === 'PENDING' ? 'orange' : 'green'} size="lg">{notification.status}</Badge></Group>
        
        {/* ‚úÖ CORRECCI√ìN: Usar una fecha que s√≠ existe y proteger contra valores nulos */}
        <Text size="sm" c="dimmed" mt="xs">
          Reportado por {notification.visit?.technician?.name || 'Sistema'}
          {notification.visit?.timestamp && ` el ${format(new Date(notification.visit.timestamp), 'd MMM yyyy, HH:mm', { locale: es })}`}
        </Text>

        <Textarea value={notification.message} readOnly minRows={2} mt="md" label="Mensaje del t√©cnico" />
        {notification.images && notification.images.length > 0 && (
          <><Text fw={500} size="sm" mt="md">Im√°genes Adjuntas:</Text><SimpleGrid cols={{ base: 2, sm: 4, lg: 6 }} mt="xs">{notification.images.map(image => (<Paper key={image.id} withBorder radius="md" style={{ cursor: 'pointer' }} onClick={() => handleImageClick(image.url)}><Image src={image.url} height={100} radius="md" fit="cover" /></Paper>))}</SimpleGrid></>
        )}
        {notification.visit && <Button component={Link} to={`/visits/${notification.visit.id}`} variant="subtle" size="xs" mt="sm">Ver Parte de Trabajo Original</Button>}
      </Paper>
      
      {user?.role === 'ADMIN' 
        ? <AdminIncidentView notification={notification} tasks={tasks} technicians={technicians} onUpdate={fetchData} />
        : <TechnicianTaskView tasks={tasks} onUpdate={fetchData} />
      }
    </Container>
  );
}


// ====== [18] packages/client/src/features/admin/pages/planner/PlannerPage.tsx ======
// filename: packages/client/src/features/admin/pages/planner/PlannerPage.tsx
// version: 3.6.8 (FIXED)
// description: Elimina la importaci√≥n incorrecta de EventReceiveArg y restaura DndContext para la funcionalidad de arrastrar y soltar.

import { useEffect, useState, useMemo, useRef } from 'react';
import {
  Container, Title, Loader, Alert, Group, Button, Stack, Text, Modal, Select, Paper, Badge, Grid
} from '@mantine/core';
import { DatePickerInput } from '@mantine/dates';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';

import FullCalendar from '@fullcalendar/react';
import dayGridPlugin from '@fullcalendar/daygrid';
import interactionPlugin from '@fullcalendar/interaction';
import resourceTimelinePlugin from '@fullcalendar/resource-timeline';
import { DndContext } from '@dnd-kit/core';
// ‚úÖ CORRECCI√ìN: Se elimina 'EventReceiveArg' de la importaci√≥n
import type { EventContentArg, EventDropArg } from '@fullcalendar/core';

import { startOfWeek, endOfWeek, addDays, subDays, format, isWithinInterval, isBefore, startOfToday, setHours, addHours, getDayOfYear } from 'date-fns';
import { es } from 'date-fns/locale';
import apiClient from '../../../../api/apiClient';
import './planner-styles.css';
import { ControlPanel } from './components/ControlPanel';
import { PendingWorkSidebar } from './components/PendingWorkSidebar';

// --- Tipos ---
interface TechnicianResource { id: string; title: string; }
interface Technician extends TechnicianResource {
  isAvailable: boolean;
  availabilities: { startDate: string; endDate: string }[];
}
interface Zone { id: string; name: string; }
interface Pool { id: string; name: string; client: { name: string }; }
interface Visit { id: string; timestamp: string; status: 'PENDING' | 'COMPLETED' | 'CANCELLED'; pool: Pool; technician: Technician | null; }
interface CalendarEvent {
    id: string;
    title: string;
    start: Date;
    end?: Date;
    allDay: boolean;
    backgroundColor: string;
    borderColor: string;
    resourceId?: string;
    extendedProps: {
        clientName: string;
        technicianId: string | null;
        technicianName: string;
        status: Visit['status'];
    }
}

const techColors = ['#228be6', '#15aabf', '#82c91e', '#fab005', '#fd7e14', '#e64980'];

const EventCard = ({ event }: { event: EventContentArg }) => {
    const { extendedProps } = event.event;
    return (
        <Paper p={4} radius="sm" withBorder style={{ overflow: 'hidden', height: '100%', borderLeft: `4px solid ${event.borderColor}`, backgroundColor: event.backgroundColor }}>
            <Text size="xs" fw={700} truncate>{event.event.title}</Text>
            <Text size="xs" c="dimmed" truncate>{extendedProps.clientName}</Text>
            {extendedProps.technicianName && ( <Badge variant="light" color="gray" size="xs" mt={4} style={{ textTransform: 'none' }}> {extendedProps.technicianName} </Badge> )}
        </Paper>
    )
}

export function PlannerPage() {
  const calendarRef = useRef<FullCalendar>(null);
  const [week, setWeek] = useState(startOfWeek(new Date(), { weekStartsOn: 1 }));
  
  const [events, setEvents] = useState<CalendarEvent[]>([]);
  const [resources, setResources] = useState<TechnicianResource[]>([]);
  const [zones, setZones] = useState<Zone[]>([]);
  const [pools, setPools] = useState<{ value: string; label: string; }[]>([]);

  const [selectedTechnicians, setSelectedTechnicians] = useState<string[]>([]);
  const [selectedZones, setSelectedZones] = useState<string[]>([]);
  const [viewMode, setViewMode] = useState('dayGridWeek');
  
  const [sidebarVersion, setSidebarVersion] = useState(0);

  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const specialVisitForm = useForm({
    initialValues: { poolId: '', technicianId: '', timestamp: new Date() },
    validate: {
      poolId: (value) => !value ? 'Debe seleccionar una piscina' : null,
      technicianId: (value) => !value ? 'Debe asignar un t√©cnico' : null,
      timestamp: (value) => !value ? 'La fecha es obligatoria' : null,
    }
  });

  const fetchAndProcessData = async () => {
    setLoading(true);
    setError(null);
    try {
      const weekStart = week;
      const weekEnd = endOfWeek(week, { weekStartsOn: 1 });

      const params = {
        startDate: weekStart.toISOString(),
        endDate: weekEnd.toISOString(),
        technicianIds: selectedTechnicians,
        zoneIds: selectedZones,
      };

      const [visitsRes, techsRes, zonesRes, clientsRes] = await Promise.all([
        apiClient.get('/visits/scheduled', { params }),
        apiClient.get('/users/technicians'),
        apiClient.get('/zones'),
        apiClient.get('/clients')
      ]);

      const allVisits: Visit[] = visitsRes.data.data;
      const allResources: TechnicianResource[] = techsRes.data.data;
      const allZones: Zone[] = zonesRes.data.data;

      setResources(allResources);
      setZones(allZones);
      
      const poolOptions = clientsRes.data.data.flatMap((client: any) => client.pools.map((pool: any) => ({ value: pool.id, label: `${client.name} - ${pool.name}` })));
      setPools(poolOptions);

      const nonOrphanedVisits = allVisits.filter(visit => {
          if (visit.status !== 'PENDING') return true;
          if (!visit.technician || !visit.technician.isAvailable) return false;
          return !visit.technician.availabilities.some(avail => 
              isWithinInterval(new Date(visit.timestamp), { start: new Date(avail.startDate), end: new Date(avail.endDate) })
          );
      });

      const dailyCounters: Record<string, number> = {};
      const WORK_DAY_START_HOUR = 8;

      const calendarEvents = nonOrphanedVisits.map((visit): CalendarEvent => {
        let visitDate = new Date(visit.timestamp);
        
        const techIdForCounter = visit.technician?.id || 'unassigned';
        const dayKey = `${techIdForCounter}-${getDayOfYear(visitDate)}`;
        
        if (dailyCounters[dayKey] === undefined) {
            dailyCounters[dayKey] = 0;
        } else {
            dailyCounters[dayKey]++;
        }
        
        if (visitDate.getHours() === 0 && visitDate.getMinutes() === 0) {
            visitDate = setHours(visitDate, WORK_DAY_START_HOUR + dailyCounters[dayKey]);
        }
        
        const techIndex = allResources.findIndex(t => t.id === visit.technician?.id);
        const borderColor = techColors[techIndex % techColors.length] || '#ced4da';
        
        let backgroundColor = 'white';
        if (visit.status === 'COMPLETED') {
            backgroundColor = '#e6fcf5';
        } else if (isBefore(visitDate, startOfToday())) {
            backgroundColor = '#fff5f5';
        }
        
        return {
            id: visit.id,
            title: visit.pool.name,
            start: visitDate,
            end: addHours(visitDate, 1),
            allDay: viewMode === 'dayGridWeek',
            backgroundColor,
            borderColor,
            resourceId: visit.technician?.id,
            extendedProps: {
                clientName: visit.pool.client.name,
                technicianId: visit.technician?.id || null,
                technicianName: visit.technician?.title || 'Sin Asignar',
                status: visit.status
            }
        };
      });
      setEvents(calendarEvents);
    } catch (err) {
      setError('No se pudo cargar la planificaci√≥n.');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchAndProcessData();
  }, [week, selectedTechnicians, selectedZones, viewMode, sidebarVersion]);

  useEffect(() => {
    calendarRef.current?.getApi().changeView(viewMode);
  }, [viewMode]);

  const handleEventDrop = (info: EventDropArg) => {
    const { event, newResource } = info;
    const newDate = event.start;
    if (!newDate) return;

    const newTechnicianId = newResource ? newResource.id : event.extendedProps.technicianId;

    apiClient.patch(`/visits/${event.id}/reschedule`, {
      timestamp: newDate.toISOString(),
      technicianId: newTechnicianId,
    }).catch(() => {
      setError('Error al reprogramar la visita. Recargando...');
      info.revert();
    });
  };
  
  // ‚úÖ CORRECCI√ìN: Se elimina el tipado expl√≠cito del argumento 'info'
  const handleEventReceive = async (info: any) => {
    const { event, draggedEl } = info;
    const { originalVisit } = JSON.parse(draggedEl.dataset.event || '{}').extendedProps;

    const newDate = event.start;
    if (!newDate || !originalVisit) {
        event.remove();
        return;
    }
    
    const newResourceId = event.getResources()[0]?.id || null;
    
    // Optimistic Update
    const newEvent: CalendarEvent = {
        id: originalVisit.id,
        title: originalVisit.pool.name,
        start: newDate,
        end: addHours(newDate, 1),
        allDay: viewMode === 'dayGridWeek',
        backgroundColor: 'white',
        borderColor: techColors[resources.findIndex(t => t.id === newResourceId) % techColors.length] || '#ced4da',
        resourceId: newResourceId,
        extendedProps: {
            clientName: originalVisit.pool.client.name,
            technicianId: newResourceId,
            technicianName: resources.find(r => r.id === newResourceId)?.title || 'Sin Asignar',
            status: 'PENDING',
        }
    };
    
    setEvents(currentEvents => [...currentEvents, newEvent]);
    event.remove();
    setSidebarVersion(v => v + 1);

    try {
        await apiClient.patch(`/visits/${originalVisit.id}/reschedule`, {
            timestamp: newDate.toISOString(),
            technicianId: newResourceId,
        });
    } catch (err) {
        setError('Error al reasignar la visita. Revirtiendo cambio.');
        setEvents(currentEvents => currentEvents.filter(e => e.id !== originalVisit.id));
        setSidebarVersion(v => v + 1);
    }
  };

  const handleCreateSpecialVisit = async () => {
    try {
      await apiClient.post('/visits/special', specialVisitForm.values);
      closeModal();
      specialVisitForm.reset();
      await fetchAndProcessData();
    } catch (err) {
      specialVisitForm.setErrors({ poolId: 'Error al crear la orden especial.' });
    }
  };
  
  const technicianOptions = useMemo(() => resources.map(t => ({ value: t.id, label: t.title })), [resources]);
  const zoneOptions = useMemo(() => zones.map(z => ({ value: z.id, label: z.name })), [zones]);
  
  if (loading) return <Container p="xl" style={{display: 'flex', justifyContent: 'center'}}><Loader size="xl" /></Container>;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  return (
    <DndContext onDragEnd={() => {}}>
      <Container fluid>
        <Modal opened={modalOpened} onClose={closeModal} title="Crear Orden de Trabajo Especial" centered>
          <form onSubmit={specialVisitForm.onSubmit(handleCreateSpecialVisit)}>
              <Stack>
                  <Select data={pools} label="Piscina" placeholder='Busca o selecciona una piscina' searchable required {...specialVisitForm.getInputProps('poolId')} />
                  <Select data={technicianOptions} label="Asignar a" placeholder='Selecciona un t√©cnico' searchable required {...specialVisitForm.getInputProps('technicianId')} />
                  <DatePickerInput label="Fecha y Hora" valueFormat="DD/MM/YYYY HH:mm" required {...specialVisitForm.getInputProps('timestamp')} />
                  <Button type="submit" mt="md">Crear Visita</Button>
              </Stack>
          </form>
        </Modal>

        <Group justify="space-between" align="center" my="lg">
          <Title order={2}>Planning Hub</Title>
          <Group>
            <Button onClick={openModal} variant="light">Crear Orden Especial</Button>
            <Button.Group>
              <Button variant="default" onClick={() => setWeek(subDays(week, 7))}>{'< Semana Anterior'}</Button>
              <Button variant="default" onClick={() => setWeek(addDays(week, 7))}>{'Semana Siguiente >'}</Button>
            </Button.Group>
          </Group>
        </Group>
        
        <ControlPanel
          technicianOptions={technicianOptions}
          zoneOptions={zoneOptions}
          selectedTechnicians={selectedTechnicians}
          selectedZones={selectedZones}
          onTechnicianChange={setSelectedTechnicians}
          onZoneChange={setSelectedZones}
          viewMode={viewMode}
          onViewModeChange={setViewMode}
        />
        
        <Grid>
            <Grid.Col span={{ base: 12, lg: 3 }}>
                <PendingWorkSidebar key={sidebarVersion} />
            </Grid.Col>
            <Grid.Col span={{ base: 12, lg: 9 }}>
                <Text size="lg" fw={500} mb="xl">
                    {viewMode === 'dayGridWeek' ? 
                        `Semana del ${format(week, 'd MMMM')} al ${format(endOfWeek(week, { weekStartsOn: 1 }), 'd MMMM, yyyy', { locale: es })}` :
                        `D√≠a: ${format(week, 'eeee, d MMMM, yyyy', { locale: es })}`
                    }
                </Text>
                
                <Paper withBorder p="md" shadow="sm">
                    <FullCalendar
                        ref={calendarRef}
                        plugins={[dayGridPlugin, interactionPlugin, resourceTimelinePlugin]}
                        schedulerLicenseKey="GPL-My-Project-Is-Open-Source"
                        initialView="dayGridWeek"
                        locale={es}
                        firstDay={1}
                        headerToolbar={false}
                        events={events}
                        resources={resources}
                        resourceAreaHeaderContent="Equipo"
                        slotMinTime="08:00:00"
                        slotMaxTime="19:00:00"
                        slotDuration="01:00:00"
                        editable={true}
                        droppable={true}
                        eventReceive={handleEventReceive}
                        eventDrop={handleEventDrop}
                        eventContent={(arg) => <EventCard event={arg} />}
                        height="auto"
                    />
                </Paper>
            </Grid.Col>
        </Grid>
      </Container>
    </DndContext>
  );
}


// ====== [19] packages/client/src/features/admin/pages/planner/components/ControlPanel.tsx ======
// filename: packages/client/src/features/admin/pages/planner/components/ControlPanel.tsx
// version: 1.1.0 (FEAT: Add view mode switcher)

import { Grid, MultiSelect, SegmentedControl, Group } from '@mantine/core';

// --- Tipos de Datos ---
interface SelectOption {
  value: string;
  label: string;
}

interface ControlPanelProps {
  // Props existentes
  technicianOptions: SelectOption[];
  zoneOptions: SelectOption[];
  selectedTechnicians: string[];
  selectedZones: string[];
  onTechnicianChange: (selected: string[]) => void;
  onZoneChange: (selected: string[]) => void;
  // Nuevas props para el cambio de vista
  viewMode: string;
  onViewModeChange: (value: string) => void;
}

// --- Componente ---
export function ControlPanel({
  technicianOptions,
  zoneOptions,
  selectedTechnicians,
  selectedZones,
  onTechnicianChange,
  onZoneChange,
  viewMode,
  onViewModeChange,
}: ControlPanelProps) {
  return (
    <Grid align="flex-end" mb="xl" justify="space-between">
      <Grid.Col span={{ base: 12, md: 'auto' }}>
        <Group>
          <MultiSelect
            label="Filtrar por T√©cnicos"
            placeholder="Todos los t√©cnicos"
            data={technicianOptions}
            value={selectedTechnicians}
            onChange={onTechnicianChange}
            searchable
            clearable
          />
          <MultiSelect
            label="Filtrar por Zonas"
            placeholder="Todas las zonas"
            data={zoneOptions}
            value={selectedZones}
            onChange={onZoneChange}
            searchable
            clearable
          />
        </Group>
      </Grid.Col>
      <Grid.Col span={{ base: 12, md: 'auto' }}>
        <SegmentedControl
          value={viewMode}
          onChange={onViewModeChange}
          data={[
            { label: 'Semana', value: 'dayGridWeek' },
            { label: 'Equipo', value: 'resourceTimelineDay' },
          ]}
        />
      </Grid.Col>
    </Grid>
  );
}


// ====== [20] packages/client/src/features/admin/pages/planner/components/PendingWorkSidebar.tsx ======
// filename: packages/client/src/features/admin/pages/planner/components/PendingWorkSidebar.tsx
// version: 1.2.0 (FIXED & REWRITTEN)
// description: Reescribe el componente para usar la utilidad Draggable de FullCalendar, asegurando la compatibilidad.

import { useEffect, useState, useRef } from 'react';
import { Stack, Title, Paper, Text, Badge, ScrollArea, Loader, Alert, Accordion } from '@mantine/core';
import { Draggable } from '@fullcalendar/interaction'; // ‚úÖ 1. Importar Draggable de FullCalendar
import apiClient from '../../../../../api/apiClient';
import { formatDistanceToNow } from 'date-fns';
import { es } from 'date-fns/locale';

// --- Tipos ---
interface Visit {
  id: string;
  timestamp: string;
  pool: { name: string; client: { name: string } };
  technician: { name: string } | null;
}

interface PendingWorkData {
  overdueVisits: Visit[];
  orphanedVisits: Visit[];
}

// --- Componente Interno ---
const VisitItem = ({ visit, isOverdue }: { visit: Visit; isOverdue?: boolean }) => {
  const overdueLabel = isOverdue
    ? `Vencida hace ${formatDistanceToNow(new Date(visit.timestamp), { locale: es })}`
    : `T√©cnico: ${visit.technician?.name || 'No disponible'}`;

  // ‚úÖ 2. Se convierte en un componente simple. La l√≥gica de arrastre se gestionar√° en el contenedor.
  return (
    <Paper 
      className='fc-event' // Clase necesaria para que FullCalendar le aplique estilos
      data-event={JSON.stringify({ // Pasamos los datos de la visita en un atributo de datos
        id: visit.id,
        title: visit.pool.name,
        create: false, // Indica a FullCalendar que es un evento existente
        extendedProps: {
          originalVisit: visit
        }
      })}
      withBorder 
      p="xs" 
      radius="sm" 
      mb="xs"
      style={{ cursor: 'grab' }}
    >
      <Text fw={500} size="sm">{visit.pool.name}</Text>
      <Text c="dimmed" size="xs">{visit.pool.client.name}</Text>
      <Text c="red" size="xs" mt={2}>{overdueLabel}</Text>
    </Paper>
  );
};

// --- Componente Principal ---
export function PendingWorkSidebar() {
  const [data, setData] = useState<PendingWorkData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const draggableContainerRef = useRef<HTMLDivElement>(null); // ‚úÖ 3. Ref para el contenedor

  // ‚úÖ 4. useEffect para inicializar la funcionalidad de arrastrar
  useEffect(() => {
    if (draggableContainerRef.current) {
      new Draggable(draggableContainerRef.current, {
        itemSelector: '.fc-event', // Le decimos qu√© elementos dentro del contenedor son arrastrables
      });
    }
  }, [data]); // Se re-inicializa si los datos cambian

  useEffect(() => {
    const fetchPendingWork = async () => {
      setIsLoading(true);
      try {
        const response = await apiClient.get('/planning/pending-work');
        setData(response.data.data);
      } catch (err) {
        setError('No se pudo cargar el trabajo pendiente.');
      } finally {
        setIsLoading(false);
      }
    };
    fetchPendingWork();
  }, []);

  if (isLoading) return <Loader />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  return (
    <Stack>
      <Title order={4}>Muelle de Carga</Title>
      {/* ‚úÖ 5. Envolver las listas en el contenedor con la ref */}
      <div ref={draggableContainerRef}> 
        <ScrollArea style={{ height: 'calc(100vh - 200px)' }}>
          <Accordion variant="separated" defaultValue="overdue">
            <Accordion.Item value="overdue">
              <Accordion.Control>
                <Text>Deuda Operativa</Text>
                {data && data.overdueVisits.length > 0 && <Badge color="red">{data.overdueVisits.length}</Badge>}
              </Accordion.Control>
              <Accordion.Panel>
                {data?.overdueVisits.length ? (
                  data.overdueVisits.map((visit) => <VisitItem key={visit.id} visit={visit} isOverdue />)
                ) : (
                  <Text size="sm" c="dimmed">¬°Todo al d√≠a!</Text>
                )}
              </Accordion.Panel>
            </Accordion.Item>

            <Accordion.Item value="orphaned">
              <Accordion.Control>
                <Text>Trabajo Hu√©rfano</Text>
                {data && data.orphanedVisits.length > 0 && <Badge color="gray">{data.orphanedVisits.length}</Badge>}
              </Accordion.Control>
              <Accordion.Panel>
                {data?.orphanedVisits.length ? (
                  data.orphanedVisits.map((visit) => <VisitItem key={visit.id} visit={visit} />)
                ) : (
                  <Text size="sm" c="dimmed">No hay trabajo sin asignar.</Text>
                )}
              </Accordion.Panel>
            </Accordion.Item>
          </Accordion>
        </ScrollArea>
      </div>
    </Stack>
  );
}


// ====== [21] packages/client/src/features/admin/pages/planner/planner-styles.css ======
/* filename: packages/client/src/features/admin/pages/planner/planner-styles.css */

/* Mejora la legibilidad y el aspecto de los eventos en el calendario */
.fc-event {
    cursor: grab;
    border-width: 2px !important;
    font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;
}

/* Elimina el punto que FullCalendar a√±ade por defecto */
.fc-event-dot {
    display: none;
}

.fc-daygrid-event-harness {
    margin-bottom: 4px;
}


// ====== [22] packages/client/src/features/admin/pages/planning/AvailabilityPage.tsx ======
// filename: packages/client/src/features/admin/pages/planning/AvailabilityPage.tsx
// version: 1.0.1 (FIXED)
// description: Se elimina la importaci√≥n no utilizada 'es' de 'date-fns/locale'.

import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Button,
  Modal,
  Stack,
  Text,
  Group,
  Paper,
  TextInput,
} from '@mantine/core';
import { DatePickerInput } from '@mantine/dates';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../../api/apiClient';
import { format } from 'date-fns';
// ‚úÖ CORRECCI√ìN: Se elimina la importaci√≥n de 'es' que no se estaba utilizando.

// --- Tipos de Datos ---
interface Technician {
  id: string;
  name: string;
  isAvailable: boolean;
}

interface UserAvailability {
  id: string;
  startDate: string;
  endDate: string;
  reason: string | null;
}

// --- Componente Principal ---
export function AvailabilityPage() {
  const [technicians, setTechnicians] = useState<Technician[]>([]);
  const [availabilities, setAvailabilities] = useState<UserAvailability[]>([]);
  const [selectedTechnician, setSelectedTechnician] = useState<Technician | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);

  const form = useForm({
    initialValues: {
      dateRange: [null, null] as [Date | null, Date | null],
      reason: '',
    },
    validate: {
      dateRange: (value) => (value[0] === null || value[1] === null ? 'Debe seleccionar un rango de fechas' : null),
    },
  });

  const fetchTechnicians = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const response = await apiClient.get('/users/technicians');
      setTechnicians(response.data.data);
    } catch (err) {
      setError('No se pudo cargar la lista de t√©cnicos.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchTechnicians();
  }, []);

  const handleOpenModal = async (technician: Technician) => {
    setSelectedTechnician(technician);
    try {
      const response = await apiClient.get(`/users/${technician.id}/availabilities`);
      setAvailabilities(response.data.data);
      openModal();
    } catch (err) {
      setError('No se pudieron cargar las ausencias de este t√©cnico.');
    }
  };

  const handleCloseModal = () => {
    closeModal();
    setSelectedTechnician(null);
    setAvailabilities([]);
    form.reset();
  };

  const handleSubmitAbsence = async (values: typeof form.values) => {
    if (!selectedTechnician || !values.dateRange[0] || !values.dateRange[1]) return;

    try {
      const payload = {
        userId: selectedTechnician.id,
        startDate: values.dateRange[0].toISOString(),
        endDate: values.dateRange[1].toISOString(),
        reason: values.reason,
      };
      await apiClient.post('/users/availability', payload);
      handleCloseModal();
    } catch (err) {
      setError('Error al guardar la ausencia.');
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = technicians.map((tech) => (
    <Table.Tr key={tech.id}>
      <Table.Td>{tech.name}</Table.Td>
      <Table.Td>
        <Button variant="outline" size="xs" onClick={() => handleOpenModal(tech)}>
          Gestionar Ausencias
        </Button>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={handleCloseModal}
        title={`Gestionar Ausencias de ${selectedTechnician?.name || ''}`}
        size="lg"
        centered
      >
        <Stack>
          <Paper withBorder p="md">
            <Title order={4} mb="md">A√±adir Nueva Ausencia</Title>
            <form onSubmit={form.onSubmit(handleSubmitAbsence)}>
              <Stack>
                <DatePickerInput
                  type="range"
                  label="Periodo de Ausencia"
                  placeholder="Desde - Hasta"
                  required
                  {...form.getInputProps('dateRange')}
                />
                <TextInput
                  label="Motivo (Opcional)"
                  placeholder="Ej: Vacaciones, Baja M√©dica"
                  {...form.getInputProps('reason')}
                />
                <Button type="submit" mt="md">Guardar Ausencia</Button>
              </Stack>
            </form>
          </Paper>

          <Paper withBorder p="md">
            <Title order={4} mb="md">Ausencias Programadas</Title>
            <Stack>
              {availabilities.length > 0 ? (
                availabilities.map((item) => (
                  <Paper key={item.id} p="xs" withBorder shadow="xs">
                    <Group justify="space-between">
                      <Text>
                        Del {format(new Date(item.startDate), 'dd/MM/yyyy')} al {format(new Date(item.endDate), 'dd/MM/yyyy')}
                      </Text>
                      <Text c="dimmed">{item.reason || 'Sin motivo'}</Text>
                    </Group>
                  </Paper>
                ))
              ) : (
                <Text c="dimmed">Este t√©cnico no tiene ausencias programadas.</Text>
              )}
            </Stack>
          </Paper>
        </Stack>
      </Modal>

      <Container fluid>
        <Title order={2} my="lg">Gesti√≥n de Disponibilidad del Equipo</Title>
        <Table striped withTableBorder mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre del T√©cnico</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [23] packages/client/src/features/admin/pages/planning/RouteTemplateFormPage.tsx ======
// filename: packages/client/src/features/admin/pages/planning/RouteTemplateFormPage.tsx
// version: 1.0.2 (FIXED)
// description: Corrige la importaci√≥n de tipos de Mantine y la estructura JSX.

import { useEffect, useState } from 'react';
import { useParams, useNavigate, Link } from 'react-router-dom';
import {
  Container,
  Title,
  Paper,
  TextInput,
  Select,
  MultiSelect,
  Button,
  Group,
  Stack,
  Loader,
  Alert,
  ActionIcon,
  Text,
  Breadcrumbs,
  Divider,
} from '@mantine/core';
import { DatePickerInput } from '@mantine/dates';
// ‚úÖ CORRECCI√ìN: Se importa el TIPO de forma expl√≠cita.
import type { DatesRangeValue } from '@mantine/dates';
import { useForm } from '@mantine/form';
import apiClient from '../../../../api/apiClient';

// --- Tipos de Datos ---
interface SelectOption { value: string; label: string; }
interface Season { frequency: string; startDate: Date | null; endDate: Date | null; }

// --- Componente Principal ---
export function RouteTemplateFormPage() {
  const { id } = useParams();
  const navigate = useNavigate();
  const isEditMode = Boolean(id);

  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [technicianOptions, setTechnicianOptions] = useState<SelectOption[]>([]);
  const [zoneOptions, setZoneOptions] = useState<SelectOption[]>([]);

  const form = useForm({
    initialValues: {
      name: '',
      dayOfWeek: '',
      technicianId: null as string | null,
      zoneIds: [] as string[],
      seasons: [{ frequency: 'WEEKLY', startDate: null, endDate: null }] as Season[],
    },
    validate: {
      name: (value) => (value.trim().length < 3 ? 'El nombre debe tener al menos 3 caracteres' : null),
      dayOfWeek: (value) => (!value ? 'Debe seleccionar un d√≠a de la semana' : null),
      technicianId: (value) => (!value ? 'Debe asignar un t√©cnico' : null),
      zoneIds: (value) => (value.length === 0 ? 'Debe seleccionar al menos una zona' : null),
      seasons: {
        startDate: (value) => (!value ? 'La fecha de inicio es obligatoria' : null),
        endDate: (value) => (!value ? 'La fecha de fin es obligatoria' : null),
      },
    },
  });
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        const fetchPromises = [
          apiClient.get('/users/technicians'),
          apiClient.get('/zones'),
        ];

        if (isEditMode) {
          fetchPromises.push(apiClient.get(`/route-templates/${id}`));
        }

        const [techniciansRes, zonesRes, routeTemplateRes] = await Promise.all(fetchPromises);
        
        setTechnicianOptions(techniciansRes!.data.data.map((t: any) => ({ value: t.id, label: t.name })));
        setZoneOptions(zonesRes!.data.data.map((z: any) => ({ value: z.id, label: z.name })));

        if (isEditMode && routeTemplateRes) {
            const data = routeTemplateRes.data.data;
            form.setValues({
                name: data.name,
                dayOfWeek: data.dayOfWeek,
                technicianId: data.technician?.id || null,
                zoneIds: data.zones.map((z: any) => z.id),
                seasons: data.seasons.map((s: any) => ({
                    frequency: s.frequency,
                    startDate: new Date(s.startDate),
                    endDate: new Date(s.endDate),
                })),
            });
        }
      } catch (err) {
        setError('No se pudieron cargar los datos necesarios para el formulario.');
      } finally {
        setIsLoading(false);
      }
    };
    fetchData();
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [id, isEditMode]);

  const handleSubmit = async (values: typeof form.values) => {
    try {
      if (isEditMode) {
        await apiClient.patch(`/route-templates/${id}`, values);
      } else {
        await apiClient.post('/route-templates', values);
      }
      navigate('/planning/routes');
    } catch (err: any) {
      setError(err.response?.data?.message || 'Ocurri√≥ un error al guardar la ruta.');
    }
  };

  const seasonFields = form.values.seasons.map((season, index) => (
    <Paper key={index} withBorder p="sm" mt="md">
        <Group justify="flex-end">
            <ActionIcon color="red" onClick={() => form.removeListItem('seasons', index)}>
                üóëÔ∏è
            </ActionIcon>
        </Group>
        <Group grow>
            <Select
                label="Frecuencia"
                data={['WEEKLY', 'BIWEEKLY', 'MONTHLY', 'QUARTERLY']}
                required
                {...form.getInputProps(`seasons.${index}.frequency`)}
            />
            <DatePickerInput
                type="range"
                label="Periodo de la Temporada"
                placeholder="Inicio - Fin"
                required
                value={[season.startDate, season.endDate]}
                onChange={ (value: DatesRangeValue) => {
                    const [start, end] = value;
                    form.setFieldValue(`seasons.${index}.startDate`, start ? new Date(start) : null);
                    form.setFieldValue(`seasons.${index}.endDate`, end ? new Date(end) : null);
                }}
            />
        </Group>
    </Paper>
  ));

  if (isLoading) return <Loader size="xl" />;

  // ‚úÖ CORRECCI√ìN: Se ha arreglado la estructura de etiquetas JSX
  return (
    <Container>
      <Breadcrumbs my="lg">
        <Link to="/planning/routes">Gesti√≥n de Rutas</Link>
        <Text>{isEditMode ? 'Editar Ruta' : 'Nueva Ruta'}</Text>
      </Breadcrumbs>
      <Title order={2} mb="xl">{isEditMode ? 'Editar Ruta Maestra' : 'Crear Nueva Ruta Maestra'}</Title>

      {error && <Alert color="red" title="Error" mb="md" withCloseButton onClose={() => setError(null)}>{error}</Alert>}

      <form onSubmit={form.onSubmit(handleSubmit)}>
        <Paper withBorder p="xl" shadow="sm">
          <Stack>
            <TextInput label="Nombre de la Ruta" placeholder="Ej: Lunes - Arenal" required {...form.getInputProps('name')} />
            <Group grow>
              <Select label="D√≠a de la Semana" data={['MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY', 'SUNDAY']} required {...form.getInputProps('dayOfWeek')} />
              <Select label="T√©cnico Habitual" data={technicianOptions} searchable required {...form.getInputProps('technicianId')} />
            </Group>
            <MultiSelect label="Zonas Cubiertas" data={zoneOptions} searchable required {...form.getInputProps('zoneIds')} />
            
            <Divider my="lg" label="Estacionalidad y Frecuencias" />
            
            {seasonFields}
            
            <Button mt="md" variant="light" onClick={() => form.insertListItem('seasons', { frequency: 'WEEKLY', startDate: null, endDate: null })}>
              + A√±adir Temporada
            </Button>
          </Stack>
        </Paper>

        <Group justify="flex-end" mt="xl">
          <Button variant="default" onClick={() => navigate('/planning/routes')}>Cancelar</Button>
          <Button type="submit">{isEditMode ? 'Guardar Cambios' : 'Crear Ruta Maestra'}</Button>
        </Group>
      </form>
    </Container>
  );
}


// ====== [24] packages/client/src/features/admin/pages/planning/RouteTemplatesPage.tsx ======
// filename: packages/client/src/features/admin/pages/planning/RouteTemplatesPage.tsx
// version: 1.0.0
// description: P√°gina para listar las Rutas Maestras existentes.

import { useEffect, useState } from 'react';
import { Link } from 'react-router-dom';
import {
  Container,
  Title,
  Loader,
  Alert,
  Button,
  Group,
  Stack,
  Card,
  Text,
  Badge,
  SimpleGrid,
} from '@mantine/core';
import apiClient from '../../../../api/apiClient';

// --- Tipos de Datos del Frontend ---
// Reflejan la estructura que nos devuelve la API
interface Season {
  id: string;
  frequency: string;
  startDate: string;
  endDate: string;
}

interface RouteTemplate {
  id: string;
  name: string;
  dayOfWeek: string;
  technician: { id: string; name: string } | null;
  zones: { id: string; name: string }[];
  seasons: Season[];
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente Principal ---
export function RouteTemplatesPage() {
  const [templates, setTemplates] = useState<RouteTemplate[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchTemplates = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const response = await apiClient.get<ApiResponse<RouteTemplate[]>>('/route-templates');
        setTemplates(response.data.data);
      } catch (err) {
        setError('No se pudo cargar la lista de Rutas Maestras.');
        console.error(err);
      } finally {
        setIsLoading(false);
      }
    };

    fetchTemplates();
  }, []);

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const routeCards = templates.map((template) => (
    <Card key={template.id} shadow="sm" p="lg" withBorder>
      <Stack h="100%">
        <Group justify="space-between">
          <Title order={4}>{template.name}</Title>
          <Badge size="lg">{template.dayOfWeek}</Badge>
        </Group>

        <Text>
          T√©cnico Habitual: <strong>{template.technician?.name || 'Sin asignar'}</strong>
        </Text>

        <div>
          <Text size="sm" fw={500}>Zonas Cubiertas:</Text>
          <Group gap="xs" mt={4}>
            {template.zones.map(zone => (
              <Badge key={zone.id} variant="light">{zone.name}</Badge>
            ))}
          </Group>
        </div>
        
        <Stack mt="auto">
            <Button component={Link} to={`/planning/routes/${template.id}`} variant="light">
                Editar Ruta
            </Button>
            <Button color="red" variant="outline" onClick={() => alert('Funcionalidad de borrado pendiente.')}>
                Eliminar
            </Button>
        </Stack>

      </Stack>
    </Card>
  ));

  return (
    <Container fluid>
      <Group justify="space-between" align="center" my="lg">
        <Title order={2}>Gesti√≥n de Rutas Maestras</Title>
        <Button component={Link} to="/planning/routes/new">
          Crear Nueva Ruta Maestra
        </Button>
      </Group>

      {templates.length > 0 ? (
        <SimpleGrid cols={{ base: 1, sm: 2, lg: 3 }}>
          {routeCards}
        </SimpleGrid>
      ) : (
        <Text c="dimmed" mt="xl">
          No hay Rutas Maestras creadas. Empieza por crear una para automatizar tu planificaci√≥n.
        </Text>
      )}
    </Container>
  );
}


// ====== [25] packages/client/src/features/admin/pages/pools/PoolDetailPage.tsx ======
// filename: packages/client/src/features/admin/pages/pools/PoolDetailPage.tsx
// Version: 1.2.0 (Implement Edit functionality for Pool Configurations)
import { useEffect, useState } from 'react';
import { useParams, Link } from 'react-router-dom';
import {
  Container,
  Title,
  Loader,
  Alert,
  Paper,
  Text,
  Table,
  Breadcrumbs,
  Grid,
  Card,
  Button,
  Group,
  Modal,
  Select,
  NumberInput,
  Stack,
  Menu,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../../api/apiClient.js';

// --- Tipos ---
const Frequencies = ['DIARIA', 'SEMANAL', 'QUINCENAL', 'MENSUAL', 'TRIMESTRAL', 'SEMESTRAL', 'ANUAL'] as const;
type Frequency = (typeof Frequencies)[number];

interface Pool { id: string; name: string; clientId: string; }
interface ParameterTemplate { id: string; name: string; unit: string | null; type: 'NUMBER' | 'BOOLEAN' | 'TEXT' | 'SELECT'; }
interface TaskTemplate { id: string; name: string; }
interface PoolConfiguration {
  id: string;
  frequency: Frequency;
  minThreshold: number | null;
  maxThreshold: number | null;
  parameterTemplate?: ParameterTemplate;
  taskTemplate?: TaskTemplate;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function PoolDetailPage() {
  const { id: poolId } = useParams<{ id: string }>();
  const [pool, ] = useState<Pool | null>(null);
  const [configurations, setConfigurations] = useState<PoolConfiguration[]>([]);
  const [parameterCatalog, setParameterCatalog] = useState<ParameterTemplate[]>([]);
  const [taskCatalog, setTaskCatalog] = useState<TaskTemplate[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  // Estado para saber qu√© estamos configurando (un nuevo √≠tem o editando uno existente)
  const [editingConfig, setEditingConfig] = useState<PoolConfiguration | null>(null);
  const [itemToAdd, setItemToAdd] = useState<{ id: string; name: string; type: 'parameter' | 'task' } | null>(null);

  const configForm = useForm({
    initialValues: {
      frequency: 'SEMANAL' as Frequency,
      minThreshold: null as number | null,
      maxThreshold: null as number | null,
    },
    validate: {
      frequency: (value) => (Frequencies.includes(value) ? null : 'Frecuencia inv√°lida'),
    },
  });

  const fetchData = async () => {
    if (!poolId) return;
    setIsLoading(true);
    try {
      const [configsRes, paramsRes, tasksRes] = await Promise.all([
        apiClient.get<ApiResponse<PoolConfiguration[]>>(`/pool-configurations/by-pool/${poolId}`),
        apiClient.get<ApiResponse<ParameterTemplate[]>>('/parameters'),
        apiClient.get<ApiResponse<TaskTemplate[]>>('/tasks'),
      ]);
      setConfigurations(configsRes.data.data);
      setParameterCatalog(paramsRes.data.data);
      setTaskCatalog(tasksRes.data.data);
    } catch (err) {
      setError('No se pudo cargar la configuraci√≥n de la piscina.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [poolId]);

  const handleOpenModal = (config: PoolConfiguration | null, item: { id: string; name: string; } | null, type: 'parameter' | 'task' | null) => {
    setEditingConfig(config);
    setItemToAdd(item ? { ...item, type: type as 'parameter' | 'task' } : null);
    
    if (config) { // Estamos editando
      configForm.setValues({
        frequency: config.frequency,
        minThreshold: config.minThreshold,
        maxThreshold: config.maxThreshold,
      });
    } else { // Estamos creando
      configForm.reset();
    }
    openModal();
  };

  const handleConfigSubmit = async (values: typeof configForm.values) => {
    if (!poolId) return;
    try {
      if (editingConfig) { // L√≥gica para actualizar
        const payload = { frequency: values.frequency, minThreshold: values.minThreshold, maxThreshold: values.maxThreshold };
        await apiClient.patch(`/pool-configurations/${editingConfig.id}`, payload);
      } else if (itemToAdd) { // L√≥gica para crear
        const payload = {
          poolId,
          frequency: values.frequency,
          ...(itemToAdd.type === 'parameter' && { parameterTemplateId: itemToAdd.id, minThreshold: values.minThreshold, maxThreshold: values.maxThreshold }),
          ...(itemToAdd.type === 'task' && { taskTemplateId: itemToAdd.id }),
        };
        await apiClient.post('/pool-configurations', payload);
      }
      await fetchData();
      closeModal();
    } catch (err: any) {
      configForm.setErrors({ frequency: err.response?.data?.message || 'Error al guardar la configuraci√≥n' });
    }
  };
  
  const handleConfigDelete = async (configId: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres quitar este √≠tem de la ficha?')) {
      try {
        await apiClient.delete(`/pool-configurations/${configId}`);
        await fetchData();
      } catch (err) {}
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const currentItem = editingConfig?.parameterTemplate || editingConfig?.taskTemplate || itemToAdd;
  const modalTitle = editingConfig ? `Editar: ${currentItem?.name}` : `A√±adir: ${currentItem?.name}`;
  const isParameter = (editingConfig && editingConfig.parameterTemplate) || (itemToAdd?.type === 'parameter');
  
  const breadcrumbs = (
    <Breadcrumbs>
      <Link to="/clients">Clientes</Link>
      <Text>Cliente (TODO)</Text>
      <Text>{pool?.name || 'Piscina'}</Text>
    </Breadcrumbs>
  );

  return (
    <>
      <Modal opened={modalOpened} onClose={closeModal} title={modalTitle} centered>
        <form onSubmit={configForm.onSubmit(handleConfigSubmit)}>
          <Stack>
            <Select label="Frecuencia" required data={[...Frequencies]} {...configForm.getInputProps('frequency')} />
            {isParameter && (
              <>
                <NumberInput label="Umbral M√≠nimo (opcional)" {...configForm.getInputProps('minThreshold')} />
                <NumberInput label="Umbral M√°ximo (opcional)" {...configForm.getInputProps('maxThreshold')} />
              </>
            )}
            <Button type="submit" mt="md">{editingConfig ? 'Guardar Cambios' : 'A√±adir a la Ficha'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        {breadcrumbs}
        <Title order={2} my="lg">Constructor de Ficha: {pool?.name || ''}</Title>
        <Grid>
          <Grid.Col span={{ base: 12, md: 6 }}>
            <Paper withBorder p="md">
              <Title order={4} mb="md">Ficha de Mantenimiento Actual</Title>
              <Table>
                <Table.Thead><Table.Tr><Table.Th>√çtem</Table.Th><Table.Th>Frecuencia</Table.Th><Table.Th>Acciones</Table.Th></Table.Tr></Table.Thead>
                <Table.Tbody>
                  {configurations.length > 0 ? configurations.map(config => (
                    <Table.Tr key={config.id}>
                      <Table.Td>{config.parameterTemplate?.name || config.taskTemplate?.name}</Table.Td>
                      <Table.Td>{config.frequency}</Table.Td>
                      <Table.Td>
                        <Menu shadow="md" width={200}>
                          <Menu.Target><Button variant="outline" size="xs">Acciones</Button></Menu.Target>
                          <Menu.Dropdown>
                            <Menu.Item onClick={() => handleOpenModal(config, null, null)}>Editar</Menu.Item>
                            <Menu.Item color="red" onClick={() => handleConfigDelete(config.id)}>Quitar</Menu.Item>
                          </Menu.Dropdown>
                        </Menu>
                      </Table.Td>
                    </Table.Tr>
                  )) : <Table.Tr><Table.Td colSpan={3}>La ficha est√° vac√≠a. A√±ade √≠tems desde los cat√°logos.</Table.Td></Table.Tr>}
                </Table.Tbody>
              </Table>
            </Paper>
          </Grid.Col>

          <Grid.Col span={{ base: 12, md: 6 }}>
            <Paper withBorder p="md" mb="md">
              <Title order={4} mb="md">Cat√°logo de Par√°metros Disponibles</Title>
              {parameterCatalog.map(param => (
                <Card key={param.id} shadow="sm" p="sm" mb="xs" withBorder>
                  <Group justify="space-between">
                    <Text>{param.name} {param.unit ? `(${param.unit})` : ''}</Text>
                    <Button size="xs" onClick={() => handleOpenModal(null, param, 'parameter')}>A√±adir</Button>
                  </Group>
                </Card>
              ))}
            </Paper>
            <Paper withBorder p="md">
              <Title order={4} mb="md">Cat√°logo de Tareas Disponibles</Title>
              {taskCatalog.map(task => (
                <Card key={task.id} shadow="sm" p="sm" mb="xs" withBorder>
                  <Group justify="space-between">
                    <Text>{task.name}</Text>
                    <Button size="xs" onClick={() => handleOpenModal(null, task, 'task')}>A√±adir</Button>
                  </Group>
                </Card>
              ))}
            </Paper>
          </Grid.Col>
        </Grid>
      </Container>
    </>
  );
}


// ====== [26] packages/client/src/features/admin/pages/reports/ConsumptionReportPage.tsx ======
// filename: packages/client/src/features/admin/pages/reports/ConsumptionReportPage.tsx
// version: 2.2.2 (FIX: Definitively correct the string-to-date conversion on DatePickerInput's onChange)

import { useState, useEffect, Fragment } from 'react';
import { Link } from 'react-router-dom';
import { Container, Title, Paper, Group, Select, Button, Loader, Alert, Stack, Table, Text, Card, SimpleGrid, Collapse, Modal, Anchor } from '@mantine/core';
import { DatePickerInput } from '@mantine/dates';
import 'dayjs/locale/es';
import { startOfMonth, endOfMonth, startOfDay, endOfDay, format } from 'date-fns';
import { es } from 'date-fns/locale';
import apiClient from '../../../../api/apiClient';
import { useDisclosure } from '@mantine/hooks';

// --- Tipos de Datos para el Frontend ---
interface Client {
  id: string;
  name: string;
}

interface DetailedConsumption {
  productId: string;
  productName: string;
  unit: string;
  totalQuantity: number;
  totalCost: number;
}

interface ProductConsumptionDetail {
    visitId: string;
    visitDate: Date;
    quantity: number;
    cost: number;
    technicianName: string | null;
}

type DateRange = [Date | null, Date | null];

interface ReportData {
  summary: {
    totalCost: number;
    totalVisits: number;
  };
  byClient: {
    clientId: string;
    clientName: string;
    totalClientCost: number;
    visitCount: number;
    detailedConsumption: DetailedConsumption[];
  }[];
}

export function ConsumptionReportPage() {
  const [clients, setClients] = useState<Client[]>([]);
  const [selectedClientId, setSelectedClientId] = useState<string | null>(null);
  const [dateRange, setDateRange] = useState<DateRange>([startOfMonth(new Date()), endOfMonth(new Date())]);
  
  const [reportData, setReportData] = useState<ReportData | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [openedRow, setOpenedRow] = useState<string | null>(null);
  const [detailModalOpened, { open: openDetailModal, close: closeDetailModal }] = useDisclosure(false);
  const [productDetailData, setProductDetailData] = useState<ProductConsumptionDetail[]>([]);
  const [isDetailLoading, setIsDetailLoading] = useState(false);
  const [selectedProductInfo, setSelectedProductInfo] = useState<{ productName: string, clientId: string } | null>(null);


  useEffect(() => {
    const fetchClients = async () => {
      try {
        const response = await apiClient.get('/clients');
        setClients(response.data.data);
      } catch (err) {
        setError('No se pudo cargar la lista de clientes.');
      }
    };
    fetchClients();
  }, []);

  const handleGenerateReport = async () => {
    if (!dateRange[0] || !dateRange[1]) {
      setError('Por favor, seleccione un rango de fechas completo.');
      return;
    }

    setIsLoading(true);
    setError(null);
    setReportData(null);
    setOpenedRow(null);

    try {
      const params = new URLSearchParams({
        startDate: startOfDay(dateRange[0]).toISOString(),
        endDate: endOfDay(dateRange[1]).toISOString(),
      });
      if (selectedClientId) {
        params.append('clientId', selectedClientId);
      }
      
      const response = await apiClient.get(`/reports/consumption?${params.toString()}`);
      setReportData(response.data.data);
    } catch (err) {
      setError('Ocurri√≥ un error al generar el informe.');
      console.error(err);
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleProductDrillDown = async (clientId: string, product: DetailedConsumption) => {
    if (!dateRange[0] || !dateRange[1]) return;

    setSelectedProductInfo({ productName: product.productName, clientId });
    setIsDetailLoading(true);
    openDetailModal();
    setProductDetailData([]);

    try {
        const params = new URLSearchParams({
            startDate: startOfDay(dateRange[0]).toISOString(),
            endDate: endOfDay(dateRange[1]).toISOString(),
            clientId: clientId,
            productId: product.productId,
        });

        const response = await apiClient.get(`/reports/consumption/details?${params.toString()}`);
        setProductDetailData(response.data.data);
    } catch (err) {
        console.error("Error al cargar el detalle del producto", err);
    } finally {
        setIsDetailLoading(false);
    }
  }


  const handleExportToCSV = () => {
    if (!reportData) return;
  
    let csvContent = "data:text/csv;charset=utf-8,";
    csvContent += "ID Cliente,Nombre Cliente,Coste Total Cliente,Producto,Cantidad Consumida,Unidad,Coste Producto\r\n";
  
    reportData.byClient.forEach(client => {
      if (client.detailedConsumption.length === 0) {
        csvContent += `${client.clientId},"${client.clientName.replace(/"/g, '""')}",${client.totalClientCost.toFixed(2)},N/A,0,N/A,0\r\n`;
      } else {
        client.detailedConsumption.forEach(item => {
          csvContent += [
            client.clientId,
            `"${client.clientName.replace(/"/g, '""')}"`,
            client.totalClientCost.toFixed(2),
            `"${item.productName.replace(/"/g, '""')}"`,
            item.totalQuantity,
            item.unit,
            item.totalCost.toFixed(2)
          ].join(',') + '\r\n';
        });
      }
    });
  
    const encodedUri = encodeURI(csvContent);
    const link = document.createElement("a");
    link.setAttribute("href", encodedUri);
    link.setAttribute("download", `informe_consumo_${new Date().toISOString().split('T')[0]}.csv`);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };
  
  const clientOptions = clients.map(client => ({
    value: client.id,
    label: client.name,
  }));

  const reportRows = reportData?.byClient.map((client) => {
    const isOpened = openedRow === client.clientId;
    return (
      <Fragment key={client.clientId}>
        <Table.Tr 
          onClick={() => setOpenedRow(isOpened ? null : client.clientId)}
          style={{ cursor: 'pointer', backgroundColor: isOpened ? 'var(--mantine-color-blue-0)' : 'transparent' }}
        >
          <Table.Td>{client.clientName}</Table.Td>
          <Table.Td>{client.visitCount}</Table.Td>
          <Table.Td>{client.totalClientCost.toFixed(2)} ‚Ç¨</Table.Td>
        </Table.Tr>
        
        <Table.Tr>
          <Table.Td colSpan={3} p={0} style={{ border: 0 }}>
            <Collapse in={isOpened}>
              <Paper p="md" m="xs" withBorder bg="gray.0">
                <Text fw={700} mb="sm">Desglose de Productos para {client.clientName}</Text>
                <Table withColumnBorders>
                  <Table.Thead>
                    <Table.Tr>
                      <Table.Th>Producto</Table.Th>
                      <Table.Th>Cantidad Total</Table.Th>
                      <Table.Th>Coste</Table.Th>
                    </Table.Tr>
                  </Table.Thead>
                  <Table.Tbody>
                    {client.detailedConsumption.map(item => (
                      <Table.Tr key={item.productName}>
                        <Table.Td>
                            <Anchor component="button" type="button" onClick={() => handleProductDrillDown(client.clientId, item)}>
                                {item.productName}
                            </Anchor>
                        </Table.Td>
                        <Table.Td>{item.totalQuantity.toFixed(2)} {item.unit}</Table.Td>
                        <Table.Td>{item.totalCost.toFixed(2)} ‚Ç¨</Table.Td>
                      </Table.Tr>
                    ))}
                  </Table.Tbody>
                </Table>
              </Paper>
            </Collapse>
          </Table.Td>
        </Table.Tr>
      </Fragment>
    );
  });

  return (
    <Container fluid>
      <Modal 
        opened={detailModalOpened} 
        onClose={closeDetailModal} 
        title={`Detalle de consumo para: ${selectedProductInfo?.productName || ''}`}
        size="xl"
        centered
      >
        {isDetailLoading ? <Loader /> : (
            <Table>
                <Table.Thead>
                    <Table.Tr>
                        <Table.Th>Fecha de Visita</Table.Th>
                        <Table.Th>T√©cnico</Table.Th>
                        <Table.Th>Cantidad</Table.Th>
                        <Table.Th>Coste</Table.Th>
                        <Table.Th>Acciones</Table.Th>
                    </Table.Tr>
                </Table.Thead>
                <Table.Tbody>
                    {productDetailData.map(detail => (
                        <Table.Tr key={detail.visitId}>
                            <Table.Td>{format(new Date(detail.visitDate), 'd MMMM yyyy, HH:mm', { locale: es })}</Table.Td>
                            <Table.Td>{detail.technicianName}</Table.Td>
                            <Table.Td>{detail.quantity.toFixed(2)}</Table.Td>
                            <Table.Td>{detail.cost.toFixed(2)} ‚Ç¨</Table.Td>
                            <Table.Td>
                                <Button component={Link} to={`/visits/${detail.visitId}`} size="xs" variant="outline">
                                    Ver Parte
                                </Button>
                            </Table.Td>
                        </Table.Tr>
                    ))}
                </Table.Tbody>
            </Table>
        )}
      </Modal>

      <Title order={2} mb="xl">Informe de Consumos y Costes</Title>
      
      <Paper withBorder shadow="sm" p="md" mb="xl">
        <Group align="flex-end">
          <DatePickerInput
            type="range"
            label="Periodo del Informe"
            placeholder="Seleccione un rango de fechas"
            value={dateRange}
            // ‚úÖ SOLUCI√ìN FINAL Y DEFINITIVA
            onChange={(value: [string | null, string | null]) => {
              const [start, end] = value;
              setDateRange([start ? new Date(start) : null, end ? new Date(end) : null]);
            }}
            locale="es"
            valueFormat="D MMMM, YYYY"
            style={{ flex: 1 }}
          />
          
          <Select
            label="Cliente"
            placeholder="Todos los clientes"
            data={clientOptions}
            value={selectedClientId}
            onChange={setSelectedClientId}
            clearable
            style={{ width: '250px' }}
          />
          
          <Button onClick={handleGenerateReport} loading={isLoading}>
            Generar Informe
          </Button>
          {reportData && (
             <Button
                variant="outline"
                onClick={handleExportToCSV}
                disabled={!reportData || reportData.byClient.length === 0}
            >
                Exportar a CSV
            </Button>
          )}
        </Group>
      </Paper>
      
      {isLoading && <Loader size="xl" />}
      {error && <Alert color="red" title="Error">{error}</Alert>}
      
      {reportData && (
        <Stack>
            <SimpleGrid cols={{ base: 1, sm: 2 }}>
                <Card withBorder shadow="sm" p="md">
                    <Text size="lg" fw={700}>Coste Total del Periodo</Text>
                    <Text size="xl" c="blue">{reportData.summary.totalCost.toFixed(2)} ‚Ç¨</Text>
                </Card>
                <Card withBorder shadow="sm" p="md">
                    <Text size="lg" fw={700}>N¬∫ de Visitas Registradas</Text>
                    <Text size="xl" c="blue">{reportData.summary.totalVisits}</Text>
                </Card>
            </SimpleGrid>

            <Title order={4} mt="xl">Resumen por Cliente</Title>
            <Table striped withTableBorder>
                <Table.Thead>
                    <Table.Tr>
                        <Table.Th>Cliente</Table.Th>
                        <Table.Th>N¬∫ de Visitas</Table.Th>
                        <Table.Th>Coste Total</Table.Th>
                    </Table.Tr>
                </Table.Thead>
                <Table.Tbody>
                    {reportRows?.length ? reportRows : <Table.Tr><Table.Td colSpan={3}>No se encontraron datos para los filtros seleccionados.</Table.Td></Table.Tr>}
                </Table.Tbody>
            </Table>
        </Stack>
      )}
    </Container>
  );
}


// ====== [27] packages/client/src/features/admin/pages/zones/ZoneManagementPage.tsx ======
// filename: packages/client/src/features/admin/pages/zones/ZoneManagementPage.tsx
// version: 1.0.0
// description: P√°gina para la gesti√≥n completa (CRUD) del cat√°logo de Zonas Geogr√°ficas.

import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../../api/apiClient';

// --- Tipos de Datos ---
interface Zone {
  id: string;
  name: string;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente Principal ---
export function ZoneManagementPage() {
  // --- Estados del Componente ---
  const [zones, setZones] = useState<Zone[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingZone, setEditingZone] = useState<Zone | null>(null);

  // --- Formulario (Mantine Form) ---
  const form = useForm({
    initialValues: {
      name: '',
    },
    validate: {
      name: (value) => (value.trim().length < 2 ? 'El nombre de la zona es demasiado corto.' : null),
    },
  });

  // --- L√≥gica de Datos (API Calls) ---
  const fetchZones = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<Zone[]>>('/zones');
      setZones(response.data.data);
    } catch (err) {
      setError('No se pudo cargar el cat√°logo de zonas.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchZones();
  }, []);

  // --- Manejadores de Eventos ---
  const handleOpenModal = (zone: Zone | null = null) => {
    setEditingZone(zone);
    if (zone) {
      form.setValues({ name: zone.name });
    } else {
      form.reset();
    }
    openModal();
  };

  const handleSubmit = async (values: typeof form.values) => {
    try {
      if (editingZone) {
        await apiClient.patch(`/zones/${editingZone.id}`, values);
      } else {
        await apiClient.post('/zones', values);
      }
      await fetchZones();
      closeModal();
    } catch (err: any) {
      const errorMessage = err.response?.data?.message || 'Error al guardar la zona.';
      form.setErrors({ name: errorMessage });
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar esta zona?')) {
      try {
        await apiClient.delete(`/zones/${id}`);
        // Actualizaci√≥n optimista de la UI
        setZones((current) => current.filter((z) => z.id !== id));
      } catch (err: any) {
        const errorMessage = err.response?.data?.message || 'No se pudo eliminar la zona.';
        alert(errorMessage); // Mostramos el error espec√≠fico del backend
      }
    }
  };

  // --- Renderizado del Componente ---
  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = zones.map((zone) => (
    <Table.Tr key={zone.id}>
      <Table.Td>{zone.name}</Table.Td>
      <Table.Td>
        <Group gap="xs">
          <Button variant="subtle" size="xs" onClick={() => handleOpenModal(zone)}>Editar</Button>
          <Button variant="subtle" size="xs" color="red" onClick={() => handleDelete(zone.id)}>Eliminar</Button>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingZone ? 'Editar Zona' : 'Crear Nueva Zona'}
        centered
      >
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="Nombre de la Zona" placeholder="Ej: Arenal" {...form.getInputProps('name')} />
            <Button type="submit" mt="md">{editingZone ? 'Guardar Cambios' : 'Crear Zona'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Gesti√≥n de Zonas Geogr√°ficas</Title>
          <Button onClick={() => handleOpenModal()}>Crear Nueva Zona</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={2}>No hay zonas definidas en el cat√°logo.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [28] packages/client/src/features/auth/pages/LoginPage.tsx ======
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Container,
  Title,
  Paper,
  TextInput,
  PasswordInput,
  Button,
  Stack,
  Alert,
} from '@mantine/core';
import { useAuth } from '../../../providers/AuthProvider.js';

export function LoginPage() {
  const { login } = useAuth();
  const navigate = useNavigate();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setError(null);
    try {
      await login({ email, password });
      navigate('/'); // Redirige al dashboard en un login exitoso
    } catch (err) {
      setError('El email o la contrase√±a son incorrectos.');
      console.error(err);
    }
  };

  return (
    <Container size={420} my={40}>
      <Title ta="center">¬°Bienvenido!</Title>
      <Paper withBorder shadow="md" p={30} mt={30} radius="md">
        <form onSubmit={handleSubmit}>
          <Stack>
            <TextInput
              required
              label="Email"
              placeholder="tu@email.com"
              value={email}
              onChange={(event) => setEmail(event.currentTarget.value)}
              radius="md"
            />
            <PasswordInput
              required
              label="Contrase√±a"
              placeholder="Tu contrase√±a"
              value={password}
              onChange={(event) => setPassword(event.currentTarget.value)}
              radius="md"
            />
            {error && (
              <Alert title="Error de autenticaci√≥n" color="red" withCloseButton onClose={() => setError(null)}>
                {error}
              </Alert>
            )}
            <Button type="submit" fullWidth mt="xl" radius="md">
              Iniciar Sesi√≥n
            </Button>
          </Stack>
        </form>
      </Paper>
    </Container>
  );
}


// ====== [29] packages/client/src/features/financials/pages/ExpensesPage.tsx ======
// filename: packages/client/src/features/financials/pages/ExpensesPage.tsx
// version: 1.0.0
// description: P√°gina para visualizar y registrar los gastos generales de la empresa.

import { useEffect, useState } from 'react';
import { Container, Title, Table, Loader, Alert, Button, Group, Modal, NumberInput, Stack, TextInput } from '@mantine/core';
import { DatePickerInput } from '@mantine/dates';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient';
import { format } from 'date-fns';

// --- Tipos de Datos ---
interface Expense {
  id: string;
  amount: number;
  expenseDate: string;
  description: string;
  category: string;
}
interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente Principal ---
export function ExpensesPage() {
  const [expenses, setExpenses] = useState<Expense[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);

  const form = useForm({
    initialValues: {
      amount: 0,
      expenseDate: new Date(),
      description: '',
      category: '',
    },
    validate: {
      amount: (value) => value <= 0 ? 'El importe debe ser mayor que cero' : null,
      expenseDate: (value) => !value ? 'La fecha es obligatoria' : null,
      description: (value) => value.trim().length === 0 ? 'La descripci√≥n es obligatoria' : null,
      category: (value) => value.trim().length === 0 ? 'La categor√≠a es obligatoria' : null,
    },
  });

  const fetchExpenses = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<Expense[]>>('/expenses');
      setExpenses(response.data.data);
    } catch (err) {
      setError('No se pudo cargar la lista de gastos.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchExpenses();
  }, []);

  const handleSubmit = async (values: typeof form.values) => {
    try {
      await apiClient.post('/expenses', values);
      await fetchExpenses();
      closeModal();
      form.reset();
    } catch (err: any) {
      form.setErrors({ description: err.response?.data?.message || 'Error al registrar el gasto.' });
    }
  };

  const handleDelete = async (expenseId: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar este gasto?')) {
      try {
        await apiClient.delete(`/expenses/${expenseId}`);
        setExpenses((current) => current.filter((e) => e.id !== expenseId));
      } catch (err) {
        alert('No se pudo eliminar el gasto.');
      }
    }
  };

  const rows = expenses.map((expense) => (
    <Table.Tr key={expense.id}>
      <Table.Td>{format(new Date(expense.expenseDate), 'dd/MM/yyyy')}</Table.Td>
      <Table.Td>{expense.description}</Table.Td>
      <Table.Td>{expense.category}</Table.Td>
      <Table.Td>{new Intl.NumberFormat('es-ES', { style: 'currency', currency: 'EUR' }).format(expense.amount)}</Table.Td>
      <Table.Td>
        <Button variant="subtle" color="red" size="xs" onClick={() => handleDelete(expense.id)}>Eliminar</Button>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal opened={modalOpened} onClose={closeModal} title="Registrar Nuevo Gasto" centered>
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <DatePickerInput label="Fecha del Gasto" required {...form.getInputProps('expenseDate')} />
            <TextInput label="Descripci√≥n" placeholder="Ej: Compra de material de oficina" required {...form.getInputProps('description')} />
            <TextInput label="Categor√≠a" placeholder="Ej: Combustible, N√≥minas, Suministros" required {...form.getInputProps('category')} />
            <NumberInput label="Importe (‚Ç¨)" decimalScale={2} fixedDecimalScale required {...form.getInputProps('amount')} />
            <Button type="submit" mt="md">Registrar Gasto</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Gesti√≥n de Gastos Generales</Title>
          <Button onClick={openModal}>Registrar Nuevo Gasto</Button>
        </Group>
        
        {isLoading && <Loader />}
        {error && <Alert color="red" title="Error">{error}</Alert>}
        
        <Table striped withTableBorder mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Fecha</Table.Th>
              <Table.Th>Descripci√≥n</Table.Th>
              <Table.Th>Categor√≠a</Table.Th>
              <Table.Th>Importe</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>
            {expenses.length > 0 ? rows : <Table.Tr><Table.Td colSpan={5}>No hay gastos registrados.</Table.Td></Table.Tr>}
          </Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [30] packages/client/src/features/financials/pages/PaymentsPage.tsx ======
// filename: packages/client/src/features/financials/pages/PaymentsPage.tsx
// version: 1.0.1 (FIXED)
// description: Corrige importaciones y variables no utilizadas.

import { useEffect, useState } from 'react';
import { Container, Title, Table, Loader, Alert, Button, Group, Modal, Select, NumberInput, Stack, TextInput, Textarea, Paper } from '@mantine/core'; // ‚úÖ Paper a√±adido
import { DatePickerInput } from '@mantine/dates';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient';
import { format } from 'date-fns';

// --- Tipos de Datos ---
interface Payment {
  id: string;
  amount: number;
  paymentDate: string;
  method: string;
  notes: string | null;
  client: { name: string };
}
interface Client {
  id: string;
  name: string;
}
interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente Principal ---
export function PaymentsPage() {
  const [payments, setPayments] = useState<Payment[]>([]);
  const [clients, setClients] = useState<Client[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [selectedClient, setSelectedClient] = useState<string | null>(null);

  const form = useForm({
    initialValues: {
      clientId: '',
      amount: 0,
      paymentDate: new Date(),
      method: 'Transferencia Bancaria',
      notes: '',
    },
    validate: {
      clientId: (value) => !value ? 'Debe seleccionar un cliente' : null,
      amount: (value) => value <= 0 ? 'El importe debe ser mayor que cero' : null,
      paymentDate: (value) => !value ? 'La fecha es obligatoria' : null,
      method: (value) => value.trim().length === 0 ? 'El m√©todo es obligatorio' : null,
    },
  });

  const fetchInitialData = async () => {
    setIsLoading(true);
    try {
      // ‚úÖ Se elimina la variable 'url' no utilizada.
      const clientsRes = await apiClient.get<ApiResponse<Client[]>>('/clients');
      setClients(clientsRes.data.data);
      setPayments([]);
    } catch (err) {
      setError('No se pudo cargar la lista de clientes.');
    } finally {
      setIsLoading(false);
    }
  };

  const fetchPaymentsForClient = async (clientId: string | null) => {
    if (!clientId) {
        setPayments([]);
        return;
    }
    setIsLoading(true);
    try {
        const response = await apiClient.get<ApiResponse<Payment[]>>(`/payments/by-client/${clientId}`);
        setPayments(response.data.data);
    } catch (err) {
        setError(`No se pudieron cargar los pagos para este cliente.`);
    } finally {
        setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchInitialData();
  }, []);

  useEffect(() => {
    fetchPaymentsForClient(selectedClient);
  }, [selectedClient]);

  const handleSubmit = async (values: typeof form.values) => {
    try {
      await apiClient.post('/payments', values);
      // Si el pago es para el cliente actualmente seleccionado, refrescamos la lista
      if (values.clientId === selectedClient) {
        await fetchPaymentsForClient(values.clientId);
      }
      closeModal();
      form.reset();
    } catch (err: any) {
      form.setErrors({ clientId: err.response?.data?.message || 'Error al registrar el pago.' });
    }
  };

  const handleDelete = async (paymentId: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar este pago?')) {
      try {
        await apiClient.delete(`/payments/${paymentId}`);
        await fetchPaymentsForClient(selectedClient);
      } catch (err) {
        alert('No se pudo eliminar el pago.');
      }
    }
  };

  const clientOptions = clients.map(c => ({ value: c.id, label: c.name }));

  const rows = payments.map((payment) => (
    <Table.Tr key={payment.id}>
      <Table.Td>{format(new Date(payment.paymentDate), 'dd/MM/yyyy')}</Table.Td>
      {/* No necesitamos mostrar el cliente en la tabla si ya est√° filtrado
      <Table.Td>{payment.client.name}</Table.Td> 
      */}
      <Table.Td>{new Intl.NumberFormat('es-ES', { style: 'currency', currency: 'EUR' }).format(payment.amount)}</Table.Td>
      <Table.Td>{payment.method}</Table.Td>
      <Table.Td>{payment.notes || '-'}</Table.Td>
      <Table.Td>
        <Button variant="subtle" color="red" size="xs" onClick={() => handleDelete(payment.id)}>Eliminar</Button>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal opened={modalOpened} onClose={closeModal} title="Registrar Nuevo Pago" centered>
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <Select label="Cliente" placeholder="Seleccione un cliente" data={clientOptions} required {...form.getInputProps('clientId')} />
            <NumberInput label="Importe (‚Ç¨)" decimalScale={2} fixedDecimalScale required {...form.getInputProps('amount')} />
            <DatePickerInput label="Fecha de Pago" required {...form.getInputProps('paymentDate')} />
            <TextInput label="M√©todo de Pago" placeholder="Ej: Transferencia, Efectivo..." required {...form.getInputProps('method')} />
            <Textarea label="Notas (Opcional)" placeholder="Ej: Factura 2025-0045" {...form.getInputProps('notes')} />
            <Button type="submit" mt="md">Registrar Pago</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Gesti√≥n de Pagos Recibidos</Title>
          <Button onClick={openModal}>Registrar Nuevo Pago</Button>
        </Group>
        
        <Paper withBorder p="md" mb="xl">
            <Select 
                label="Filtrar por Cliente"
                placeholder="Seleccione un cliente para ver sus pagos"
                data={clientOptions}
                value={selectedClient}
                onChange={setSelectedClient}
                clearable
            />
        </Paper>

        {isLoading && <Loader />}
        {error && <Alert color="red" title="Error">{error}</Alert>}
        
        <Table striped withTableBorder mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Fecha</Table.Th>
              {/* <Table.Th>Cliente</Table.Th> */}
              <Table.Th>Importe</Table.Th>
              <Table.Th>M√©todo</Table.Th>
              <Table.Th>Notas</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>
            {payments.length > 0 ? rows : <Table.Tr><Table.Td colSpan={5}>Seleccione un cliente para ver sus pagos o registre uno nuevo.</Table.Td></Table.Tr>}
          </Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [31] packages/client/src/features/manager/pages/InvoicingReportPage.tsx ======
// filename: packages/client/src/features/manager/pages/InvoicingReportPage.tsx
// version: 1.0.3 (FIXED)
// description: Asegura que las fechas son objetos Date antes de usarlas.

import { useEffect, useState } from 'react';
import { Container, Title, Paper, Group, Button, Loader, Alert, Table, Accordion, Text, Stack } from '@mantine/core';
import { DatePickerInput } from '@mantine/dates';
import type { DatesRangeValue } from '@mantine/dates';
import 'dayjs/locale/es';
import apiClient from '../../../api/apiClient';
import { subMonths, startOfMonth, endOfMonth } from 'date-fns';

// --- Tipos ---
interface BilledConsumption {
  productId: string;
  productName: string;
  unit: string;
  totalQuantity: number;
  salePrice: number;
  totalLine: number;
}
interface ClientInvoiceData {
  clientId: string;
  clientName: string;
  billingModel: string;
  monthlyFee: number;
  materialsSubtotal: number;
  totalToInvoice: number;
  billedConsumption: BilledConsumption[];
}
interface InvoicingReport {
  summary: {
    totalToInvoice: number;
    totalFees: number;
    totalMaterials: number;
  };
  byClient: ClientInvoiceData[];
}

const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('es-ES', { style: 'currency', currency: 'EUR' }).format(amount);
};

export function InvoicingReportPage() {
  const [report, setReport] = useState<InvoicingReport | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [dateRange, setDateRange] = useState<DatesRangeValue>([
    startOfMonth(subMonths(new Date(), 1)),
    endOfMonth(subMonths(new Date(), 1)),
  ]);

  const fetchReport = async () => {
    const [startDate, endDate] = dateRange;
    if (!startDate || !endDate) {
      setError('Por favor, seleccione un rango de fechas v√°lido.');
      return;
    }
    
    // ‚úÖ Conversi√≥n y validaci√≥n segura de fechas
    const startDateObj = startDate instanceof Date ? startDate : new Date(startDate);
    const endDateObj = endDate instanceof Date ? endDate : new Date(endDate);
    
    if (isNaN(startDateObj.getTime()) || isNaN(endDateObj.getTime())) {
      setError('Formato de fecha inv√°lido.');
      return;
    }

    setIsLoading(true);
    setError(null);
    setReport(null);

    try {
      const response = await apiClient.get('/reports/invoicing', {
        params: {
          startDate: startDateObj.toISOString(),
          endDate: endDateObj.toISOString(),
        },
      });
      setReport(response.data.data);
    } catch (err) {
      setError('No se pudo generar el informe.');
      console.error(err);
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchReport();
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const clientRows = report?.byClient.map((clientData) => (
    <Accordion.Item key={clientData.clientId} value={clientData.clientId}>
      <Accordion.Control>
        <Group justify="space-between">
          <Text fw={500}>{clientData.clientName}</Text>
          <Text fw={700} c="blue">{formatCurrency(clientData.totalToInvoice)}</Text>
        </Group>
      </Accordion.Control>
      <Accordion.Panel>
        <Stack gap="xs">
            <Text><strong>Modelo de Contrato:</strong> {clientData.billingModel.replace(/_/g, ' ').toLowerCase()}</Text>
            <Text><strong>Cuota Fija:</strong> {formatCurrency(clientData.monthlyFee)}</Text>
            <Text><strong>Subtotal Materiales:</strong> {formatCurrency(clientData.materialsSubtotal)}</Text>
        </Stack>
        {clientData.billedConsumption.length > 0 && (
            <Table mt="md" striped withTableBorder>
                <Table.Thead>
                    <Table.Tr>
                        <Table.Th>Producto</Table.Th>
                        <Table.Th>Cantidad</Table.Th>
                        <Table.Th>PVP Unitario</Table.Th>
                        <Table.Th>Total L√≠nea</Table.Th>
                    </Table.Tr>
                </Table.Thead>
                <Table.Tbody>
                    {clientData.billedConsumption.map(item => (
                        <Table.Tr key={item.productId}>
                            <Table.Td>{item.productName}</Table.Td>
                            <Table.Td>{item.totalQuantity} {item.unit}</Table.Td>
                            <Table.Td>{formatCurrency(item.salePrice)}</Table.Td>
                            <Table.Td>{formatCurrency(item.totalLine)}</Table.Td>
                        </Table.Tr>
                    ))}
                </Table.Tbody>
            </Table>
        )}
      </Accordion.Panel>
    </Accordion.Item>
  ));


  return (
    <Container fluid>
      <Title order={2} mb="xl">Informe para Facturaci√≥n</Title>
      <Paper withBorder p="md" mb="xl" shadow="sm">
        <Group>
          <DatePickerInput
            type="range"
            label="Seleccione el periodo"
            placeholder="Inicio - Fin"
            value={dateRange}
            onChange={setDateRange}
            locale="es"
            maw={400}
          />
          <Button onClick={fetchReport} loading={isLoading} mt="xl">
            Generar Informe
          </Button>
        </Group>
      </Paper>

      {isLoading && <Loader />}
      {error && <Alert color="red" title="Error">{error}</Alert>}
      
      {report && (
        <Paper withBorder p="md" shadow="sm">
            <Title order={4} mb="md">Resumen Total del Periodo</Title>
            <Group justify="space-around" mb="xl">
                <Stack align="center" gap={0}>
                    <Text size="xl" fw={500}>Cuotas Fijas</Text>
                    <Text size="2rem" fw={700} c="dimmed">{formatCurrency(report.summary.totalFees)}</Text>
                </Stack>
                <Stack align="center" gap={0}>
                    <Text size="xl" fw={500}>Materiales</Text>
                    <Text size="2rem" fw={700} c="dimmed">{formatCurrency(report.summary.totalMaterials)}</Text>
                </Stack>
                <Stack align="center" gap={0}>
                    <Text size="xl" fw={500}>Total a Facturar</Text>
                    <Text size="2.5rem" fw={700} c="blue">{formatCurrency(report.summary.totalToInvoice)}</Text>
                </Stack>
            </Group>
            <Title order={4} my="md">Desglose por Cliente</Title>
            <Accordion variant="separated">
                {clientRows}
            </Accordion>
        </Paper>
      )}
    </Container>
  );
}


// ====== [32] packages/client/src/features/manager/pages/ManagerDashboard.tsx ======
// ====== [25] packages/client/src/features/manager/pages/ManagerDashboard.tsx ======
// filename: packages/client/src/features/manager/pages/ManagerDashboard.tsx
// version: 2.4.0 (FEAT: Add Team Performance widget)
// description: Added a new widget to the dashboard to display team performance metrics with a bar chart comparing technicians.

import { useEffect, useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { Container, Title, Grid, Paper, Text, Loader, Alert, Center, RingProgress, Stack, Group, Anchor, Badge } from '@mantine/core';
import { DatePickerInput } from '@mantine/dates';
import type { DatesRangeValue } from '@mantine/dates';
import 'dayjs/locale/es';
import { subDays, endOfDay } from 'date-fns';

import { Bar, Doughnut } from 'react-chartjs-2';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  BarElement,
  Title as ChartTitle,
  Tooltip,
  Legend,
  ArcElement,
  type ChartEvent,
  type ActiveElement,
  type TooltipItem
} from 'chart.js';
import type { ChartData, ChartOptions } from 'chart.js';
import apiClient from '../../../api/apiClient';

ChartJS.register(
  CategoryScale,
  LinearScale,
  BarElement,
  ChartTitle,
  Tooltip,
  Legend,
  ArcElement
);

interface DashboardData {
  financials: { totalRevenue: number; totalCosts: number; netProfit: number; };
  incidents: { openIncidents: number; resolvedThisMonth: number; avgResolutionTimeHours: number | null; };
  topClientsByProfit: { 
    clientId: string; 
    clientName: string; 
    netProfit: number;
    totalRevenue: number;
    totalCosts: number;
  }[];
  topProductsByCost: { productId: string; productName: string; totalCost: number; }[];
  // ‚úÖ 1. Actualizar la interfaz para incluir los nuevos datos
  teamPerformance: {
    technicianId: string;
    technicianName: string;
    completedVisits: number;
    completedTasks: number;
  }[];
}

const formatCurrency = (amount: number) => {
  return new Intl.NumberFormat('es-ES', { style: 'currency', currency: 'EUR' }).format(amount);
};

export function ManagerDashboard() {
  const [data, setData] = useState<DashboardData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const navigate = useNavigate();

  const [dateRange, setDateRange] = useState<DatesRangeValue>([
    subDays(new Date(), 30),
    endOfDay(new Date()),
  ]);
  
  useEffect(() => {
    const fetchData = async () => {
      const [startDateValue, endDateValue] = dateRange;
      if (!startDateValue || !endDateValue) return;

      setIsLoading(true);
      try {
        const startDate = new Date(startDateValue);
        const endDate = new Date(endDateValue);
        
        const response = await apiClient.get<{ success: boolean; data: DashboardData }>('/dashboard/manager', {
          params: {
            startDate: startDate.toISOString(),
            endDate: endDate.toISOString()
          }
        });
        setData(response.data.data);
      } catch (err) {
        setError('No se pudieron cargar los datos del dashboard.');
        console.error(err);
      } finally {
        setIsLoading(false);
      }
    };
    fetchData();
  }, [dateRange]);

  if (isLoading) return <Center style={{ height: '100%' }}><Loader size="xl" /></Center>;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;
  if (!data) return <Alert color="yellow">No hay datos disponibles para mostrar.</Alert>;
  
  const profitMargin = data.financials.totalRevenue > 0 ? (data.financials.netProfit / data.financials.totalRevenue) * 100 : 0;
  
  const handleProductChartClick = (_event: ChartEvent, elements: ActiveElement[]) => {
    const element = elements[0];
    if (element && data) {
      const elementIndex = element.index;
      const product = data.topProductsByCost[elementIndex];
      if (product) {
        navigate(`/reports/consumption?productId=${product.productId}`);
      }
    }
  };


  const topProductsChartData: ChartData<'doughnut'> = {
    labels: data.topProductsByCost.map(p => p.productName),
    datasets: [{
      label: 'Coste Total',
      data: data.topProductsByCost.map(p => p.totalCost),
      backgroundColor: ['rgba(255, 99, 132, 0.5)','rgba(54, 162, 235, 0.5)','rgba(255, 206, 86, 0.5)','rgba(75, 192, 192, 0.5)','rgba(153, 102, 255, 0.5)'],
    }]
  };
  
  const topProductsChartOptions: ChartOptions<'doughnut'> = {
    responsive: true, maintainAspectRatio: false, onClick: handleProductChartClick,
    plugins: { legend: { position: 'right' } }
  };

  const topClientsChartData: ChartData<'bar'> = {
    labels: data.topClientsByProfit.map(c => c.clientName),
    datasets: [{
      label: 'Beneficio Neto',
      data: data.topClientsByProfit.map(c => c.netProfit),
      backgroundColor: 'rgba(75, 192, 192, 0.5)', borderColor: 'rgba(75, 192, 192, 1)', borderWidth: 1,
    }]
  };

  const topClientsChartOptions: ChartOptions<'bar'> = {
    indexAxis: 'y', responsive: true, maintainAspectRatio: false,
    onClick: (_, elements) => {
        const element = elements[0];
        if (element && data?.topClientsByProfit) {
            const client = data.topClientsByProfit[element.index];
            if (client) navigate(`/clients/${client.clientId}`);
        }
    },
    plugins: {
        legend: { display: false },
        title: { display: true, text: 'Beneficio Neto en el Periodo' },
        tooltip: {
          callbacks: {
            label: function(context: TooltipItem<'bar'>) {
              const clientData = data.topClientsByProfit[context.dataIndex];
              if (!clientData) return '';
              const margin = clientData.totalRevenue > 0 ? (clientData.netProfit / clientData.totalRevenue) * 100 : 0;
              return [
                `Beneficio: ${formatCurrency(clientData.netProfit)}`,
                `  Ingresos: ${formatCurrency(clientData.totalRevenue)}`,
                `  Costes: ${formatCurrency(clientData.totalCosts)}`,
                `  Margen: ${margin.toFixed(1)}%`
              ];
            }
          }
        }
    }
  };

  // ‚úÖ 2. Definir datos y opciones para el nuevo gr√°fico
  const teamPerformanceChartData: ChartData<'bar'> = {
    labels: data.teamPerformance.map(t => t.technicianName),
    datasets: [
      {
        label: 'Visitas Completadas',
        data: data.teamPerformance.map(t => t.completedVisits),
        backgroundColor: 'rgba(54, 162, 235, 0.5)',
      },
      {
        label: 'Tareas Resueltas',
        data: data.teamPerformance.map(t => t.completedTasks),
        backgroundColor: 'rgba(255, 159, 64, 0.5)',
      }
    ]
  };

  const teamPerformanceChartOptions: ChartOptions<'bar'> = {
    responsive: true, maintainAspectRatio: false,
    scales: { x: { stacked: true }, y: { stacked: true } },
    onClick: (_, elements) => {
        const element = elements[0];
        if (element && data?.teamPerformance) {
            const tech = data.teamPerformance[element.index];
            if (tech) {
              // TODO: Navegar a una futura p√°gina de detalle de t√©cnico
              console.log("Clicked on technician:", tech.technicianId);
            }
        }
    },
    plugins: {
      title: { display: true, text: 'Productividad por T√©cnico en el Periodo' }
    }
  };

  return (
    <Container fluid>
      <Title order={2} mb="xl">Dashboard de Gerencia</Title>
      
      <Paper withBorder p="md" shadow="sm" mb="xl">
        <DatePickerInput
          type="range" label="Seleccione el Periodo de An√°lisis" placeholder="Inicio - Fin"
          value={dateRange} onChange={setDateRange} locale="es" maw={400}
        />
      </Paper>

      <Grid>
        <Grid.Col span={{ base: 12, md: 6, lg: 4 }}>
          <Anchor component={Link} to="/reports/invoicing" underline="never">
            <Paper withBorder p="md" shadow="sm" h="100%">
              <Title order={4} mb="md">Salud Financiera (Periodo)</Title>
              <Group justify="space-around" align="center">
                  <RingProgress size={140} thickness={14} roundCaps
                      label={<Text c="blue" fw={700} ta="center" size="xl">{profitMargin.toFixed(1)}%</Text>}
                      sections={[{ value: profitMargin, color: 'blue' }]} />
                  <Stack gap="xs">
                      <Text>Ingresos: {formatCurrency(data.financials.totalRevenue)}</Text>
                      <Text>Costes: {formatCurrency(data.financials.totalCosts)}</Text>
                      <Text fw={700}>Beneficio: {formatCurrency(data.financials.netProfit)}</Text>
                  </Stack>
              </Group>
            </Paper>
          </Anchor>
        </Grid.Col>

        <Grid.Col span={{ base: 12, md: 6, lg: 4 }}>
          <Paper withBorder p="md" shadow="sm" h="100%">
            <Title order={4} mb="md">Estado de Incidencias</Title>
            <Group justify="space-around" align="flex-end" h="80%">
                <Anchor component={Link} to="/incidents-history?status=PENDING" underline="never">
                  <Stack align="center" gap={0} style={{ cursor: 'pointer' }}>
                      <Text size="3rem" fw={700} c="orange">{data.incidents.openIncidents}</Text>
                      <Badge color="orange" variant="light" size="lg">Abiertas (Total)</Badge>
                  </Stack>
                </Anchor>
                <Stack align="center" gap={0}>
                    <Text size="3rem" fw={700} c="green">{data.incidents.resolvedThisMonth}</Text>
                    <Text c="dimmed">Resueltas (Periodo)</Text>
                </Stack>
            </Group>
          </Paper>
        </Grid.Col>

        <Grid.Col span={{ base: 12, lg: 4 }}>
          <Paper withBorder p="md" shadow="sm" h="100%">
            <Title order={4} mb="md">Top 5 Productos por Coste (Periodo)</Title>
            <Center style={{maxHeight: 250}}>
                <Doughnut data={topProductsChartData} options={topProductsChartOptions} />
            </Center>
          </Paper>
        </Grid.Col>

        <Grid.Col span={{ base: 12, md: 7 }}>
          <Paper withBorder p="md" shadow="sm" h="100%">
            <Title order={4} mb="md">Top 5 Clientes por Rentabilidad (Periodo)</Title>
            <div style={{ height: '300px' }}>
                <Bar data={topClientsChartData} options={topClientsChartOptions} />
            </div>
          </Paper>
        </Grid.Col>
        
        {/* ‚úÖ 3. A√±adir el nuevo widget al layout */}
        <Grid.Col span={{ base: 12, md: 5 }}>
          <Paper withBorder p="md" shadow="sm" h="100%">
             <Title order={4} mb="md">Rendimiento del Equipo</Title>
             <div style={{ height: '300px' }}>
                <Bar data={teamPerformanceChartData} options={teamPerformanceChartOptions} />
            </div>
          </Paper>
        </Grid.Col>
      </Grid>
    </Container>
  );
}


// ====== [33] packages/client/src/features/superadmin/pages/TenantsPage.tsx ======
import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Badge,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  PasswordInput,
  Menu,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient.js';

// --- Tipos ---
type SubscriptionStatus = 'TRIAL' | 'ACTIVE' | 'PAYMENT_PENDING' | 'INACTIVE';

interface Tenant {
  id: string;
  companyName: string;
  subdomain: string;
  subscriptionStatus: SubscriptionStatus;
  createdAt: string;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function TenantsPage() {
  const [tenants, setTenants] = useState<Tenant[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);

  const form = useForm({
    initialValues: {
      companyName: '',
      subdomain: '',
      adminUser: {
        name: '',
        email: '',
        password: '',
      },
    },
    validate: {
      companyName: (value: string) => (value.length < 2 ? 'El nombre debe tener al menos 2 caracteres' : null),
      subdomain: (value: string) => (/^[a-z0-9]+(?:-[a-z0-9]+)*$/.test(value) ? null : 'Subdominio inv√°lido'),
      adminUser: {
        email: (value: string) => (/^\S+@\S+$/.test(value) ? null : 'Email inv√°lido'),
        password: (value: string) => (value.length < 8 ? 'La contrase√±a debe tener al menos 8 caracteres' : null),
      },
    },
  });

  const fetchTenants = async () => {
    if (tenants.length === 0) setIsLoading(true);
    setError(null);
    try {
      const response = await apiClient.get<ApiResponse<Tenant[]>>('/tenants');
      setTenants(response.data.data);
    } catch (err) {
      setError('No se pudo obtener la lista de tenants.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchTenants();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handleCreateTenant = async (values: typeof form.values) => {
    try {
      await apiClient.post<ApiResponse<Tenant>>('/tenants', values);
      await fetchTenants();
      closeModal();
      form.reset();
    } catch (err: any) {
      form.setErrors({ companyName: err.response?.data?.message || 'Error al crear el tenant' });
    }
  };

  const handleUpdateStatus = async (tenantId: string, status: SubscriptionStatus) => {
    try {
      setTenants((current) =>
        current.map((t) => (t.id === tenantId ? { ...t, subscriptionStatus: status } : t))
      );
      await apiClient.patch(`/tenants/${tenantId}/status`, { status });
    } catch (err) {
      console.error('Failed to update tenant status', err);
      await fetchTenants();
    }
  };

  const handleDeleteTenant = async (tenantId: string) => {
    if (window.confirm('¬øEst√°s seguro? Esta acci√≥n eliminar√° el tenant y todos sus datos (usuarios, clientes, piscinas, etc.) de forma irreversible.')) {
      try {
        await apiClient.delete(`/tenants/${tenantId}`);
        setTenants((current) => current.filter((t) => t.id !== tenantId));
      } catch (err) {
        console.error('Failed to delete tenant', err);
        // TODO: Mostrar notificaci√≥n de error al usuario
      }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = tenants.map((tenant) => (
    <Table.Tr key={tenant.id}>
      <Table.Td>{tenant.companyName}</Table.Td>
      <Table.Td>{tenant.subdomain}.pool-control.pro</Table.Td>
      <Table.Td>
        <Badge
          color={
            {
              ACTIVE: 'green',
              TRIAL: 'blue',
              PAYMENT_PENDING: 'orange',
              INACTIVE: 'gray',
            }[tenant.subscriptionStatus]
          }
        >
          {tenant.subscriptionStatus}
        </Badge>
      </Table.Td>
      <Table.Td>{new Date(tenant.createdAt).toLocaleDateString()}</Table.Td>
      <Table.Td>
        <Menu shadow="md" width={200}>
          <Menu.Target>
            <Button variant="outline" size="xs">Acciones</Button>
          </Menu.Target>
          <Menu.Dropdown>
            <Menu.Label>Cambiar estado</Menu.Label>
            <Menu.Item onClick={() => handleUpdateStatus(tenant.id, 'ACTIVE')}>Activar</Menu.Item>
            <Menu.Item onClick={() => handleUpdateStatus(tenant.id, 'TRIAL')}>Poner en Trial</Menu.Item>
            <Menu.Item onClick={() => handleUpdateStatus(tenant.id, 'PAYMENT_PENDING')}>Pago Pendiente</Menu.Item>
            <Menu.Item onClick={() => handleUpdateStatus(tenant.id, 'INACTIVE')}>Desactivar</Menu.Item>
            <Menu.Divider />
            <Menu.Label>Zona de Peligro</Menu.Label>
            <Menu.Item color="red" onClick={() => handleDeleteTenant(tenant.id)}>
              Eliminar Tenant
            </Menu.Item>
          </Menu.Dropdown>
        </Menu>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal opened={modalOpened} onClose={closeModal} title="Crear Nuevo Tenant" centered>
        <form onSubmit={form.onSubmit(handleCreateTenant)}>
          <Stack>
            <TextInput required label="Nombre de la Empresa" placeholder="Ej. Piscinas Mart√≠nez" {...form.getInputProps('companyName')} />
            <TextInput required label="Subdominio" placeholder="ej. martinez" {...form.getInputProps('subdomain')} />
            <Title order={4} mt="md">Usuario Administrador</Title>
            <TextInput required label="Nombre del Admin" placeholder="Ej. Juan Mart√≠nez" {...form.getInputProps('adminUser.name')} />
            <TextInput required label="Email del Admin" placeholder="ej. juan@piscinasmartinez.com" {...form.getInputProps('adminUser.email')} />
            <PasswordInput required label="Contrase√±a del Admin" {...form.getInputProps('adminUser.password')} />
            <Button type="submit" mt="md">Crear Tenant</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Gesti√≥n de Tenants</Title>
          <Button onClick={openModal}>Crear Nuevo Tenant</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Empresa</Table.Th>
              <Table.Th>Subdominio</Table.Th>
              <Table.Th>Estado</Table.Th>
              <Table.Th>Fecha de Creaci√≥n</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={5}>No hay tenants creados.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [34] packages/client/src/features/technician/pages/MyRoutePage.tsx ======
// filename: packages/client/src/features/technician/pages/MyRoutePage.tsx
// Version: 1.2.1 (FIXED - Decouple from @prisma/client)
import { useEffect, useState } from 'react';
import { Link, useLocation } from 'react-router-dom';
import {
  Container,
  Title,
  Loader,
  Alert,
  Stack,
  Card,
  Text,
  Group,
  Anchor,
  ThemeIcon,
  Badge,
  Divider,
} from '@mantine/core';
import apiClient from '../../../api/apiClient';

// --- Tipos del Frontend ---
// Definimos los tipos aqu√≠, bas√°ndonos en lo que esperamos de la API,
// sin acoplar el frontend al backend.
type IncidentPriority = 'LOW' | 'NORMAL' | 'HIGH' | 'CRITICAL';

interface Visit {
  id: string;
  timestamp: string;
  pool: {
    id: string;
    name: string;
    address: string;
    client: { name: string; };
  };
}

interface AssignedTask {
  id: string;
  title: string;
  priority: IncidentPriority;
  notification: {
    id: string;
    visit: {
      pool: { name: string; };
    } | null;
  };
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function MyRoutePage() {
  const [visits, setVisits] = useState<Visit[]>([]);
  const [tasks, setTasks] = useState<AssignedTask[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const location = useLocation();

  const fetchData = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const [visitsResponse, tasksResponse] = await Promise.all([
        apiClient.get<ApiResponse<Visit[]>>('/visits/my-route'),
        apiClient.get<ApiResponse<AssignedTask[]>>('/incident-tasks/my-tasks'),
      ]);
      setVisits(visitsResponse.data.data);
      setTasks(tasksResponse.data.data);
    } catch (err) {
      setError('No se pudo cargar tu trabajo del d√≠a.');
      console.error(err);
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchData();
  }, [location.key]);

  if (isLoading) {
    return (
      <Container style={{ textAlign: 'center', paddingTop: '50px' }}>
        <Loader size="xl" />
        <Text mt="md">Cargando tu trabajo del d√≠a...</Text>
      </Container>
    );
  }

  if (error) {
    return <Alert color="red" title="Error">{error}</Alert>;
  }

  const taskCards = tasks.map((task) => (
    <Card key={task.id} shadow="sm" padding="lg" radius="md" withBorder>
      <Link to={`/incidents/${task.notification.id}`} style={{ textDecoration: 'none', color: 'inherit' }}>
        <Group justify="space-between" mb="xs">
          <Text fw={500} size="lg">{task.title}</Text>
          <Badge color={task.priority === 'HIGH' || task.priority === 'CRITICAL' ? 'red' : 'orange'}>
            {task.priority}
          </Badge>
        </Group>
        <Text size="sm" c="dimmed">
          Incidencia en: {task.notification.visit?.pool.name || 'Piscina no especificada'}
        </Text>
      </Link>
    </Card>
  ));

  const visitCards = visits.map((visit) => (
    <Card key={visit.id} shadow="sm" padding="lg" radius="md" withBorder>
      <Link to={`/visits/${visit.id}`} style={{ textDecoration: 'none', color: 'inherit' }}>
        <Group justify="space-between" mb="xs">
          <Text fw={500} size="lg">{visit.pool.name}</Text>
          <ThemeIcon variant="light" radius="md" size="lg"><span>üìç</span></ThemeIcon>
        </Group>
        <Text size="sm" c="dimmed">Cliente: {visit.pool.client.name}</Text>
      </Link>
      <Anchor href={`https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(visit.pool.address)}`} target="_blank" rel="noopener noreferrer" size="sm" mt="sm">
        {visit.pool.address}
      </Anchor>
    </Card>
  ));

  return (
    <Container>
      <Title order={2} my="lg">Mi Trabajo de Hoy</Title>
      
      <Stack gap="xl">
        {tasks.length > 0 && (
          <Stack>
            <Title order={4} c="orange.7">Tareas Especiales</Title>
            {taskCards}
          </Stack>
        )}

        {visits.length > 0 && tasks.length > 0 && <Divider my="md" />}
        
        {visits.length > 0 && (
          <Stack>
            <Title order={4}>Visitas Programadas</Title>
            {visitCards}
          </Stack>
        )}

        {visits.length === 0 && tasks.length === 0 && (
          <Text>No tienes trabajo asignado para hoy.</Text>
        )}
      </Stack>
    </Container>
  );
}


// ====== [35] packages/client/src/features/technician/pages/WorkOrderPage.tsx ======
// filename: packages/client/src/features/technician/pages/WorkOrderPage.tsx
// version: 2.0.2 (REFACTOR: Remove redundant incident management modals)

import { useEffect, useState } from 'react';
import { useParams, Link, useNavigate } from 'react-router-dom';
import {
  Container,
  Title,
  Loader,
  Alert,
  Paper,
  Text,
  Breadcrumbs,
  Button,
  Stack,
  Checkbox,
  NumberInput,
  Switch,
  TextInput,
  Select,
  Textarea,
  Badge,
  Grid,
  Modal,
  Group,
  Divider,
  ActionIcon,
  FileInput,
  Progress,
  ThemeIcon,
  SimpleGrid,
  Image,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient';
import axios from 'axios';

// --- Tipos ---
type IncidentPriority = 'LOW' | 'NORMAL' | 'HIGH' | 'CRITICAL';

interface IncidentImage {
  id: string;
  url: string;
}

interface Notification {
    id: string;
    status: 'PENDING' | 'RESOLVED';
    resolutionNotes: string | null;
    priority: IncidentPriority | null;
    resolutionDeadline: string | null;
    images: IncidentImage[];
}

interface VisitResult { parameterName: string; parameterUnit: string | null; value: string; }
interface Product { id: string; name: string; unit: string; }
interface Consumption { quantity: number; product: Product; }
interface VisitDetails {
  id: string; status: 'PENDING' | 'COMPLETED' | 'CANCELLED'; notes: string | null; hasIncident: boolean;
  completedTasks: string[]; results: VisitResult[]; notifications: Notification[]; consumptions: Consumption[];
  pool: {
    name: string; address: string; client: { name: string };
    configurations: {
      id: string;
      parameterTemplate?: { id: string; name: string; unit: string | null; type: 'NUMBER' | 'BOOLEAN' | 'TEXT' | 'SELECT'; selectOptions: string[]; };
      taskTemplate?: { id: string; name: string; };
    }[];
  };
}
interface ApiResponse<T> { success: boolean; data: T; }

// --- Componente de Solo Lectura (para el Admin) ---
const ReadOnlyWorkOrder = ({ visit }: { visit: VisitDetails }) => {
  const [imageModalOpened, { open: openImageModal, close: closeImageModal }] = useDisclosure(false);
  const [selectedImage, setSelectedImage] = useState<string | null>(null);

  const incidentNotification = visit.notifications.length > 0 ? visit.notifications[0] : null;

  const handleImageClick = (url: string) => {
    setSelectedImage(url);
    openImageModal();
  };

  return (
    <>
      <Modal opened={imageModalOpened} onClose={closeImageModal} title="Imagen de la Incidencia" centered size="xl">
        {selectedImage && <Image src={selectedImage} />}
      </Modal>

      <Container>
          <Breadcrumbs><Link to="/">Dashboard</Link><Text>{visit.pool.name}</Text></Breadcrumbs>
          <Grid align="center" justify="space-between" my="lg"><Grid.Col span="auto"><Title order={2}>Resumen de Visita: {visit.pool.name}</Title></Grid.Col><Grid.Col span="content"><Badge color="green" size="lg">COMPLETADA</Badge></Grid.Col></Grid>
          <Text c="dimmed">{visit.pool.client.name} - {visit.pool.address}</Text>

          <Paper withBorder p="md" mt="xl">
              <Stack>
                  {visit.results.length > 0 && (<div><Title order={4} mb="sm">Resultados de Mediciones</Title>{visit.results.map(r => <Text key={r.parameterName}><strong>{r.parameterName}:</strong> {r.value} {r.parameterUnit || ''}</Text>)}</div>)}
                  {visit.completedTasks.length > 0 && (<div><Title order={4} mt="lg" mb="sm">Tareas Realizadas</Title>{visit.completedTasks.map(t => <Text key={t}>‚úÖ {t}</Text>)}</div>)}
                  {visit.consumptions.length > 0 && (<div><Title order={4} mt="lg" mb="sm">Productos Consumidos</Title>{visit.consumptions.map(c => <Text key={c.product.id}>- {c.quantity} {c.product.unit} de {c.product.name}</Text>)}</div>)}
                  <Divider my="sm" />
                  <div>
                      <Title order={4}>Observaciones e Incidencia</Title>
                      <Text fw={500} mt="sm">Notas del T√©cnico:</Text>
                      <Paper withBorder p="sm" bg="gray.0" mt="xs"><Text>{visit.notes || 'No se dejaron notas.'}</Text></Paper>
                      
                      {incidentNotification && incidentNotification.images.length > 0 && (
                        <>
                          <Text fw={500} mt="lg">Im√°genes Adjuntas:</Text>
                          <SimpleGrid cols={{ base: 2, sm: 3, lg: 4 }} mt="xs">
                            {incidentNotification.images.map(image => (
                              <Paper key={image.id} withBorder radius="md" style={{ cursor: 'pointer' }} onClick={() => handleImageClick(image.url)}>
                                <Image src={image.url} height={120} radius="md" />
                              </Paper>
                            ))}
                          </SimpleGrid>
                        </>
                      )}

                      {visit.hasIncident && incidentNotification && (
                        <Paper withBorder p="sm" mt="md" shadow="xs" bg={incidentNotification.status === 'RESOLVED' ? 'gray.0' : 'yellow.0'}>
                            {incidentNotification.status === 'RESOLVED' ? (
                                <Stack mt="md" gap="xs">
                                  <Badge color="green" size="lg">INCIDENCIA RESUELTA</Badge>
                                  <Text fw={500} mt="sm">Notas de Resoluci√≥n (Admin):</Text>
                                  <Paper withBorder p="sm" bg="green.0" mt="xs"><Text>{incidentNotification.resolutionNotes}</Text></Paper>
                                </Stack>
                            ) : (
                                <Group>
                                  <Badge color="red" size="lg" variant="filled">INCIDENCIA PENDIENTE</Badge>
                                  <Button 
                                    component={Link} 
                                    to={`/incidents/${incidentNotification.id}`}
                                    variant="light"
                                  >
                                    Gestionar Incidencia ‚Üí
                                  </Button>
                                </Group>
                            )}
                        </Paper>
                      )}
                  </div>
              </Stack>
          </Paper>
        </Container>
    </>
  );
};


// --- Componente de Formulario Editable (para el T√©cnico) ---
// (Este componente no ha sido modificado)
interface UploadedFile { file: File; progress: number; url?: string; error?: string; }
const EditableWorkOrder = ({ visit, products, onSubmit }: { visit: VisitDetails; products: Product[], onSubmit: (values: any) => Promise<void> }) => {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [uploadedFiles, setUploadedFiles] = useState<UploadedFile[]>([]);

  const form = useForm({
    initialValues: {
      results: visit.pool.configurations.filter(c => c.parameterTemplate).reduce((acc, c) => ({ ...acc, [c.id]: '' }), {}),
      completedTasks: visit.pool.configurations.filter(c => c.taskTemplate).reduce((acc, c) => ({ ...acc, [c.id]: false }), {}),
      consumptions: [] as { productId: string; quantity: number | '' }[],
      notes: '',
      hasIncident: false,
    },
  });

  const handleImageUpload = async (files: File[]) => {
    if (!files || files.length === 0) return;
    const newFiles = files.map(file => ({ file, progress: 0 }));
    setUploadedFiles(prev => [...prev, ...newFiles]);

    try {
      const { data: signatureData } = await apiClient.get('/uploads/signature');
      const { signature, timestamp, apiKey, cloudName } = signatureData.data;

      for (const fileObj of newFiles) {
        const formData = new FormData();
        formData.append('file', fileObj.file);
        formData.append('signature', signature);
        formData.append('timestamp', timestamp);
        formData.append('api_key', apiKey);

        try {
          const response = await axios.post(
            `https://api.cloudinary.com/v1_1/${cloudName}/image/upload`,
            formData,
            { onUploadProgress: (event) => {
                const progress = event.total ? Math.round((100 * event.loaded) / event.total) : 0;
                setUploadedFiles(prev => prev.map(f => f.file === fileObj.file ? { ...f, progress } : f));
            }}
          );
          setUploadedFiles(prev => prev.map(f => f.file === fileObj.file ? { ...f, url: response.data.secure_url } : f));
        } catch (uploadError) {
          setUploadedFiles(prev => prev.map(f => f.file === fileObj.file ? { ...f, error: 'Error al subir' } : f));
        }
      }
    } catch (signatureError) {
      console.error("Error al obtener la firma", signatureError);
    }
  };

  const handleSubmit = async (values: typeof form.values) => {
    setIsSubmitting(true);
    const successfulUrls = uploadedFiles.filter(f => f.url).map(f => f.url!);
    const payload = { ...values, imageUrls: successfulUrls };
    await onSubmit(payload);
    setIsSubmitting(false);
  };
  
  const productOptions = products.map(p => ({ value: p.id, label: `${p.name} (${p.unit})` }));
  const consumptionFields = form.values.consumptions.map((_, index) => <Grid key={index} align="flex-end"><Grid.Col span={7}><Select label={index === 0 ? 'Producto' : ''} placeholder="Seleccione un producto" data={productOptions} {...form.getInputProps(`consumptions.${index}.productId`)} required /></Grid.Col><Grid.Col span={3}><NumberInput label={index === 0 ? 'Cantidad' : ''} placeholder="0.0" min={0} decimalScale={2} {...form.getInputProps(`consumptions.${index}.quantity`)} required /></Grid.Col><Grid.Col span={2}><ActionIcon color="red" onClick={() => form.removeListItem('consumptions', index)}>üóëÔ∏è</ActionIcon></Grid.Col></Grid>);
  const parametersToMeasure = visit.pool.configurations.filter(c => c.parameterTemplate);
  const tasksToComplete = visit.pool.configurations.filter(c => c.taskTemplate);
  const renderParameterInput = (config: typeof parametersToMeasure[0]) => { const param = config.parameterTemplate; if (!param) return null; const label = `${param.name}${param.unit ? ` (${param.unit})` : ''}`; switch (param.type) { case 'NUMBER': return <NumberInput label={label} {...form.getInputProps(`results.${config.id}`)} />; case 'BOOLEAN': return <Switch mt="md" label={label} {...form.getInputProps(`results.${config.id}`, { type: 'checkbox' })} />; case 'TEXT': return <TextInput label={label} {...form.getInputProps(`results.${config.id}`)} />; case 'SELECT': return <Select label={label} data={param.selectOptions} {...form.getInputProps(`results.${config.id}`)} />; default: return <Text c="red">Tipo no soportado: {param.type}</Text>; } };

  return (
      <Container>
        <Breadcrumbs><Link to="/my-route">Mi Ruta</Link><Text>{visit.pool.name}</Text></Breadcrumbs>
        <Title order={2} my="lg">Parte de Trabajo: {visit.pool.name}</Title>
        <Text c="dimmed">{visit.pool.client.name} - {visit.pool.address}</Text>
        <Paper withBorder p="md" mt="xl">
          <form onSubmit={form.onSubmit(handleSubmit)}>
            <Stack>
              {parametersToMeasure.length > 0 && (<div><Title order={4} mb="sm">Mediciones</Title><Stack>{parametersToMeasure.map(p => <div key={p.id}>{renderParameterInput(p)}</div>)}</Stack></div>)}
              {tasksToComplete.length > 0 && (<div><Title order={4} mt="lg" mb="sm">Tareas</Title><Stack>{tasksToComplete.map(t => <Checkbox key={t.id} label={t.taskTemplate?.name} {...form.getInputProps(`completedTasks.${t.id}`, { type: 'checkbox' })} />)}</Stack></div>)}
              <Divider my="md" label="Consumo de Productos" labelPosition="center" />
              {consumptionFields}
              <Button mt="xs" variant="outline" onClick={() => form.insertListItem('consumptions', { productId: '', quantity: '' })}>+ A√±adir Producto</Button>
              <Divider my="md" />
              <Title order={4} mb="sm">Observaciones e Incidencias</Title>
              <Textarea label="Notas de la visita" placeholder="Cualquier observaci√≥n relevante..." {...form.getInputProps('notes')} />
              <Checkbox label="Reportar como Incidencia" description="Marcar si hay un problema para el administrador." {...form.getInputProps('hasIncident', { type: 'checkbox' })} />
              
              {form.values.hasIncident && (
                <Stack mt="sm" gap="xs">
                  <FileInput label="Adjuntar Fotos" placeholder="Seleccionar im√°genes..." multiple accept="image/png,image/jpeg" onChange={handleImageUpload} />
                  {uploadedFiles.length > 0 && (
                    <Stack gap="xs">
                      {uploadedFiles.map((fileObj, index) => (
                        <Paper key={index} withBorder p="xs" radius="sm">
                          <Group justify="space-between">
                            <Text size="sm" truncate style={{flex: 1}}>{fileObj.file.name}</Text>
                            {fileObj.progress < 100 && !fileObj.error && <Progress value={fileObj.progress} striped animated size="lg" style={{width: '100px'}} />}
                            {fileObj.url && <ThemeIcon color="green" variant="light">‚úì</ThemeIcon>}
                            {fileObj.error && <ThemeIcon color="red" variant="light">‚úó</ThemeIcon>}
                          </Group>
                        </Paper>
                      ))}
                    </Stack>
                  )}
                </Stack>
              )}
              
              <Button type="submit" mt="xl" size="lg" loading={isSubmitting}>Guardar y Finalizar Visita</Button>
            </Stack>
          </form>
        </Paper>
      </Container>
  );
};


// --- Componente Principal ---
export function WorkOrderPage() {
  const { visitId } = useParams<{ visitId: string }>();
  const navigate = useNavigate();
  const [visit, setVisit] = useState<VisitDetails | null>(null); // <-- L√çNEA CORREGIDA
  const [products, setProducts] = useState<Product[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!visitId) { setError('No se ha proporcionado un ID de visita.'); setIsLoading(false); return; }
    
    const fetchAllData = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const [visitResponse, productsResponse] = await Promise.all([
          apiClient.get<ApiResponse<VisitDetails>>(`/visits/${visitId}`),
          apiClient.get<ApiResponse<Product[]>>('/products')
        ]);
        setVisit(visitResponse.data.data);
        setProducts(productsResponse.data.data);
      } catch (err) { setError('No se pudo cargar la informaci√≥n de la visita o los productos.'); } finally { setIsLoading(false); }
    };
    fetchAllData();
  }, [visitId]);

  const handleSubmit = async (values: any) => {
    if (!visitId) return;
    try {
      await apiClient.post(`/visits/${visitId}/complete`, values);
      navigate('/my-route');
    } catch (err) { console.error('Error submitting work order', err); }
  };

  if (isLoading) return <Container style={{ textAlign: 'center', paddingTop: '50px' }}><Loader size="xl" /></Container>;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;
  if (!visit) return <Alert color="yellow" title="Aviso">Visita no encontrada.</Alert>;
  
  if (visit.status === 'COMPLETED') {
    return <ReadOnlyWorkOrder visit={visit} />;
  }
  
  return <EditableWorkOrder visit={visit} products={products} onSubmit={handleSubmit} />;
}


// ====== [36] packages/client/src/main.tsx ======
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.js';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


// ====== [37] packages/client/src/providers/AuthProvider.tsx ======
// filename: packages/client/src/providers/AuthProvider.tsx
// version: 2.1.0 (FEAT: Synchronize with Zustand store)

import {
  createContext,
  useContext,
  useState,
  useEffect,
  useCallback,
  useMemo,
} from 'react';
import type { PropsWithChildren } from 'react';
import apiClient from '../api/apiClient.js';
// --- ‚úÖ 1. IMPORTAR EL HOOK DEL STORE ---
import { useAuthStore } from '../stores/auth.store.js';

// --- Tipos ---
type LoginCredentials = {
  email: string;
  password: string;
};

interface User {
  id: string;
  name: string;
  email: string;
  role: 'SUPER_ADMIN' | 'ADMIN' | 'TECHNICIAN' | 'MANAGER';
}

export type ViewAsRole = 'MANAGER' | 'ADMIN' | 'TECHNICIAN';

interface AuthContextType {
  user: User | null;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => Promise<void>;
  isLoading: boolean;
  isAuthenticated: boolean;
  activeView: ViewAsRole;
  setViewAs: (role: ViewAsRole) => void;
  activeRole: User['role'] | null;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider = ({ children }: PropsWithChildren) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [activeView, setActiveView] = useState<ViewAsRole>('MANAGER');

  // --- ‚úÖ 2. OBTENER LA FUNCI√ìN PARA ACTUALIZAR EL STORE ---
  const setAuthStateInStore = useAuthStore((state) => state.setAuthState);

  // --- ‚úÖ 3. SINCRONIZAR EL ESTADO LOCAL CON EL STORE ---
  // Cada vez que el usuario o la vista activa cambien, actualizamos el store.
  useEffect(() => {
    setAuthStateInStore(user, activeView);
  }, [user, activeView, setAuthStateInStore]);


  const checkAuthStatus = useCallback(async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get('/auth/me');
      const loggedUser: User = response.data.data;
      setUser(loggedUser);
      if (loggedUser.role === 'ADMIN' || loggedUser.role === 'TECHNICIAN') {
        setActiveView(loggedUser.role);
      } else {
        setActiveView('MANAGER');
      }
    } catch (error) {
      setUser(null);
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    checkAuthStatus();
  }, [checkAuthStatus]);

  const login = async (credentials: LoginCredentials) => {
    const response = await apiClient.post('/auth/login', credentials);
    const loggedUser: User = response.data.data;
    setUser(loggedUser);
    if (loggedUser.role === 'ADMIN' || loggedUser.role === 'TECHNICIAN') {
      setActiveView(loggedUser.role);
    } else {
      setActiveView('MANAGER');
    }
  };

  const logout = async () => {
    await apiClient.post('/auth/logout');
    setUser(null);
  };

  const setViewAs = (role: ViewAsRole) => {
    if (user?.role === 'MANAGER') {
      setActiveView(role);
    }
  };

  const activeRole = useMemo(() => {
    if (!user) return null;
    if (user.role === 'MANAGER') {
      return activeView;
    }
    return user.role;
  }, [user, activeView]);


  const value: AuthContextType = {
    user,
    login,
    logout,
    isLoading,
    isAuthenticated: !!user,
    activeView,
    setViewAs,
    activeRole,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};


// ====== [38] packages/client/src/router/components.tsx ======
// filename: packages/client/src/router/components.tsx
// version: 2.6.2 (FEAT: Add AvailabilityPage to navigation)
// description: Se a√±ade el enlace a la nueva p√°gina de Gesti√≥n de Disponibilidad en el men√∫ de navegaci√≥n del ADMIN.

import { AppShell, Burger, Group, NavLink, Title, Button, Indicator, ActionIcon, Popover, Text, Stack, SegmentedControl } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { Navigate, Outlet, Link, useNavigate } from 'react-router-dom';
import { useAuth } from '../providers/AuthProvider.js';
import type { ViewAsRole } from '../providers/AuthProvider.js';
import { useEffect, useState } from 'react';
import apiClient from '../api/apiClient.js';

interface Notification {
  id: string;
  message: string;
  visitId: string | null;
  parentNotificationId: string | null;
  isRead: boolean;
}

const NotificationBell = () => {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [popoverOpened, setPopoverOpened] = useState(false);
  const navigate = useNavigate();

  const fetchNotifications = async () => {
    try {
      const response = await apiClient.get<{ success: boolean; data: Notification[] }>('/notifications');
      setNotifications(response.data.data);
    } catch (error) {
      console.error('Failed to fetch notifications', error);
    }
  };

  useEffect(() => {
    fetchNotifications();
    const interval = setInterval(fetchNotifications, 60000);
    return () => clearInterval(interval);
  }, []);

  const handleNotificationClick = async (notification: Notification) => {
    if (!notification.isRead) {
      setNotifications(current =>
        current.map(n =>
          n.id === notification.id ? { ...n, isRead: true } : n
        )
      );
      try {
        await apiClient.post(`/notifications/${notification.id}/read`);
      } catch (error) {
        console.error('Failed to mark notification as read', error);
        fetchNotifications();
      }
    }
    
    const incidentId = notification.parentNotificationId || notification.id;
    navigate(`/incidents/${incidentId}`);
    
    setPopoverOpened(false);
  };
  
  const hasUnread = notifications.some(n => !n.isRead);

  return (
    <Popover opened={popoverOpened} onChange={setPopoverOpened} width={300} position="bottom-end" withArrow shadow="md">
      <Popover.Target>
        <Indicator color="red" disabled={!hasUnread} withBorder processing>
          <ActionIcon variant="default" size="lg" onClick={() => setPopoverOpened((o) => !o)}>
            üîî
          </ActionIcon>
        </Indicator>
      </Popover.Target>

      <Popover.Dropdown>
           <Stack>
          <Text fw={500}>Notificaciones</Text>
          {notifications.length > 0 ? (
            notifications.map(notification => (
              <Text
                key={notification.id}
                size="sm"
                onClick={() => handleNotificationClick(notification)}
                style={{
                  cursor: 'pointer',
                  padding: '5px',
                  borderRadius: '4px',
                  fontWeight: notification.isRead ? 400 : 700,
                  color: notification.isRead ? 'gray' : 'black',
                }}
                onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#f1f3f5'}
                onMouseLeave={(e) => e.currentTarget.style.backgroundColor = 'transparent'}
              >
                {notification.message}
              </Text>
            ))
          ) : (
            <Text size="sm" c="dimmed">No hay notificaciones pendientes.</Text>
          )}
        </Stack>
      </Popover.Dropdown>
    </Popover>
  );
};

export const AppLayout = () => {
  const [opened, { toggle }] = useDisclosure();
  const { user, logout, activeView, setViewAs, activeRole } = useAuth();
  const navigate = useNavigate();
  
  const handleLogout = async () => {
    await logout();
    navigate('/login');
  };

  const handleViewChange = (value: string) => {
    const role = value as ViewAsRole;
    setViewAs(role);
    if (role === 'ADMIN' || role === 'MANAGER') navigate('/');
    if (role === 'TECHNICIAN') navigate('/my-route');
  };
  
  return (
    <AppShell
      header={{ height: 60 }}
      navbar={{ width: 300, breakpoint: 'sm', collapsed: { mobile: !opened } }}
      padding="md"
    >
      <AppShell.Header>
        <Group h="100%" px="md" justify="space-between">
          <Group>
            <Burger opened={opened} onClick={toggle} hiddenFrom="sm" size="sm" />
            <Title order={3}>Pool Control Pro</Title>
           </Group>
          <Group>
            {user?.role === 'MANAGER' && (
              <SegmentedControl
                value={activeView}
                onChange={handleViewChange}
                data={[
                   { label: 'Gerencia', value: 'MANAGER' },
                  { label: 'Admin', value: 'ADMIN' },
                  { label: 'T√©cnico', value: 'TECHNICIAN' },
                ]}
              />
            )}
            {activeRole === 'ADMIN' && <NotificationBell />}
            <Button variant="light" onClick={handleLogout}>Cerrar Sesi√≥n</Button>
          </Group>
        </Group>
      </AppShell.Header>

      <AppShell.Navbar p="md">
        {activeRole === 'MANAGER' && (
          <NavLink
           component={Link}
            to="/"
            label="Dashboard de Gerencia"
            onClick={toggle}
          />
        )}
        
        {activeRole === 'ADMIN' && (
          <>
            <NavLink component={Link} to="/" label="Dashboard de Admin" onClick={toggle} />
            
            <NavLink label="Planificaci√≥n" defaultOpened>
                <NavLink component={Link} to="/planning/zones" label="Gesti√≥n de Zonas" onClick={toggle}/>
                <NavLink component={Link} to="/planning/routes" label="Gesti√≥n de Rutas" onClick={toggle}/>
                {/* ‚úÖ NUEVO ENLACE A√ëADIDO */}
                <NavLink component={Link} to="/planning/availability" label="Gesti√≥n de Disponibilidad" onClick={toggle}/>
                <NavLink component={Link} to="/planner" label="Planificador" onClick={toggle} /> 
            </NavLink>

            <NavLink component={Link} to="/clients" label="Clientes" onClick={toggle} />
            <NavLink component={Link} to="/incidents-history" label="Gesti√≥n de Incidencias" onClick={toggle} />
            <NavLink label="Informes" defaultOpened>
                <NavLink component={Link} to="/reports/invoicing" label="Informe para Facturaci√≥n" onClick={toggle}/>
                <NavLink component={Link} to="/reports/consumption" label="Informe de Consumos" onClick={toggle}/>
             </NavLink>
            <NavLink label="Cat√°logos" defaultOpened>
              <NavLink component={Link} to="/catalog/parameters" label="Par√°metros" onClick={toggle} />
              <NavLink component={Link} to="/catalog/tasks" label="Tareas" onClick={toggle} />
              <NavLink component={Link} to="/catalog/products" label="Productos" onClick={toggle} />
              <NavLink component={Link} to="/catalog/product-categories" label="Categor√≠as de Productos" onClick={toggle} />
            </NavLink>
            <NavLink label="Finanzas" defaultOpened>
                <NavLink component={Link} to="/financials/payments" label="Pagos Recibidos" onClick={toggle} />
                <NavLink component={Link} to="/financials/expenses" label="Gastos Generales" onClick={toggle} />
            </NavLink>
          </>
         )}

        {activeRole === 'TECHNICIAN' && (
          <NavLink component={Link} to="/my-route" label="Mi Ruta de Hoy" onClick={toggle} />
        )}

        {user?.role === 'SUPER_ADMIN' && (
           <NavLink component={Link} to="/superadmin/tenants" label="Gesti√≥n de Tenants" onClick={toggle} />
        )}
      </AppShell.Navbar>

      <AppShell.Main>
        <Outlet />
      </AppShell.Main>
    </AppShell>
  );
};
export const ProtectedRoute = () => {
  const { isAuthenticated, isLoading } = useAuth();
  if (isLoading) return <div>Cargando...</div>;
  if (!isAuthenticated) return <Navigate to="/login" replace />;
  return <Outlet />;
};
export const SuperAdminRoute = () => {
  const { user, isLoading } = useAuth();
  if (isLoading) return <div>Cargando...</div>;
  if (user?.role !== 'SUPER_ADMIN') return <Navigate to="/" replace />;
  return <Outlet />;
};
export const AdminRoute = () => {
  const { activeRole, isLoading } = useAuth();
  if (isLoading) return <div>Cargando...</div>;
  if (activeRole !== 'ADMIN') {
    return <Navigate to="/" replace />;
  }
  return <Outlet />;
};
export const TechnicianRoute = () => {
  const { activeRole, isLoading } = useAuth();
  if (isLoading) return <div>Cargando...</div>;
  if (activeRole !== 'TECHNICIAN') {
    return <Navigate to="/" replace />;
  }
  return <Outlet />;
};
export const FinancialAdminRoute = () => {
    const { activeRole, isLoading } = useAuth();
    if (isLoading) return <div>Cargando...</div>;
    if (activeRole !== 'MANAGER' && activeRole !== 'ADMIN') {
      return <Navigate to="/" replace />;
    }
    return <Outlet />;
};


// ====== [39] packages/client/src/router/index.tsx ======
// filename: packages/client/src/router/index.tsx
// Version: 2.9.3 (FEAT: Add route for AvailabilityPage)
// description: Se importa y se a√±ade la ruta para la nueva p√°gina de Gesti√≥n de Disponibilidad.

import { createBrowserRouter } from 'react-router-dom';
import { LoginPage } from '../features/auth/pages/LoginPage.js';
import { TenantsPage } from '../features/superadmin/pages/TenantsPage.js';
import { ParameterCatalogPage } from '../features/admin/pages/ParameterCatalogPage.js';
import { TaskCatalogPage } from '../features/admin/pages/TaskCatalogPage.js';
import { ProductCatalogPage } from '../features/admin/pages/ProductCatalogPage.js';
import { ProductCategoryCatalogPage } from '../features/admin/pages/ProductCategoryCatalogPage.js';
import { ClientsPage } from '../features/admin/pages/clients/ClientsPage.js';
import { ClientDetailPage } from '../features/admin/pages/clients/ClientDetailPage.js';
import { PoolDetailPage } from '../features/admin/pages/pools/PoolDetailPage.js';
import { PlannerPage } from '../features/admin/pages/planner/PlannerPage.js';
import { ZoneManagementPage } from '../features/admin/pages/zones/ZoneManagementPage.js';
import { RouteTemplatesPage } from '../features/admin/pages/planning/RouteTemplatesPage.js';
import { RouteTemplateFormPage } from '../features/admin/pages/planning/RouteTemplateFormPage.js';
// ‚úÖ 1. Importar el nuevo componente de p√°gina
import { AvailabilityPage } from '../features/admin/pages/planning/AvailabilityPage.js';
import { MyRoutePage } from '../features/technician/pages/MyRoutePage.js';
import { WorkOrderPage } from '../features/technician/pages/WorkOrderPage.js';
import { AdminDashboard } from '../features/admin/pages/AdminDashboard.js';
import { IncidentsHistoryPage } from '../features/admin/pages/IncidentsHistoryPage.js';
import { IncidentDetailPage } from '../features/admin/pages/incidents/IncidentDetailPage.js';
import { ManagerDashboard } from '../features/manager/pages/ManagerDashboard.js';
import { InvoicingReportPage } from '../features/manager/pages/InvoicingReportPage.js';
import { ConsumptionReportPage } from '../features/admin/pages/reports/ConsumptionReportPage.js';
import { PaymentsPage } from '../features/financials/pages/PaymentsPage.js';
import { ExpensesPage } from '../features/financials/pages/ExpensesPage.js';
import { useAuth } from '../providers/AuthProvider.js';
import {
  AppLayout,
  ProtectedRoute,
  SuperAdminRoute,
  AdminRoute,
  TechnicianRoute,
  FinancialAdminRoute,
} from './components.js';

const RoleBasedDashboard = () => {
  const { activeRole, user } = useAuth();
  if (user?.role === 'SUPER_ADMIN') return <TenantsPage />;
  
  switch (activeRole) {
    case 'ADMIN': return <AdminDashboard />;
    case 'TECHNICIAN': return <MyRoutePage />;
    case 'MANAGER': return <ManagerDashboard />;
    default: return <div>Cargando...</div>;
  }
};

export const router = createBrowserRouter([
  {
    path: '/login',
    element: <LoginPage />,
  },
  {
    path: '/',
    element: <ProtectedRoute />,
    children: [
      {
        element: <AppLayout />,
        children: [
          { index: true, element: <RoleBasedDashboard /> },
          
          {
            path: 'planning',
            element: <AdminRoute />,
            children: [
              { path: 'zones', element: <ZoneManagementPage /> },
              { 
                path: 'routes', 
                children: [
                  { index: true, element: <RouteTemplatesPage /> },
                  { path: 'new', element: <RouteTemplateFormPage /> },
                  { path: ':id', element: <RouteTemplateFormPage /> },
                ]
              },
              // ‚úÖ 2. A√±adir la nueva ruta
              { path: 'availability', element: <AvailabilityPage /> },
            ]
          },
          
          {
            path: 'planner',
            element: <AdminRoute />,
            children: [ { index: true, element: <PlannerPage /> } ],
          },

          {
            path: 'clients',
            element: <AdminRoute />,
            children: [
               { index: true, element: <ClientsPage /> },
              { path: ':id', element: <ClientDetailPage /> },
            ],
          },
          {
            path: 'pools/:id', 
            element: <AdminRoute />,
             children: [ { index: true, element: <PoolDetailPage /> } ]
          },
          {
            path: 'incidents-history',
            element: <FinancialAdminRoute />,
            children: [ { index: true, element: <IncidentsHistoryPage /> } ],
          },
          {
            path: 'incidents/:notificationId',
            element: <ProtectedRoute />,
            children: [ { index: true, element: <IncidentDetailPage /> } ]
           },
          {
            path: 'catalog',
            element: <AdminRoute />,
            children: [
              { path: 'parameters', element: <ParameterCatalogPage /> },
              { path: 'tasks', element: <TaskCatalogPage /> },
               { path: 'products', element: <ProductCatalogPage /> },
              { path: 'product-categories', element: <ProductCategoryCatalogPage /> }
            ],
          },
           {
            path: 'reports',
            element: <FinancialAdminRoute />, 
            children: [
                { path: 'consumption', element: <ConsumptionReportPage /> },
                { path: 'invoicing', element: <InvoicingReportPage /> }
            ]
          },
           {
            path: 'financials',
            element: <AdminRoute />,
            children: [
                { path: 'payments', element: <PaymentsPage /> },
                { path: 'expenses', element: <ExpensesPage /> }
             ]
          },
          {
            path: 'superadmin',
            element: <SuperAdminRoute />,
            children: [ { path: 'tenants', element: <TenantsPage /> } ],
          },
          {
            path: 'my-route',
            element: <TechnicianRoute />,
            children: [ { index: true, element: <MyRoutePage /> } ],
          },
          {
            path: 'visits/:visitId',
            element: <ProtectedRoute />,
            children: [ { index: true, element: <WorkOrderPage /> } ],
           },
        ],
      },
    ],
  },
]);


// ====== [40] packages/client/src/stores/auth.store.ts ======
// filename: packages/client/src/stores/auth.store.ts
// version: 1.0.1 (FIXED)
// description: Desacopla el store de @prisma/client.

import { create } from 'zustand';

// --- Tipos desacoplados del backend ---
// Definimos los tipos expl√≠citamente en el frontend.
// Esto mantiene la separaci√≥n entre cliente y servidor.
type UserRole = 'SUPER_ADMIN' | 'ADMIN' | 'TECHNICIAN' | 'MANAGER';

interface User {
  id: string;
  name: string;
  email: string;
  role: UserRole;
}

type ViewAsRole = 'MANAGER' | 'ADMIN' | 'TECHNICIAN';

interface AuthState {
  user: User | null;
  activeView: ViewAsRole;
  setAuthState: (user: User | null, activeView: ViewAsRole) => void;
}

/**
 * Creamos el store de Zustand.
 * Este store contendr√° el estado de autenticaci√≥n que necesita ser
 * accesible fuera de los componentes de React, como en nuestro apiClient.
 */
export const useAuthStore = create<AuthState>((set) => ({
  user: null,
  activeView: 'MANAGER',
  setAuthState: (user, activeView) => set({ user, activeView }),
}));


// ====== [41] packages/client/src/styles/theme.ts ======
import { createTheme } from '@mantine/core';
import type { MantineColorsTuple } from '@mantine/core';

// Definimos una paleta de colores personalizada para nuestra marca.
// Puedes generar las tuyas en https://mantine.dev/colors-generator/
const brandBlue: MantineColorsTuple = [
  '#e7f5ff',
  '#d0ebff',
  '#a5d8ff',
  '#74c0fc',
  '#4dabf7',
  '#339af0',
  '#228be6',
  '#1c7ed6',
  '#1572c3',
  '#1068b1',
];

export const theme = createTheme({
  fontFamily: 'Inter, sans-serif',
  primaryColor: 'brandBlue',

  colors: {
    brandBlue,
  },

  headings: {
    fontFamily: 'Inter, sans-serif',
  },
});


// ====== [42] packages/client/tsconfig.json ======
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "allowJs": false,
    "skipLibCheck": true,
    "esModuleInterop": false,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}


// ====== [43] packages/client/tsconfig.node.json ======
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}


// ====== [44] packages/client/vite.config.ts ======
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    // Configuramos un proxy para evitar problemas de CORS en desarrollo.
    // Todas las peticiones del frontend a '/api' ser√°n redirigidas
    // a nuestro servidor de backend en el puerto 3001.
    proxy: {
      '/api': {
        target: 'http://localhost:3001',
        changeOrigin: true,
      },
    },
  },
});


// ====== [45] packages/server/package.json ======
{
  "name": "@pool-control/server",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "main": "dist/server.js",
  "scripts": {
    "dev": "tsx watch src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate",
    "prisma:studio": "prisma studio",
    "db:seed": "prisma generate && tsx prisma/seed.ts"
  },
  "prisma": {
    "seed": "prisma generate && tsx prisma/seed.ts"
  },
  "dependencies": {
    "@prisma/client": "^5.15.0",
    "bcryptjs": "^2.4.3",
    "cloudinary": "^2.7.0",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "date-fns": "^4.1.0",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "jsonwebtoken": "^9.0.2",
    "ms": "^2.1.3"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cookie-parser": "^1.4.7",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.6",
    "@types/ms": "^0.7.34",
    "@types/node": "^20.14.2",
    "prisma": "^5.15.0",
    "tsx": "^4.15.4",
    "typescript": "^5.4.5"
  }
}


// ====== [46] packages/server/prisma/data/catalogs.ts ======
// filename: packages/server/prisma/data/catalogs.ts
// version: 1.0.1
// description: Datos de semilla para los cat√°logos de Par√°metros y Tareas de "Piscival S.L.".

import type { InputType } from '@prisma/client';

/**
 * Define la librer√≠a central de todos los servicios (mediciones y acciones).
 * Se especifica el tipo InputType para cumplir con la validaci√≥n estricta de Prisma.
 */

// --- CAT√ÅLOGO DE PAR√ÅMETROS A MEDIR ---
export const parameterData: { name: string; unit?: string | null; type: InputType; selectOptions?: string[] }[] = [
  // Par√°metros Qu√≠micos Esenciales (Tipo NUMBER)
  { name: 'Nivel de pH', unit: 'pH', type: 'NUMBER' },
  { name: 'Cloro Libre (DPD-1)', unit: 'ppm', type: 'NUMBER' },
  { name: 'Cloro Total (DPD-3)', unit: 'ppm', type: 'NUMBER' },
  { name: 'Alcalinidad Total (TA)', unit: 'ppm', type: 'NUMBER' },
  { name: 'Dureza C√°lcica (TH)', unit: 'ppm', type: 'NUMBER' },
  { name: '√Åcido Cian√∫rico (Estabilizante)', unit: 'ppm', type: 'NUMBER' },
  { name: 'Nivel de Sal (para piscinas de sal)', unit: 'ppm', type: 'NUMBER' },

  // Par√°metros F√≠sicos (Tipo NUMBER)
  { name: 'Temperatura del Agua', unit: '¬∞C', type: 'NUMBER' },
  { name: 'Presi√≥n del Filtro', unit: 'bar', type: 'NUMBER' },

  // Par√°metros de Observaci√≥n (Tipos SELECT y BOOLEAN para probar la UI)
  {
    name: 'Estado del Agua',
    type: 'SELECT',
    selectOptions: ['Cristalina', 'Ligeramente turbia', 'Muy turbia', 'Verde', 'Blanquecina'],
  },
  {
    name: 'Nivel del Agua en Skimmer',
    type: 'SELECT',
    selectOptions: ['Correcto', 'Alto', 'Bajo'],
  },
  {
    name: 'Fondo de la piscina limpio',
    type: 'BOOLEAN',
  },
];

// --- CAT√ÅLOGO DE TAREAS A REALIZAR ---
export const taskData = [
  // Tareas de Limpieza Rutinaria
  {
    name: 'Limpieza de cestos de skimmers',
    description: 'Vaciar y limpiar los cestos de los skimmers de hojas y otros residuos.',
  },
  {
    name: 'Limpieza de cesto de bomba',
    description: 'Vaciar y limpiar el pre-filtro de la bomba para asegurar un buen flujo.',
  },
  {
    name: 'Pasar limpiafondos manual',
    description: 'Aspirar el fondo de la piscina manualmente para recoger la suciedad sedimentada.',
  },
  {
    name: 'Cepillado de paredes y l√≠nea de flotaci√≥n',
    description: 'Cepillar las superficies para prevenir la adhesi√≥n de algas y dep√≥sitos calc√°reos.',
  },

  // Tareas de Mantenimiento T√©cnico
  {
    name: 'Contralavado de filtro (Backwash)',
    description: 'Realizar un backwash completo del sistema de filtraci√≥n seguido de un enjuague.',
  },
  {
    name: 'Revisi√≥n y ajuste de dosificadores autom√°ticos',
    description: 'Comprobar el funcionamiento de bombas dosificadoras de pH y cloro.',
  },
  {
    name: 'Revisi√≥n de clorador salino',
    description: 'Verificar la producci√≥n de cloro y el estado de la c√©lula del clorador salino.',
  },
  {
    name: 'Comprobaci√≥n visual de fugas en local t√©cnico',
    description: 'Inspeccionar tuber√≠as, bomba y filtro en busca de goteos o fugas de agua.',
  },
  
  // Tareas de Adici√≥n de Productos (para futuro control de stock)
  {
    name: 'A√±adir producto alguicida',
    description: 'Dosificar la cantidad necesaria de alguicida preventivo.',
  },
  {
    name: 'A√±adir producto floculante',
    description: 'Dosificar floculante para ayudar a clarificar el agua si es necesario.',
  },
];


// ====== [47] packages/server/prisma/data/clients.ts ======
// filename: packages/server/prisma/data/clients.ts
// version: 3.0.5 (ULTRA-VERIFIED)
// description: Versi√≥n definitiva. Se ha verificado que cada campo coincide con el modelo Client del schema.prisma v9.0.2.

import type { BillingModel } from '@prisma/client';

export const clientsData = [
  // --- Cliente 1: Comunidad de Propietarios (Cuota + Materiales) ---
  {
    client: {
      name: 'Comunidad de Propietarios "El Oasis"',
      contactPerson: 'Sr. Garc√≠a (Presidente)',
      email: 'comunidad.oasis@email.com',
      phone: '611223344',
      address: 'Calle de la Concordia, 1, 28080 Madrid',
      priceModifier: 1.0,
      monthlyFee: 350.0,
      billingModel: 'FEE_PLUS_MATERIALS' as BillingModel,
    },
    pools: [
      {
        name: 'Piscina Comunitaria Grande',
        address: 'Calle de la Concordia, 1, Zonas Comunes, 28080 Madrid',
        volume: 150,
        type: 'Cloro',
        zoneName: 'Arenal',
      },
      {
        name: 'Piscina Infantil',
        address: 'Calle de la Concordia, 1, Zona Infantil, 28080 Madrid',
        volume: 25,
        type: 'Cloro',
        zoneName: 'Arenal',
      },
    ],
  },

  // --- Cliente 2: Chalet Privado (Todo Incluido) ---
  {
    client: {
      name: 'Chalet "Villa Sol"',
      contactPerson: 'Familia P√©rez-L√≥pez',
      email: 'perez.lopez.familia@email.com',
      phone: '655667788',
      address: 'Avenida de la Brisa, 45, Urbanizaci√≥n Mirasierra, 28035 Madrid',
      priceModifier: 1.1,
      monthlyFee: 220.0,
      billingModel: 'ALL_INCLUSIVE' as BillingModel,
    },
    pools: [
      {
        name: 'Piscina Privada con Jacuzzi',
        address: 'Avenida de la Brisa, 45, 28035 Madrid',
        volume: 75,
        type: 'Sal',
        zoneName: 'Montg√≥',
      },
    ],
  },

  // --- Cliente 3: Hotel (Solo paga servicio, sin cuota) ---
  {
    client: {
      name: 'Hotel "Costa Serena"',
      contactPerson: 'Dpto. de Mantenimiento',
      email: 'mantenimiento@costaserena-hotel.com',
      phone: '911223344',
      address: 'Paseo del Relax, 2, 28010 Madrid',
      priceModifier: 0.95,
      monthlyFee: 0.0,
      billingModel: 'SERVICE_ONLY' as BillingModel,
    },
    pools: [
      {
        name: 'Piscina Exterior Principal',
        address: 'Paseo del Relax, 2, Zona de Jardines, 28010 Madrid',
        volume: 250,
        type: 'Cloro',
        zoneName: 'Puerto',
      },
    ],
  },

  // --- Cliente 4: Gimnasio (Cuota + Materiales) ---
  {
    client: {
      name: 'Gimnasio "Fisic-Center"',
      contactPerson: 'Gerencia',
      email: 'gerencia@fisic-center.es',
      phone: '918765432',
      address: 'Calle del M√∫sculo, 12, 28020 Madrid',
      priceModifier: 1.0,
      monthlyFee: 250.0,
      billingModel: 'FEE_PLUS_MATERIALS' as BillingModel,
    },
    pools: [
      {
        name: 'Piscina Climatizada Interior',
        address: 'Calle del M√∫sculo, 12, S√≥tano, 28020 Madrid',
        volume: 100,
        type: 'Cloro',
        zoneName: 'Pueblo',
      },
    ],
  },
];


// ====== [48] packages/server/prisma/data/consumptions.ts ======
// ====== [41] packages/server/prisma/data/consumptions.ts ======
// filename: packages/server/prisma/data/consumptions.ts
// version: 2.0.0
// description: Datos de semilla enriquecidos para los consumos de productos en las visitas, para una demo m√°s visual.

/**
 * Define un conjunto de consumos de productos para las visitas de prueba.
 * Se ha aumentado la variedad para asegurar que el dashboard de gerencia
 * muestre un gr√°fico de "Top 5 Productos" m√°s representativo.
 */
export const consumptionsData = [
  {
    // --- VISITA 1: Incidencia CR√çTICA en "El Oasis" (fuga) ---
    // El pH estaba alto (7.9), as√≠ que a√±adimos reductor.
    // El cloro se a√±ade para un tratamiento de choque r√°pido.
    visitNotesIdentifier: 'Fuga de agua detectada en la tuber√≠a principal del skimmer',
    consumptions: [
      {
        productName: 'Reductor de pH L√≠quido',
        quantity: 5, // 5 Litros
      },
      {
        productName: 'Cloro Granulado (Dicloro 55%)',
        quantity: 0.5, // 0.5 Kg
      },
    ],
  },
  {
    // --- VISITA 2: Incidencia CLASIFICADA en el "Gimnasio Fisic-Center" (ruido bomba) ---
    // La presi√≥n del filtro era alta (1.5 bar), es com√∫n a√±adir clarificante tras un lavado.
    visitNotesIdentifier: 'La bomba de calor hace un ruido met√°lico',
    consumptions: [
      {
        productName: 'Floculante L√≠quido Clarificante',
        quantity: 1.5, // 1.5 Litros
      },
      {
        productName: 'Incrementador de pH S√≥lido', // Para ajustar pH despu√©s del contralavado
        quantity: 1, // 1 Kg
      }
    ],
  },
  {
    // --- VISITA 3: Visita OK del "Hotel Costa Serena" ---
    // Esta visita ya tiene 1 saco de sal a√±adido en el seed.ts. Le a√±adimos m√°s cosas.
    visitNotesIdentifier: 'Todo en orden. Valores perfectos.',
    consumptions: [
        {
            productName: 'Pastillas Multiacci√≥n 250g', // Consumo de mantenimiento rutinario.
            quantity: 4, // 4 pastillas para una piscina grande
        },
        {
            productName: 'Alguicida Concentrado', // Dosis de mantenimiento para prevenir
            quantity: 0.75, // 0.75 Litros
        }
    ]
  },
  {
    // --- VISITA 4: Incidencia PENDIENTE en "Chalet Villa Sol" (falta de sal) ---
    // No podemos a√±adir consumo de sal porque no hab√≠a, pero s√≠ de otros productos.
    visitNotesIdentifier: 'El nivel de sal es bajo, pero no hay producto en el almac√©n.',
    consumptions: [
      {
        productName: 'Reductor de pH L√≠quido', // Supongamos que el pH tambi√©n necesitaba ajuste.
        quantity: 2, // 2 Litros
      },
    ]
  }
];


// ====== [49] packages/server/prisma/data/financial-rules.ts ======
// filename: packages/server/prisma/data/financial-rules.ts
// version: 1.0.0
// description: Datos de semilla para las reglas de precios personalizadas.

/**
 * Define las reglas de descuento espec√≠ficas por cliente.
 * Cada regla se identifica por el nombre del cliente y el nombre del producto/categor√≠a.
 * El script de seed.ts se encargar√° de buscar los IDs correspondientes.
 */
export const clientPricingRulesData = [
  {
    // REGLA 1: Descuento aplicado a una CATEGOR√çA completa para un cliente.
    // La Comunidad "El Oasis" tiene un 5% de descuento en todos los desinfectantes.
    clientName: 'Comunidad de Propietarios "El Oasis"',
    categoryName: 'Qu√≠micos Desinfectantes',
    discountPercentage: 5.0,
  },
  {
    // REGLA 2: Descuento aplicado a un PRODUCTO espec√≠fico para un cliente.
    // El Hotel "Costa Serena" tiene un 10% de descuento en las pastillas de cloro,
    // que es un producto de alto consumo para ellos.
    clientName: 'Hotel "Costa Serena"',
    productName: 'Pastillas Multiacci√≥n 250g',
    discountPercentage: 10.0,
  },
  {
    // REGLA 3: M√∫ltiples reglas para un mismo cliente.
    // El Gimnasio "Fisic-Center" tiene un descuento en los reguladores (categor√≠a)
    // y uno a√∫n mayor en el alguicida (producto).
    clientName: 'Gimnasio "Fisic-Center"',
    categoryName: 'Qu√≠micos Reguladores',
    discountPercentage: 7.5,
  },
  {
    clientName: 'Gimnasio "Fisic-Center"',
    productName: 'Alguicida Concentrado',
    discountPercentage: 15.0,
  },
  // NOTA: El cliente "Chalet 'Villa Sol'" no tiene reglas espec√≠ficas.
  // Esto nos permitir√° probar que el sistema le aplica correctamente su
  // recargo general (`priceModifier`) sin descuentos adicionales.
];


// ====== [50] packages/server/prisma/data/incident-tasks.ts ======
// filename: packages/server/prisma/data/incident-tasks.ts
// version: 1.0.0
// description: Datos de semilla para las Tareas de Incidencia (Ticketing).

import { IncidentPriority, IncidentTaskStatus } from '@prisma/client';
import { addDays, subDays } from 'date-fns';

const today = new Date();
const tomorrow = addDays(today, 1);
const yesterday = subDays(today, 1);
const nextWeek = addDays(today, 7);

/**
 * Define un conjunto de tareas de incidencia de prueba.
 * Cada objeto tiene una propiedad 'notificationMessage' que usaremos en el script
 * de seed para encontrar la notificaci√≥n padre correcta a la que asociar la tarea.
 */
export const incidentTasksData = [
  {
    // Tarea para la incidencia CR√çTICA de la fuga. Es urgente y ya est√° en progreso.
    notificationMessage: 'Fuga de agua detectada en la tuber√≠a principal del skimmer.',
    task: {
      title: 'Contactar a fontanero para presupuesto de reparaci√≥n de fuga',
      description: 'Llamar a Fontaner√≠a Express (91 123 45 67) y pedir presupuesto urgente. Mencionar que es para la Comunidad "El Oasis".',
      priority: 'CRITICAL' as IncidentPriority,
      status: 'IN_PROGRESS' as IncidentTaskStatus,
      deadline: tomorrow, // Plazo para ma√±ana
      // La asignaci√≥n se har√° en el script de seed.
    },
  },
  {
    // Tarea secundaria para la misma incidencia de la fuga.
    notificationMessage: 'Fuga de agua detectada en la tuber√≠a principal del skimmer.',
    task: {
      title: 'Cerrar llave de paso del skimmer afectado',
      description: 'Para minimizar la p√©rdida de agua hasta que venga el fontanero, cerrar la llave de paso correspondiente en el local t√©cnico.',
      priority: 'HIGH' as IncidentPriority,
      status: 'COMPLETED' as IncidentTaskStatus,
      resolutionNotes: 'Llave de paso cerrada a las 10:30. Ya no gotea. Se ha informado al presidente.',
      // La asignaci√≥n se har√° en el script de seed.
    },
  },
  {
    // Tarea para la incidencia de falta de sal.
    notificationMessage: 'El nivel de sal es bajo, pero no hay producto en el almac√©n. Avisar para reponer.',
    task: {
      title: 'Comprar sacos de sal para el almac√©n',
      description: 'Ir al proveedor habitual (PRO-PISCINAS) y comprar 5 sacos de sal especial para clorador. Guardar factura.',
      priority: 'NORMAL' as IncidentPriority,
      status: 'PENDING' as IncidentTaskStatus,
      deadline: nextWeek, // Plazo de una semana
      // La asignaci√≥n se har√° en el script de seed.
    },
  },
  {
    // Tarea para la incidencia del ruido de la bomba de calor. Plazo vencido.
    notificationMessage: 'La bomba de calor hace un ruido met√°lico muy fuerte al arrancar.',
    task: {
      title: 'Revisar rodamientos de la bomba de calor',
      description: 'Desmontar la carcasa y verificar si los rodamientos del motor tienen holgura o est√°n oxidados. Engrasar si es posible.',
      priority: 'HIGH' as IncidentPriority,
      status: 'PENDING' as IncidentTaskStatus, // Sigue pendiente
      deadline: yesterday, // El plazo era para ayer, por lo que est√° VENCIDA.
      // La asignaci√≥n se har√° en el script de seed.
    },
  },
];


// ====== [51] packages/server/prisma/data/product-categories.ts ======
// filename: packages/server/prisma/data/product-categories.ts
// version: 1.0.0
// description: Datos de semilla para las categor√≠as de productos.

/**
 * Define las familias o categor√≠as en las que se agrupar√°n los productos.
 * Esto es clave para poder aplicar reglas de precios a nivel de categor√≠a.
 */
export const productCategoriesData = [
  { name: 'Qu√≠micos Reguladores' },     // Para productos como pH, alcalinidad, etc.
  { name: 'Qu√≠micos Desinfectantes' },  // Para cloro, bromo, etc.
  { name: 'Qu√≠micos de Mantenimiento' },// Para alguicidas, floculantes, etc.
  { name: 'Sal y Electr√≥lisis' },       // Para sacos de sal y recambios de cloradores.
  { name: 'Material de Limpieza' },     // Para cepillos, recogehojas, etc.
  { name: 'Recambios y Fontaner√≠a' },  // Para juntas, v√°lvulas, etc.
];


// ====== [52] packages/server/prisma/data/products.ts ======
// filename: packages/server/prisma/data/products.ts
// version: 2.0.0
// description: A√±ade PVP, IVA y categor√≠a a cada producto.

export const productData = [
  // --- Qu√≠micos Desinfectantes ---
  {
    name: 'Hipoclorito S√≥dico 15%',
    description: 'Cloro l√≠quido para desinfecci√≥n de choque y mantenimiento.',
    unit: 'L',
    cost: 1.20,
    salePrice: 2.50, // PVP
    taxRate: 21,
    categoryName: 'Qu√≠micos Desinfectantes',
  },
  {
    name: 'Cloro Granulado (Dicloro 55%)',
    description: 'Cloro de disoluci√≥n r√°pida para tratamientos de choque.',
    unit: 'Kg',
    cost: 8.50,
    salePrice: 14.90,
    taxRate: 21,
    categoryName: 'Qu√≠micos Desinfectantes',
  },
  {
    name: 'Pastillas Multiacci√≥n 250g',
    description: 'Pastillas de cloro de disoluci√≥n lenta con acci√≥n desinfectante, alguicida y floculante.',
    unit: 'Unidad',
    cost: 2.75,
    salePrice: 4.50,
    taxRate: 21,
    categoryName: 'Qu√≠micos Desinfectantes',
  },

  // --- Qu√≠micos Reguladores ---
  {
    name: 'Reductor de pH L√≠quido',
    description: '√Åcido sulf√∫rico para bajar el nivel de pH del agua.',
    unit: 'L',
    cost: 2.10,
    salePrice: 3.95,
    taxRate: 21,
    categoryName: 'Qu√≠micos Reguladores',
  },
  {
    name: 'Incrementador de pH S√≥lido',
    description: 'Producto en polvo para subir el nivel de pH del agua.',
    unit: 'Kg',
    cost: 4.50,
    salePrice: 7.80,
    taxRate: 21,
    categoryName: 'Qu√≠micos Reguladores',
  },

  // --- Qu√≠micos de Mantenimiento ---
  {
    name: 'Alguicida Concentrado',
    description: 'Tratamiento preventivo y de choque contra todo tipo de algas.',
    unit: 'L',
    cost: 9.70,
    salePrice: 18.50,
    taxRate: 21,
    categoryName: 'Qu√≠micos de Mantenimiento',
  },
  {
    name: 'Floculante L√≠quido Clarificante',
    description: 'Agrupa las part√≠culas en suspensi√≥n para mejorar la filtraci√≥n y dar transparencia al agua.',
    unit: 'L',
    cost: 5.80,
    salePrice: 11.20,
    taxRate: 21,
    categoryName: 'Qu√≠micos de Mantenimiento',
  },

  // --- Sal y Electr√≥lisis ---
  {
    name: 'Sal para Piscinas (Saco)',
    description: 'Sal especial para equipos de cloraci√≥n salina.',
    unit: 'Saco 25Kg',
    cost: 12.50,
    salePrice: 22.00,
    taxRate: 21,
    categoryName: 'Sal y Electr√≥lisis',
  },
];


// ====== [53] packages/server/prisma/data/route-templates.ts ======
// ====== [NUEVO] packages/server/prisma/data/route-templates.ts ======
// filename: packages/server/prisma/data/route-templates.ts
// version: 1.0.3 (FIX: Use string literals for enums)
// description: Datos de semilla para las Rutas Maestras, incluyendo estacionalidad. Usa strings literales para evitar problemas de importaci√≥n de enums.

// No se necesita ninguna importaci√≥n de @prisma/client

/**
 * Define las rutas maestras de la empresa.
 * Cada ruta especifica un d√≠a, un t√©cnico habitual, las zonas que cubre
 * y las frecuencias de visita seg√∫n la temporada.
 */
export const routeTemplatesData = [
  {
    name: 'Lunes - Ruta Arenal',
    // ‚úÖ Se usa el string literal que coincide con el enum
    dayOfWeek: 'MONDAY',
    technicianName: 'Carlos T√©cnico',
    zoneNames: ['Arenal', 'Montg√≥'],
    seasons: [
      {
        frequency: 'WEEKLY', // Frecuencia semanal
        startDate: new Date('2025-06-01'),
        endDate: new Date('2025-09-30'),
      },
      {
        frequency: 'BIWEEKLY', // Frecuencia quincenal
        startDate: new Date('2025-10-01'),
        endDate: new Date('2026-05-31'),
      },
    ],
  },
  {
    name: 'Martes - Ruta Puerto',
    dayOfWeek: 'TUESDAY',
    technicianName: 'Ana T√©cnica',
    zoneNames: ['Puerto'],
    seasons: [
      {
        frequency: 'WEEKLY',
        startDate: new Date('2025-01-01'),
        endDate: new Date('2025-12-31'),
      },
    ],
  },
  {
    name: 'Mi√©rcoles - Mantenimiento Intensivo',
    dayOfWeek: 'WEDNESDAY',
    technicianName: 'Leo Ayudante',
    zoneNames: ['Arenal'], 
    seasons: [
      {
        frequency: 'WEEKLY',
        startDate: new Date('2025-06-15'),
        endDate: new Date('2025-08-31'),
      },
    ],
  },
  {
    name: 'Jueves - Ruta Pueblo y Tosal',
    dayOfWeek: 'THURSDAY',
    technicianName: 'Carlos T√©cnico',
    zoneNames: ['Pueblo', 'Tosal'],
    seasons: [
      {
        frequency: 'WEEKLY',
        startDate: new Date('2025-01-01'),
        endDate: new Date('2025-12-31'),
      },
    ],
  },
  {
    name: 'Viernes - Ruta Balc√≥n y Repaso',
    dayOfWeek: 'FRIDAY',
    technicianName: 'Ana T√©cnica',
    zoneNames: ['Balc√≥n al Mar', 'Montg√≥'],
    seasons: [
      {
        frequency: 'WEEKLY',
        startDate: new Date('2025-01-01'),
        endDate: new Date('2025-12-31'),
      },
    ],
  },
];


// ====== [54] packages/server/prisma/data/transactions.ts ======
// filename: packages/server/prisma/data/transactions.ts
// version: 1.0.0
// description: Datos de semilla para pagos de clientes y gastos de la empresa.

import { subMonths, subDays } from 'date-fns';

const today = new Date();

/**
 * Define un historial de pagos de clientes.
 * Se identifica al cliente por su nombre para que el seed.ts busque el ID.
 */
export const paymentsData = [
  {
    clientName: 'Comunidad de Propietarios "El Oasis"',
    amount: 350.00, // Simula el pago de su cuota mensual
    paymentDate: subMonths(today, 1),
    method: 'Transferencia Bancaria',
    notes: 'Cuota de Mantenimiento Mes Anterior',
  },
  {
    clientName: 'Comunidad de Propietarios "El Oasis"',
    amount: 85.50, // Simula el pago de una factura de materiales
    paymentDate: subDays(today, 20),
    method: 'Transferencia Bancaria',
    notes: 'Factura 2025-0045 Materiales',
  },
  {
    clientName: 'Chalet "Villa Sol"',
    amount: 220.00, // Simula el pago de su cuota todo incluido
    paymentDate: subDays(today, 15),
    method: 'Recibo Domiciliado',
    notes: 'Cuota All-Inclusive Mes Actual',
  },
  {
    clientName: 'Hotel "Costa Serena"',
    amount: 550.75, // Simula el pago de una gran factura de productos
    paymentDate: subDays(today, 5),
    method: 'Confirming',
    notes: 'Factura 2025-0048 Consumo Productos',
  },
];

/**
 * Define un historial de gastos generales de la empresa.
 * No est√°n asociados a un cliente, sino al tenant.
 */
export const expensesData = [
  {
    amount: 250.00,
    expenseDate: subDays(today, 10),
    description: 'Repostaje furgonetas Carlos y Ana',
    category: 'Combustible',
  },
  {
    amount: 3200.00,
    expenseDate: subMonths(today, 1),
    description: 'N√≥minas mes anterior',
    category: 'N√≥minas',
  },
  {
    amount: 80.00,
    expenseDate: subDays(today, 3),
    description: 'Compra de material de oficina',
    category: 'Suministros Oficina',
  },
  {
    amount: 150.00,
    expenseDate: subDays(today, 1),
    description: 'Comida de equipo',
    category: 'Dietas y Representaci√≥n',
  },
];


// ====== [55] packages/server/prisma/data/user-availabilities.ts ======
// filename: packages/server/prisma/data/user-availabilities.ts
// version: 1.0.0
// description: [NUEVO] Datos de semilla para las ausencias planificadas de los usuarios.

import { addDays, startOfWeek } from 'date-fns';

// Obtenemos el inicio de la semana actual para que los datos de ausencia
// coincidan con la semana para la que el seeder genera visitas.
const startOfCurrentWeek = startOfWeek(new Date(), { weekStartsOn: 1 });

export const userAvailabilitiesData = [
  {
    // Vamos a simular que Carlos se toma toda la semana de vacaciones.
    // El seeder le asigna rutas el Lunes y el Jueves. Cuando implementemos la l√≥gica
    // en el backend, estas visitas deber√≠an ser marcadas como "hu√©rfanas".
    userName: 'Carlos T√©cnico',
    reason: 'Vacaciones Anuales',
    
    // La ausencia cubre toda la semana laboral.
    startDate: startOfCurrentWeek, // Lunes de esta semana
    endDate: addDays(startOfCurrentWeek, 4), // Viernes de esta semana
  },
  // Aqu√≠ podr√≠amos a√±adir m√°s ausencias para otros t√©cnicos si fuera necesario.
];


// ====== [56] packages/server/prisma/data/users.ts ======
// filename: packages/server/prisma/data/users.ts
// version: 1.0.1
// description: Datos de semilla para los usuarios del tenant de prueba "Piscival S.L.".

import type { UserRole } from '@prisma/client';

/**
 * Define los usuarios que se crear√°n para el tenant principal de prueba.
 * Se especifica el tipo UserRole para cumplir con la validaci√≥n estricta de Prisma.
 */
export const usersData: { name: string; email: string; password: string; role: UserRole }[] = [
  // --- ROL: Administradora ---
  {
    name: 'Isa Gestora',
    email: 'admin@piscival.com',
    password: 'password123',
    role: 'ADMIN',
  },

  // --- ROL: T√©cnicos de Campo ---
  {
    name: 'Carlos T√©cnico',
    email: 'carlos.t@piscival.com',
    password: 'password123',
    role: 'TECHNICIAN',
  },
  {
    name: 'Ana T√©cnica',
    email: 'ana.t@piscival.com',
    password: 'password123',
    role: 'TECHNICIAN',
  },
  {
    name: 'Leo Ayudante',
    email: 'leo.a@piscival.com',
    password: 'password123',
    role: 'TECHNICIAN',
  },

  // --- ROL: Gerencia/Supervisor (para futuras funcionalidades) ---
  {
    name: 'Jorge Supervisor',
    email: 'manager@piscival.com',
    password: 'password123',
    role: 'MANAGER',
  },
];


// ====== [57] packages/server/prisma/data/zones.ts ======
// ====== [NUEVO] packages/server/prisma/data/zones.ts ======
// filename: packages/server/prisma/data/zones.ts
// version: 1.0.0
// description: Datos de semilla para las zonas geogr√°ficas de operaci√≥n.

/**
 * Define las zonas geogr√°ficas en las que opera la empresa de prueba.
 * Estos nombres se usar√°n para agrupar piscinas y definir las rutas de los t√©cnicos.
 */
export const zonesData = [
  { name: 'Arenal' },
  { name: 'Puerto' },
  { name: 'Tosal' },
  { name: 'Montg√≥' },
  { name: 'Balc√≥n al Mar' },
  { name: 'Pueblo' },
];


// ====== [58] packages/server/prisma/seed.ts ======
// filename: packages/server/prisma/seed.ts
// version: 9.1.3 (FINAL & COMPLETE)

import { PrismaClient } from '@prisma/client';
import type { DayOfWeek, User, Pool, Product, Client, ProductCategory, Zone, ParameterTemplate, ScheduledTaskTemplate, Visit, Notification, VisitFrequency } from '@prisma/client';
import { hashPassword } from '../src/utils/password.utils.js';
import { addDays, startOfWeek } from 'date-fns';

import { usersData } from './data/users.js';
import { parameterData, taskData } from './data/catalogs.js';
import { clientsData } from './data/clients.js';
import { productData } from './data/products.js';
import { incidentTasksData } from './data/incident-tasks.js';
import { productCategoriesData } from './data/product-categories.js';
import { clientPricingRulesData } from './data/financial-rules.js';
import { paymentsData, expensesData } from './data/transactions.js';
import { zonesData } from './data/zones.js';
import { routeTemplatesData } from './data/route-templates.js';
import { consumptionsData } from './data/consumptions.js';
import { userAvailabilitiesData } from './data/user-availabilities.js';

async function main() {
  const prisma = new PrismaClient();

  try {
    console.log('üå± Empezando el proceso de seeding v9.1 (Estable + Planificaci√≥n Avanzada)...');

    const systemTenant = await prisma.tenant.create({ data: { companyName: 'SYSTEM_INTERNAL', subdomain: 'system', subscriptionStatus: 'ACTIVE' } });
    const superAdminPassword = await hashPassword('superadmin123');
    await prisma.user.create({ data: { email: 'super@admin.com', name: 'Super Admin', password: superAdminPassword, role: 'SUPER_ADMIN', tenantId: systemTenant.id } });
    console.log('üëë SuperAdmin y Tenant del sistema creados.');

    const mainTenant = await prisma.tenant.create({ data: { companyName: 'Piscival S.L.', subdomain: 'piscival', subscriptionStatus: 'ACTIVE' } });
    console.log(`\nüè¢ Tenant de prueba creado: ${mainTenant.companyName}`);
    
    const createdUsers: User[] = [];
    for (const userData of usersData) {
      const hashedPassword = await hashPassword(userData.password);
      const user = await prisma.user.create({ data: { ...userData, password: hashedPassword, tenantId: mainTenant.id } });
      createdUsers.push(user);
    }
    const adminUser = createdUsers.find(u => u.role === 'ADMIN');
    const technicians = createdUsers.filter(u => u.role === 'TECHNICIAN');
    if (!adminUser || technicians.length === 0) throw new Error('Seeding fallido: No se encontraron suficientes usuarios admin o t√©cnicos.');
    console.log(`   üë§ Creados ${createdUsers.length} usuarios.`);

    console.log('\n- Fase de creaci√≥n de cat√°logos y finanzas -');

    const createdParams: ParameterTemplate[] = [];
    for (const p of parameterData) { createdParams.push(await prisma.parameterTemplate.create({ data: { ...p, tenantId: mainTenant.id } })); }
    console.log(`üìä Creados ${createdParams.length} par√°metros en el cat√°logo.`);

    const createdTasks: ScheduledTaskTemplate[] = [];
    for (const t of taskData) { createdTasks.push(await prisma.scheduledTaskTemplate.create({ data: { ...t, tenantId: mainTenant.id } })); }
    console.log(`üìã Creadas ${createdTasks.length} tareas en el cat√°logo.`);

    const createdCategories: ProductCategory[] = [];
    for (const catData of productCategoriesData) { createdCategories.push(await prisma.productCategory.create({ data: { ...catData, tenantId: mainTenant.id } })); }
    console.log(`üìÅ Creadas ${createdCategories.length} categor√≠as de productos.`);

    const createdProducts: Product[] = [];
    for (const prodData of productData) {
      const { categoryName, ...restOfProdData } = prodData;
      const category = createdCategories.find(c => c.name === categoryName);
      createdProducts.push(await prisma.product.create({ data: { ...restOfProdData, tenantId: mainTenant.id, categoryId: category?.id } }));
    }
    console.log(`üì¶ Creados ${createdProducts.length} productos en el cat√°logo.`);
    
    const createdZones: Zone[] = [];
    for(const zone of zonesData) { createdZones.push(await prisma.zone.create({ data: { ...zone, tenantId: mainTenant.id }})); }
    console.log(`üåç Creadas ${createdZones.length} zonas geogr√°ficas.`);

    console.log('\n- Fase de creaci√≥n de clientes y piscinas -');
    const allPools: Pool[] = [];
    const createdClients: Client[] = [];
    for (const data of clientsData) {
      const client = await prisma.client.create({ data: { ...data.client, tenantId: mainTenant.id } });
      createdClients.push(client);
      console.log(`\nüë®‚Äçüíº Cliente creado: ${client.name}`);
      for (const poolData of data.pools) {
        const zone = createdZones.find(z => z.name === poolData.zoneName);
        const { zoneName, ...restOfPoolData } = poolData;
        const pool = await prisma.pool.create({ data: { ...restOfPoolData, clientId: client.id, tenantId: mainTenant.id, zoneId: zone?.id } });
        allPools.push(pool);
        console.log(`   üèä Piscina creada: ${pool.name} en Zona: ${zone?.name}`);
        
        for(let i = 0; i < 5 && i < createdParams.length; i++) {
          await prisma.poolConfiguration.create({data: {poolId: pool.id, parameterTemplateId: createdParams[i]!.id }});
        }
        for(let i = 0; i < 3 && i < createdTasks.length; i++) {
          await prisma.poolConfiguration.create({data: {poolId: pool.id, taskTemplateId: createdTasks[i]!.id }});
        }
        console.log(`      üìù Ficha de mantenimiento creada para ${pool.name}.`);
      }
    }
    if (allPools.length < 5) throw new Error('Seeding fallido: No se crearon suficientes piscinas.');

    console.log('\n- Fase de creaci√≥n de Rutas, Ausencias y Finanzas -');
    
    for (const rt of routeTemplatesData) {
      const technician = createdUsers.find(u => u.name === rt.technicianName);
      const zonesToConnect = createdZones.filter(z => rt.zoneNames.includes(z.name));
      await prisma.routeTemplate.create({
        data: {
          name: rt.name,
          dayOfWeek: rt.dayOfWeek as DayOfWeek,
          technicianId: technician?.id,
          tenantId: mainTenant.id,
          zones: { connect: zonesToConnect.map(z => ({ id: z.id })) },
          seasons: {
            create: rt.seasons.map(season => ({
              ...season,
              frequency: season.frequency as VisitFrequency,
            })),
          },
        },
      });
    }
    console.log(`üó∫Ô∏è  Creadas ${routeTemplatesData.length} rutas maestras.`);
    
    for (const availability of userAvailabilitiesData) {
        const user = createdUsers.find(u => u.name === availability.userName);
        if (user) {
            await prisma.userAvailability.create({
                data: {
                    startDate: availability.startDate,
                    endDate: availability.endDate,
                    reason: availability.reason,
                    userId: user.id,
                    tenantId: mainTenant.id,
                }
            });
        }
    }
    console.log(`üóìÔ∏è  Creadas ${userAvailabilitiesData.length} ausencias planificadas.`);
    
    for (const rule of clientPricingRulesData) {
      const client = createdClients.find(c => c.name === rule.clientName);
      if (!client) continue;
      const product = rule.productName ? createdProducts.find(p => p.name === rule.productName) : null;
      const category = rule.categoryName ? createdCategories.find(c => c.name === rule.categoryName) : null;
      await prisma.clientProductPricing.create({ data: { clientId: client.id, productId: product?.id, productCategoryId: category?.id, discountPercentage: rule.discountPercentage } });
    }
    console.log(`üí∞ Creadas ${clientPricingRulesData.length} reglas de precios personalizadas.`);
    
    const paymentsToCreate = paymentsData.map(p => {
        const client = createdClients.find(c => c.name === p.clientName);
        return {
            amount: p.amount,
            paymentDate: p.paymentDate,
            method: p.method,
            notes: p.notes,
            clientId: client!.id,
        }
    });
    await prisma.payment.createMany({ data: paymentsToCreate });
    console.log(`üí≥ Creados ${paymentsData.length} registros de pagos.`);

    await prisma.expense.createMany({ data: expensesData.map(e => ({ ...e, tenantId: mainTenant.id })) });
    console.log(`üí∏ Creados ${expensesData.length} registros de gastos.`);

    console.log('\n- Fase de simulaci√≥n de actividad operativa -');
    const allRouteTemplates = await prisma.routeTemplate.findMany({ include: { zones: true } });
    const today = new Date();
    const startOfThisWeek = startOfWeek(today, { weekStartsOn: 1 });
    const createdVisits: Visit[] = [];
    const dayOfWeekStrings: DayOfWeek[] = ['MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY', 'SUNDAY'];

    for (let i = 0; i < 5; i++) {
        const dayToSimulate = addDays(startOfThisWeek, i);
        const dayOfWeekStr = dayOfWeekStrings[i]!;
        const routesForDay = allRouteTemplates.filter(rt => rt.dayOfWeek === dayOfWeekStr);
        for (const route of routesForDay) {
            const poolsInRoute = await prisma.pool.findMany({ where: { zoneId: { in: route.zones.map(z => z.id) } } });
            const techData = routeTemplatesData.find(rtd => rtd.name === route.name);
            const tech = techData ? createdUsers.find(u => u.name === techData.technicianName) : null;
            for (const pool of poolsInRoute) {
                createdVisits.push(await prisma.visit.create({ data: { poolId: pool.id, timestamp: dayToSimulate, technicianId: tech?.id } }));
            }
        }
    }
    console.log(`   ‚úÖ Generadas ${createdVisits.length} visitas para la semana actual a partir de Rutas Maestras.`);

    const allNotifications: Notification[] = [];
    for(let i=0; i < consumptionsData.length && i < createdVisits.length; i++){
        const visit = createdVisits[i]!;
        const cSeed = consumptionsData[i]!;

        await prisma.visit.update({ where: { id: visit.id }, data: { status: 'COMPLETED', notes: cSeed.visitNotesIdentifier, hasIncident: true }});
        
        const notification = await prisma.notification.create({ data: { message: cSeed.visitNotesIdentifier, visitId: visit.id, tenantId: mainTenant.id, userId: adminUser.id, priority: 'HIGH' }});
        allNotifications.push(notification);

        for(const cons of cSeed.consumptions) {
            const p = createdProducts.find(pr => pr.name === cons.productName);
            if(p) await prisma.consumption.create({ data: { visitId: visit.id, productId: p.id, quantity: cons.quantity }});
        }
    }
    console.log(`   - Marcadas ${allNotifications.length} visitas como completadas con datos de demo.`);

    let taskCount = 0;
    for (const tSeed of incidentTasksData) {
      const pNotification = allNotifications.find(n => n.message.includes(tSeed.notificationMessage));
      if (!pNotification) continue;
      
      const aUser = tSeed.task.title.includes('Contactar') ? adminUser : technicians.find(t => t.isAvailable);
      if (aUser) {
        await prisma.incidentTask.create({ data: { ...tSeed.task, notificationId: pNotification.id, assignedToId: aUser.id, tenantId: mainTenant.id, createdById: adminUser.id } });
        taskCount++;
      }
    }
    console.log(`   - Creadas ${taskCount} tareas de incidencia.`);


    console.log('\n\n‚úÖ Seeding de demostraci√≥n v9.1 completado con √©xito!');
    console.log('--- Credenciales de prueba ---');
    console.log('SuperAdmin: super@admin.com / superadmin123');
    console.log('Admin:      admin@piscival.com / password123');
    console.log('T√©cnicos:   carlos.t@piscival.com, ana.t@piscival.com, leo.a@piscival.com (pass: password123)');
    console.log('Manager:    manager@piscival.com / password123');

  } catch (e) {
    console.error('‚ùå Error fatal durante el proceso de seeding:', e);
    await prisma.$disconnect();
    return;
  } finally {
    await prisma.$disconnect();
  }
}

main();


// ====== [59] packages/server/src/api/auth/auth.controller.ts ======
import type { Response, NextFunction } from 'express';
import { register, login } from './auth.service.js';
import { signToken } from '../../utils/jwt.utils.js';
import config from '../../config/index.js';
import type { CookieOptions, Request } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';

const cookieOptions: CookieOptions = {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'lax',
  maxAge: config.JWT_EXPIRES_IN * 1000, // maxAge est√° en milisegundos
};

/**
 * Maneja la petici√≥n de registro de un nuevo usuario.
 */
export const registerHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const user = await register(req.body);
    res.status(201).json({
      success: true,
      data: user,
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la petici√≥n de login de un usuario.
 */
export const loginHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const user = await login(req.body);
    const token = signToken({ id: user.id, role: user.role });
    res.cookie('token', token, cookieOptions);
    res.status(200).json({
      success: true,
      data: user,
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n del usuario actualmente autenticado (a trav√©s del token).
 */
export const getMeHandler = (req: AuthRequest, res: Response) => {
  // El middleware 'protect' se ejecuta antes que este manejador.
  // Si llega hasta aqu√≠, significa que el token es v√°lido y 'req.user' existe.
  res.status(200).json({
    success: true,
    data: req.user,
  });
};


// ====== [60] packages/server/src/api/auth/auth.routes.ts ======
import { Router } from 'express';
import type { Response } from 'express';
import {
  registerHandler,
  loginHandler,
  getMeHandler,
} from './auth.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const authRouter = Router();

/**
 * @route   POST /api/auth/register
 * @desc    Registra un nuevo usuario
 * @access  Public
 */
authRouter.post('/register', registerHandler);

/**
 * @route   POST /api/auth/login
 * @desc    Inicia sesi√≥n y devuelve un token en una cookie
 * @access  Public
 */
authRouter.post('/login', loginHandler);

/**
 * @route   GET /api/auth/me
 * @desc    Obtiene los datos del usuario logueado a partir de su token
 * @access  Private
 */
authRouter.get('/me', protect, getMeHandler);

/**
 * @route   POST /api/auth/logout
 * @desc    Cierra la sesi√≥n del usuario eliminando la cookie
 * @access  Public
 */
authRouter.post('/logout', (_req, res: Response) => {
  res.cookie('token', '', {
    httpOnly: true,
    expires: new Date(0),
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
  });
  res.status(200).json({ success: true, message: 'Sesi√≥n cerrada con √©xito.' });
});

export default authRouter;


// ====== [61] packages/server/src/api/auth/auth.service.ts ======
import { PrismaClient } from '@prisma/client';
import type { User } from '@prisma/client';
import { hashPassword, comparePassword } from '../../utils/password.utils.js';

const prisma = new PrismaClient();

// Tipo para la entrada de datos del registro.
export type RegisterUserInput = Omit<User, 'id' | 'createdAt' | 'updatedAt'>;

// Tipo para la entrada de datos del login.
export type LoginUserInput = {
  email: string;
  password: string;
};

/**
 * Registra un nuevo usuario en la base de datos.
 * @param input - Datos del usuario para el registro.
 * @returns El objeto de usuario creado (sin la contrase√±a).
 */
export const register = async (input: RegisterUserInput) => {
  const { email, password, ...rest } = input;

  const existingUser = await prisma.user.findUnique({
    where: { email },
  });

  if (existingUser) {
    throw new Error('Ya existe un usuario con este correo electr√≥nico.');
  }

  const hashedPassword = await hashPassword(password);

  const user = await prisma.user.create({
    data: {
      email,
      password: hashedPassword,
      ...rest,
    },
    select: {
      id: true,
      email: true,
      name: true,
      role: true,
      tenantId: true,
      createdAt: true,
      updatedAt: true,
    },
  });

  return user;
};

/**
 * Valida las credenciales de un usuario para el login.
 * @param input - Email y contrase√±a del usuario.
 * @returns El objeto de usuario autenticado (sin la contrase√±a).
 */
export const login = async (input: LoginUserInput): Promise<Omit<User, 'password'>> => {
  const user = await prisma.user.findUnique({
    where: { email: input.email },
  });

  if (!user) {
    throw new Error('El email o la contrase√±a son incorrectos.');
  }

  const isPasswordValid = await comparePassword(input.password, user.password);

  if (!isPasswordValid) {
    throw new Error('El email o la contrase√±a son incorrectos.');
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const { password, ...userWithoutPassword } = user;

  return userWithoutPassword;
};


// ====== [62] packages/server/src/api/client-product-pricing/client-product-pricing.controller.ts ======
// filename: packages/server/src/api/client-product-pricing/client-product-pricing.controller.ts
// version: 1.0.0
// description: Controlador para manejar las peticiones HTTP del CRUD de reglas de precios.

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createPricingRule,
  getPricingRulesByClient,
  updatePricingRule,
  deletePricingRule,
} from './client-product-pricing.service.js';

/**
 * Maneja la creaci√≥n de una nueva regla de precios.
 */
export const createPricingRuleHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    // Aqu√≠ el clientId vendr√° en el cuerpo de la petici√≥n.
    // Podr√≠amos a√±adir una validaci√≥n para asegurar que el cliente pertenece al tenant del usuario.
    const newRule = await createPricingRule(req.body);
    res.status(201).json({ success: true, data: newRule });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todas las reglas de precios de un cliente.
 */
export const getPricingRulesByClientHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { clientId } = req.params;
    if (!clientId) {
      return res.status(400).json({ success: false, message: 'El ID del cliente es requerido.' });
    }
    // TODO: Validar que el cliente pertenece al tenant del usuario.
    const rules = await getPricingRulesByClient(clientId);
    res.status(200).json({ success: true, data: rules });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n de una regla de precios.
 */
export const updatePricingRuleHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ success: false, message: 'El ID de la regla es requerido.' });
    }
    // TODO: Validar que la regla pertenece a un cliente del tenant del usuario.
    const updatedRule = await updatePricingRule(id, req.body);
    res.status(200).json({ success: true, data: updatedRule });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de una regla de precios.
 */
export const deletePricingRuleHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ success: false, message: 'El ID de la regla es requerido.' });
    }
    // TODO: Validar que la regla pertenece a un cliente del tenant del usuario.
    await deletePricingRule(id);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [63] packages/server/src/api/client-product-pricing/client-product-pricing.routes.ts ======
// filename: packages/server/src/api/client-product-pricing/client-product-pricing.routes.ts
// version: 2.0.0 (FEAT: Protect routes with ADMIN authorization)

import { Router } from 'express';
import {
  createPricingRuleHandler,
  getPricingRulesByClientHandler,
  updatePricingRuleHandler,
  deletePricingRuleHandler,
} from './client-product-pricing.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const clientProductPricingRouter = Router();

// Protegemos todas las rutas de este m√≥dulo.
// Solo los usuarios autenticados con rol de ADMIN pueden gestionar las reglas de precios.
clientProductPricingRouter.use(protect, authorize('ADMIN'));


// Ruta para crear una nueva regla
clientProductPricingRouter.post('/', createPricingRuleHandler);

// Ruta para obtener todas las reglas de un cliente espec√≠fico
clientProductPricingRouter.get('/by-client/:clientId', getPricingRulesByClientHandler);

// Rutas para actualizar o eliminar una regla espec√≠fica por su ID
clientProductPricingRouter.route('/:id')
  .patch(updatePricingRuleHandler)
  .delete(deletePricingRuleHandler);

export default clientProductPricingRouter;


// ====== [64] packages/server/src/api/client-product-pricing/client-product-pricing.service.ts ======
// filename: packages/server/src/api/client-product-pricing/client-product-pricing.service.ts
// version: 1.0.0
// description: Servicio para la l√≥gica de negocio de las reglas de precios.

import { PrismaClient } from '@prisma/client';
import type { ClientProductPricing } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreatePricingRuleInput = {
  clientId: string;
  discountPercentage: number;
  productId?: string;
  productCategoryId?: string;
};

export type UpdatePricingRuleInput = {
  discountPercentage: number;
};

/**
 * Crea una nueva regla de precios para un cliente.
 * @param data - Los datos de la regla.
 * @returns La regla reci√©n creada.
 */
export const createPricingRule = async (data: CreatePricingRuleInput): Promise<ClientProductPricing> => {
  // La unicidad se maneja a nivel de base de datos con @@unique
  return prisma.clientProductPricing.create({
    data,
  });
};

/**
 * Obtiene todas las reglas de precios para un cliente espec√≠fico.
 * @param clientId - El ID del cliente.
 * @returns Un array con todas las reglas de precios del cliente.
 */
export const getPricingRulesByClient = async (clientId: string): Promise<ClientProductPricing[]> => {
  return prisma.clientProductPricing.findMany({
    where: { clientId },
    include: {
      product: { select: { name: true } },
      productCategory: { select: { name: true } },
    },
    orderBy: {
      // Opcional: alg√∫n orden l√≥gico si se desea
      product: { name: 'asc' },
    },
  });
};

/**
 * Actualiza una regla de precios existente.
 * @param id - El ID de la regla a actualizar.
 * @param data - Los datos a modificar (solo el descuento).
 * @returns La regla actualizada.
 */
export const updatePricingRule = async (id: string, data: UpdatePricingRuleInput): Promise<ClientProductPricing> => {
  return prisma.clientProductPricing.update({
    where: { id },
    data,
  });
};

/**
 * Elimina una regla de precios.
 * @param id - El ID de la regla a eliminar.
 */
export const deletePricingRule = async (id: string): Promise<void> => {
  await prisma.clientProductPricing.delete({
    where: { id },
  });
};


// ====== [65] packages/server/src/api/clients/clients.controller.ts ======
// filename: packages/server/src/api/clients/clients.controller.ts
// Version: 2.0.0 (FEAT: Pass tenantId to service for validation)

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createClient,
  deleteClient,
  getClientById,
  getClientsByTenant,
  updateClient,
} from './clients.service.js';

/**
 * Maneja la creaci√≥n de un nuevo cliente.
 */
export const createClientHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }

    const input = { ...req.body, tenantId };
    const newClient = await createClient(input);
    res.status(201).json({ success: true, data: newClient });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todos los clientes de un tenant.
 */
export const getClientsByTenantHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }

    const clients = await getClientsByTenant(tenantId);
    res.status(200).json({ success: true, data: clients });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de un cliente espec√≠fico por ID.
 */
export const getClientByIdHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    const { id: clientId } = req.params;

    if (!tenantId || !clientId) {
      return res.status(400).json({ success: false, message: 'ID de cliente o de tenant faltante.' });
    }

    const client = await getClientById(clientId, tenantId);
    if (!client) {
      return res.status(404).json({ success: false, message: 'Cliente no encontrado.' });
    }

    res.status(200).json({ success: true, data: client });
  } catch (error) {
    next(error);
  }
};


/**
 * Maneja la actualizaci√≥n de un cliente.
 */
export const updateClientHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;
    
    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de cliente o de tenant faltante.' });
    }
    
    const updatedClient = await updateClient(id, tenantId, req.body);
    res.status(200).json({ success: true, data: updatedClient });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de un cliente.
 */
export const deleteClientHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de cliente o de tenant faltante.' });
    }

    await deleteClient(id, tenantId);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [66] packages/server/src/api/clients/clients.routes.ts ======
// filename: packages/server/src/api/clients/clients.routes.ts
// Version: 2.0.0 (FEAT: Protect routes with ADMIN/MANAGER authorization)

import { Router } from 'express';
import {
  createClientHandler,
  deleteClientHandler,
  getClientByIdHandler,
  getClientsByTenantHandler,
  updateClientHandler,
} from './clients.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const clientsRouter = Router();

// Aplicamos el middleware 'protect' a TODAS las rutas de este enrutador.
clientsRouter.use(protect);

// Las rutas para listar y crear clientes solo son accesibles para ADMINS.
clientsRouter.route('/')
  .get(authorize('ADMIN', 'MANAGER'), getClientsByTenantHandler)
  .post(authorize('ADMIN'), createClientHandler);

// Las rutas para un cliente espec√≠fico son accesibles para ADMIN y MANAGER para ver,
// pero solo para ADMIN para modificar o eliminar.
// Esto permite al MANAGER ver los detalles del cliente desde su dashboard.
clientsRouter.route('/:id')
  .get(authorize('ADMIN', 'MANAGER'), getClientByIdHandler)
  .patch(authorize('ADMIN'), updateClientHandler)
  .delete(authorize('ADMIN'), deleteClientHandler);

export default clientsRouter;


// ====== [67] packages/server/src/api/clients/clients.service.ts ======
// filename: packages/server/src/api/clients/clients.service.ts
// Version: 2.0.0 (FEAT: Add tenantId validation for CUD operations)

import { PrismaClient } from '@prisma/client';
import type { Client } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateClientInput = Omit<Client, 'id' | 'createdAt' | 'updatedAt'>;
export type UpdateClientInput = Partial<Omit<CreateClientInput, 'tenantId' | 'createdAt' | 'updatedAt'>>;

// --- Funciones del Servicio ---

/**
 * Crea un nuevo cliente para un tenant espec√≠fico.
 * @param data - Datos del nuevo cliente.
 * @returns El cliente creado.
 */
export const createClient = async (data: CreateClientInput): Promise<Client> => {
  return prisma.client.create({
    data,
  });
};

/**
 * Obtiene todos los clientes de un tenant espec√≠fico.
 * @param tenantId - El ID del tenant.
 * @returns Un array de clientes.
 */
export const getClientsByTenant = async (tenantId: string): Promise<Client[]> => {
  return prisma.client.findMany({
    where: { tenantId },
    orderBy: { name: 'asc' },
    include: {
      pools: true,
    },
  });
};

/**
 * Obtiene un cliente espec√≠fico por su ID.
 * @param id - El ID del cliente a buscar.
 * @param tenantId - El ID del tenant para asegurar la pertenencia.
 * @returns El objeto del cliente o null si no se encuentra o no pertenece al tenant.
 */
export const getClientById = async (id: string, tenantId: string): Promise<Client | null> => {
  return prisma.client.findFirst({
    where: { id, tenantId },
     include: {
      pools: true,
    },
  });
};


/**
 * Actualiza un cliente existente, verificando la pertenencia al tenant.
 * @param id - El ID del cliente a actualizar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 * @param data - Los datos a actualizar.
 * @returns El cliente actualizado.
 */
export const updateClient = async (id: string, tenantId: string, data: UpdateClientInput): Promise<Client> => {
  const { count } = await prisma.client.updateMany({
    where: {
      id,
      tenantId, // <-- Condici√≥n de seguridad
    },
    data,
  });

  if (count === 0) {
    throw new Error('Cliente no encontrado o sin permisos para modificar.');
  }

  return prisma.client.findUniqueOrThrow({ where: { id } });
};

/**
 * Elimina un cliente, verificando la pertenencia al tenant.
 * @param id - El ID del cliente a eliminar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 */
export const deleteClient = async (id: string, tenantId: string): Promise<void> => {
  const { count } = await prisma.client.deleteMany({
    where: {
      id,
      tenantId, // <-- Condici√≥n de seguridad
    },
  });

  if (count === 0) {
    throw new Error('Cliente no encontrado o sin permisos para eliminar.');
  }
};


// ====== [68] packages/server/src/api/dashboard/dashboard.controller.ts ======
// ====== [58] packages/server/src/api/dashboard/dashboard.controller.ts ======
// filename: packages/server/src/api/dashboard/dashboard.controller.ts
// version: 2.0.0 (FEAT: Handle date range parameters from query)
// description: The controller now reads startDate and endDate from the query string, providing a default if they are absent.

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { getManagerDashboardData } from './dashboard.service.js';
// ‚úÖ 1. Importar utilidades de fecha para el rango por defecto
import { subDays, endOfDay } from 'date-fns';

/**
 * Maneja la obtenci√≥n de todos los datos agregados para el dashboard del manager.
 */
export const getManagerDashboardHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    if (!req.user || !req.user.tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida. Usuario o Tenant no identificado.' });
    }
    
    const tenantId = req.user.tenantId;

    if (req.user.role !== 'MANAGER' && req.user.role !== 'SUPER_ADMIN') {
        return res.status(403).json({ success: false, message: 'Acceso denegado. Se requiere rol de Manager.'})
    }

    // ‚úÖ 2. Leer los par√°metros de fecha de la query string
    const { startDate: startDateStr, endDate: endDateStr } = req.query;

    let startDate: Date;
    let endDate: Date;

    // ‚úÖ 3. Establecer rango por defecto si no se proporcionan fechas
    if (startDateStr && endDateStr && typeof startDateStr === 'string' && typeof endDateStr === 'string') {
        startDate = new Date(startDateStr);
        endDate = new Date(endDateStr);
        
        // ‚úÖ 4. Validar las fechas recibidas
        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
            return res.status(400).json({ success: false, message: 'Formato de fecha inv√°lido.' });
        }
    } else {
        // Rango por defecto: √∫ltimos 30 d√≠as
        const today = new Date();
        startDate = subDays(today, 30);
        endDate = endOfDay(today); // Aseguramos que incluya todo el d√≠a de hoy
    }
    
    // ‚úÖ 5. Pasar el rango de fechas al servicio
    const dashboardData = await getManagerDashboardData(tenantId, startDate, endDate);
    res.status(200).json({ success: true, data: dashboardData });
  } catch (error) {
    next(error);
  }
};


// ====== [69] packages/server/src/api/dashboard/dashboard.routes.ts ======
// filename: packages/server/src/api/dashboard/dashboard.routes.ts
// version: 1.0.0
// description: Define el endpoint de la API para los datos del Dashboard de Gerencia.

import { Router } from 'express';
import { getManagerDashboardHandler } from './dashboard.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const dashboardRouter = Router();

// Protegemos la ruta para que solo usuarios autenticados puedan acceder.
dashboardRouter.use(protect);

/**
 * @route   GET /api/dashboard/manager
 * @desc    Obtiene todos los datos agregados para el Dashboard de Gerencia.
 * @access  Private (Manager)
 */
dashboardRouter.get('/manager', getManagerDashboardHandler);

export default dashboardRouter;


// ====== [70] packages/server/src/api/dashboard/dashboard.service.ts ======
// ====== [60] packages/server/src/api/dashboard/dashboard.service.ts ======
// filename: packages/server/src/api/dashboard/dashboard.service.ts
// version: 2.2.1 (FIX: Correct field names and group by accessors)
// description: Fixed errors related to non-existent fields in where clauses and incorrect access to groupBy count.

import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

interface DashboardData {
  financials: {
    totalRevenue: number;
    totalCosts: number;
    netProfit: number;
  };
  incidents: {
    openIncidents: number;
    resolvedThisMonth: number;
    avgResolutionTimeHours: number | null;
  };
  topClientsByProfit: {
    clientId: string;
    clientName: string;
    netProfit: number;
    totalRevenue: number;
    totalCosts: number;
  }[];
  topProductsByCost: {
    productId: string;
    productName: string;
    totalCost: number;
  }[];
  teamPerformance: {
    technicianId: string;
    technicianName: string;
    completedVisits: number;
    completedTasks: number;
  }[];
}

export const getManagerDashboardData = async (
  tenantId: string,
  startDate: Date,
  endDate: Date
): Promise<DashboardData> => {
  // --- 1. Datos Financieros (Periodo Seleccionado) ---
  const expenses = await prisma.expense.aggregate({
    _sum: { amount: true },
    where: { tenantId, expenseDate: { gte: startDate, lte: endDate } },
  });

  const consumptions = await prisma.consumption.findMany({
    where: {
      visit: {
        pool: { tenantId },
        timestamp: { gte: startDate, lte: endDate },
      },
    },
    include: {
      product: true,
      visit: {
        include: {
          pool: true,
        },
      },
    },
  });
  
  const totalConsumptionCost = consumptions.reduce((sum, c) => sum + (c.quantity * c.product.cost), 0);
  const totalCosts = (expenses._sum.amount || 0) + totalConsumptionCost;

  const clientsForRevenue = await prisma.client.findMany({ where: { tenantId } });
  const totalFees = clientsForRevenue.reduce((sum, c) => sum + c.monthlyFee, 0); 
  const totalMaterialsRevenue = consumptions.reduce((sum, c) => sum + (c.quantity * c.product.salePrice), 0);
  const totalRevenue = totalFees + totalMaterialsRevenue;

  // --- 2. Datos de Incidencias ---
  const openIncidents = await prisma.notification.count({
    where: { tenantId, status: 'PENDING' },
  });
  
  const resolvedThisMonth = await prisma.notification.count({
    where: {
      tenantId,
      status: 'RESOLVED',
      // ‚úÖ CORRECCI√ìN: 'createdAt' no existe en el modelo Notification, se elimina el filtro de fecha aqu√≠, 
      // la l√≥gica se mantiene en el esp√≠ritu de "resueltas en el periodo".
      // Para una l√≥gica m√°s precisa, necesitar√≠amos un campo 'resolvedAt'.
    },
  });

  // --- 3. Top 5 Clientes por Rentabilidad (en el periodo) ---
  const clientsWithPricing = await prisma.client.findMany({
    where: { tenantId },
    include: { clientPricingRules: true }, 
  });

  const clientProfits = clientsWithPricing.map(client => {
    let clientRevenue = client.monthlyFee;
    const clientConsumptions = consumptions.filter(c => c.visit.pool.clientId === client.id);

    if (client.billingModel !== 'ALL_INCLUSIVE') {
      for (const consumption of clientConsumptions) {
        const product = consumption.product;
        let finalSalePrice = product.salePrice;
        
        const productRule = client.clientPricingRules.find(r => r.productId === product.id);
        const categoryRule = client.clientPricingRules.find(r => r.productCategoryId === product.categoryId);

        if (productRule) {
          finalSalePrice *= (1 - productRule.discountPercentage / 100);
        } else if (categoryRule) {
          finalSalePrice *= (1 - categoryRule.discountPercentage / 100);
        } else {
          finalSalePrice *= client.priceModifier;
        }
        clientRevenue += consumption.quantity * finalSalePrice;
      }
    }

    const clientCosts = clientConsumptions.reduce((sum, c) => sum + (c.quantity * c.product.cost), 0);
    
    return {
      clientId: client.id,
      clientName: client.name,
      totalRevenue: clientRevenue,
      totalCosts: clientCosts,
      netProfit: clientRevenue - clientCosts,
    };
  });

  const topClientsByProfit = clientProfits
    .sort((a, b) => b.netProfit - a.netProfit)
    .slice(0, 5);


  // --- 4. Top 5 Productos por Coste (en el periodo) ---
  const productCosts = await prisma.consumption.groupBy({
    by: ['productId'],
    _sum: { quantity: true },
    where: {
        visit: {
            pool: { tenantId },
            timestamp: { gte: startDate, lte: endDate },
        }
    },
  });
  
  const productDetails = await prisma.product.findMany({
    where: { id: { in: productCosts.map(p => p.productId) } },
  });

  const topProductsByCost = productCosts.map(p => {
    const detail = productDetails.find(d => d.id === p.productId);
    return {
      productId: p.productId,
      productName: detail?.name || 'Desconocido',
      totalCost: (p._sum.quantity || 0) * (detail?.cost || 0),
    };
  }).sort((a, b) => b.totalCost - a.totalCost).slice(0, 5);
  
  // --- 5. Nuevas consultas para el rendimiento del equipo ---
  const visitsByTechnician = await prisma.visit.groupBy({
    by: ['technicianId'],
    where: {
      pool: { tenantId },
      status: 'COMPLETED',
      technicianId: { not: null },
      timestamp: { gte: startDate, lte: endDate }
    },
    _count: { id: true }, // ‚úÖ CORRECCI√ìN: Contar por un campo espec√≠fico como 'id'
  });

  const tasksByTechnician = await prisma.incidentTask.groupBy({
    by: ['assignedToId'],
    where: {
      tenantId,
      status: 'COMPLETED',
      assignedToId: { not: null },
      // ‚úÖ CORRECCI√ìN: 'updatedAt' no existe en IncidentTask, se elimina el filtro de fecha
    },
    _count: { id: true }, // ‚úÖ CORRECCI√ìN: Contar por un campo espec√≠fico como 'id'
  });
  
  // --- 6. L√≥gica para fusionar los datos ---
  const technicians = await prisma.user.findMany({
    where: { tenantId, role: 'TECHNICIAN' },
    select: { id: true, name: true }
  });

  const teamPerformance = technicians.map(tech => {
    const visitData = visitsByTechnician.find(v => v.technicianId === tech.id);
    const taskData = tasksByTechnician.find(t => t.assignedToId === tech.id);
    return {
      technicianId: tech.id,
      technicianName: tech.name,
      // ‚úÖ CORRECCI√ìN: Acceder al contador a trav√©s de `_count.id`
      completedVisits: visitData?._count.id || 0,
      completedTasks: taskData?._count.id || 0,
    };
  });

  return {
    financials: {
      totalRevenue,
      totalCosts,
      netProfit: totalRevenue - totalCosts,
    },
    incidents: {
      openIncidents,
      resolvedThisMonth,
      avgResolutionTimeHours: null,
    },
    topClientsByProfit,
    topProductsByCost,
    teamPerformance,
  };
};


// ====== [71] packages/server/src/api/expenses/expenses.controller.ts ======
// filename: packages/server/src/api/expenses/expenses.controller.ts
// version: 1.0.0
// description: Controlador para manejar las peticiones HTTP del CRUD de gastos.

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createExpense,
  getExpensesByTenant,
  deleteExpense,
} from './expenses.service.js';

/**
 * Maneja la creaci√≥n de un nuevo gasto.
 */
export const createExpenseHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }
    const input = { ...req.body, tenantId };
    const newExpense = await createExpense(input);
    res.status(201).json({ success: true, data: newExpense });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todos los gastos de un tenant.
 */
export const getExpensesByTenantHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }
    const expenses = await getExpensesByTenant(tenantId);
    res.status(200).json({ success: true, data: expenses });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de un gasto.
 */
export const deleteExpenseHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ success: false, message: 'El ID del gasto es requerido.' });
    }
    // TODO: Validar que el gasto pertenece al tenant del usuario.
    await deleteExpense(id);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [72] packages/server/src/api/expenses/expenses.routes.ts ======
// filename: packages/server/src/api/expenses/expenses.routes.ts
// version: 2.0.0 (FEAT: Protect routes with ADMIN authorization)

import { Router } from 'express';
import {
  createExpenseHandler,
  getExpensesByTenantHandler,
  deleteExpenseHandler,
} from './expenses.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const expensesRouter = Router();

// Protegemos todas las rutas de este m√≥dulo.
// Solo los usuarios autenticados con rol de ADMIN pueden gestionar los gastos.
expensesRouter.use(protect, authorize('ADMIN'));


// Rutas para /api/expenses
expensesRouter.route('/')
  .get(getExpensesByTenantHandler)
  .post(createExpenseHandler);

// Ruta para eliminar un gasto espec√≠fico por su ID
expensesRouter.delete('/:id', deleteExpenseHandler);

export default expensesRouter;


// ====== [73] packages/server/src/api/expenses/expenses.service.ts ======
// filename: packages/server/src/api/expenses/expenses.service.ts
// version: 1.0.0
// description: Servicio para la l√≥gica de negocio de los gastos de la empresa.

import { PrismaClient } from '@prisma/client';
import type { Expense } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateExpenseInput = Omit<Expense, 'id'>;

/**
 * Crea un nuevo registro de gasto para un tenant.
 * @param data - Los datos del gasto a crear.
 * @returns El gasto reci√©n creado.
 */
export const createExpense = async (data: CreateExpenseInput): Promise<Expense> => {
  return prisma.expense.create({
    data,
  });
};

/**
 * Obtiene todos los gastos de un tenant espec√≠fico.
 * @param tenantId - El ID del tenant.
 * @returns Un array con todos los gastos del tenant.
 */
export const getExpensesByTenant = async (tenantId: string): Promise<Expense[]> => {
  return prisma.expense.findMany({
    where: { tenantId },
    orderBy: { expenseDate: 'desc' },
  });
};

/**
 * Elimina un registro de gasto.
 * @param id - El ID del gasto a eliminar.
 */
export const deleteExpense = async (id: string): Promise<void> => {
  await prisma.expense.delete({
    where: { id },
  });
};


// ====== [74] packages/server/src/api/incident-tasks/incident-tasks.controller.ts ======
// filename: packages/server/src/api/incident-tasks/incident-tasks.controller.ts
// version: 1.3.1 (Cleaned)

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createIncidentTask,
  getTasksByNotificationId,
  updateIncidentTask,
  deleteIncidentTask,
  getTasksAssignedToUser,
  updateTaskStatus,
  addTaskLog,
  getTaskLogs,
  updateTaskDeadline,
} from './incident-tasks.service.js';

export const getMyAssignedTasksHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const userId = req.user?.id;
    if (!userId) { return res.status(401).json({ success: false, message: 'Usuario no autenticado.' }); }
    const tasks = await getTasksAssignedToUser(userId);
    res.status(200).json({ success: true, data: tasks });
  } catch (error) { next(error); }
};

export const createIncidentTaskHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const tenantId = req.user?.tenantId;
    const actorId = req.user?.id;

    if (!tenantId || !actorId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida. Usuario o tenant no identificado.' });
    }

    const input = { ...req.body, tenantId };
    const newTask = await createIncidentTask(input, actorId);
    res.status(201).json({ success: true, data: newTask });
  } catch (error) {
    next(error);
  }
};

export const getTasksByNotificationHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) { return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' }); }
    const { notificationId } = req.params;
    if (!notificationId) { return res.status(400).json({ success: false, message: 'El ID de la notificaci√≥n es requerido.' }); }
    const tasks = await getTasksByNotificationId(notificationId, tenantId);
    res.status(200).json({ success: true, data: tasks });
  } catch (error) { next(error); }
};

export const updateIncidentTaskHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const { id } = req.params;
    if (!id) { return res.status(400).json({ success: false, message: 'El ID de la tarea es requerido.' }); }
    
    const updatedTask = await updateIncidentTask(id, req.body);
    res.status(200).json({ success: true, data: updatedTask });
  } catch (error) { 
    next(error); 
  }
};

export const deleteIncidentTaskHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const { id } = req.params;
    if (!id) { return res.status(400).json({ success: false, message: 'El ID de la tarea es requerido.' }); }
    await deleteIncidentTask(id);
    res.status(204).send();
  } catch (error) { next(error); }
};

export const updateTaskStatusHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
    try {
        const { id: taskId } = req.params;
        const actorId = req.user?.id;
        const { status, resolutionNotes } = req.body;
        if (!taskId) { return res.status(400).json({ success: false, message: 'El ID de la tarea es requerido.'}); }
        if (!actorId) { return res.status(401).json({ success: false, message: 'Usuario no autenticado.'}); }
        if (!status) { return res.status(400).json({ success: false, message: 'El estado es requerido.'}); }

        const updatedTask = await updateTaskStatus(taskId, actorId, status, resolutionNotes);
        res.status(200).json({ success: true, data: updatedTask });
    } catch (error) {
        next(error);
    }
};

export const addTaskLogHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
    try {
        const { id: taskId } = req.params;
        const actorId = req.user?.id;
        if (!taskId) { return res.status(400).json({ success: false, message: 'El ID de la tarea es requerido.'}); }
        if (!actorId) { return res.status(401).json({ success: false, message: 'Usuario no autenticado.'}); }
        
        const log = await addTaskLog(taskId, actorId, req.body);
        res.status(201).json({ success: true, data: log });
    } catch (error) {
        next(error);
    }
};

export const getTaskLogsHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
    try {
        const { id: taskId } = req.params;
        if (!taskId) { return res.status(400).json({ success: false, message: 'El ID de la tarea es requerido.'}); }
        
        const logs = await getTaskLogs(taskId);
        res.status(200).json({ success: true, data: logs });
    } catch (error) {
        next(error);
    }
};

export const updateTaskDeadlineHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
    try {
        const { id: taskId } = req.params;
        const actorId = req.user?.id;
        const { deadline } = req.body;
        if (!taskId) { return res.status(400).json({ success: false, message: 'El ID de la tarea es requerido.'}); }
        if (!actorId) { return res.status(401).json({ success: false, message: 'Usuario no autenticado.'}); }
        if (typeof deadline !== 'string' || !deadline) { return res.status(400).json({ success: false, message: 'Se requiere un plazo (deadline) v√°lido.'}); }

        const updatedTask = await updateTaskDeadline(taskId, deadline, actorId);
        res.status(200).json({ success: true, data: updatedTask });
    } catch (error) {
        next(error);
    }
};


// ====== [75] packages/server/src/api/incident-tasks/incident-tasks.routes.ts ======
// filename: packages/server/src/api/incident-tasks/incident-tasks.routes.ts
// version: 2.0.0 (FEAT: Protect routes with granular ADMIN/TECHNICIAN authorization)

import { Router } from 'express';
import {
  createIncidentTaskHandler,
  getTasksByNotificationHandler,
  updateIncidentTaskHandler,
  deleteIncidentTaskHandler,
  getMyAssignedTasksHandler,
  updateTaskStatusHandler,
  addTaskLogHandler,
  getTaskLogsHandler,
  updateTaskDeadlineHandler,
} from './incident-tasks.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const incidentTasksRouter = Router();

// Todas las rutas de tareas de incidencia requieren autenticaci√≥n.
incidentTasksRouter.use(protect);

// --- Rutas Generales y de Listado ---
// El t√©cnico ve sus tareas pendientes.
incidentTasksRouter.get('/my-tasks', authorize('TECHNICIAN'), getMyAssignedTasksHandler);
// El admin ve las tareas asociadas a una notificaci√≥n.
incidentTasksRouter.get('/by-notification/:notificationId', authorize('ADMIN'), getTasksByNotificationHandler);
// Solo el admin puede crear tareas.
incidentTasksRouter.post('/', authorize('ADMIN'), createIncidentTaskHandler);


// --- Rutas para una Tarea Espec√≠fica por ID ---
// Tanto admin como t√©cnico pueden ver el historial de una tarea.
incidentTasksRouter.get('/:id/logs', authorize('ADMIN', 'TECHNICIAN'), getTaskLogsHandler);
// Tanto admin como t√©cnico pueden a√±adir comentarios/logs.
incidentTasksRouter.post('/:id/log', authorize('ADMIN', 'TECHNICIAN'), addTaskLogHandler);
// El t√©cnico actualiza el estado (ej: a IN_PROGRESS o COMPLETED).
incidentTasksRouter.patch('/:id/status', authorize('TECHNICIAN'), updateTaskStatusHandler);
// El admin actualiza el plazo (deadline).
incidentTasksRouter.patch('/:id/deadline', authorize('ADMIN'), updateTaskDeadlineHandler);
// El admin edita los detalles principales de la tarea.
incidentTasksRouter.patch('/:id', authorize('ADMIN'), updateIncidentTaskHandler);
// El admin elimina la tarea.
incidentTasksRouter.delete('/:id', authorize('ADMIN'), deleteIncidentTaskHandler);

export default incidentTasksRouter;


// ====== [76] packages/server/src/api/incident-tasks/incident-tasks.service.ts ======
// filename: packages/server/src/api/incident-tasks/incident-tasks.service.ts
// version: 1.6.2 (FIXED)
// description: Se corrige la funci√≥n createIncidentTask para que asigne el 'createdById' al crear una nueva tarea, solucionando el error de tipo de TypeScript.

import { PrismaClient } from '@prisma/client';
import type { IncidentTask, IncidentPriority, IncidentTaskStatus, IncidentTaskLog } from '@prisma/client';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateIncidentTaskInput = {
  title: string;
  notificationId: string;
  tenantId: string;
  description?: string;
  priority?: IncidentPriority;
  assignedToId?: string;
};

export type UpdateIncidentTaskInput = {
  title?: string;
  description?: string;
  status?: IncidentTaskStatus;
  priority?: IncidentPriority;
  assignedToId?: string | null;
  resolutionNotes?: string;
  deadline?: string | null;
};

export type AddLogInput = {
  details: string;
  newDeadline?: string;
};

// --- Funciones del Servicio ---

export const createIncidentTask = async (data: CreateIncidentTaskInput, actorId: string): Promise<IncidentTask> => {
  const task = await prisma.incidentTask.create({
    data: {
      title: data.title,
      description: data.description,
      priority: data.priority,
      notificationId: data.notificationId,
      assignedToId: data.assignedToId,
      tenantId: data.tenantId,
      createdById: actorId, // ‚úÖ CORRECCI√ìN APLICADA AQU√ç
    },
  });
  await prisma.incidentTaskLog.create({
    data: {
      action: 'CREATION',
      details: `Tarea creada.`,
      incidentTaskId: task.id,
      userId: actorId,
    }
  });
  return task;
};

export const getTasksByNotificationId = async (notificationId: string, tenantId: string): Promise<IncidentTask[]> => {
  return prisma.incidentTask.findMany({
    where: { notificationId, tenantId },
    select: {
      id: true,
      title: true,
      description: true,
      status: true,
      priority: true,
      deadline: true,
      resolutionNotes: true,
      assignedTo: {
        select: {
          id: true,
          name: true,
        },
      },
      notificationId: true, 
      assignedToId: true,
      tenantId: true,
      createdById: true, // Incluir el campo para futuras referencias
      logs: false, 
    },
    orderBy: [{ priority: 'desc' }, { id: 'asc' }],
  });
};

export const getTasksAssignedToUser = async (userId: string): Promise<IncidentTask[]> => {
  return prisma.incidentTask.findMany({ where: { assignedToId: userId, status: { in: ['PENDING', 'IN_PROGRESS'], }, }, include: { notification: { include: { visit: { include: { pool: { select: { name: true } } } } } } }, orderBy: { priority: 'desc', }, });
};

export const updateIncidentTask = async (id: string, data: UpdateIncidentTaskInput): Promise<IncidentTask> => {
  return prisma.$transaction(async (tx) => {
    const originalTask = await tx.incidentTask.findUniqueOrThrow({
      where: { id },
      include: { assignedTo: true }
    });

    const updatedTask = await tx.incidentTask.update({
        where: { id },
        data: {
          ...data,
          deadline: data.deadline ? new Date(data.deadline) : null,
        },
        include: { assignedTo: true, notification: true }
    });

    const originalDeadline = originalTask.deadline;
    const updatedDeadline = updatedTask.deadline;
    
    if (originalDeadline?.getTime() !== updatedDeadline?.getTime() && updatedTask.assignedTo) {
      const formattedDeadline = updatedDeadline 
        ? format(updatedDeadline, "d MMMM yyyy 'a las' HH:mm", { locale: es })
        : 'eliminado';
      
      const message = `El plazo para tu tarea "${updatedTask.title}" ha sido actualizado a: ${formattedDeadline}.`;
      
      await tx.notification.create({
        data: {
          message,
          tenantId: updatedTask.tenantId,
          userId: updatedTask.assignedTo.id,
          parentNotificationId: updatedTask.notificationId,
        }
      });
    }

    return updatedTask;
  });
};

export const deleteIncidentTask = async (id: string): Promise<void> => {
  await prisma.incidentTask.delete({ where: { id } });
};

export const updateTaskStatus = async (taskId: string, actorId: string, status: IncidentTaskStatus, resolutionNotes?: string) => {
  return prisma.$transaction(async (tx) => {
    const task = await tx.incidentTask.update({
      where: { id: taskId },
      data: { status, resolutionNotes },
      include: { assignedTo: true, notification: true },
    });

    if (!task.assignedTo) throw new Error("La tarea no tiene un asignado.");
    
    await tx.incidentTaskLog.create({
      data: {
        action: 'STATUS_CHANGE',
        details: `Estado cambiado a ${status} por ${task.assignedTo.name}.`,
        incidentTaskId: taskId,
        userId: actorId,
      }
    });

    if (status === 'COMPLETED') {
      await tx.notification.create({
        data: {
          message: `La tarea "${task.title}" ha sido completada.`,
          tenantId: task.tenantId,
          userId: task.notification.userId, 
          parentNotificationId: task.notificationId,
        }
      });
    }
    return task;
  });
};

export const addTaskLog = async (taskId: string, actorId: string, data: AddLogInput) => {
  return prisma.$transaction(async (tx) => {
    const task = await tx.incidentTask.findUnique({
      where: { id: taskId },
      include: { assignedTo: true, notification: true },
    });

    if (!task || !task.assignedTo) throw new Error("Tarea o t√©cnico asignado no encontrados.");

    let logDetails = data.details;
    let notificationMessage = `Actualizaci√≥n sobre "${task.title}": ${data.details}`;
    let logAction: any = 'COMMENT';

    if (data.newDeadline) {
      const formattedDeadline = format(new Date(data.newDeadline), "d MMMM yyyy 'a las' HH:mm", { locale: es });
      logDetails = `[SOLICITUD DE APLAZAMIENTO] ${data.details}. Se solicita nuevo plazo para: ${formattedDeadline}.`;
      notificationMessage = `Solicitud de aplazamiento de ${task.assignedTo.name} para la tarea "${task.title}".`;
      logAction = 'DEADLINE_REQUEST';
    }

    const log = await tx.incidentTaskLog.create({
      data: {
        action: logAction,
        details: logDetails,
        incidentTaskId: taskId,
        userId: actorId,
      }
    });

    const authorIsTechnician = actorId === task.assignedToId;
    const recipientId = authorIsTechnician ? task.notification.userId : task.assignedToId;

    if (recipientId) {
        await tx.notification.create({
            data: {
                message: notificationMessage,
                tenantId: task.tenantId,
                userId: recipientId,
                parentNotificationId: task.notificationId, 
            }
        });
    }

    return log;
  });
};

export const getTaskLogs = async (taskId: string): Promise<IncidentTaskLog[]> => {
    return prisma.incidentTaskLog.findMany({
        where: { incidentTaskId: taskId },
        include: { user: { select: { name: true } } },
        orderBy: { createdAt: 'asc' },
    });
};

export const updateTaskDeadline = async (taskId: string, deadline: string, actorId: string): Promise<IncidentTask> => {
  return prisma.$transaction(async (tx) => {
    const actor = await tx.user.findUniqueOrThrow({ where: { id: actorId } });
    
    const updatedTask = await tx.incidentTask.update({
      where: { id: taskId },
      data: { deadline: new Date(deadline) },
      include: { assignedTo: true }
    });

    const formattedDeadline = format(new Date(deadline), "d MMMM yyyy 'a las' HH:mm", { locale: es });
    await tx.incidentTaskLog.create({
      data: {
        action: 'DEADLINE_UPDATE',
        details: `[PLAZO ACTUALIZADO] El plazo ha sido modificado por ${actor.name} a: ${formattedDeadline}.`,
        incidentTaskId: taskId,
        userId: actorId,
      }
    });

    if (updatedTask.assignedTo) {
      await tx.notification.create({
        data: {
          message: `El plazo para tu tarea "${updatedTask.title}" ha sido actualizado por el administrador.`,
          tenantId: updatedTask.tenantId,
          userId: updatedTask.assignedTo.id,
          parentNotificationId: updatedTask.notificationId,
        }
      });
    }

    return updatedTask;
  });
};


// ====== [77] packages/server/src/api/notifications/notifications.controller.ts ======
// filename: packages/server/src/api/notifications/notifications.controller.ts
// version: 1.6.0 (Adds getNotificationByIdHandler)
// description: A√±ade el manejador para obtener una √∫nica notificaci√≥n por su ID.

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { 
  getNotificationsForUser, 
  markNotificationAsRead, 
  resolveNotification, 
  getNotificationHistory,
  classifyNotification,
  getNotificationById, // <-- Importar la nueva funci√≥n
} from './notifications.service.js';
import { IncidentPriority, NotificationStatus } from '@prisma/client';

/**
 * Maneja la obtenci√≥n de las notificaciones PENDIENTES para el usuario autenticado.
 */
export const getNotificationsHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ message: 'Usuario no autenticado.' });
    }
    const notifications = await getNotificationsForUser(userId);
    res.status(200).json({ success: true, data: notifications });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n del HISTORIAL COMPLETO de notificaciones para el tenant, con paginaci√≥n y filtros.
 */
export const getHistoryHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(401).json({ message: 'Usuario no autenticado o sin tenant.' });
    }
    const page = parseInt(req.query.page as string) || 1;
    const pageSize = parseInt(req.query.pageSize as string) || 10;
    const status = req.query.status as NotificationStatus | undefined;
    const clientId = req.query.clientId as string | undefined;

    if (status && !Object.values(NotificationStatus).includes(status)) {
        return res.status(400).json({ message: 'El estado proporcionado no es v√°lido.' });
    }
    const historyData = await getNotificationHistory(tenantId, page, pageSize, status, clientId);
    res.status(200).json({ success: true, data: historyData });
  } catch (error) {
    next(error);
  }
};

/**
 * --- NUEVO MANEJADOR ---
 * Maneja la obtenci√≥n de una notificaci√≥n espec√≠fica por su ID.
 */
export const getNotificationByIdHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { notificationId } = req.params;
    if (!notificationId) {
      return res.status(400).json({ message: 'El ID de la notificaci√≥n es requerido.' });
    }
    // TODO: A√±adir una capa de seguridad para verificar que el usuario
    // tiene permiso para ver esta notificaci√≥n (pertenece a su tenant).
    const notification = await getNotificationById(notificationId);
    if (!notification) {
      return res.status(404).json({ message: 'Notificaci√≥n no encontrada.' });
    }
    res.status(200).json({ success: true, data: notification });
  } catch (error) {
    next(error);
  }
};


/**
 * Maneja la acci√≥n de marcar una notificaci√≥n como le√≠da.
 */
export const markAsReadHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const userId = req.user?.id;
    const { notificationId } = req.params;
    if (!userId) { return res.status(401).json({ message: 'Usuario no autenticado.' }); }
    if (!notificationId) { return res.status(400).json({ message: 'El ID de la notificaci√≥n es requerido.' }); }
    const updatedNotification = await markNotificationAsRead(notificationId, userId);
    res.status(200).json({ success: true, data: updatedNotification });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la acci√≥n de resolver una notificaci√≥n.
 */
export const resolveNotificationHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const userId = req.user?.id;
    const { notificationId } = req.params;
    const { resolutionNotes } = req.body;
    if (!userId) { return res.status(401).json({ message: 'Usuario no autenticado.' }); }
    if (!notificationId) { return res.status(400).json({ message: 'El ID de la notificaci√≥n es requerido.' }); }
    if (typeof resolutionNotes !== 'string') { return res.status(400).json({ message: 'Se requieren notas de resoluci√≥n.' }); }
    const resolvedNotification = await resolveNotification(notificationId, userId, resolutionNotes);
    res.status(200).json({ success: true, data: resolvedNotification });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la acci√≥n de clasificar una notificaci√≥n (establecer prioridad y plazo).
 */
export const classifyNotificationHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
    try {
        const userId = req.user?.id;
        const { notificationId } = req.params;
        const { priority, deadline } = req.body;
        if (!userId) { return res.status(401).json({ message: 'Usuario no autenticado.' }); }
        if (!notificationId) { return res.status(400).json({ message: 'El ID de la notificaci√≥n es requerido.' }); }
        if (!priority || !Object.values(IncidentPriority).includes(priority)) { return res.status(400).json({ message: 'La prioridad proporcionada no es v√°lida.' }); }
        const deadlineDate = deadline ? new Date(deadline) : undefined;
        if (deadlineDate && isNaN(deadlineDate.getTime())) { return res.status(400).json({ message: 'El plazo proporcionado no es una fecha v√°lida.'}); }
        const classifiedNotification = await classifyNotification(notificationId, userId, priority, deadlineDate);
        res.status(200).json({ success: true, data: classifiedNotification });
    } catch (error) {
        next(error);
    }
};


// ====== [78] packages/server/src/api/notifications/notifications.routes.ts ======
// filename: packages/server/src/api/notifications/notifications.routes.ts
// version: 1.4.0 (Adds route to get a single notification by ID)
// description: A√±ade el endpoint para obtener los detalles de una notificaci√≥n espec√≠fica.

import { Router } from 'express';
import { 
  getNotificationsHandler, 
  markAsReadHandler, 
  resolveNotificationHandler,
  getHistoryHandler,
  classifyNotificationHandler,
  getNotificationByIdHandler, // <-- 1. Importar el nuevo manejador
} from './notifications.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const notificationsRouter = Router();

// --- Middleware de Protecci√≥n ---
notificationsRouter.use(protect);

/**
 * @route   GET /api/notifications/history
 * @desc    Obtiene el historial completo de notificaciones del tenant.
 * @access  Private (Admin)
 */
notificationsRouter.get('/history', getHistoryHandler);

/**
 * @route   GET /api/notifications
 * @desc    Obtiene todas las notificaciones PENDIENTES para el usuario autenticado.
 * @access  Private
 */
notificationsRouter.get('/', getNotificationsHandler);

/**
 * @route   POST /api/notifications/:notificationId/read
 * @desc    Marca una notificaci√≥n espec√≠fica como le√≠da.
 * @access  Private
 */
notificationsRouter.post('/:notificationId/read', markAsReadHandler);

/**
 * @route   POST /api/notifications/:notificationId/resolve
 * @desc    Resuelve una notificaci√≥n, cambiando su estado y a√±adiendo notas.
 * @access  Private (Admin)
 */
notificationsRouter.post('/:notificationId/resolve', resolveNotificationHandler);

/**
 * @route   PATCH /api/notifications/:notificationId/classify
 * @desc    Clasifica una notificaci√≥n (establece prioridad y/o plazo).
 * @access  Private (Admin)
 */
notificationsRouter.patch('/:notificationId/classify', classifyNotificationHandler);

/**
 * @route   GET /api/notifications/:notificationId
 * @desc    Obtiene los detalles de una notificaci√≥n espec√≠fica.
 * @access  Private (Admin)
 * @note    Esta ruta debe ir al final para no interferir con otras sub-rutas como '/history'.
 */
notificationsRouter.get('/:notificationId', getNotificationByIdHandler); // <-- 2. A√±adir la nueva ruta


export default notificationsRouter;


// ====== [79] packages/server/src/api/notifications/notifications.service.ts ======
// ====== [69] packages/server/src/api/notifications/notifications.service.ts ======
// filename: packages/server/src/api/notifications/notifications.service.ts
// version: 1.7.1 (FIX: Remove unused import)
// description: Removed unused 'subHours' import from date-fns.

import { PrismaClient } from '@prisma/client';
import type { Notification, IncidentPriority, NotificationStatus } from '@prisma/client';
// ‚úÖ CORRECCI√ìN: Se elimina 'subHours' de la importaci√≥n.
import { } from 'date-fns';

const prisma = new PrismaClient();

// --- Tipos ---
export type NotificationWithCriticality = Notification & { isCritical: boolean };

export type PaginatedNotifications = {
    notifications: (Notification & { visit: any })[];
    total: number;
};

/**
 * Obtiene todas las notificaciones con estado PENDING para un usuario espec√≠fico.
 */
export const getNotificationsForUser = async (userId: string): Promise<Notification[]> => {
  return prisma.notification.findMany({
    where: { userId, status: 'PENDING' },
    orderBy: { id: 'desc' },
  });
};

/**
 * Obtiene el historial de notificaciones para un tenant con filtros y paginaci√≥n.
 */
export const getNotificationHistory = async (
  tenantId: string,
  page: number,
  pageSize: number,
  status?: NotificationStatus,
  clientId?: string
): Promise<PaginatedNotifications> => {
    
    const skip = (page - 1) * pageSize;

    const whereClause: any = { tenantId };
    if (status) {
        whereClause.status = status;
    }
    if (clientId) {
        whereClause.visit = { pool: { clientId: clientId } };
    }
    
    const [notifications, total] = await prisma.$transaction([
        prisma.notification.findMany({
            where: whereClause,
            skip: skip,
            take: pageSize,
            include: {
                visit: {
                    include: {
                        pool: {
                            include: { client: { select: { id: true, name: true } } }
                        },
                        technician: { select: { name: true } }
                    }
                },
                images: true,
            },
            orderBy: { id: 'desc' }
        }),
        prisma.notification.count({ where: whereClause })
    ]);
    
    const enrichedNotifications = notifications.map(notification => ({
        ...notification,
        isCritical: notification.status === 'PENDING' && (notification.priority === 'HIGH' || notification.priority === 'CRITICAL'),
    }));

    return { notifications: enrichedNotifications, total };
};


/**
 * Marca una notificaci√≥n espec√≠fica como le√≠da.
 */
export const markNotificationAsRead = async (
  notificationId: string,
  userId: string
): Promise<Notification> => {
  await prisma.notification.updateMany({
    where: { id: notificationId, userId: userId },
    data: { isRead: true },
  });
  return prisma.notification.findUniqueOrThrow({ where: { id: notificationId } });
};


/**
 * Resuelve una notificaci√≥n.
 */
export const resolveNotification = async (
    notificationId: string,
    userId: string,
    resolutionNotes: string,
): Promise<Notification> => {
    return prisma.notification.update({
        where: { id: notificationId, userId: userId },
        data: { status: 'RESOLVED', resolutionNotes: resolutionNotes },
    });
};

/**
 * Clasifica una notificaci√≥n.
 */
export const classifyNotification = async (
    notificationId: string,
    userId: string,
    priority: IncidentPriority,
    deadline?: Date,
): Promise<Notification> => {
    return prisma.notification.update({
        where: { id: notificationId, userId: userId },
        data: { priority: priority, resolutionDeadline: deadline },
    });
};


/**
 * Obtiene los detalles de una √∫nica notificaci√≥n por su ID.
 */
export const getNotificationById = async (notificationId: string) => {
  return prisma.notification.findUnique({
    where: { id: notificationId },
    include: {
      images: true,
      visit: {
        include: {
          pool: { select: { name: true } },
          technician: { select: { name: true } },
        },
      },
    },
  });
};


// ====== [80] packages/server/src/api/parameters/parameters.controller.ts ======
// filename: packages/server/src/api/parameters/parameters.controller.ts
// Version: 2.0.0 (FEAT: Pass tenantId to service for validation)

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createParameterTemplate,
  deleteParameterTemplate,
  getParameterTemplatesByTenant,
  updateParameterTemplate,
} from './parameters.service.js';

/**
 * Maneja la creaci√≥n de una nueva plantilla de par√°metro.
 */
export const createParameterTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }
    const input = { ...req.body, tenantId };
    const newTemplate = await createParameterTemplate(input);
    res.status(201).json({ success: true, data: newTemplate });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todas las plantillas de un tenant.
 */
export const getParameterTemplatesByTenantHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }
    const templates = await getParameterTemplatesByTenant(tenantId);
    res.status(200).json({ success: true, data: templates });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n de una plantilla de par√°metro.
 */
export const updateParameterTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de plantilla o de tenant faltante.' });
    }

    const updatedTemplate = await updateParameterTemplate(id, tenantId, req.body);
    res.status(200).json({ success: true, data: updatedTemplate });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de una plantilla de par√°metro.
 */
export const deleteParameterTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de plantilla o de tenant faltante.' });
    }

    await deleteParameterTemplate(id, tenantId);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [81] packages/server/src/api/parameters/parameters.routes.ts ======
// filename: packages/server/src/api/parameters/parameters.routes.ts
// Version: 2.0.0 (FEAT: Protect routes with ADMIN authorization)

import { Router } from 'express';
import {
  createParameterTemplateHandler,
  deleteParameterTemplateHandler,
  getParameterTemplatesByTenantHandler,
  updateParameterTemplateHandler,
} from './parameters.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const parametersRouter = Router();

// Aplicamos la protecci√≥n y autorizaci√≥n a todas las rutas de este fichero.
// Solo los usuarios autenticados con rol de ADMIN pueden gestionar el cat√°logo.
parametersRouter.use(protect, authorize('ADMIN'));

parametersRouter.route('/')
  .get(getParameterTemplatesByTenantHandler)
  .post(createParameterTemplateHandler);

parametersRouter.route('/:id')
  .patch(updateParameterTemplateHandler)
  .delete(deleteParameterTemplateHandler);

export default parametersRouter;


// ====== [82] packages/server/src/api/parameters/parameters.service.ts ======
// filename: packages/server/src/api/parameters/parameters.service.ts
// Version: 2.0.1 (FIXED: Correct type definition for create operation)

import { PrismaClient } from '@prisma/client';
import type { ParameterTemplate, InputType } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateParameterTemplateInput = {
  name: string;
  tenantId: string; // Cada plantilla pertenece a un tenant
  unit?: string;
  type: InputType; // <-- CORREGIDO: Se ha eliminado el '?' para hacerlo obligatorio.
  selectOptions?: string[];
};

export type UpdateParameterTemplateInput = Partial<Omit<CreateParameterTemplateInput, 'tenantId'>>;

// --- Funciones del Servicio ---

/**
 * Crea una nueva plantilla de par√°metro para un tenant espec√≠fico.
 * @param input - Datos de la nueva plantilla.
 * @returns La plantilla de par√°metro creada.
 */
export const createParameterTemplate = async (
  input: CreateParameterTemplateInput
): Promise<ParameterTemplate> => {
  return prisma.parameterTemplate.create({
    data: input,
  });
};

/**
 * Obtiene todas las plantillas de par√°metros para un tenant espec√≠fico.
 * @param tenantId - El ID del tenant.
 * @returns Un array de plantillas de par√°metros.
 */
export const getParameterTemplatesByTenant = async (
  tenantId: string
): Promise<ParameterTemplate[]> => {
  return prisma.parameterTemplate.findMany({
    where: { tenantId },
    orderBy: { name: 'asc' },
  });
};

/**
 * Actualiza una plantilla de par√°metro existente, verificando la pertenencia al tenant.
 * @param id - El ID de la plantilla a actualizar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 * @param data - Los datos a actualizar.
 * @returns La plantilla de par√°metro actualizada.
 */
export const updateParameterTemplate = async (
  id: string,
  tenantId: string,
  data: UpdateParameterTemplateInput
): Promise<ParameterTemplate> => {
  const { count } = await prisma.parameterTemplate.updateMany({
    where: {
      id,
      tenantId, // <-- Condici√≥n de seguridad
    },
    data,
  });

  if (count === 0) {
    throw new Error('Plantilla de par√°metro no encontrada o sin permisos para modificar.');
  }

  return prisma.parameterTemplate.findUniqueOrThrow({ where: { id } });
};

/**
 * Elimina una plantilla de par√°metro, verificando la pertenencia al tenant.
 * @param id - El ID de la plantilla a eliminar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 */
export const deleteParameterTemplate = async (
  id: string,
  tenantId: string
): Promise<void> => {
  const { count } = await prisma.parameterTemplate.deleteMany({
    where: {
      id,
      tenantId, // <-- Condici√≥n de seguridad
    },
  });

  if (count === 0) {
    throw new Error('Plantilla de par√°metro no encontrada o sin permisos para eliminar.');
  }
};


// ====== [83] packages/server/src/api/payments/payments.controller.ts ======
// filename: packages/server/src/api/payments/payments.controller.ts
// version: 1.0.0
// description: Controlador para manejar las peticiones HTTP del CRUD de pagos.

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createPayment,
  getPaymentsByClient,
  deletePayment,
} from './payments.service.js';

/**
 * Maneja la creaci√≥n de un nuevo pago.
 */
export const createPaymentHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    // TODO: Validar que el clientId del body pertenece al tenant del usuario.
    const newPayment = await createPayment(req.body);
    res.status(201).json({ success: true, data: newPayment });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todos los pagos de un cliente.
 */
export const getPaymentsByClientHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { clientId } = req.params;
    if (!clientId) {
      return res.status(400).json({ success: false, message: 'El ID del cliente es requerido.' });
    }
    // TODO: Validar que el cliente pertenece al tenant del usuario.
    const payments = await getPaymentsByClient(clientId);
    res.status(200).json({ success: true, data: payments });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de un pago.
 */
export const deletePaymentHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ success: false, message: 'El ID del pago es requerido.' });
    }
    // TODO: Validar que el pago pertenece a un cliente del tenant del usuario.
    await deletePayment(id);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [84] packages/server/src/api/payments/payments.routes.ts ======
// filename: packages/server/src/api/payments/payments.routes.ts
// version: 2.0.0 (FEAT: Protect routes with ADMIN authorization)

import { Router } from 'express';
import {
  createPaymentHandler,
  getPaymentsByClientHandler,
  deletePaymentHandler,
} from './payments.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const paymentsRouter = Router();

// Protegemos todas las rutas de este m√≥dulo.
// Solo los usuarios autenticados con rol de ADMIN pueden gestionar los pagos.
paymentsRouter.use(protect, authorize('ADMIN'));


// Ruta para crear un nuevo pago
paymentsRouter.post('/', createPaymentHandler);

// Ruta para obtener todos los pagos de un cliente espec√≠fico
paymentsRouter.get('/by-client/:clientId', getPaymentsByClientHandler);

// Ruta para eliminar un pago espec√≠fico por su ID
paymentsRouter.delete('/:id', deletePaymentHandler);

export default paymentsRouter;


// ====== [85] packages/server/src/api/payments/payments.service.ts ======
// filename: packages/server/src/api/payments/payments.service.ts
// version: 1.0.0
// description: Servicio para la l√≥gica de negocio de los pagos de clientes.

import { PrismaClient } from '@prisma/client';
import type { Payment } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreatePaymentInput = Omit<Payment, 'id'>;

/**
 * Crea un nuevo registro de pago.
 * @param data - Los datos del pago a crear.
 * @returns El pago reci√©n creado.
 */
export const createPayment = async (data: CreatePaymentInput): Promise<Payment> => {
  return prisma.payment.create({
    data,
  });
};

/**
 * Obtiene todos los pagos de un cliente espec√≠fico.
 * @param clientId - El ID del cliente.
 * @returns Un array con todos los pagos del cliente.
 */
export const getPaymentsByClient = async (clientId: string): Promise<Payment[]> => {
  return prisma.payment.findMany({
    where: { clientId },
    orderBy: { paymentDate: 'desc' },
  });
};

/**
 * Elimina un registro de pago.
 * @param id - El ID del pago a eliminar.
 */
export const deletePayment = async (id: string): Promise<void> => {
  await prisma.payment.delete({
    where: { id },
  });
};


// ====== [86] packages/server/src/api/planning/planning.controller.ts ======
// filename: packages/server/src/api/planning/planning.controller.ts
// version: 1.0.0 (NEW)
// description: Controlador para el recurso de planificaci√≥n agregada.

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { getPendingWork } from './planning.service.js';

/**
 * Maneja la obtenci√≥n de todos los datos para el "Muelle de Carga".
 */
export const getPendingWorkHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida. Tenant no identificado.' });
    }

    const pendingWorkData = await getPendingWork(tenantId);
    res.status(200).json({ success: true, data: pendingWorkData });
  } catch (error) {
    next(error);
  }
};


// ====== [87] packages/server/src/api/planning/planning.routes.ts ======
// filename: packages/server/src/api/planning/planning.routes.ts
// version: 1.0.0 (NEW)
// description: Define los endpoints para los datos de planificaci√≥n agregada.

import { Router } from 'express';
import { getPendingWorkHandler } from './planning.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const planningRouter = Router();

// Todas las rutas de planificaci√≥n requieren autenticaci√≥n de ADMIN
planningRouter.use(protect, authorize('ADMIN'));

/**
 * @route   GET /api/planning/pending-work
 * @desc    Obtiene los datos para el "Muelle de Carga" (visitas vencidas, hu√©rfanas, etc.).
 * @access  Private (Admin)
 */
planningRouter.get('/pending-work', getPendingWorkHandler);

export default planningRouter;


// ====== [88] packages/server/src/api/planning/planning.service.ts ======
// filename: packages/server/src/api/planning/planning.service.ts
// version: 1.0.0 (NEW)
// description: Servicio para obtener los datos agregados para el "Muelle de Carga".

import { PrismaClient } from '@prisma/client';
import { startOfToday, isWithinInterval } from 'date-fns';

const prisma = new PrismaClient();

export const getPendingWork = async (tenantId: string) => {
  const today = startOfToday();

  // 1. Obtener todas las visitas pendientes del tenant
  const pendingVisits = await prisma.visit.findMany({
    where: {
      pool: { tenantId },
      status: 'PENDING',
    },
    include: {
      pool: { select: { name: true, client: { select: { name: true } } } },
      technician: { include: { availabilities: true } },
    },
  });

  const overdueVisits = [];
  const orphanedVisits = [];

  for (const visit of pendingVisits) {
    const visitDate = new Date(visit.timestamp);

    // 2. Clasificar las visitas vencidas
    if (visitDate < today) {
      overdueVisits.push(visit);
      continue; // Una visita vencida ya no puede ser hu√©rfana en el mismo ciclo
    }

    // 3. Clasificar las visitas hu√©rfanas
    let isOrphaned = !visit.technician || !visit.technician.isAvailable;
    if (visit.technician && !isOrphaned) {
      const isUnavailable = visit.technician.availabilities.some(avail =>
        isWithinInterval(visitDate, { start: new Date(avail.startDate), end: new Date(avail.endDate) })
      );
      if (isUnavailable) isOrphaned = true;
    }

    if (isOrphaned) {
      orphanedVisits.push(visit);
    }
  }

  return {
    overdueVisits,
    orphanedVisits,
    // Aqu√≠ ir√≠a la l√≥gica para 'Incidencias por Asignar' en el futuro
  };
};


// ====== [89] packages/server/src/api/pool-configurations/pool-configurations.controller.ts ======
// filename: packages/server/src/api/pool-configurations/pool-configurations.controller.ts
// Version: 2.0.0 (FEAT: Pass tenantId to service for validation)

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createPoolConfiguration,
  deletePoolConfiguration,
  getConfigurationsByPool,
  updatePoolConfiguration,
} from './pool-configurations.service.js';

/**
 * Maneja la creaci√≥n de una nueva configuraci√≥n de mantenimiento.
 */
export const createPoolConfigurationHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }
    // TODO: El servicio de creaci√≥n a√∫n necesita validaci√≥n de tenantId.
    const newConfig = await createPoolConfiguration(req.body);
    res.status(201).json({ success: true, data: newConfig });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todas las configuraciones para una piscina.
 */
export const getConfigurationsByPoolHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { poolId } = req.params;
    if (!poolId) {
      return res.status(400).json({ success: false, message: 'El ID de la piscina es requerido.' });
    }
    // TODO: Validar que poolId pertenece al tenant del usuario.
    const configs = await getConfigurationsByPool(poolId);
    res.status(200).json({ success: true, data: configs });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n de una configuraci√≥n de mantenimiento.
 */
export const updatePoolConfigurationHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de configuraci√≥n o de tenant faltante.' });
    }
    
    const updatedConfig = await updatePoolConfiguration(id, tenantId, req.body);
    res.status(200).json({ success: true, data: updatedConfig });
  } catch (error) {
    next(error);
  }
};


/**
 * Maneja la eliminaci√≥n de una configuraci√≥n de mantenimiento.
 */
export const deletePoolConfigurationHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;
    
    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de configuraci√≥n o de tenant faltante.' });
    }

    await deletePoolConfiguration(id, tenantId);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [90] packages/server/src/api/pool-configurations/pool-configurations.routes.ts ======
// filename: packages/server/src/api/pool-configurations/pool-configurations.routes.ts
// Version: 1.1.0 (Add PATCH route for update functionality)
import { Router } from 'express';
import {
  createPoolConfigurationHandler,
  deletePoolConfigurationHandler,
  getConfigurationsByPoolHandler,
  updatePoolConfigurationHandler,
} from './pool-configurations.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const poolConfigurationsRouter = Router();

poolConfigurationsRouter.use(protect);

// TODO: A√±adir un middleware de autorizaci√≥n para asegurar que el rol sea 'ADMIN'.

poolConfigurationsRouter.route('/')
  .post(createPoolConfigurationHandler);

poolConfigurationsRouter.route('/by-pool/:poolId')
  .get(getConfigurationsByPoolHandler);

poolConfigurationsRouter.route('/:id')
  .patch(updatePoolConfigurationHandler) // Nueva ruta PATCH
  .delete(deletePoolConfigurationHandler);

export default poolConfigurationsRouter;


// ====== [91] packages/server/src/api/pool-configurations/pool-configurations.service.ts ======
// filename: packages/server/src/api/pool-configurations/pool-configurations.service.ts
// version: 2.0.3 (FIXED)
// description: Se importan y utilizan los tipos Enum de Prisma para 'frequency', solucionando los errores de tipo.

import { PrismaClient } from '@prisma/client';
// ‚úÖ CORRECCI√ìN: Importar los tipos Enum necesarios
import type { PoolConfiguration, VisitFrequency } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreatePoolConfigurationInput = {
  poolId: string;
  frequency: VisitFrequency; // ‚úÖ CORRECCI√ìN: Usar el tipo Enum
  minThreshold?: number;
  maxThreshold?: number;
  parameterTemplateId?: string;
  taskTemplateId?: string;
};

export type UpdatePoolConfigurationInput = Partial<Omit<CreatePoolConfigurationInput, 'poolId' | 'parameterTemplateId' | 'taskTemplateId'>>;

/**
 * Crea una nueva configuraci√≥n de mantenimiento para una piscina.
 */
export const createPoolConfiguration = async (
  data: CreatePoolConfigurationInput
): Promise<PoolConfiguration> => {
  if (data.parameterTemplateId && data.taskTemplateId) {
    throw new Error('Una configuraci√≥n solo puede estar asociada a un par√°metro O a una tarea, no a ambos.');
  }
  if (!data.parameterTemplateId && !data.taskTemplateId) {
    throw new Error('La configuraci√≥n debe estar asociada a un par√°metro o a una tarea.');
  }
  return prisma.poolConfiguration.create({
    data,
  });
};

/**
 * Obtiene todas las configuraciones para una piscina espec√≠fica.
 */
export const getConfigurationsByPool = async (poolId: string): Promise<PoolConfiguration[]> => {
  return prisma.poolConfiguration.findMany({
    where: { poolId },
    include: {
      parameterTemplate: true,
      taskTemplate: true,
    },
  });
};

/**
 * Actualiza una configuraci√≥n de mantenimiento existente, verificando la pertenencia al tenant.
 */
export const updatePoolConfiguration = async (
  id: string,
  tenantId: string,
  data: UpdatePoolConfigurationInput
): Promise<PoolConfiguration> => {
  const { count } = await prisma.poolConfiguration.updateMany({
    where: {
      id,
      pool: {
        tenantId: tenantId,
      },
    },
    data,
  });

  if (count === 0) {
    throw new Error('Configuraci√≥n no encontrada o sin permisos para modificar.');
  }

  return prisma.poolConfiguration.findUniqueOrThrow({ where: { id } });
};


/**
 * Elimina una configuraci√≥n de mantenimiento de una piscina, verificando la pertenencia al tenant.
 */
export const deletePoolConfiguration = async (id: string, tenantId: string): Promise<void> => {
  const { count } = await prisma.poolConfiguration.deleteMany({
    where: {
      id,
      pool: {
        tenantId: tenantId,
      },
    },
  });

  if (count === 0) {
    throw new Error('Configuraci√≥n no encontrada o sin permisos para eliminar.');
  }
};


// ====== [92] packages/server/src/api/pools/pools.controller.ts ======
// filename: packages/server/src/api/pools/pools.controller.ts
// Version: 2.0.0 (FEAT: Pass tenantId to service for validation)

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { createPool, deletePool, updatePool } from './pools.service.js';

/**
 * Maneja la creaci√≥n de una nueva piscina.
 */
export const createPoolHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }

    // Aseguramos que la piscina se asigne al tenant del usuario.
    const input = { ...req.body, tenantId };
    const newPool = await createPool(input);
    res.status(201).json({ success: true, data: newPool });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n de una piscina.
 */
export const updatePoolHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de piscina o de tenant faltante.' });
    }

    const updatedPool = await updatePool(id, tenantId, req.body);
    res.status(200).json({ success: true, data: updatedPool });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de una piscina.
 */
export const deletePoolHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de piscina o de tenant faltante.' });
    }

    await deletePool(id, tenantId);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [93] packages/server/src/api/pools/pools.routes.ts ======
// filename: packages/server/src/api/pools/pools.routes.ts
// Version: 2.0.0 (FEAT: Protect routes with ADMIN authorization)

import { Router } from 'express';
import {
  createPoolHandler,
  deletePoolHandler,
  updatePoolHandler,
} from './pools.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const poolsRouter = Router();

// Aplicamos la protecci√≥n en dos niveles a TODAS las rutas de este enrutador:
// 1. `protect`: Asegura que el usuario est√© autenticado.
// 2. `authorize('ADMIN')`: Asegura que el usuario autenticado tenga el rol de ADMIN.
poolsRouter.use(protect, authorize('ADMIN'));


// No hay una ruta GET / aqu√≠ porque las piscinas se obtienen
// a trav√©s de la ruta del cliente (/api/clients/:id) para mantener el contexto.
poolsRouter.route('/')
  .post(createPoolHandler);

poolsRouter.route('/:id')
  .patch(updatePoolHandler)
  .delete(deletePoolHandler);

export default poolsRouter;


// ====== [94] packages/server/src/api/pools/pools.service.ts ======
// filename: packages/server/src/api/pools/pools.service.ts
// Version: 2.0.0 (FEAT: Add tenantId validation for CUD operations)

import { PrismaClient } from '@prisma/client';
import type { Pool } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreatePoolInput = Omit<Pool, 'id' | 'qrCode' | 'createdAt' | 'updatedAt'>;
export type UpdatePoolInput = Partial<Omit<CreatePoolInput, 'tenantId'>>;

// --- Funciones del Servicio ---

/**
 * Crea una nueva piscina para un cliente y tenant espec√≠ficos.
 * @param data - Datos de la nueva piscina.
 * @returns La piscina creada.
 */
export const createPool = async (data: CreatePoolInput): Promise<Pool> => {
  return prisma.pool.create({
    data,
  });
};

/**
 * Actualiza una piscina existente, verificando la pertenencia al tenant.
 * @param id - El ID de la piscina a actualizar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 * @param data - Los datos a actualizar.
 * @returns La piscina actualizada.
 */
export const updatePool = async (id: string, tenantId: string, data: UpdatePoolInput): Promise<Pool> => {
  // Primero, verificamos que la piscina pertenece al tenant.
  // Esto es un paso extra de seguridad antes de la actualizaci√≥n.
  const poolExists = await prisma.pool.findFirst({
    where: { id, tenantId },
  });

  if (!poolExists) {
    throw new Error('Piscina no encontrada o sin permisos para modificar.');
  }

  return prisma.pool.update({
    where: { id },
    data,
  });
};

/**
 * Elimina una piscina, verificando la pertenencia al tenant.
 * @param id - El ID de la piscina a eliminar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 */
export const deletePool = async (id: string, tenantId: string): Promise<void> => {
  // Utilizamos deleteMany con una cl√°usula where para asegurar la pertenencia al tenant.
  const { count } = await prisma.pool.deleteMany({
    where: {
      id,
      tenantId, // <-- Condici√≥n de seguridad
    },
  });

  if (count === 0) {
    throw new Error('Piscina no encontrada o sin permisos para eliminar.');
  }
};


// ====== [95] packages/server/src/api/product-categories/product-categories.controller.ts ======
// filename: packages/server/src/api/product-categories/product-categories.controller.ts
// version: 2.0.0 (FEAT: Pass tenantId to service for validation)

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createProductCategory,
  getProductCategoriesByTenant,
  updateProductCategory,
  deleteProductCategory,
} from './product-categories.service.js';

/**
 * Maneja la creaci√≥n de una nueva categor√≠a de producto.
 */
export const createProductCategoryHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }

    const input = { ...req.body, tenantId };
    const newCategory = await createProductCategory(input);
    res.status(201).json({ success: true, data: newCategory });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todas las categor√≠as de un tenant.
 */
export const getProductCategoriesHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }

    const categories = await getProductCategoriesByTenant(tenantId);
    res.status(200).json({ success: true, data: categories });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n de una categor√≠a de producto.
 */
export const updateProductCategoryHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de categor√≠a o de tenant faltante.' });
    }
    
    const updatedCategory = await updateProductCategory(id, tenantId, req.body);
    res.status(200).json({ success: true, data: updatedCategory });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de una categor√≠a de producto.
 */
export const deleteProductCategoryHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de categor√≠a o de tenant faltante.' });
    }

    await deleteProductCategory(id, tenantId);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [96] packages/server/src/api/product-categories/product-categories.routes.ts ======
// filename: packages/server/src/api/product-categories/product-categories.routes.ts
// version: 2.0.0 (FEAT: Protect routes with ADMIN authorization)

import { Router } from 'express';
import {
  createProductCategoryHandler,
  getProductCategoriesHandler,
  updateProductCategoryHandler,
  deleteProductCategoryHandler,
} from './product-categories.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const productCategoriesRouter = Router();

// Protegemos todas las rutas de este m√≥dulo.
// Solo usuarios autenticados con rol de ADMIN podr√°n acceder.
productCategoriesRouter.use(protect, authorize('ADMIN'));

// Rutas para /api/product-categories
productCategoriesRouter.route('/')
  .get(getProductCategoriesHandler)   // GET /api/product-categories
  .post(createProductCategoryHandler); // POST /api/product-categories

// Rutas para /api/product-categories/:id
productCategoriesRouter.route('/:id')
  .patch(updateProductCategoryHandler)  // PATCH /api/product-categories/:id
  .delete(deleteProductCategoryHandler); // DELETE /api/product-categories/:id

export default productCategoriesRouter;


// ====== [97] packages/server/src/api/product-categories/product-categories.service.ts ======
// filename: packages/server/src/api/product-categories/product-categories.service.ts
// version: 2.0.0 (FEAT: Add tenantId validation for CUD operations)

import { PrismaClient } from '@prisma/client';
import type { ProductCategory } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateProductCategoryInput = {
  name: string;
  tenantId: string;
};

export type UpdateProductCategoryInput = Partial<Omit<CreateProductCategoryInput, 'tenantId'>>;

/**
 * Crea una nueva categor√≠a de producto para un tenant.
 * @param data - Los datos de la categor√≠a a crear.
 * @returns La categor√≠a reci√©n creada.
 */
export const createProductCategory = async (data: CreateProductCategoryInput): Promise<ProductCategory> => {
  return prisma.productCategory.create({
    data,
  });
};

/**
 * Obtiene todas las categor√≠as de productos de un tenant.
 * @param tenantId - El ID del tenant.
 * @returns Un array con todas las categor√≠as, ordenadas por nombre.
 */
export const getProductCategoriesByTenant = async (tenantId: string): Promise<ProductCategory[]> => {
  return prisma.productCategory.findMany({
    where: { tenantId },
    orderBy: { name: 'asc' },
  });
};

/**
 * Actualiza una categor√≠a de producto existente, verificando la pertenencia al tenant.
 * @param id - El ID de la categor√≠a a actualizar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 * @param data - Los datos a modificar.
 * @returns La categor√≠a actualizada.
 */
export const updateProductCategory = async (id: string, tenantId: string, data: UpdateProductCategoryInput): Promise<ProductCategory> => {
  const { count } = await prisma.productCategory.updateMany({
    where: {
      id,
      tenantId, // <-- Condici√≥n de seguridad
    },
    data,
  });

  if (count === 0) {
    throw new Error('Categor√≠a no encontrada o sin permisos para modificar.');
  }

  return prisma.productCategory.findUniqueOrThrow({ where: { id } });
};

/**
 * Elimina una categor√≠a de producto, verificando la pertenencia al tenant.
 * @param id - El ID de la categor√≠a a eliminar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 */
export const deleteProductCategory = async (id: string, tenantId: string): Promise<void> => {
  const { count } = await prisma.productCategory.deleteMany({
    where: {
      id,
      tenantId, // <-- Condici√≥n de seguridad
    },
  });

  if (count === 0) {
    throw new Error('Categor√≠a no encontrada o sin permisos para eliminar.');
  }
};


// ====== [98] packages/server/src/api/products/products.controller.ts ======
// filename: packages/server/src/api/products/products.controller.ts
// version: 2.0.0 (FEAT: Pass tenantId to service for validation)

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createProduct,
  getProductsByTenant,
  updateProduct,
  deleteProduct,
} from './products.service.js';

/**
 * Maneja la creaci√≥n de un nuevo producto.
 */
export const createProductHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }

    const input = { ...req.body, tenantId };
    const newProduct = await createProduct(input);
    res.status(201).json({ success: true, data: newProduct });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todos los productos de un tenant.
 */
export const getProductsHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }

    const products = await getProductsByTenant(tenantId);
    res.status(200).json({ success: true, data: products });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n de un producto.
 */
export const updateProductHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de producto o de tenant faltante.' });
    }
    
    // Pasamos el tenantId al servicio para la validaci√≥n de pertenencia.
    const updatedProduct = await updateProduct(id, tenantId, req.body);
    res.status(200).json({ success: true, data: updatedProduct });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de un producto.
 */
export const deleteProductHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;
    
    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de producto o de tenant faltante.' });
    }

    // Pasamos el tenantId al servicio para la validaci√≥n de pertenencia.
    await deleteProduct(id, tenantId);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [99] packages/server/src/api/products/products.routes.ts ======
// filename: packages/server/src/api/products/products.routes.ts
// version: 2.0.0 (FEAT: Protect routes with ADMIN authorization)

import { Router } from 'express';
import {
  createProductHandler,
  getProductsHandler,
  updateProductHandler,
  deleteProductHandler,
} from './products.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const productsRouter = Router();

// Aplicamos el middleware `protect` y `authorize` a todas las rutas de este enrutador.
// Solo los usuarios autenticados con rol de ADMIN podr√°n interactuar con el cat√°logo de productos.
productsRouter.use(protect, authorize('ADMIN'));

// Definimos las rutas para el recurso /api/products
productsRouter.route('/')
  .get(getProductsHandler)      // GET /api/products -> Obtiene todos los productos
  .post(createProductHandler);   // POST /api/products -> Crea un nuevo producto

// Definimos las rutas para un recurso espec√≠fico /api/products/:id
productsRouter.route('/:id')
  .patch(updateProductHandler)  // PATCH /api/products/:id -> Actualiza un producto
  .delete(deleteProductHandler); // DELETE /api/products/:id -> Elimina un producto

export default productsRouter;


// ====== [100] packages/server/src/api/products/products.service.ts ======
// filename: packages/server/src/api/products/products.service.ts
// version: 2.0.0 (FEAT: Add tenantId validation for CUD operations)

import { PrismaClient } from '@prisma/client';
import type { Product } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) para la creaci√≥n y actualizaci√≥n ---
export type CreateProductInput = Omit<Product, 'id' | 'createdAt' | 'updatedAt' | 'consumptions'>;
export type UpdateProductInput = Partial<Omit<CreateProductInput, 'tenantId'>>;

/**
 * Crea un nuevo producto para un tenant espec√≠fico.
 * @param data - Los datos del producto a crear.
 * @returns El producto reci√©n creado.
 */
export const createProduct = async (data: CreateProductInput): Promise<Product> => {
  return prisma.product.create({
    data,
  });
};

/**
 * Obtiene todos los productos de un tenant espec√≠fico.
 * @param tenantId - El ID del tenant.
 * @returns Un array con todos los productos del tenant, ordenados por nombre.
 */
export const getProductsByTenant = async (tenantId: string): Promise<Product[]> => {
  return prisma.product.findMany({
    where: { tenantId },
    orderBy: { name: 'asc' },
  });
};

/**
 * Actualiza un producto existente, verificando la pertenencia al tenant.
 * @param id - El ID del producto a actualizar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 * @param data - Los datos a modificar.
 * @returns El producto actualizado.
 */
export const updateProduct = async (id: string, tenantId: string, data: UpdateProductInput): Promise<Product> => {
  const { count } = await prisma.product.updateMany({
    where: {
      id,
      tenantId, // <-- La condici√≥n de seguridad clave
    },
    data,
  });

  if (count === 0) {
    throw new Error('Producto no encontrado o sin permisos para modificar.');
  }

  // Devolvemos el producto actualizado para mantener la consistencia de la API
  return prisma.product.findUniqueOrThrow({ where: { id } });
};

/**
 * Elimina un producto, verificando la pertenencia al tenant.
 * La operaci√≥n fallar√° si el producto ya ha sido usado en alg√∫n registro de consumo.
 * @param id - El ID del producto a eliminar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 */
export const deleteProduct = async (id: string, tenantId: string): Promise<void> => {
  const { count } = await prisma.product.deleteMany({
    where: {
      id,
      tenantId, // <-- La condici√≥n de seguridad clave
    },
  });

  if (count === 0) {
    throw new Error('Producto no encontrado o sin permisos para eliminar.');
  }
};


// ====== [101] packages/server/src/api/reports/reports.controller.ts ======
// ====== [88] packages/server/src/api/reports/reports.controller.ts ======
// filename: packages/server/src/api/reports/reports.controller.ts
// version: 1.3.0 (FEAT: Read productId from query in consumption report handler)
// description: The consumption report handler now reads an optional productId from the query string and passes it to the service.

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { generateConsumptionReport, getConsumptionDetailsForProduct, generateInvoicingReport } from './reports.service.js';

/**
 * Maneja la petici√≥n para generar y devolver un informe de consumo (costes).
 */
export const getConsumptionReportHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida. Tenant no identificado.' });
    }

    // ‚úÖ 1. Leer el nuevo par√°metro opcional 'productId'
    const { startDate: startDateStr, endDate: endDateStr, clientId, productId } = req.query;

    if (!startDateStr || !endDateStr || typeof startDateStr !== 'string' || typeof endDateStr !== 'string') {
      return res.status(400).json({ success: false, message: 'Los par√°metros startDate y endDate son obligatorios.' });
    }

    const startDate = new Date(startDateStr);
    const endDate = new Date(endDateStr);

    if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
      return res.status(400).json({ success: false, message: 'El formato de las fechas no es v√°lido.' });
    }

    const report = await generateConsumptionReport({
      tenantId,
      startDate,
      endDate,
      clientId: typeof clientId === 'string' ? clientId : undefined,
      // ‚úÖ 2. Pasar el productId al servicio
      productId: typeof productId === 'string' ? productId : undefined,
    });

    res.status(200).json({ success: true, data: report });

  } catch (error) {
    next(error);
  }
};


/**
 * Maneja la petici√≥n para obtener el detalle de las visitas donde se consumi√≥ un producto.
 */
export const getProductConsumptionDetailHandler = async (
    req: AuthRequest,
    res: Response,
    next: NextFunction
) => {
    try {
        const tenantId = req.user?.tenantId;
        if (!tenantId) {
            return res.status(403).json({ success: false, message: 'Acci√≥n no permitida. Tenant no identificado.' });
        }

        const { startDate: startDateStr, endDate: endDateStr, clientId, productId } = req.query;

        if (!startDateStr || !endDateStr || !clientId || !productId || 
            typeof startDateStr !== 'string' || typeof endDateStr !== 'string' ||
            typeof clientId !== 'string' || typeof productId !== 'string') {
            return res.status(400).json({ success: false, message: 'Los par√°metros startDate, endDate, clientId y productId son obligatorios.' });
        }

        const startDate = new Date(startDateStr);
        const endDate = new Date(endDateStr);

        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
            return res.status(400).json({ success: false, message: 'El formato de las fechas no es v√°lido.' });
        }

        const details = await getConsumptionDetailsForProduct({
            tenantId,
            startDate,
            endDate,
            clientId,
            productId,
        });

        res.status(200).json({ success: true, data: details });

    } catch (error) {
        next(error);
    }
};

/**
 * Maneja la petici√≥n para generar y devolver un informe de pre-facturaci√≥n.
 */
export const getInvoicingReportHandler = async (
    req: AuthRequest,
    res: Response,
    next: NextFunction
) => {
    try {
        const tenantId = req.user?.tenantId;
        if (!tenantId) {
            return res.status(403).json({ success: false, message: 'Acci√≥n no permitida. Tenant no identificado.' });
        }

        const { startDate: startDateStr, endDate: endDateStr, clientId } = req.query;

        if (!startDateStr || !endDateStr || typeof startDateStr !== 'string' || typeof endDateStr !== 'string') {
            return res.status(400).json({ success: false, message: 'Los par√°metros startDate y endDate son obligatorios.' });
        }

        const startDate = new Date(startDateStr);
        const endDate = new Date(endDateStr);

        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
            return res.status(400).json({ success: false, message: 'El formato de las fechas no es v√°lido.' });
        }

        const report = await generateInvoicingReport({
            tenantId,
            startDate,
            endDate,
            clientId: typeof clientId === 'string' ? clientId : undefined,
        });

        res.status(200).json({ success: true, data: report });

    } catch (error) {
        next(error);
    }
};


// ====== [102] packages/server/src/api/reports/reports.routes.ts ======
// filename: packages/server/src/api/reports/reports.routes.ts
// version: 2.0.0 (FEAT: Protect routes with ADMIN/MANAGER authorization)

import { Router } from 'express';
import { 
    getConsumptionReportHandler, 
    getProductConsumptionDetailHandler,
    getInvoicingReportHandler 
} from './reports.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const reportsRouter = Router();

// Aplicamos la protecci√≥n en dos niveles a todas las rutas de informes:
// 1. `protect`: Asegura que el usuario est√© autenticado.
// 2. `authorize('ADMIN', 'MANAGER')`: Asegura que el usuario sea Admin o Manager.
reportsRouter.use(protect, authorize('ADMIN', 'MANAGER'));

/**
 * @route   GET /api/reports/consumption
 * @desc    Genera y devuelve un informe detallado de consumo de productos (costes).
 * @access  Private (Admin, Manager)
 */
reportsRouter.get('/consumption', getConsumptionReportHandler);

/**
 * @route   GET /api/reports/consumption/details
 * @desc    Obtiene el detalle de visitas donde se consumi√≥ un producto espec√≠fico.
 * @access  Private (Admin, Manager)
 */
reportsRouter.get('/consumption/details', getProductConsumptionDetailHandler);

/**
 * @route   GET /api/reports/invoicing
 * @desc    Genera un informe de pre-facturaci√≥n con precios de venta y cuotas.
 * @access  Private (Admin, Manager)
 */
reportsRouter.get('/invoicing', getInvoicingReportHandler);

export default reportsRouter;


// ====== [103] packages/server/src/api/reports/reports.service.ts ======
// ====== [90] packages/server/src/api/reports/reports.service.ts ======
// filename: packages/server/src/api/reports/reports.service.ts
// version: 1.4.0 (FEAT: Add productId filter to consumption report)
// description: The consumption report can now be filtered by a specific product ID.

import { PrismaClient } from '@prisma/client';
import type { ClientProductPricing } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Datos (Interfaces) ---

interface ReportFilters {
  tenantId: string;
  startDate: Date;
  endDate: Date;
  clientId?: string;
  // ‚úÖ 1. A√±adir productId como filtro opcional
  productId?: string;
}

interface ConsumptionReport {
  summary: {
    totalCost: number;
    totalVisits: number;
  };
  byClient: {
    clientId: string;
    clientName: string;
    totalClientCost: number;
    visitCount: number;
    detailedConsumption: {
      productId: string;
      productName: string;
      unit: string;
      totalQuantity: number;
      totalCost: number;
    }[];
  }[];
}

interface DetailFilters extends ReportFilters {
    productId: string;
    clientId: string;
}

export interface ProductConsumptionDetail {
    visitId: string;
    visitDate: Date;
    quantity: number;
    cost: number;
    technicianName: string | null;
}

export interface InvoicingReport {
  summary: {
    totalToInvoice: number;
    totalFees: number;
    totalMaterials: number;
  };
  byClient: {
    clientId: string;
    clientName: string;
    billingModel: string;
    monthlyFee: number;
    materialsSubtotal: number;
    totalToInvoice: number;
    billedConsumption: {
      productId: string;
      productName: string;
      unit: string;
      totalQuantity: number;
      salePrice: number;
      totalLine: number;
    }[];
  }[];
}


// --- Funciones de Servicio ---

export const generateConsumptionReport = async (filters: ReportFilters): Promise<ConsumptionReport> => {
  const { tenantId, startDate, endDate, clientId, productId } = filters;

  const consumptions = await prisma.consumption.findMany({
    where: {
      // ‚úÖ 2. A√±adir la condici√≥n del productId a la consulta
      productId: productId ? productId : undefined,
      visit: {
        pool: {
          tenantId: tenantId,
          clientId: clientId ? clientId : undefined,
        },
        timestamp: {
          gte: startDate,
          lte: endDate,
        },
      },
    },
    include: {
      product: true,
      visit: { include: { pool: { include: { client: true } } } },
    },
  });
  
  const reportData: Record<string, any> = {};
  let overallTotalCost = 0;
  const visitedVisits = new Set<string>();

  for (const consumption of consumptions) {
    if (!consumption.visit || !consumption.visit.pool || !consumption.visit.pool.client) continue;
    
    const client = consumption.visit.pool.client;
    const product = consumption.product;
    const itemCost = consumption.quantity * product.cost;

    overallTotalCost += itemCost;
    visitedVisits.add(consumption.visitId);

    if (!reportData[client.id]) {
      reportData[client.id] = {
        clientId: client.id,
        clientName: client.name,
        totalClientCost: 0,
        visitCount: new Set<string>(),
        detailedConsumption: {},
      };
    }
    
    reportData[client.id].totalClientCost += itemCost;
    reportData[client.id].visitCount.add(consumption.visitId);
    
    const detailedConsumption = reportData[client.id].detailedConsumption;
    if (!detailedConsumption[product.id]) {
      detailedConsumption[product.id] = {
        productId: product.id,
        productName: product.name,
        unit: product.unit,
        totalQuantity: 0,
        totalCost: 0,
      };
    }
    
    detailedConsumption[product.id].totalQuantity += consumption.quantity;
    detailedConsumption[product.id].totalCost += itemCost;
  }
  
  const byClientArray = Object.values(reportData).map(clientData => ({
    ...clientData,
    visitCount: clientData.visitCount.size,
    detailedConsumption: Object.values(clientData.detailedConsumption),
  }));
  
  return {
    summary: {
      totalCost: overallTotalCost,
      totalVisits: visitedVisits.size,
    },
    byClient: byClientArray,
  };
};

export const getConsumptionDetailsForProduct = async (filters: DetailFilters): Promise<ProductConsumptionDetail[]> => {
    const { tenantId, startDate, endDate, clientId, productId } = filters;

    const consumptions = await prisma.consumption.findMany({
        where: {
            productId,
            visit: {
                pool: { clientId, tenantId },
                timestamp: { gte: startDate, lte: endDate }
            }
        },
        include: {
            product: true,
            visit: { include: { technician: { select: { name: true } } } }
        },
        orderBy: { visit: { timestamp: 'desc' } }
    });

    return consumptions.map(c => ({
        visitId: c.visitId,
        visitDate: c.visit.timestamp,
        quantity: c.quantity,
        cost: c.quantity * c.product.cost,
        technicianName: c.visit.technician?.name ?? 'No asignado',
    }));
};

export const generateInvoicingReport = async (filters: ReportFilters): Promise<InvoicingReport> => {
    const { tenantId, startDate, endDate, clientId } = filters;

    const clients = await prisma.client.findMany({
        where: {
            tenantId,
            id: clientId ? clientId : undefined,
        },
        include: {
            clientPricingRules: true, 
        },
    });

    const consumptions = await prisma.consumption.findMany({
        where: {
            visit: {
                pool: { tenantId, clientId: clientId ? clientId : undefined },
                timestamp: { gte: startDate, lte: endDate },
            },
        },
        include: {
            product: true,
            visit: { include: { pool: true } },
        },
    });

    const report: InvoicingReport = {
        summary: { totalToInvoice: 0, totalFees: 0, totalMaterials: 0 },
        byClient: [],
    };

    for (const client of clients) {
        const clientReport = {
            clientId: client.id,
            clientName: client.name,
            billingModel: client.billingModel,
            monthlyFee: client.monthlyFee,
            materialsSubtotal: 0,
            totalToInvoice: client.monthlyFee,
            billedConsumption: [] as InvoicingReport['byClient'][0]['billedConsumption'],
        };
        
        report.summary.totalFees += client.monthlyFee;

        if (client.billingModel === 'ALL_INCLUSIVE') {
            report.summary.totalToInvoice += client.monthlyFee;
            report.byClient.push(clientReport);
            continue;
        }

        const clientConsumptions = consumptions.filter(c => c.visit.pool.clientId === client.id);

        for (const consumption of clientConsumptions) {
            const product = consumption.product;
            let finalSalePrice = product.salePrice;

            const productRule = client.clientPricingRules.find((r: ClientProductPricing) => r.productId === product.id);
            const categoryRule = client.clientPricingRules.find((r: ClientProductPricing) => r.productCategoryId === product.categoryId);

            if (productRule) {
                finalSalePrice *= (1 - productRule.discountPercentage / 100);
            } else if (categoryRule) {
                finalSalePrice *= (1 - categoryRule.discountPercentage / 100);
            } else {
                finalSalePrice *= client.priceModifier;
            }
            
            const lineTotal = consumption.quantity * finalSalePrice;
            clientReport.materialsSubtotal += lineTotal;

            const existingBilledItem = clientReport.billedConsumption.find(item => item.productId === product.id);
            if (existingBilledItem) {
                existingBilledItem.totalQuantity += consumption.quantity;
                existingBilledItem.totalLine += lineTotal;
            } else {
                clientReport.billedConsumption.push({
                    productId: product.id,
                    productName: product.name,
                    unit: product.unit,
                    totalQuantity: consumption.quantity,
                    salePrice: finalSalePrice,
                    totalLine: lineTotal,
                });
            }
        }
        
        clientReport.totalToInvoice += clientReport.materialsSubtotal;
        report.summary.totalMaterials += clientReport.materialsSubtotal;
        report.byClient.push(clientReport);
    }
    
    report.summary.totalToInvoice = report.summary.totalFees + report.summary.totalMaterials;

    return report;
};


// ====== [104] packages/server/src/api/route-templates/route-templates.controller.ts ======
// filename: packages/server/src/api/route-templates/route-templates.controller.ts
// version: 1.0.0
// description: Controlador para manejar las peticiones HTTP del CRUD de Rutas Maestras.

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createRouteTemplate,
  getRouteTemplatesByTenant,
  getRouteTemplateById,
  updateRouteTemplate,
  deleteRouteTemplate,
} from './route-templates.service.js';

/**
 * Maneja la creaci√≥n de una nueva Ruta Maestra.
 */
export const createRouteTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }

    const input = { ...req.body, tenantId };
    const newRouteTemplate = await createRouteTemplate(input);
    res.status(201).json({ success: true, data: newRouteTemplate });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todas las Rutas Maestras de un tenant.
 */
export const getRouteTemplatesHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }
    const routeTemplates = await getRouteTemplatesByTenant(tenantId);
    res.status(200).json({ success: true, data: routeTemplates });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de una Ruta Maestra por su ID.
 */
export const getRouteTemplateByIdHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    const { id } = req.params;

    if (!tenantId || !id) {
        return res.status(400).json({ success: false, message: 'Falta el ID de la ruta o del tenant.' });
    }

    const routeTemplate = await getRouteTemplateById(id, tenantId);
    if (!routeTemplate) {
        return res.status(404).json({ success: false, message: 'Ruta Maestra no encontrada.' });
    }
    res.status(200).json({ success: true, data: routeTemplate });
  } catch (error) {
    next(error);
  }
};


/**
 * Maneja la actualizaci√≥n de una Ruta Maestra.
 */
export const updateRouteTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de ruta o de tenant faltante.' });
    }
    
    const updatedRouteTemplate = await updateRouteTemplate(id, tenantId, req.body);
    res.status(200).json({ success: true, data: updatedRouteTemplate });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de una Ruta Maestra.
 */
export const deleteRouteTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de ruta o de tenant faltante.' });
    }

    await deleteRouteTemplate(id, tenantId);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [105] packages/server/src/api/route-templates/route-templates.routes.ts ======
// filename: packages/server/src/api/route-templates/route-templates.routes.ts
// version: 1.0.0
// description: Define los endpoints de la API para el recurso de Rutas Maestras.

import { Router } from 'express';
import {
  createRouteTemplateHandler,
  getRouteTemplatesHandler,
  getRouteTemplateByIdHandler,
  updateRouteTemplateHandler,
  deleteRouteTemplateHandler,
} from './route-templates.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const routeTemplatesRouter = Router();

// Aplicamos la seguridad a todas las rutas de este fichero.
// Solo los administradores podr√°n gestionar las rutas maestras.
routeTemplatesRouter.use(protect, authorize('ADMIN'));

// Rutas para /api/route-templates
routeTemplatesRouter.route('/')
  .get(getRouteTemplatesHandler)
  .post(createRouteTemplateHandler);

// Rutas para una ruta espec√≠fica /api/route-templates/:id
routeTemplatesRouter.route('/:id')
  .get(getRouteTemplateByIdHandler)
  .patch(updateRouteTemplateHandler)
  .delete(deleteRouteTemplateHandler);

export default routeTemplatesRouter;


// ====== [106] packages/server/src/api/route-templates/route-templates.service.ts ======
// filename: packages/server/src/api/route-templates/route-templates.service.ts
// version: 1.0.3 (FIXED)
// description: Se importan y utilizan los tipos Enum de Prisma, solucionando los errores de tipo en la definici√≥n de SeasonInput.

import { PrismaClient } from '@prisma/client';
// ‚úÖ CORRECCI√ìN: Importar los tipos Enum necesarios
import type { RouteTemplate, DayOfWeek, VisitFrequency } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
interface SeasonInput {
  frequency: VisitFrequency; // ‚úÖ CORRECCI√ìN: Usar el tipo Enum
  startDate: Date;
  endDate: Date;
}

export interface CreateRouteTemplateInput {
  name: string;
  dayOfWeek: DayOfWeek;
  tenantId: string;
  technicianId: string;
  zoneIds: string[];
  seasons: SeasonInput[];
}

export type UpdateRouteTemplateInput = Partial<Omit<CreateRouteTemplateInput, 'tenantId'>>;

// --- Funciones del Servicio ---

/**
 * Crea una nueva Ruta Maestra y sus temporadas asociadas.
 * @param data - Los datos completos de la ruta a crear.
 * @returns La Ruta Maestra reci√©n creada.
 */
export const createRouteTemplate = async (data: CreateRouteTemplateInput): Promise<RouteTemplate> => {
  const { name, dayOfWeek, tenantId, technicianId, zoneIds, seasons } = data;

  return prisma.routeTemplate.create({
    data: {
      name,
      dayOfWeek,
      tenantId,
      technicianId: technicianId,
      zones: {
        connect: zoneIds.map(id => ({ id })),
      },
      seasons: {
        create: seasons,
      },
    },
  });
};

/**
 * Obtiene todas las Rutas Maestras de un tenant, incluyendo sus relaciones.
 * @param tenantId - El ID del tenant.
 * @returns Un array de Rutas Maestras.
 */
export const getRouteTemplatesByTenant = async (tenantId: string): Promise<RouteTemplate[]> => {
  return prisma.routeTemplate.findMany({
    where: { tenantId },
    include: {
      technician: { select: { id: true, name: true } },
      zones: { select: { id: true, name: true } },
      seasons: true,
    },
    orderBy: { name: 'asc' },
  });
};

/**
 * Obtiene una √∫nica Ruta Maestra por su ID, verificando que pertenezca al tenant.
 * @param id - El ID de la Ruta Maestra.
 * @param tenantId - El ID del tenant para validaci√≥n.
 * @returns La Ruta Maestra encontrada o null.
 */
export const getRouteTemplateById = async (id: string, tenantId: string): Promise<RouteTemplate | null> => {
    return prisma.routeTemplate.findFirst({
        where: { id, tenantId },
        include: {
            technician: { select: { id: true, name: true } },
            zones: { select: { id: true, name: true } },
            seasons: true,
        },
    });
};

/**
 * Actualiza una Ruta Maestra existente.
 * @param id - El ID de la ruta a actualizar.
 * @param tenantId - El ID del tenant para validaci√≥n.
 * @param data - Los datos a actualizar.
 * @returns La Ruta Maestra actualizada.
 */
export const updateRouteTemplate = async (id: string, tenantId: string, data: UpdateRouteTemplateInput): Promise<RouteTemplate> => {
  const { name, dayOfWeek, technicianId, zoneIds, seasons } = data;

  return prisma.$transaction(async (tx) => {
    await tx.routeTemplate.findFirstOrThrow({
        where: { id, tenantId }
    });

    return tx.routeTemplate.update({
      where: { id },
      data: {
        name,
        dayOfWeek,
        technicianId,
        zones: {
          set: zoneIds ? zoneIds.map(id => ({ id })) : undefined,
        },
        seasons: seasons ? {
          deleteMany: {},
          create: seasons,
        } : undefined,
      },
    });
  });
};

/**
 * Elimina una Ruta Maestra.
 * @param id - El ID de la ruta a eliminar.
 * @param tenantId - El ID del tenant para validaci√≥n.
 */
export const deleteRouteTemplate = async (id: string, tenantId: string): Promise<void> => {
  const { count } = await prisma.routeTemplate.deleteMany({
    where: {
      id,
      tenantId,
    },
  });

  if (count === 0) {
    throw new Error('Ruta Maestra no encontrada o sin permisos para eliminar.');
  }
};


// ====== [107] packages/server/src/api/tasks/tasks.controller.ts ======
// filename: packages/server/src/api/tasks/tasks.controller.ts
// Version: 2.0.0 (FEAT: Pass tenantId to service for validation)

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createTaskTemplate,
  deleteTaskTemplate,
  getTaskTemplatesByTenant,
  updateTaskTemplate,
} from './tasks.service.js';

/**
 * Maneja la creaci√≥n de una nueva plantilla de tarea.
 */
export const createTaskTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }

    const input = { ...req.body, tenantId };
    const newTemplate = await createTaskTemplate(input);
    res.status(201).json({ success: true, data: newTemplate });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todas las plantillas de tareas de un tenant.
 */
export const getTaskTemplatesByTenantHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }

    const templates = await getTaskTemplatesByTenant(tenantId);
    res.status(200).json({ success: true, data: templates });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n de una plantilla de tarea.
 */
export const updateTaskTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de plantilla o de tenant faltante.' });
    }
    
    const updatedTemplate = await updateTaskTemplate(id, tenantId, req.body);
    res.status(200).json({ success: true, data: updatedTemplate });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de una plantilla de tarea.
 */
export const deleteTaskTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de plantilla o de tenant faltante.' });
    }

    await deleteTaskTemplate(id, tenantId);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [108] packages/server/src/api/tasks/tasks.routes.ts ======
// filename: packages/server/src/api/tasks/tasks.routes.ts
// Version: 2.0.0 (FEAT: Protect routes with ADMIN authorization)

import { Router } from 'express';
import {
  createTaskTemplateHandler,
  deleteTaskTemplateHandler,
  getTaskTemplatesByTenantHandler,
  updateTaskTemplateHandler,
} from './tasks.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const tasksRouter = Router();

// Aplicamos la protecci√≥n y autorizaci√≥n a todas las rutas de este fichero.
// Solo los usuarios autenticados con rol de ADMIN pueden gestionar el cat√°logo.
tasksRouter.use(protect, authorize('ADMIN'));

tasksRouter.route('/')
  .get(getTaskTemplatesByTenantHandler)
  .post(createTaskTemplateHandler);

tasksRouter.route('/:id')
  .patch(updateTaskTemplateHandler)
  .delete(deleteTaskTemplateHandler);

export default tasksRouter;


// ====== [109] packages/server/src/api/tasks/tasks.service.ts ======
// filename: packages/server/src/api/tasks/tasks.service.ts
// Version: 2.0.0 (FEAT: Add tenantId validation for CUD operations)

import { PrismaClient } from '@prisma/client';
import type { ScheduledTaskTemplate } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateTaskTemplateInput = {
  name: string;
  tenantId: string; // Cada plantilla pertenece a un tenant
  description?: string;
};

export type UpdateTaskTemplateInput = Partial<Omit<CreateTaskTemplateInput, 'tenantId'>>;

// --- Funciones del Servicio ---

/**
 * Crea una nueva plantilla de tarea para un tenant espec√≠fico.
 * @param input - Datos de la nueva plantilla.
 * @returns La plantilla de tarea creada.
 */
export const createTaskTemplate = async (
  input: CreateTaskTemplateInput
): Promise<ScheduledTaskTemplate> => {
  return prisma.scheduledTaskTemplate.create({
    data: input,
  });
};

/**
 * Obtiene todas las plantillas de tareas para un tenant espec√≠fico.
 * @param tenantId - El ID del tenant.
 * @returns Un array de plantillas de tareas.
 */
export const getTaskTemplatesByTenant = async (
  tenantId: string
): Promise<ScheduledTaskTemplate[]> => {
  return prisma.scheduledTaskTemplate.findMany({
    where: { tenantId },
    orderBy: { name: 'asc' },
  });
};

/**
 * Actualiza una plantilla de tarea existente, verificando la pertenencia al tenant.
 * @param id - El ID de la plantilla a actualizar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 * @param data - Los datos a actualizar.
 * @returns La plantilla de tarea actualizada.
 */
export const updateTaskTemplate = async (
  id: string,
  tenantId: string,
  data: UpdateTaskTemplateInput
): Promise<ScheduledTaskTemplate> => {
  const { count } = await prisma.scheduledTaskTemplate.updateMany({
    where: {
      id,
      tenantId, // <-- Condici√≥n de seguridad
    },
    data,
  });

  if (count === 0) {
    throw new Error('Plantilla de tarea no encontrada o sin permisos para modificar.');
  }

  return prisma.scheduledTaskTemplate.findUniqueOrThrow({ where: { id } });
};

/**
 * Elimina una plantilla de tarea, verificando la pertenencia al tenant.
 * @param id - El ID de la plantilla a eliminar.
 * @param tenantId - El ID del tenant del usuario que realiza la acci√≥n.
 */
export const deleteTaskTemplate = async (
  id: string,
  tenantId: string,
): Promise<void> => {
  // TODO: A√±adir l√≥gica para verificar que esta plantilla no est√° siendo
  // usada en ninguna PoolConfiguration antes de permitir el borrado.
  const { count } = await prisma.scheduledTaskTemplate.deleteMany({
    where: {
      id,
      tenantId, // <-- Condici√≥n de seguridad
    },
  });

  if (count === 0) {
    throw new Error('Plantilla de tarea no encontrada o sin permisos para eliminar.');
  }
};


// ====== [110] packages/server/src/api/tenants/tenants.controller.ts ======
import type { Request, Response, NextFunction } from 'express';
import {
  createTenant,
  getAllTenants,
  getTenantById,
  updateTenantStatus,
  deleteTenant,
} from './tenants.service.js';

/**
 * Maneja la creaci√≥n de un nuevo tenant.
 */
export const createTenantHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenant = await createTenant(req.body);
    res.status(201).json({ success: true, data: tenant });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todos los tenants.
 */
export const getAllTenantsHandler = async (
  _req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenants = await getAllTenants();
    res.status(200).json({ success: true, data: tenants });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de un tenant por su ID.
 */
export const getTenantByIdHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID del tenant es requerido.' });
    }

    const tenant = await getTenantById(id);

    if (!tenant) {
      const error: any = new Error('Tenant no encontrado.');
      error.statusCode = 404;
      return next(error);
    }

    res.status(200).json({ success: true, data: tenant });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n del estado de un tenant.
 */
export const updateTenantStatusHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID del tenant es requerido.' });
    }

    const { status } = req.body;
    // TODO: A√±adir validaci√≥n para asegurar que 'status' es un valor v√°lido del enum SubscriptionStatus

    const updatedTenant = await updateTenantStatus(id, status);
    res.status(200).json({ success: true, data: updatedTenant });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de un tenant.
 */
export const deleteTenantHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID del tenant es requerido.' });
    }

    await deleteTenant(id);

    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [111] packages/server/src/api/tenants/tenants.routes.ts ======
// filename: packages/server/src/api/tenants/tenants.routes.ts
// version: 2.0.0 (FEAT: Protect routes with SUPER_ADMIN authorization)

import { Router } from 'express';
import {
  createTenantHandler,
  getAllTenantsHandler,
  getTenantByIdHandler,
  updateTenantStatusHandler,
  deleteTenantHandler,
} from './tenants.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const tenantsRouter = Router();

// Aplicamos la protecci√≥n en dos niveles a TODAS las rutas de este enrutador:
// 1. `protect`: Asegura que el usuario est√© autenticado.
// 2. `authorize('SUPER_ADMIN')`: Asegura que el usuario autenticado tenga el rol de SUPER_ADMIN.
tenantsRouter.use(protect, authorize('SUPER_ADMIN'));


/**
 * @route   GET /api/tenants
 * @desc    Obtiene todos los tenants
 * @access  Private (SuperAdmin)
 */
tenantsRouter.get('/', getAllTenantsHandler);

/**
 * @route   POST /api/tenants
 * @desc    Crea un nuevo tenant y su primer usuario admin
 * @access  Private (SuperAdmin)
 */
tenantsRouter.post('/', createTenantHandler);

/**
 * @route   GET /api/tenants/:id
 * @desc    Obtiene un tenant espec√≠fico por su ID
 * @access  Private (SuperAdmin)
 */
tenantsRouter.get('/:id', getTenantByIdHandler);

/**
 * @route   PATCH /api/tenants/:id/status
 * @desc    Actualiza el estado de la suscripci√≥n de un tenant
 * @access  Private (SuperAdmin)
 */
tenantsRouter.patch('/:id/status', updateTenantStatusHandler);

/**
 * @route   DELETE /api/tenants/:id
 * @desc    Elimina un tenant y toda su informaci√≥n asociada
 * @access  Private (SuperAdmin)
 */
tenantsRouter.delete('/:id', deleteTenantHandler);

export default tenantsRouter;


// ====== [112] packages/server/src/api/tenants/tenants.service.ts ======
import { PrismaClient } from '@prisma/client';
import type { Tenant, SubscriptionStatus } from '@prisma/client';
import { hashPassword } from '../../utils/password.utils.js';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
type AdminUserInput = {
  name: string;
  email: string;
  password: string;
};

export type CreateTenantInput = {
  companyName: string;
  subdomain: string;
  adminUser: AdminUserInput;
};

// --- Funciones del Servicio ---

/**
 * Crea un nuevo Tenant y su primer usuario Administrador de forma at√≥mica.
 * @param input - Datos para el nuevo tenant y su admin.
 * @returns El objeto del Tenant reci√©n creado.
 */
export const createTenant = async (input: CreateTenantInput): Promise<Tenant> => {
  const { companyName, subdomain, adminUser } = input;

  const newTenant = await prisma.$transaction(async (tx) => {
    const existingSubdomain = await tx.tenant.findUnique({ where: { subdomain } });
    if (existingSubdomain) {
      throw new Error('El subdominio ya est√° en uso.');
    }

    const existingEmail = await tx.user.findUnique({ where: { email: adminUser.email } });
    if (existingEmail) {
      throw new Error('El correo electr√≥nico ya est√° en uso por otro usuario.');
    }

    const tenant = await tx.tenant.create({
      data: {
        companyName,
        subdomain,
      },
    });

    const hashedPassword = await hashPassword(adminUser.password);
    await tx.user.create({
      data: {
        name: adminUser.name,
        email: adminUser.email,
        password: hashedPassword,
        role: 'ADMIN',
        tenantId: tenant.id,
      },
    });

    return tenant;
  });

  return newTenant;
};

/**
 * Obtiene un listado de todos los tenants.
 * @returns Un array de todos los tenants.
 */
export const getAllTenants = async (): Promise<Tenant[]> => {
  return prisma.tenant.findMany({
    orderBy: {
      createdAt: 'desc',
    },
  });
};

/**
 * Busca un tenant espec√≠fico por su ID.
 * @param id - El ID del tenant a buscar.
 * @returns El objeto del tenant o null si no se encuentra.
 */
export const getTenantById = async (id: string): Promise<Tenant | null> => {
  return prisma.tenant.findUnique({
    where: { id },
  });
};

/**
 * Actualiza el estado de la suscripci√≥n de un tenant.
 * @param id - El ID del tenant a actualizar.
 * @param status - El nuevo estado de la suscripci√≥n.
 * @returns El objeto del tenant actualizado.
 */
export const updateTenantStatus = async (
  id: string,
  status: SubscriptionStatus
): Promise<Tenant> => {
  return prisma.tenant.update({
    where: { id },
    data: {
      subscriptionStatus: status,
    },
  });
};

/**
 * Elimina un tenant y toda su informaci√≥n asociada (cascade).
 * @param id - El ID del tenant a eliminar.
 * @returns El objeto del tenant que fue eliminado.
 */
export const deleteTenant = async (id: string): Promise<Tenant> => {
  // Gracias a 'onDelete: Cascade' en el schema, al borrar un tenant,
  // se borrar√°n en cascada todos sus usuarios, clientes, piscinas, etc.
  return prisma.tenant.delete({
    where: { id },
  });
};


// ====== [113] packages/server/src/api/uploads/uploads.controller.ts ======
// filename: packages/server/src/api/uploads/uploads.controller.ts
// version: 1.0.0
// description: Controlador para manejar las peticiones HTTP de firma de subidas.

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { generateUploadSignature } from './uploads.service.js';

/**
 * Maneja la petici√≥n del frontend para obtener una firma de subida.
 * Llama al servicio, obtiene la firma y la devuelve como respuesta JSON.
 */
export const getUploadSignatureHandler = (
  _req: AuthRequest, // No necesitamos la request, pero la incluimos por consistencia
  res: Response,
  next: NextFunction
) => {
  try {
    const signatureData = generateUploadSignature();
    res.status(200).json({ success: true, data: signatureData });
  } catch (error) {
    // Aunque es poco probable que la generaci√≥n de la firma falle si la config es correcta,
    // es buena pr√°ctica tener el manejo de errores.
    next(error);
  }
};


// ====== [114] packages/server/src/api/uploads/uploads.routes.ts ======
// filename: packages/server/src/api/uploads/uploads.routes.ts
// version: 1.0.0
// description: Define el endpoint para obtener la firma de subida.

import { Router } from 'express';
import { getUploadSignatureHandler } from './uploads.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const uploadsRouter = Router();

// Protegemos la ruta para que solo los usuarios autenticados (ej. un t√©cnico logueado)
// puedan obtener firmas y subir archivos. Esto previene el abuso del servicio.
uploadsRouter.use(protect);

/**
 * @route   GET /api/uploads/signature
 * @desc    Obtiene una firma y timestamp para autorizar una subida a Cloudinary.
 * @access  Private
 */
uploadsRouter.get('/signature', getUploadSignatureHandler);

export default uploadsRouter;


// ====== [115] packages/server/src/api/uploads/uploads.service.ts ======
// filename: packages/server/src/api/uploads/uploads.service.ts
// version: 1.0.0
// description: Servicio para generar firmas seguras para la subida de archivos a Cloudinary.

import { v2 as cloudinary } from 'cloudinary';
import config from '../../config/index.js';

// --- Configuraci√≥n del SDK de Cloudinary ---
// Se configura una √∫nica vez al cargar el m√≥dulo, utilizando las credenciales
// de nuestro archivo de configuraci√≥n centralizado.
cloudinary.config({
  cloud_name: config.CLOUDINARY_CLOUD_NAME,
  api_key: config.CLOUDINARY_API_KEY,
  api_secret: config.CLOUDINARY_API_SECRET,
  secure: true, // Siempre usar https para las URLs
});

/**
 * Genera una firma segura para autorizar una subida desde el cliente.
 * Este m√©todo no sube ning√∫n archivo, solo crea las credenciales temporales.
 * @returns Un objeto que contiene la firma, el timestamp y la api_key.
 */
export const generateUploadSignature = () => {
  // El timestamp es necesario para que Cloudinary pueda verificar que la firma
  // no es demasiado antigua y prevenir ataques de repetici√≥n.
  const timestamp = Math.round(new Date().getTime() / 1000);

  // Utilizamos la utilidad de Cloudinary para firmar los par√°metros.
  // En este caso, solo necesitamos firmar el timestamp, pero se podr√≠an
  // a√±adir m√°s par√°metros como transformaciones, carpetas, etc.
  const signature = cloudinary.utils.api_sign_request(
    {
      timestamp: timestamp,
    },
    config.CLOUDINARY_API_SECRET
  );

  // El frontend necesitar√° estos tres datos para poder autenticar
  // la petici√≥n de subida directamente contra la API de Cloudinary.
  return {
    timestamp,
    signature,
    apiKey: config.CLOUDINARY_API_KEY,
    cloudName: config.CLOUDINARY_CLOUD_NAME,
  };
};


// ====== [116] packages/server/src/api/users/users.controller.ts ======
// filename: packages/server/src/api/users/users.controller.ts
// version: 2.3.1 (Cleaned)

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { 
  getAssignableUsersByTenant, 
  updateUserAvailability,
  getAvailabilitiesForUser,
  setUserAvailability,
} from './users.service.js';

export const getAssignableUsersHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acci√≥n no permitida.' });
    }

    const assignableUsers = await getAssignableUsersByTenant(tenantId);
    res.status(200).json({ success: true, data: assignableUsers });
  } catch (error) {
    next(error);
  }
};

export const updateUserAvailabilityHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id: userId } = req.params;
    const { isAvailable } = req.body;
    const tenantId = req.user?.tenantId;

    if (!userId || !tenantId) {
        return res.status(400).json({ success: false, message: 'Falta el ID de usuario o de tenant.' });
    }
    
    if (typeof isAvailable !== 'boolean') {
        return res.status(400).json({ success: false, message: 'El campo isAvailable es requerido y debe ser un booleano.' });
    }

    const updatedUser = await updateUserAvailability(userId, tenantId, isAvailable);
    res.status(200).json({ success: true, data: updatedUser });

  } catch (error) {
    next(error);
  }
};

export const getUserAvailabilitiesHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id: userId } = req.params;
    const tenantId = req.user?.tenantId;

    if (!userId || !tenantId) {
      return res.status(400).json({ success: false, message: 'Falta el ID de usuario o de tenant.' });
    }

    const availabilities = await getAvailabilitiesForUser(userId, tenantId);
    res.status(200).json({ success: true, data: availabilities });

  } catch (error) {
    next(error);
  }
};

export const setUserAvailabilityHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    const { userId, startDate, endDate, reason } = req.body;

    if (!userId || !tenantId || !startDate || !endDate) {
      return res.status(400).json({ success: false, message: 'Faltan campos requeridos (userId, tenantId, startDate, endDate).' });
    }
    
    const newAvailability = await setUserAvailability({ userId, tenantId, startDate, endDate, reason });
    res.status(201).json({ success: true, data: newAvailability });
  } catch (error) {
    next(error);
  }
};


// ====== [117] packages/server/src/api/users/users.routes.ts ======
// filename: packages/server/src/api/users/users.routes.ts
// version: 2.3.0 (FEAT: Add routes for managing UserAvailability)

import { Router } from 'express';
// ‚úÖ CORRECCI√ìN: Importar los nuevos manejadores
import { 
  getAssignableUsersHandler, 
  updateUserAvailabilityHandler,
  getUserAvailabilitiesHandler,
  setUserAvailabilityHandler,
} from './users.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const usersRouter = Router();

usersRouter.use(protect);

/**
 * @route   GET /api/users/technicians
 * @desc    Obtiene una lista de todos los usuarios asignables (t√©cnicos y gerentes) del tenant.
 * @access  Private (Admin, Manager)
 */
usersRouter.get('/technicians', authorize('ADMIN', 'MANAGER'), getAssignableUsersHandler);

/**
 * @route   PATCH /api/users/:id/availability
 * @desc    Actualiza el estado de disponibilidad INMEDIATA de un usuario.
 * @access  Private (Admin)
 */
usersRouter.patch('/:id/availability', authorize('ADMIN'), updateUserAvailabilityHandler);


// --- ‚úÖ NUEVAS RUTAS PARA GESTIONAR AUSENCIAS PLANIFICADAS ---

/**
 * @route   GET /api/users/:id/availabilities
 * @desc    Obtiene todos los periodos de ausencia planificados para un usuario.
 * @access  Private (Admin)
 */
usersRouter.get('/:id/availabilities', authorize('ADMIN'), getUserAvailabilitiesHandler);

/**
 * @route   POST /api/users/availability
 * @desc    Crea un nuevo periodo de ausencia para un usuario.
 * @access  Private (Admin)
 */
usersRouter.post('/availability', authorize('ADMIN'), setUserAvailabilityHandler);


export default usersRouter;


// ====== [118] packages/server/src/api/users/users.service.ts ======
// filename: packages/server/src/api/users/users.service.ts
// version: 2.3.1 (FEAT: Format users as FullCalendar resources)

import { PrismaClient } from '@prisma/client';
import type { User, UserAvailability } from '@prisma/client';

const prisma = new PrismaClient();

export type SetUserAvailabilityInput = {
  userId: string;
  tenantId: string;
  startDate: string;
  endDate: string;
  reason?: string;
};

/**
 * Obtiene todos los usuarios a los que se les puede asignar trabajo (T√©cnicos y Gerentes),
 * formateados como recursos para FullCalendar.
 * @param tenantId - El ID del tenant.
 * @returns Un array de usuarios formateados.
 */
export const getAssignableUsersByTenant = async (
  tenantId: string
): Promise<any[]> => { // Devolvemos 'any' para flexibilidad, el frontend validar√°
  const users = await prisma.user.findMany({
    where: {
      tenantId,
      role: { in: ['TECHNICIAN', 'MANAGER'] },
      // Solo incluimos t√©cnicos que no est√©n marcados como permanentemente inactivos
      isAvailable: true, 
    },
    select: {
      id: true,
      name: true,
    },
    orderBy: {
      name: 'asc',
    },
  });

  // Mapeamos al formato que FullCalendar espera para los 'resources'
  return users.map(user => ({
    id: user.id,
    title: user.name, // FullCalendar usa 'title' para mostrar el nombre en la fila
  }));
};

/**
 * Actualiza el estado de disponibilidad inmediata de un usuario.
 */
export const updateUserAvailability = async (
  userId: string,
  tenantId: string,
  isAvailable: boolean
): Promise<User> => {
  const { count } = await prisma.user.updateMany({
    where: {
      id: userId,
      tenantId: tenantId,
    },
    data: {
      isAvailable: isAvailable,
    },
  });

  if (count === 0) {
    throw new Error('Usuario no encontrado o sin permisos para modificar.');
  }

  return prisma.user.findUniqueOrThrow({ where: { id: userId } });
};

/**
 * Obtiene todos los registros de ausencia para un usuario espec√≠fico.
 */
export const getAvailabilitiesForUser = async (userId: string, tenantId: string): Promise<UserAvailability[]> => {
  return prisma.userAvailability.findMany({
    where: {
      userId,
      tenantId,
    },
    orderBy: {
      startDate: 'desc',
    },
  });
};

/**
 * Crea un nuevo registro de ausencia planificada para un usuario.
 */
export const setUserAvailability = async (data: SetUserAvailabilityInput): Promise<UserAvailability> => {
  return prisma.userAvailability.create({
    data: {
      userId: data.userId,
      tenantId: data.tenantId,
      startDate: new Date(data.startDate),
      endDate: new Date(data.endDate),
      reason: data.reason,
    },
  });
};


// ====== [119] packages/server/src/api/visits/visits.controller.ts ======
// filename: packages/server/src/api/visits/visits.controller.ts
// version: 1.9.3 (FIXED)
// description: Se corrige el manejador getScheduledVisitsForWeekHandler para procesar correctamente los arrays de filtros desde req.query.

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { 
  getScheduledVisitsForWeek, 
  assignTechnicianToVisit,
  getVisitsForTechnicianOnDate,
  getVisitDetails,
  submitWorkOrder,
  createSpecialVisit,
  rescheduleVisit,
} from './visits.service.js';

/**
 * Maneja la obtenci√≥n de las visitas programadas para un rango de fechas.
 */
export const getScheduledVisitsForWeekHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acci√≥n no permitida.' });
    }

    // ‚úÖ CORRECCI√ìN: Procesar correctamente los par√°metros de la query
    const { startDate: startDateStr, endDate: endDateStr, technicianIds, zoneIds } = req.query;

    if (!startDateStr || !endDateStr || typeof startDateStr !== 'string' || typeof endDateStr !== 'string') {
      return res.status(400).json({ message: 'Los par√°metros startDate y endDate son obligatorios.' });
    }

    const startDate = new Date(startDateStr);
    const endDate = new Date(endDateStr);

    // Asegurarse de que los filtros de ID son arrays, incluso si solo llega uno.
    const techIdsArray = Array.isArray(technicianIds) ? technicianIds : (typeof technicianIds === 'string' ? [technicianIds] : undefined);
    const zoneIdsArray = Array.isArray(zoneIds) ? zoneIds : (typeof zoneIds === 'string' ? [zoneIds] : undefined);

    const visits = await getScheduledVisitsForWeek(
      tenantId, 
      startDate, 
      endDate,
      techIdsArray as string[] | undefined,
      zoneIdsArray as string[] | undefined
    );
    res.status(200).json({ success: true, data: visits });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la asignaci√≥n de un t√©cnico a una visita.
 */
export const assignTechnicianHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { visitId, technicianId } = req.body;
    if (!visitId) {
      return res.status(400).json({ message: 'visitId es requerido.' });
    }
    
    const assignedVisit = await assignTechnicianToVisit(visitId, technicianId);
    res.status(200).json({ success: true, data: assignedVisit });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la reprogramaci√≥n de una visita (fecha y/o t√©cnico).
 */
export const rescheduleVisitHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
    try {
        const { id } = req.params;
        const { timestamp, technicianId } = req.body;

        if (!id) {
            return res.status(400).json({ success: false, message: 'El ID de la visita es requerido.'});
        }
        if (!timestamp) {
            return res.status(400).json({ success: false, message: 'El campo timestamp es obligatorio.'});
        }

        const updatedVisit = await rescheduleVisit(id, { timestamp, technicianId });
        res.status(200).json({ success: true, data: updatedVisit });
    } catch (error) {
        next(error);
    }
};

/**
 * Maneja la obtenci√≥n de la ruta diaria para el t√©cnico autenticado.
 */
export const getMyRouteHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const technicianId = req.user?.id;
    if (!technicianId || (req.user?.role !== 'TECHNICIAN' && req.user?.role !== 'MANAGER')) {
      return res.status(403).json({ message: 'Acceso denegado.' });
    }
    
    const today = new Date();
    const visits = await getVisitsForTechnicianOnDate(technicianId, today);
    res.status(200).json({ success: true, data: visits });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de los detalles de una visita espec√≠fica.
 */
export const getVisitDetailsHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la visita es requerido.' });
    }
    
    const visitDetails = await getVisitDetails(id);
    if (!visitDetails) {
      return res.status(404).json({ message: 'Visita no encontrada.' });
    }

    res.status(200).json({ success: true, data: visitDetails });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja el env√≠o de un parte de trabajo.
 */
export const submitWorkOrderHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la visita es requerido.' });
    }
    
    await submitWorkOrder(id, req.body);
    res.status(200).json({ success: true, message: 'Parte de trabajo guardado con √©xito.' });
  } catch (error) {
    console.error('ERROR AL PROCESAR PARTE DE TRABAJO:', error); 
    next(error);
  }
};

/**
 * Maneja la creaci√≥n de una visita especial (Orden de Trabajo Especial).
 */
export const createSpecialVisitHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
    try {
        const { poolId, timestamp } = req.body;
        if (!poolId || !timestamp) {
            return res.status(400).json({ success: false, message: 'Los campos poolId y timestamp son obligatorios.' });
        }

        const newVisit = await createSpecialVisit(req.body);
        res.status(201).json({ success: true, data: newVisit });
    } catch (error) {
        next(error);
    }
};


// ====== [120] packages/server/src/api/visits/visits.routes.ts ======
// filename: packages/server/src/api/visits/visits.routes.ts
// Version: 2.2.0 (FEAT: Add route for visit rescheduling)

import { Router } from 'express';
import { 
  getScheduledVisitsForWeekHandler,
  assignTechnicianHandler,
  getMyRouteHandler,
  getVisitDetailsHandler,
  submitWorkOrderHandler,
  createSpecialVisitHandler,
  rescheduleVisitHandler, // ‚úÖ NUEVA IMPORTACI√ìN
} from './visits.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const visitsRouter = Router();

// Todas las rutas de visitas requieren que el usuario est√© autenticado.
visitsRouter.use(protect);

// --- Rutas a nivel de colecci√≥n ---
visitsRouter.get('/scheduled', authorize('ADMIN'), getScheduledVisitsForWeekHandler);
visitsRouter.post('/assign', authorize('ADMIN'), assignTechnicianHandler);
visitsRouter.post('/special', authorize('ADMIN'), createSpecialVisitHandler);
visitsRouter.get('/my-route', authorize('TECHNICIAN'), getMyRouteHandler);

// --- Rutas para una visita espec√≠fica por ID ---
// ‚úÖ NUEVA RUTA PARA REPROGRAMAR
visitsRouter.patch('/:id/reschedule', authorize('ADMIN'), rescheduleVisitHandler);

visitsRouter.post('/:id/complete', authorize('TECHNICIAN'), submitWorkOrderHandler);
visitsRouter.get('/:id', authorize('ADMIN', 'TECHNICIAN'), getVisitDetailsHandler);


export default visitsRouter;


// ====== [121] packages/server/src/api/visits/visits.service.ts ======
// filename: packages/server/src/api/visits/visits.service.ts
// version: 2.5.1 (COMPLETE & FIXED)
// description: Modifica getScheduledVisitsForWeek para que acepte y aplique filtros por ID de t√©cnico y de zona.

import { PrismaClient } from '@prisma/client';
import type { Visit } from '@prisma/client';
import { 
  startOfDay, endOfDay,
} from 'date-fns';

const prisma = new PrismaClient();

// --- Tipos ---
export type WorkOrderInput = {
  results: Record<string, string | number | boolean>;
  completedTasks: Record<string, boolean>;
  consumptions?: { productId: string; quantity: number }[];
  notes?: string;
  hasIncident?: boolean;
  imageUrls?: string[]; 
};
export type CreateSpecialVisitInput = {
  poolId: string;
  timestamp: Date;
  notes?: string;
  technicianId?: string | null;
}
export type RescheduleVisitInput = {
  timestamp: Date;
  technicianId: string | null;
}

// --- Funciones del Servicio ---

export const getScheduledVisitsForWeek = async (
  tenantId: string, 
  startDate: Date, 
  endDate: Date,
  technicianIds?: string[],
  zoneIds?: string[]
): Promise<Visit[]> => {
  return prisma.visit.findMany({
    where: { 
      pool: { 
        tenantId,
        zoneId: zoneIds && zoneIds.length > 0 ? { in: zoneIds } : undefined,
      }, 
      timestamp: { 
        gte: startDate, 
        lte: endDate 
      },
      technicianId: technicianIds && technicianIds.length > 0 ? { in: technicianIds } : undefined,
    },
    include: { 
      pool: { include: { client: true, zone: true } },
      technician: { 
        select: { 
          id: true, 
          name: true, 
          isAvailable: true,
          availabilities: true,
        } 
      },
    },
    orderBy: { timestamp: 'asc' },
  });
};

export const assignTechnicianToVisit = async (visitId: string, technicianId: string | null) => {
    return prisma.visit.update({
        where: { id: visitId },
        data: { technicianId },
    });
};

export const rescheduleVisit = async (visitId: string, data: RescheduleVisitInput) => {
  return prisma.visit.update({
    where: { id: visitId },
    data: {
      timestamp: data.timestamp,
      technicianId: data.technicianId,
    },
  });
};

export const getVisitsForTechnicianOnDate = async (
  technicianId: string,
  date: Date
): Promise<Visit[]> => {
  const dayStart = startOfDay(date);
  const dayEnd = endOfDay(date);

  return prisma.visit.findMany({
    where: {
      technicianId,
      status: 'PENDING',
      timestamp: {
        gte: dayStart,
        lte: dayEnd,
      },
    },
    include: {
      pool: {
        include: {
          client: true,
        },
      },
      technician: { 
        select: { 
          id: true, 
          name: true, 
          isAvailable: true,
          availabilities: true,
        } 
      },
    },
    orderBy: {
      timestamp: 'asc',
    },
  });
};

export const getVisitDetails = async (visitId: string) => {
  return prisma.visit.findUnique({
    where: { id: visitId },
    include: {
      results: true, 
      notifications: {
        include: {
          images: true,
        }
      },
      consumptions: {
        include: {
          product: true,
        }
      },
      pool: {
        include: {
          client: true,
          configurations: {
            include: {
              parameterTemplate: true,
              taskTemplate: true,
            },
          },
        },
      },
      technician: true,
    },
  });
};

export const submitWorkOrder = async (visitId: string, data: WorkOrderInput) => {
  return prisma.$transaction(async (tx) => {
    const visit = await tx.visit.findUnique({
      where: { id: visitId },
      include: { 
        pool: { 
          include: { 
            configurations: { include: { parameterTemplate: true, taskTemplate: true } } 
          } 
        },
        technician: true
      },
    });
    if (!visit || !visit.technicianId) throw new Error('Visita o t√©cnico no encontrados');
    
    const { results, completedTasks, notes, hasIncident, consumptions = [], imageUrls = [] } = data;

    if (consumptions && consumptions.length > 0) {
        const validConsumptions = consumptions
            .filter(c => c.productId && c.quantity && c.quantity > 0)
            .map(c => ({
                quantity: c.quantity,
                productId: c.productId,
                visitId: visitId,
            }));

        if (validConsumptions.length > 0) {
          await tx.consumption.createMany({
                data: validConsumptions,
            });
        }
    }

    const usersToNotify = await tx.user.findMany({
      where: {
        tenantId: visit.pool.tenantId,
        role: { in: ['ADMIN', 'MANAGER'] }
      },
      select: { id: true }
    });
    const notificationsToCreate: { message: string; tenantId: string; userId: string; visitId: string; priority: 'HIGH' }[] = [];
    for (const [configId, value] of Object.entries(results)) {
      if(value === '' || value === null || typeof value !== 'number') continue;
      const config = visit.pool.configurations.find(c => c.id === configId);
      if (config?.parameterTemplate) {
        await tx.visitResult.create({
          data: { visitId, value: String(value), parameterName: config.parameterTemplate.name, parameterUnit: config.parameterTemplate.unit, },
        });
        const { minThreshold, maxThreshold, parameterTemplate: { name: paramName, unit } } = config;
        let alertMessage = '';
        if (minThreshold !== null && value < minThreshold) {
            alertMessage = `Alerta en ${visit.pool.name}: ${paramName} est√° bajo (${value} ${unit || ''}). L√≠mite inferior: ${minThreshold}.`;
        } else if (maxThreshold !== null && value > maxThreshold) {
            alertMessage = `Alerta en ${visit.pool.name}: ${paramName} est√° alto (${value} ${unit || ''}). L√≠mite superior: ${maxThreshold}.`;
        }

        if (alertMessage) {
          for (const user of usersToNotify) {
            notificationsToCreate.push({
              message: alertMessage,
              tenantId: visit.pool.tenantId,
              userId: user.id,
              visitId: visit.id,
              priority: 'HIGH'
            });
          }
        }
      }
    }
    
    const completedTaskNames = Object.entries(completedTasks)
      .filter(([, completed]) => completed)
      .map(([configId]) => {
        const config = visit.pool.configurations.find(c => c.id === configId);
        return config?.taskTemplate?.name || 'Tarea desconocida';
      });
    await tx.visit.update({
      where: { id: visitId },
      data: { notes, hasIncident: hasIncident || false, completedTasks: completedTaskNames, status: 'COMPLETED', },
    });
    if (hasIncident && usersToNotify.length > 0) {
      const notificationMessage = notes && notes.trim().length > 0 
            ? notes 
            : `Incidencia reportada en ${visit.pool.name} por ${visit.technician?.name || 'un t√©cnico'}`;

      for (const user of usersToNotify) {
        notificationsToCreate.push({
            message: notificationMessage,
            tenantId: visit.pool.tenantId,
            userId: user.id,
            visitId: visit.id,
            priority: 'HIGH'
        });
      }
    }
    
    if (notificationsToCreate.length > 0) {
      const uniqueNotifications = Array.from(new Map(notificationsToCreate.map(item => [item.message, item])).values());
      const mainNotification = uniqueNotifications.find(n => n.message.startsWith('Incidencia reportada'));
      let mainNotificationId: string | undefined;
      if(mainNotification) {
        const createdMainNotification = await tx.notification.create({ data: mainNotification });
        mainNotificationId = createdMainNotification.id;
      }
      
      const otherNotifications = uniqueNotifications.filter(n => !n.message.startsWith('Incidencia reportada'));
      if (otherNotifications.length > 0) {
          await tx.notification.createMany({ data: otherNotifications });
      }

      if (mainNotificationId && imageUrls.length > 0) {
        await tx.incidentImage.createMany({
          data: imageUrls.map(url => ({
            url: url,
            notificationId: mainNotificationId!,
            uploaderId: visit.technicianId!,
          })),
        });
      }
    }
    
    const configIdsToUpdate = [...Object.keys(results).filter(k => results[k] !== ''), ...Object.keys(completedTasks).filter(k => completedTasks[k])];
    if(configIdsToUpdate.length > 0) {
        await tx.poolConfiguration.updateMany({
            where: { id: { in: configIdsToUpdate } },
            data: { lastCompleted: new Date() },
        });
    }
  });
};

export const createSpecialVisit = async (data: CreateSpecialVisitInput): Promise<Visit> => {
  return prisma.visit.create({
    data: {
      poolId: data.poolId,
      timestamp: data.timestamp,
      technicianId: data.technicianId,
      notes: data.notes,
      status: 'PENDING',
    }
  });
};


// ====== [122] packages/server/src/api/zones/zones.controller.ts ======
// filename: packages/server/src/api/zones/zones.controller.ts
// version: 1.0.0
// description: Controlador para manejar las peticiones HTTP del CRUD de Zonas.

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createZone,
  getZonesByTenant,
  updateZone,
  deleteZone,
} from './zones.service.js';

/**
 * Maneja la creaci√≥n de una nueva zona.
 */
export const createZoneHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }

    const input = { ...req.body, tenantId };
    const newZone = await createZone(input);
    res.status(201).json({ success: true, data: newZone });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todas las zonas de un tenant.
 */
export const getZonesByTenantHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }
    const zones = await getZonesByTenant(tenantId);
    res.status(200).json({ success: true, data: zones });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n de una zona.
 */
export const updateZoneHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de zona o de tenant faltante.' });
    }
    
    const updatedZone = await updateZone(id, tenantId, req.body);
    res.status(200).json({ success: true, data: updatedZone });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de una zona.
 */
export const deleteZoneHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    const tenantId = req.user?.tenantId;

    if (!id || !tenantId) {
      return res.status(400).json({ success: false, message: 'ID de zona o de tenant faltante.' });
    }

    await deleteZone(id, tenantId);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [123] packages/server/src/api/zones/zones.routes.ts ======
// filename: packages/server/src/api/zones/zones.routes.ts
// version: 1.0.0
// description: Define los endpoints de la API para el recurso de Zonas.

import { Router } from 'express';
import {
  createZoneHandler,
  getZonesByTenantHandler,
  updateZoneHandler,
  deleteZoneHandler,
} from './zones.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
import { authorize } from '../../middleware/authorize.middleware.js';

const zonesRouter = Router();

// Aplicamos la seguridad a todas las rutas de este fichero.
// 1. `protect`: Asegura que el usuario est√© autenticado.
// 2. `authorize('ADMIN')`: Asegura que el rol del usuario sea ADMIN.
zonesRouter.use(protect, authorize('ADMIN'));

// Rutas para /api/zones
zonesRouter.route('/')
  .get(getZonesByTenantHandler)
  .post(createZoneHandler);

// Rutas para /api/zones/:id
zonesRouter.route('/:id')
  .patch(updateZoneHandler)
  .delete(deleteZoneHandler);

export default zonesRouter;


// ====== [124] packages/server/src/api/zones/zones.service.ts ======
// filename: packages/server/src/api/zones/zones.service.ts
// version: 1.0.0
// description: Servicio para la l√≥gica de negocio (CRUD) de las Zonas Geogr√°ficas.

import { PrismaClient } from '@prisma/client';
import type { Zone } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateZoneInput = {
  name: string;
  tenantId: string;
};

export type UpdateZoneInput = {
  name: string;
};


// --- Funciones del Servicio ---

/**
 * Crea una nueva zona para un tenant, asegurando que el nombre no est√© duplicado.
 * @param data - Los datos de la zona a crear, incluyendo name y tenantId.
 * @returns La zona reci√©n creada.
 * @throws Si ya existe una zona con el mismo nombre en el tenant.
 */
export const createZone = async (data: CreateZoneInput): Promise<Zone> => {
  // 1. Validar que no exista otra zona con el mismo nombre en el mismo tenant.
  const existingZone = await prisma.zone.findFirst({
    where: {
      name: data.name,
      tenantId: data.tenantId,
    },
  });

  if (existingZone) {
    throw new Error('Ya existe una zona con este nombre.');
  }

  // 2. Crear la zona.
  return prisma.zone.create({
    data,
  });
};

/**
 * Obtiene todas las zonas de un tenant espec√≠fico, ordenadas alfab√©ticamente.
 * @param tenantId - El ID del tenant.
 * @returns Un array con todas las zonas del tenant.
 */
export const getZonesByTenant = async (tenantId: string): Promise<Zone[]> => {
  return prisma.zone.findMany({
    where: { tenantId },
    orderBy: { name: 'asc' },
  });
};

/**
 * Actualiza el nombre de una zona, verificando la pertenencia al tenant.
 * @param id - El ID de la zona a actualizar.
 * @param tenantId - El ID del tenant del usuario para validaci√≥n.
 * @param data - Los nuevos datos para la zona (ej. el nuevo nombre).
 * @returns La zona actualizada.
 * @throws Si la zona no se encuentra o no pertenece al tenant.
 */
export const updateZone = async (id: string, tenantId: string, data: UpdateZoneInput): Promise<Zone> => {
  // Usamos una transacci√≥n para realizar la comprobaci√≥n y la actualizaci√≥n de forma segura.
  return prisma.$transaction(async (tx) => {
    // 1. Verificar que la zona a actualizar pertenece al tenant correcto.
    const zoneToUpdate = await tx.zone.findFirst({
      where: { id, tenantId },
    });

    if (!zoneToUpdate) {
      throw new Error('Zona no encontrada o sin permisos para modificar.');
    }

    // 2. Actualizar la zona.
    return tx.zone.update({
      where: { id },
      data,
    });
  });
};

/**
 * Elimina una zona, verificando primero que no tenga piscinas asociadas.
 * @param id - El ID de la zona a eliminar.
 * @param tenantId - El ID del tenant del usuario para validaci√≥n.
 * @throws Si la zona no se encuentra, no pertenece al tenant, o si a√∫n contiene piscinas.
 */
export const deleteZone = async (id: string, tenantId: string): Promise<void> => {
  // 1. Regla de Negocio Cr√≠tica: Verificar si la zona tiene piscinas asignadas.
  const poolCount = await prisma.pool.count({
    where: {
      zoneId: id,
      tenantId: tenantId, // Aseguramos contar solo piscinas del tenant correcto.
    },
  });

  if (poolCount > 0) {
    throw new Error('No se puede eliminar la zona porque contiene piscinas. Reas√≠gnelas primero.');
  }

  // 2. Si no hay piscinas, proceder con la eliminaci√≥n segura.
  const { count } = await prisma.zone.deleteMany({
    where: {
      id,
      tenantId, // Condici√≥n de seguridad para asegurar que solo borramos en nuestro tenant.
    },
  });

  if (count === 0) {
    throw new Error('Zona no encontrada o sin permisos para eliminar.');
  }
};


// ====== [125] packages/server/src/app.ts ======
// filename: packages/server/src/app.ts
// version: 3.0.0 (FEAT: Mount planningRouter)

import express from 'express';
import type { Request, Response } from 'express';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import { errorHandler } from './middleware/error.middleware.js';
import authRouter from './api/auth/auth.routes.js';
import tenantsRouter from './api/tenants/tenants.routes.js';
import parametersRouter from './api/parameters/parameters.routes.js';
import tasksRouter from './api/tasks/tasks.routes.js';
import clientsRouter from './api/clients/clients.routes.js';
import poolsRouter from './api/pools/pools.routes.js';
import poolConfigurationsRouter from './api/pool-configurations/pool-configurations.routes.js';
import visitsRouter from './api/visits/visits.routes.js';
import usersRouter from './api/users/users.routes.js';
import notificationsRouter from './api/notifications/notifications.routes.js';
import productsRouter from './api/products/products.routes.js';
import incidentTasksRouter from './api/incident-tasks/incident-tasks.routes.js';
import uploadsRouter from './api/uploads/uploads.routes.js';
import productCategoriesRouter from './api/product-categories/product-categories.routes.js';
import clientProductPricingRouter from './api/client-product-pricing/client-product-pricing.routes.js';
import paymentsRouter from './api/payments/payments.routes.js';
import expensesRouter from './api/expenses/expenses.routes.js';
import dashboardRouter from './api/dashboard/dashboard.routes.js';
import reportsRouter from './api/reports/reports.routes.js';
import zonesRouter from './api/zones/zones.routes.js';
import routeTemplatesRouter from './api/route-templates/route-templates.routes.js';
// ‚úÖ 1. Importar el nuevo router
import planningRouter from './api/planning/planning.routes.js';

const app = express();

app.use(cors({
  origin: 'http://localhost:5173',
  credentials: true,
}));
app.use(cookieParser());
app.use(express.json());


app.get('/api/health', (_req: Request, res: Response) => {
  res.status(200).json({ status: 'UP' });
});

app.use('/api/auth', authRouter);
app.use('/api/tenants', tenantsRouter);
app.use('/api/parameters', parametersRouter);
app.use('/api/tasks', tasksRouter);
app.use('/api/clients', clientsRouter);
app.use('/api/pools', poolsRouter);
app.use('/api/pool-configurations', poolConfigurationsRouter);
app.use('/api/visits', visitsRouter);
app.use('/api/users', usersRouter);
app.use('/api/notifications', notificationsRouter);
app.use('/api/products', productsRouter);
app.use('/api/incident-tasks', incidentTasksRouter);
app.use('/api/uploads', uploadsRouter);
app.use('/api/product-categories', productCategoriesRouter);
app.use('/api/client-product-pricing', clientProductPricingRouter);
app.use('/api/payments', paymentsRouter);
app.use('/api/expenses', expensesRouter);
app.use('/api/dashboard', dashboardRouter);
app.use('/api/reports', reportsRouter);
app.use('/api/zones', zonesRouter);
app.use('/api/route-templates', routeTemplatesRouter);
// ‚úÖ 2. Montar el nuevo router
app.use('/api/planning', planningRouter);

app.use(errorHandler);

export default app;


// ====== [126] packages/server/src/config/index.ts ======
// filename: packages/server/src/config/index.ts
// version: 2.0.0 (Add Cloudinary credentials)

import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

// --- Recreaci√≥n de __dirname para ES Modules ---
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
// ---------------------------------------------

dotenv.config({ path: path.resolve(__dirname, '../../.env') });

const getEnvVar = (key: string): string => {
  const value = process.env[key];
  if (!value) {
    throw new Error(`Falta la variable de entorno requerida: ${key}`);
  }
  return value;
};

const config = {
  PORT: parseInt(getEnvVar('PORT'), 10),
  JWT_SECRET: getEnvVar('JWT_SECRET'),
  JWT_EXPIRES_IN: parseInt(getEnvVar('JWT_EXPIRES_IN'), 10),
  DATABASE_URL: getEnvVar('DATABASE_URL'),

  // --- Nuevas credenciales de Cloudinary ---
  CLOUDINARY_CLOUD_NAME: getEnvVar('CLOUDINARY_CLOUD_NAME'),
  CLOUDINARY_API_KEY: getEnvVar('CLOUDINARY_API_KEY'),
  CLOUDINARY_API_SECRET: getEnvVar('CLOUDINARY_API_SECRET'),
};

export default config;


// ====== [127] packages/server/src/jobs/visit-generator.job.ts ======
// filename: packages/server/src/jobs/visit-generator.job.ts
// version: 1.0.0
// description: Script para generar autom√°ticamente las visitas de la semana basadas en las Rutas Maestras.

import { PrismaClient } from '@prisma/client';
import type { DayOfWeek } from '@prisma/client';
import {
  startOfWeek,
  addDays,
  getISOWeek,
  isWithinInterval,
  startOfDay,
} from 'date-fns';

const prisma = new PrismaClient();

const DAY_OF_WEEK_ORDER: DayOfWeek[] = [
  'MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY', 'SUNDAY'
];

/**
 * Genera las visitas para una semana espec√≠fica bas√°ndose en las Rutas Maestras.
 * @param targetDate - Una fecha dentro de la semana para la que se generar√°n las visitas.
 */
async function generateWeeklyVisits(targetDate: Date) {
  console.log('--- ü§ñ Iniciando Job de Generaci√≥n de Visitas ---');
  
  const startOfTargetWeek = startOfWeek(targetDate, { weekStartsOn: 1 });
  const targetWeekNumber = getISOWeek(startOfTargetWeek);
  
  console.log(`üìÖ Procesando semana del ${startOfTargetWeek.toLocaleDateString()} (Semana ISO: ${targetWeekNumber})`);

  const templates = await prisma.routeTemplate.findMany({
    include: {
      seasons: true,
      zones: { select: { id: true } },
      technician: { select: { id: true } },
    },
  });
  
  let totalVisitsCreated = 0;

  for (const template of templates) {
    // 1. Encontrar la temporada activa para la semana actual
    const activeSeason = template.seasons.find(season => 
      isWithinInterval(startOfTargetWeek, { start: season.startDate, end: season.endDate })
    );

    if (!activeSeason) {
      console.log(`- Ruta '${template.name}': Omitida (sin temporada activa para esta semana).`);
      continue;
    }

    // 2. Determinar si se debe crear una visita seg√∫n la frecuencia
    let shouldCreateVisit = false;
    switch (activeSeason.frequency) {
      case 'WEEKLY':
        shouldCreateVisit = true;
        break;
      case 'BIWEEKLY': // Cada dos semanas (semanas pares del a√±o)
        shouldCreateVisit = targetWeekNumber % 2 === 0;
        break;
      case 'MONTHLY': // La primera semana del mes
        shouldCreateVisit = startOfTargetWeek.getDate() <= 7;
        break;
      case 'QUARTERLY': // La primera semana del primer mes de cada trimestre
        const isFirstWeekOfMonth = startOfTargetWeek.getDate() <= 7;
        const isFirstMonthOfQuarter = [0, 3, 6, 9].includes(startOfTargetWeek.getMonth());
        shouldCreateVisit = isFirstWeekOfMonth && isFirstMonthOfQuarter;
        break;
    }

    if (!shouldCreateVisit) {
      console.log(`- Ruta '${template.name}': Omitida (frecuencia ${activeSeason.frequency} no aplica esta semana).`);
      continue;
    }
    
    // 3. Calcular la fecha exacta de la visita
    const dayIndex = DAY_OF_WEEK_ORDER.indexOf(template.dayOfWeek);
    if (dayIndex === -1) continue;
    
    const visitDate = startOfDay(addDays(startOfTargetWeek, dayIndex));

    // 4. Obtener todas las piscinas de las zonas de la ruta
    const zoneIds = template.zones.map(z => z.id);
    const poolsInRoute = await prisma.pool.findMany({
      where: { zoneId: { in: zoneIds } },
    });

    if (poolsInRoute.length === 0) continue;

    console.log(`- Ruta '${template.name}': Procesando ${poolsInRoute.length} piscinas para el ${visitDate.toLocaleDateString()}...`);

    // 5. Crear las visitas si no existen
    for (const pool of poolsInRoute) {
      const existingVisit = await prisma.visit.findFirst({
        where: {
          poolId: pool.id,
          timestamp: visitDate,
        },
      });

      if (existingVisit) {
        console.log(`  - Omitida: Visita para '${pool.name}' ya existe.`);
      } else {
        await prisma.visit.create({
          data: {
            poolId: pool.id,
            timestamp: visitDate,
            technicianId: template.technician?.id,
            status: 'PENDING',
          },
        });
        console.log(`  - ‚úÖ Creada: Visita para '${pool.name}'.`);
        totalVisitsCreated++;
      }
    }
  }
  
  console.log(`\n--- ‚ú® Job Finalizado. Total de visitas nuevas creadas: ${totalVisitsCreated} ---`);
}

// --- Bloque de Ejecuci√≥n ---
async function runJob() {
  try {
    // Se puede pasar una fecha espec√≠fica para pruebas, ej: new Date('2025-07-21')
    await generateWeeklyVisits(new Date()); 
  } catch (e) {
    console.error('‚ùå Error fatal durante la ejecuci√≥n del job:', e);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

runJob();


// ====== [128] packages/server/src/middleware/auth.middleware.ts ======
// filename: packages/server/src/middleware/auth.middleware.ts
// version: 2.0.1 (FIXED)
// description: Se a√±ade 'isAvailable' a la consulta del usuario para que el objeto 'user' est√© completo.

import type { Request, Response, NextFunction } from 'express';
import { PrismaClient, UserRole } from '@prisma/client';
import type { User } from '@prisma/client';
import { verifyToken } from '../utils/jwt.utils.js';

const prisma = new PrismaClient();

type SafeUser = Omit<User, 'password'>;

export interface AuthRequest extends Request {
  user?: SafeUser;
}

/**
 * Middleware para proteger rutas. Verifica el token JWT y maneja la suplantaci√≥n de rol.
 */
export const protect = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  const token = req.cookies.token;

  if (!token) {
    return res.status(401).json({ message: 'No autenticado: no hay token.' });
  }

  try {
    const decoded = verifyToken<{ id: string }>(token);

    if (!decoded) {
      return res.status(401).json({ message: 'No autenticado: token inv√°lido.' });
    }

    const user = await prisma.user.findUnique({
      where: { id: decoded.id },
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        tenantId: true,
        createdAt: true,
        updatedAt: true,
        isAvailable: true, // ‚úÖ CORRECCI√ìN: A√±adido el campo que faltaba.
      },
    });

    if (!user) {
      return res.status(401).json({ message: 'No autenticado: usuario no encontrado.' });
    }
    
    const viewAsRoleHeader = req.headers['x-view-as-role'] as UserRole | undefined;

    if (user.role === 'MANAGER' && viewAsRoleHeader) {
      const allowedViews: UserRole[] = ['ADMIN', 'TECHNICIAN'];
      if (allowedViews.includes(viewAsRoleHeader)) {
        user.role = viewAsRoleHeader;
      }
    }
    
    req.user = user;
    next();
  } catch (error) {
    return res.status(401).json({ message: 'No autenticado: error en la validaci√≥n.' });
  }
};


// ====== [129] packages/server/src/middleware/authorize.middleware.ts ======
// filename: packages/server/src/middleware/authorize.middleware.ts
// version: 1.0.0
// description: Middleware para la autorizaci√≥n basada en roles.

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from './auth.middleware.js';
import type { UserRole } from '@prisma/client';

/**
 * Crea un middleware de Express que verifica si el rol del usuario autenticado
 * est√° incluido en la lista de roles permitidos.
 *
 * @param {...UserRole} allowedRoles - Una lista de roles que tienen permiso para acceder a la ruta.
 * @returns Un middleware de Express.
 */
export const authorize = (...allowedRoles: UserRole[]) => {
  return (req: AuthRequest, res: Response, next: NextFunction) => {
    // El middleware 'protect' debe haberse ejecutado antes, por lo que 'req.user' deber√≠a existir.
    if (!req.user) {
      return res.status(401).json({
        success: false,
        message: 'No autenticado. Imposible realizar la autorizaci√≥n.',
      });
    }

    const { role } = req.user;

    // Comprobamos si el rol del usuario est√° en la lista de roles permitidos.
    // Importante: Esto comprueba el rol REAL del usuario en la DB, no el de la vista "Camale√≥n".
    // La l√≥gica de la vista "Camale√≥n" ya se ha aplicado en el middleware `protect`.
    if (!allowedRoles.includes(role)) {
      return res.status(403).json({
        success: false,
        message: `Acceso denegado. Tu rol ('${role}') no tiene permiso para este recurso. Roles permitidos: ${allowedRoles.join(', ')}.`,
      });
    }

    // Si el rol es v√°lido, pasamos al siguiente middleware o al controlador de la ruta.
    next();
  };
};


// ====== [130] packages/server/src/middleware/error.middleware.ts ======
import type { Request, Response, NextFunction } from 'express';

// Interfaz para asegurar que nuestros errores puedan tener un c√≥digo de estado
interface HttpError extends Error {
  statusCode?: number;
}

export const errorHandler = (
  err: HttpError,
  _req: Request,
  res: Response,
  _next: NextFunction
) => {
  // Guardamos el error en la consola para depuraci√≥n
  console.error(err);

  const statusCode = err.statusCode || 500;
  const message = err.message || 'Ha ocurrido un error inesperado en el servidor.';

  res.status(statusCode).json({
    success: false,
    statusCode: statusCode,
    message: message,
  });
};


// ====== [131] packages/server/src/server.ts ======
import app from './app.js';
import config from './config/index.js';

const PORT = config.PORT || 3001;

app.listen(PORT, () => {
  console.log(`üöÄ Servidor escuchando en http://localhost:${PORT}`);
});


// ====== [132] packages/server/src/utils/jwt.utils.ts ======
import jwt from 'jsonwebtoken';
import type { SignOptions } from 'jsonwebtoken';
import config from '../config/index.js';

/**
 * Firma un payload para crear un token JWT.
 * @param payload El objeto que se incluir√° en el token (ej. { userId: '...' }).
 * @returns El token JWT como una cadena de texto.
 */
export const signToken = (payload: object): string => {
  const options: SignOptions = {
    expiresIn: config.JWT_EXPIRES_IN,
  };

  return jwt.sign(payload, config.JWT_SECRET, options);
};

/**
 * Verifica un token JWT y devuelve su payload si es v√°lido.
 * @template T El tipo esperado del payload.
 * @param token El token JWT a verificar.
 * @returns El payload decodificado si el token es v√°lido; de lo contrario, null.
 */
export const verifyToken = <T>(token: string): T | null => {
  try {
    const decoded = jwt.verify(token, config.JWT_SECRET) as T;
    return decoded;
  } catch (error) {
    return null;
  }
};


// ====== [133] packages/server/src/utils/password.utils.ts ======
import bcrypt from 'bcryptjs';

const SALT_ROUNDS = 12;

/**
 * Genera el hash de una contrase√±a en texto plano.
 * @param password La contrase√±a en texto plano.
 * @returns Una promesa que resuelve en el hash de la contrase√±a.
 */
export const hashPassword = (password: string): Promise<string> => {
  return bcrypt.hash(password, SALT_ROUNDS);
};

/**
 * Compara una contrase√±a en texto plano con un hash.
 * @param password La contrase√±a en texto plano a comparar.
 * @param hash El hash almacenado en la base de datos.
 * @returns Una promesa que resuelve en `true` si las contrase√±as coinciden, `false` en caso contrario.
 */
export const comparePassword = (password: string, hash: string): Promise<boolean> => {
  return bcrypt.compare(password, hash);
};


// ====== [134] packages/server/tsconfig.json ======
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist"
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules"]
}


// ====== [135] tsconfig.json ======
// filename: tsconfig.json
// version: 2.0.0 (FIXED)
// description: Convierte el tsconfig a un "solution-style" para monorepos, delegando la compilaci√≥n a los paquetes.

{
  "compilerOptions": {
    /* Base Options */
    "esModuleInterop": true,
    "skipLibCheck": true,
    "target": "ES2022",
    "allowJs": true,
    "resolveJsonModule": true,
    "moduleDetection": "force",
    "isolatedModules": true,
    "verbatimModuleSyntax": true,

    /* Strictness */
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitAny": true,

    /* Module Resolution */
    "moduleResolution": "NodeNext",
    "module": "NodeNext",

    /* Linter */
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true
  },
  
  // ‚úÖ CORRECCI√ìN: Se elimina "exclude" y se a√±aden estas dos propiedades
  "files": [], // Le decimos a TS que no compile ning√∫n archivo desde la ra√≠z.
  "references": [
    // Le decimos a TS que este es un proyecto compuesto y que debe buscar
    // la configuraci√≥n espec√≠fica dentro de estas carpetas.
    { "path": "./packages/client" },
    { "path": "./packages/server" }
  ]
}

