# √çNDICE DE ARCHIVOS (ESTRUCTURA REFACTORIZADA)

1. DEVELOPMENT_PLAN.md
2. PROJECT_STATUS.md
3. README.md
4. package.json
5. packages/client/index.html
6. packages/client/package.json
7. packages/client/src/App.tsx
8. packages/client/src/api/apiClient.ts
9. packages/client/src/features/admin/pages/AdminDashboard.tsx
10. packages/client/src/features/admin/pages/IncidentsHistoryPage.tsx
11. packages/client/src/features/admin/pages/ParameterCatalogPage.tsx
12. packages/client/src/features/admin/pages/ProductCatalogPage.tsx
13. packages/client/src/features/admin/pages/TaskCatalogPage.tsx
14. packages/client/src/features/admin/pages/clients/ClientDetailPage.tsx
15. packages/client/src/features/admin/pages/clients/ClientsPage.tsx
16. packages/client/src/features/admin/pages/incidents/IncidentDetailPage.tsx
17. packages/client/src/features/admin/pages/planner/PlannerPage.tsx
18. packages/client/src/features/admin/pages/pools/PoolDetailPage.tsx
19. packages/client/src/features/auth/pages/LoginPage.tsx
20. packages/client/src/features/superadmin/pages/TenantsPage.tsx
21. packages/client/src/features/technician/pages/MyRoutePage.tsx
22. packages/client/src/features/technician/pages/WorkOrderPage.tsx
23. packages/client/src/main.tsx
24. packages/client/src/providers/AuthProvider.tsx
25. packages/client/src/router/components.tsx
26. packages/client/src/router/index.tsx
27. packages/client/src/styles/theme.ts
28. packages/client/tsconfig.json
29. packages/client/tsconfig.node.json
30. packages/client/vite.config.ts
31. packages/server/package.json
32. packages/server/prisma/data/catalogs.ts
33. packages/server/prisma/data/clients.ts
34. packages/server/prisma/data/incident-tasks.ts
35. packages/server/prisma/data/products.ts
36. packages/server/prisma/data/users.ts
37. packages/server/prisma/seed.ts
38. packages/server/src/api/auth/auth.controller.ts
39. packages/server/src/api/auth/auth.routes.ts
40. packages/server/src/api/auth/auth.service.ts
41. packages/server/src/api/clients/clients.controller.ts
42. packages/server/src/api/clients/clients.routes.ts
43. packages/server/src/api/clients/clients.service.ts
44. packages/server/src/api/incident-tasks/incident-tasks.controller.ts
45. packages/server/src/api/incident-tasks/incident-tasks.routes.ts
46. packages/server/src/api/incident-tasks/incident-tasks.service.ts
47. packages/server/src/api/notifications/notifications.controller.ts
48. packages/server/src/api/notifications/notifications.routes.ts
49. packages/server/src/api/notifications/notifications.service.ts
50. packages/server/src/api/parameters/parameters.controller.ts
51. packages/server/src/api/parameters/parameters.routes.ts
52. packages/server/src/api/parameters/parameters.service.ts
53. packages/server/src/api/pool-configurations/pool-configurations.controller.ts
54. packages/server/src/api/pool-configurations/pool-configurations.routes.ts
55. packages/server/src/api/pool-configurations/pool-configurations.service.ts
56. packages/server/src/api/pools/pools.controller.ts
57. packages/server/src/api/pools/pools.routes.ts
58. packages/server/src/api/pools/pools.service.ts
59. packages/server/src/api/products/products.controller.ts
60. packages/server/src/api/products/products.routes.ts
61. packages/server/src/api/products/products.service.ts
62. packages/server/src/api/tasks/tasks.controller.ts
63. packages/server/src/api/tasks/tasks.routes.ts
64. packages/server/src/api/tasks/tasks.service.ts
65. packages/server/src/api/tenants/tenants.controller.ts
66. packages/server/src/api/tenants/tenants.routes.ts
67. packages/server/src/api/tenants/tenants.service.ts
68. packages/server/src/api/uploads/uploads.controller.ts
69. packages/server/src/api/uploads/uploads.routes.ts
70. packages/server/src/api/uploads/uploads.service.ts
71. packages/server/src/api/users/users.controller.ts
72. packages/server/src/api/users/users.routes.ts
73. packages/server/src/api/users/users.service.ts
74. packages/server/src/api/visits/visits.controller.ts
75. packages/server/src/api/visits/visits.routes.ts
76. packages/server/src/api/visits/visits.service.ts
77. packages/server/src/app.ts
78. packages/server/src/config/index.ts
79. packages/server/src/middleware/auth.middleware.ts
80. packages/server/src/middleware/error.middleware.ts
81. packages/server/src/server.ts
82. packages/server/src/utils/jwt.utils.ts
83. packages/server/src/utils/password.utils.ts
84. packages/server/tsconfig.json
85. tsconfig.json


# CONTENIDO DE ARCHIVOS


// ====== [1] DEVELOPMENT_PLAN.md ======
# Plan de Desarrollo y Arquitectura: Pool-Control Professional

**Filosof√≠a del Documento:** Este no es solo un plan, es la narrativa arquitect√≥nica y de negocio del proyecto. Sirve como la hoja de ruta para el trabajo futuro y, a la vez, como una cr√≥nica de las decisiones tomadas, garantizando un entendimiento profundo del sistema en cualquier punto de su ciclo de vida.

---

## ‚úÖ FASE 0 a 6: Fundaci√≥n, Operativa y Rentabilidad

- **Estado:** `COMPLETADAS`
- **Resumen:** Durante estas fases iniciales, se estableci√≥ una base arquitect√≥nica robusta (Monorepo, TypeScript estricto), se construy√≥ un backend seguro con Prisma y autenticaci√≥n JWT, y se desarrollaron todos los m√≥dulos operativos clave. Esto incluye la gesti√≥n completa de cat√°logos (par√°metros, tareas, productos), la planificaci√≥n de rutas, la ejecuci√≥n de partes de trabajo y la supervisi√≥n de incidencias y consumo de materiales. El sistema alcanz√≥ un estado funcional completo para la digitalizaci√≥n de la operativa diaria.

---

## üöß FASE 7: Ticketing Avanzado y Comunicaci√≥n Proactiva

- **Estado:** `EN PROGRESO`
- **Intenci√≥n Estrat√©gica:** Transformar el sistema de incidencias reactivo en un motor de resoluci√≥n de problemas proactivo y colaborativo. El objetivo es crear un sistema de ticketing completo que formalice la comunicaci√≥n, asigne responsabilidades claras y proporcione una trazabilidad total de cada acci√≥n.
- **Plan de Acci√≥n y Hitos de Implementaci√≥n:**

  1.  **Ampliaci√≥n del Modelo de Datos para Ticketing:**

      - **Estado:** `COMPLETADO`
      - **Descripci√≥n:** Se ha modificado el `schema.prisma` para dar soporte a un flujo de trabajo granular.
        - Se a√±adi√≥ el modelo `IncidentTask` para representar tareas accionables con `status`, `priority` y `deadline`.
        - Se a√±adi√≥ el modelo `IncidentImage` para permitir la adjunci√≥n de evidencia visual a las incidencias, un requisito clave para el diagn√≥stico remoto.
        - Se a√±adi√≥ el modelo `IncidentTaskLog` para crear una pista de auditor√≠a inmutable de cada cambio y comentario en una tarea.

  2.  **Desarrollo del Backend para el Ciclo de Vida del Ticket:**

      - **Estado:** `COMPLETADO`
      - **Descripci√≥n:** Se ha construido toda la infraestructura de API necesaria para la nueva funcionalidad.
        - **API de Subida Segura:** Se implement√≥ un endpoint (`/api/uploads/signature`) que se integra con Cloudinary para permitir la subida de im√°genes desde el cliente de forma segura.
        - **API de Tareas:** Se crearon los endpoints CRUD para `/api/incident-tasks`.
        - **API de Comunicaci√≥n:** Se implementaron endpoints espec√≠ficos como `/api/incident-tasks/:id/status` y `/api/incident-tasks/:id/log` que, adem√°s de realizar la acci√≥n, crean notificaciones autom√°ticas para el `ADMIN`, cerrando el bucle de comunicaci√≥n.
        - **API de Consulta:** Se desarroll√≥ el endpoint `/api/incident-tasks/my-tasks` para que cada usuario pueda consultar √∫nicamente las tareas que tiene asignadas.

  3.  **Integraci√≥n en la Interfaz del T√©cnico (Flujo de Entrada):**

      - **Estado:** `COMPLETADO`
      - **Descripci√≥n:** Se ha modificado el flujo de trabajo del t√©cnico para incorporar las nuevas capacidades.
        - En `WorkOrderPage.tsx`, el t√©cnico ahora puede adjuntar im√°genes a una incidencia.
        - En `MyRoutePage.tsx`, el t√©cnico ahora ve una nueva secci√≥n con las "Tareas Especiales" que se le han asignado.

  4.  **Desarrollo de la Interfaz de Gesti√≥n (Admin y T√©cnico):**
      - **Estado:** `EN PROGRESO - BLOQUEADO`
      - **Descripci√≥n:** Se ha desarrollado la p√°gina `IncidentDetailPage.tsx`, que act√∫a como centro de mando. La p√°gina ya incluye renderizado condicional por rol, mostrando una vista de gesti√≥n para el `ADMIN` y una vista de ejecuci√≥n para el `T√âCNICO`.
      - **Bloqueo Actual:** La funcionalidad est√° mayormente implementada, pero un `TypeError` persistente en el componente `DateTimePicker` de la vista del t√©cnico impide que este pueda interactuar plenamente con la tarea (solicitar aplazamientos), lo que bloquea la validaci√≥n del flujo completo.

---

## ‚ñ∂Ô∏è FASE 8 y Visi√≥n de Futuro

- **Estado:** `PLANIFICADO`
- **Intenci√≥n Estrat√©gica:** Una vez desbloqueado y finalizado el sistema de ticketing, se expandir√°n las capacidades de la plataforma hacia el an√°lisis de negocio y la mejora de la eficiencia operativa.
- **Plan de Acci√≥n Detallado:**
  1.  **M√≥dulo de Informes de Consumo:**
      - **Prop√≥sito de Negocio:** Permitir al `ADMIN` y al `MANAGER` analizar la rentabilidad por cliente y periodo, y exportar los datos para su facturaci√≥n.
      - **Tareas T√©cnicas:** Crear la API de reportes con agregaciones y la p√°gina de visualizaci√≥n en el frontend.
  2.  **Modo Offline (PWA) para T√©cnicos:**
      - **Prop√≥sito de Negocio:** Garantizar la operatividad del t√©cnico en zonas de baja o nula conectividad.
      - **Tareas T√©cnicas:** Implementar `Service Workers` e `IndexedDB` para el funcionamiento sin conexi√≥n.
  3.  **Dashboard de Gerencia (`MANAGER`):**
      - **Prop√≥sito de Negocio:** Proporcionar al rol `MANAGER` KPIs y gr√°ficos de alto nivel para el an√°lisis estrat√©gico del negocio, incluyendo m√©tricas del nuevo sistema de ticketing (ej. tiempo medio de resoluci√≥n).
      - **Tareas T√©cnicas:** Crear endpoints de agregaci√≥n en el backend y desarrollar componentes de visualizaci√≥n de datos.



// ====== [2] PROJECT_STATUS.md ======
# Estado del Proyecto y Cr√≥nica de Desarrollo: Pool-Control Professional

**Filosof√≠a de este documento:** Este no es solo un registro de tareas, es el pulso del proyecto. Refleja nuestro compromiso con la excelencia, documentando no solo _qu√©_ hemos hecho, sino _por qu√©_ lo hemos hecho y el _valor_ que cada fase aporta al producto final. Est√° dise√±ado para ser la fuente de verdad para cualquier miembro del equipo, presente o futuro.

_√öltima actualizaci√≥n: 13 de julio de 2025, 10:00 CEST_

---

## 1. Visi√≥n Estrat√©gica Actual: Hacia la Gesti√≥n Integral del Negocio

El proyecto ha alcanzado y superado con √©xito sus objetivos iniciales de digitalizaci√≥n operativa. Ahora, hemos entrado en una fase de consolidaci√≥n y expansi√≥n estrat√©gica, enfocada en dotar a la plataforma de las herramientas necesarias para una **gesti√≥n integral del negocio**, abarcando no solo la operativa diaria sino tambi√©n el **control de la rentabilidad** y la **calidad del servicio post-visita**.

---

## 2. Hitos de Desarrollo y Entregables Validados

### üöß **Hito Actual: Flujo de Trabajo Avanzado para Incidencias (Ticketing)**

- **Estado:** `EN PROGRESO (Backend: 100% completado | Frontend: 95% completado)`
- **Objetivo Estrat√©gico:** Evolucionar el sistema de "notificaciones" a un sistema de "ticketing" profesional y accionable. El objetivo es crear un bucle de comunicaci√≥n y resoluci√≥n completo y auditable entre el `ADMIN` y el `T√âCNICO` para cualquier problema detectado en campo.
- **Detalles T√©cnicos y de Implementaci√≥n (Backend - COMPLETADO):**

  - **Ampliaci√≥n Profunda del Modelo de Datos (`schema.prisma`):**
    - **`IncidentTask`:** Se ha creado el modelo central del ticketing para registrar tareas de seguimiento (t√≠tulo, descripci√≥n, estado, prioridad).
    - **`deadline`:** Se ha a√±adido un campo de plazo a las `IncidentTask` para permitir el control de vencimientos.
    - **`IncidentImage`:** Se ha a√±adido un modelo para asociar una o varias im√°genes a una incidencia, guardando la URL del fichero y el ID del t√©cnico que la subi√≥.
    - **`IncidentTaskLog`:** Se ha implementado un modelo de auditor√≠a para registrar cada acci√≥n (creaci√≥n, cambio de estado, comentarios) sobre una tarea, garantizando una trazabilidad total.
  - **API para Subida Segura de Archivos (`/api/uploads`):**
    - Se ha integrado con **Cloudinary** para el almacenamiento de im√°genes.
    - Se ha creado un endpoint (`GET /api/uploads/signature`) que genera una firma de un solo uso para que el frontend pueda subir archivos de forma segura directamente a la nube, sin pasar por nuestro servidor.
  - **API para el Ciclo de Vida del Ticket (`/api/incident-tasks`):**
    - Se ha construido un m√≥dulo de API RESTful completo para las tareas de incidencia, incluyendo:
      - `POST /`: Crear una nueva tarea.
      - `GET /my-tasks`: Endpoint para que un usuario (t√©cnico/admin) obtenga solo las tareas que tiene asignadas.
      - `PATCH /:id/status`: Cambiar el estado de una tarea (`PENDING`, `IN_PROGRESS`, `COMPLETED`).
      - `POST /:id/log`: A√±adir un comentario o solicitar un aplazamiento, generando un registro de auditor√≠a.
      - `GET /:id/logs`: Obtener el historial completo de una tarea.
  - **Integraci√≥n en el Flujo de Trabajo Principal (`visits.service.ts`):**
    - La funci√≥n `submitWorkOrder` ha sido robustecida para que, si una visita tiene una incidencia, procese el array de `imageUrls` subidas a Cloudinary y cree los registros correspondientes en la tabla `IncidentImage` dentro de la misma transacci√≥n at√≥mica.

- **Detalles de Implementaci√≥n (Frontend - CASI COMPLETADO):**
  - **Subida de Im√°genes (`WorkOrderPage.tsx`):** El t√©cnico, al reportar una incidencia, ahora tiene un componente `FileInput` que le permite seleccionar im√°genes. La interfaz gestiona la subida en segundo plano a Cloudinary y muestra el progreso.
  - **Visibilidad para el T√©cnico (`MyRoutePage.tsx`):** La p√°gina de inicio del t√©cnico ahora consulta y muestra una nueva secci√≥n de "Tareas Especiales" asignadas, adem√°s de sus visitas diarias.
  - **P√°gina de Detalle de Incidencia (`IncidentDetailPage.tsx`):**
    - Se ha creado esta nueva p√°gina, que es el centro de operaciones del ticketing.
    - **Renderizado por Rol:** La p√°gina detecta el rol del usuario y muestra una vista diferente para el `ADMIN` (con controles de gesti√≥n completos) y para el `T√âCNICO` (con controles de ejecuci√≥n de la tarea).
    - **Funcionalidad Implementada:** Visualizaci√≥n de detalles, galer√≠a de im√°genes, creaci√≥n y edici√≥n de tareas, historial de auditor√≠a y la mayor parte de las acciones del t√©cnico.

### ‚úÖ **Hito Previo: M√≥dulo de Control de Rentabilidad**

- **Estado:** `COMPLETADO Y VALIDADO`
- **Detalles:** Se implement√≥ con √©xito la gesti√≥n del cat√°logo de `Products` y el registro de `Consumption` en los partes de trabajo.

---

## 3. Tareas Inmediatas / Pr√≥ximos Pasos dentro del Hito Actual

1.  **Resolver Bloqueo del Frontend:** La m√°xima prioridad es solucionar el `TypeError` en `IncidentDetailPage.tsx` para desbloquear el flujo de comunicaci√≥n del t√©cnico.
2.  **Notificaciones en la App:** Implementar la l√≥gica para que la campana de notificaciones del `ADMIN` se actualice en tiempo real cuando un t√©cnico completa una tarea o a√±ade un comentario.
3.  **Refinamiento de la UI:** Una vez que el flujo sea 100% funcional, realizar una pasada de pulido visual sobre las nuevas interfaces (`IncidentDetailPage` y los nuevos elementos en `MyRoutePage`).

---

## 4. Bloqueos Actuales

- **ESTADO:** `ACTIVO - BLOQUEO CR√çTICO EN FRONTEND`
- **Descripci√≥n Detallada:**
  - **Archivo:** `packages/client/src/features/admin/pages/incidents/IncidentDetailPage.tsx`
  - **Componente:** `TechnicianTaskView`
  - **Problema:** Existe un `TypeError` persistente que se dispara en la prop `onChange` del componente `<DateTimePicker>` de Mantine. Este error impide al t√©cnico usar la funcionalidad de "A√±adir Actualizaci√≥n / Solicitar Aplazamiento".
  - **Impacto:** Este bug interrumpe el flujo de comunicaci√≥n bidireccional, que es el n√∫cleo de la nueva funcionalidad de ticketing. Aunque el backend est√° listo, la incapacidad del t√©cnico para interactuar plenamente con la tarea bloquea la validaci√≥n del ciclo completo.
  - **Contexto:** El problema ha resistido varios intentos de correcci√≥n, lo que sugiere una sutil incompatibilidad de tipos o un comportamiento inesperado de la librer√≠a que requiere un an√°lisis fresco y enfocado.



// ====== [3] README.md ======
# Pool-Control Professional: Especificaci√≥n Funcional y Arquitect√≥nica v5.0

| **Documentos de Apoyo:** | [Ver Plan de Desarrollo](./DEVELOPMENT_PLAN.md) | [Ver Estado del Proyecto](./PROJECT_STATUS.md) |
| :----------------------- | :---------------------------------------------- | :--------------------------------------------- |

---

**Fecha de la Versi√≥n:** 12 de julio de 2025
**Proyecto:** Plataforma Integral de Gesti√≥n para Empresas de Mantenimiento de Piscinas.

---

## 1. Visi√≥n del Producto: El Sistema Nervioso para Empresas de Mantenimiento de Piscinas

**Pool-Control Professional** no es simplemente un software; es una plataforma SaaS (Software como Servicio) multi-tenant concebida para ser el **centro de operaciones digital e inteligente** de cualquier empresa dedicada al mantenimiento de piscinas.

Nuestra misi√≥n es erradicar las ineficiencias end√©micas del sector: la dependencia del papel, la falta de control sobre los costes de materiales, la comunicaci√≥n fragmentada entre la oficina y los t√©cnicos, y la incapacidad de tomar decisiones estrat√©gicas basadas en datos fiables.

A trav√©s de la digitalizaci√≥n y la automatizaci√≥n de cada proceso clave, transformamos la gesti√≥n reactiva en una **operativa proactiva, estandarizada, rentable y medible.**

#### **Pilares Estrat√©gicos:**

- **Eficiencia Operativa Absoluta:** Automatizar o semi-automatizar tareas administrativas cr√≠ticas, liberando horas de gesti√≥n para enfocarlas en el crecimiento del negocio.
- **Control Total de la Rentabilidad:** Proporcionar una visi√≥n granular y en tiempo real del consumo de productos qu√≠micos y materiales por visita, piscina y cliente. Este es el pilar para una gesti√≥n de costes y una facturaci√≥n precisas.
- **Calidad de Servicio Estandarizada y Proactiva:** Garantizar que cada t√©cnico siga los procedimientos exactos definidos por la empresa para cada piscina y que cualquier incidencia sea notificada, gestionada y resuelta de forma trazable.
- **Inteligencia de Negocio Accionable:** Ofrecer a los roles de gerencia KPIs y m√©tricas fiables para identificar patrones, optimizar operaciones y fundamentar decisiones estrat√©gicas.

---

## 2. Definici√≥n de Roles y Flujos de Autorizaci√≥n

La plataforma se fundamenta en un sistema de roles estricto, dise√±ado para garantizar la seguridad, la integridad de los datos y la focalizaci√≥n de cada usuario en sus responsabilidades exclusivas.

| Rol                  | Misi√≥n Principal                                    | Capacidades Clave y Flujo de Trabajo Detallado                                                                                                                                                                                                                                                                                                                                                                        |
| -------------------- | --------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **SuperAdmin**       | **Gestionar la Plataforma SaaS.**                   | Responsable del ciclo de vida de los tenants (las empresas que contratan el servicio). Realiza el CRUD completo sobre los **Tenants**, gestiona sus estados de suscripci√≥n y crea el usuario `ADMIN` inicial para cada nueva empresa. Por dise√±o, no tiene ninguna visibilidad sobre los datos operativos de sus clientes.                                                                                            |
| **Admin (Isa)**      | **Dise√±ar y Dirigir la Operativa de su Empresa.**   | Es el "Arquitecto del Servicio". Su misi√≥n es configurar, planificar y supervisar. Define los cat√°logos de **servicios** y **productos**, gestiona la cartera de **clientes y piscinas**, dise√±a las **fichas de mantenimiento**, planifica las **rutas semanales** con una interfaz `Drag & Drop`, y supervisa la operativa a trav√©s de un **dashboard central** y un potente sistema de **gesti√≥n de incidencias**. |
| **T√©cnico**          | **Ejecutar el Trabajo de Campo con Precisi√≥n.**     | Su interfaz est√° 100% optimizada para la eficiencia en movilidad. Su √∫nica misi√≥n es consultar su **ruta de trabajo del d√≠a**, desplazarse al cliente y rellenar el **parte de trabajo din√°mico**. Es el responsable de registrar los datos de mediciones, las tareas realizadas, el **consumo de productos** y reportar cualquier incidencia.                                                                        |
| **Gerencia (Jorge)** | **Analizar la Salud y el Rendimiento del Negocio.** | Un rol de **solo lectura** con acceso a toda la informaci√≥n operativa y de configuraci√≥n. Su objetivo no es operar, sino analizar. A trav√©s de **dashboards y reportes de KPIs**, supervisa la rentabilidad, la eficiencia del equipo y el estado general del negocio, tomando decisiones estrat√©gicas basadas en datos.                                                                                              |

---

## 3. Especificaci√≥n Funcional Detallada del Ciclo Operativo

El sistema opera como un ciclo virtuoso y continuo: **CONFIGURAR ‚ûî PLANIFICAR ‚ûî EJECUTAR ‚ûî SUPERVISAR Y ANALIZAR**.

### **ETAPA 1: CONFIGURACI√ìN (El Cerebro del Sistema)**

_Rol: Admin_

Aqu√≠ se define el ADN del servicio que ofrece la empresa.

#### **Pantallas: Cat√°logos de Servicios y Productos**

- **Prop√≥sito:** Crear una librer√≠a centralizada de todas las acciones, mediciones y materiales de la empresa.
- **Funcionalidad Detallada:**
  - **Cat√°logo de Par√°metros:** El `ADMIN` define plantillas para cada **medici√≥n** (ej: "Nivel de pH"), estableciendo su `Nombre`, `Unidad` y `Tipo de Input` (`NUMBER`, `BOOLEAN`, `TEXT`, `SELECT`).
  - **Cat√°logo de Tareas:** Se definen plantillas para cada **acci√≥n f√≠sica** (ej: "Limpieza de cestos de skimmers").
  - **Cat√°logo de Productos:** Se define el inventario de productos qu√≠micos y materiales, especificando `Nombre`, `Unidad` de medida (L, Kg, Saco, etc.) y, fundamentalmente, el **`Coste`** por unidad para el c√°lculo de rentabilidad.
- **Estado de Implementaci√≥n:** `COMPLETADA Y OPERATIVA`.

#### **Pantalla: Constructor de Fichas de Mantenimiento**

- **Prop√≥sito:** Definir el "contrato de servicio" digital y √∫nico para **cada piscina**.
- **Flujo de Trabajo:** El `ADMIN` asocia √≠tems de los cat√°logos a cada piscina, estableciendo reglas de negocio como la `Frecuencia` y los `Umbrales de Alerta`.
- **Estado de Implementaci√≥n:** `COMPLETADA Y OPERATIVA`.

### **ETAPA 2: PLANIFICACI√ìN Y EJECUCI√ìN (La Operativa)**

_Roles: Admin, T√©cnico_

#### **Pantalla: Planificador Semanal (`PlannerPage`)**

- **Prop√≥sito:** Organizar y asignar la carga de trabajo semanal de forma visual.
- **Funcionalidad Detallada:** El sistema genera las visitas pendientes y el `ADMIN` las asigna a los t√©cnicos mediante `Drag & Drop`. La interfaz ofrece **feedback visual instant√°neo**, atenuando y coloreando las visitas completadas (verde para OK, rojo para incidencia) para un seguimiento r√°pido. Cada visita es clicable para un acceso directo a los detalles.
- **Estado de Implementaci√≥n:** `COMPLETADA Y OPERATIVA`.

#### **Pantalla: Parte de Trabajo Din√°mico (`WorkOrderPage`)**

- **Prop√≥sito:** La herramienta de campo del t√©cnico, dise√±ada para ser r√°pida, inteligente y a prueba de errores.
- **Flujo de Trabajo Detallado:**
  1.  La p√°gina construye un **formulario din√°mico** basado en la ficha de mantenimiento de la piscina.
  2.  El t√©cnico rellena los valores de **par√°metros**, marca las **tareas** realizadas y registra el **consumo de productos** desde el cat√°logo.
  3.  Reporta **incidencias** a trav√©s de un campo de observaciones, cuyas notas se convierten en el mensaje de alerta para el `ADMIN`.
  4.  Al guardar, todos los datos (resultados, tareas, consumos, notas) se env√≠an a la API en una √∫nica transacci√≥n at√≥mica.
- **Estado de Implementaci√≥n:** `COMPLETADA Y OPERATIVA`.

### **ETAPA 3: SUPERVISI√ìN Y AN√ÅLISIS (El Control de Calidad y Negocio)**

_Roles: Admin, Gerencia_

Aqu√≠ es donde la informaci√≥n recopilada se convierte en inteligencia accionable.

#### **Pantalla: Dashboard del Administrador (`AdminDashboard`)**

- **Prop√≥sito:** La "torre de control" del `ADMIN`, ofreciendo una visi√≥n de 360 grados de la operativa diaria.
- **Funcionalidad Detallada:**
  - **Widget de Visitas del D√≠a:** Resumen en tiempo real de las visitas de hoy, con su estado y t√©cnico, diferenciando visualmente las pendientes de las completadas.
  - **Widget de Incidencias Activas:** Una lista priorizada de problemas. Las incidencias que superan un umbral de tiempo **se resaltan autom√°ticamente en rojo**. Los mensajes muestran las notas reales del t√©cnico.
- **Estado de Implementaci√≥n:** `COMPLETADA Y OPERATIVA`.

#### **Flujo y Pantalla de Gesti√≥n de Incidencias**

- **Prop√≥sito:** Un sistema de "ticketing" robusto y trazable para la resoluci√≥n de problemas.
- **Flujo de Trabajo:** El `ADMIN` es notificado, accede a una **vista de solo lectura** del parte (garantizando la integridad de los datos), y desde all√≠ puede **"Clasificar"** la incidencia (asignando prioridad y plazo) o **"Resolverla"** (a√±adiendo notas de resoluci√≥n).
- **Pantalla de Historial:** Una tabla potente con **filtrado y paginaci√≥n por backend** muestra el archivo completo de todas las incidencias para una auditor√≠a total.
- **Estado de Implementaci√≥n:** `COMPLETADA Y OPERATIVA`.

---

## 4. Pr√≥ximas Funcionalidades Planificadas (Roadmap Futuro)

- **M√≥dulo de Informes de Consumo:** Crear una nueva secci√≥n para analizar la rentabilidad, con filtros por cliente y fecha, KPIs de costes y la capacidad de **exportar los datos a CSV/Excel** para la facturaci√≥n. **(Pr√≥xima gran funcionalidad)**.
- **Flujo de Trabajo Avanzado para Incidencias:** Evolucionar el sistema de incidencias para que puedan generar "tareas de seguimiento" asignables a t√©cnicos o servicios externos.
- **Modo Offline (PWA):** Permitir a los t√©cnicos trabajar sin conexi√≥n a internet.
- **Dashboard de Gerencia Avanzado:** Desarrollar los gr√°ficos y KPIs para el an√°lisis estrat√©gico del negocio.
- **Sistema de Facturaci√≥n y Gesti√≥n de Inventario.**



// ====== [4] package.json ======
{
  "name": "pool-control-professional",
  "private": true,
  "version": "1.0.0",
  "description": "SaaS para la gesti√≥n integral de empresas de mantenimiento de piscinas.",
  "author": "",
  "license": "ISC",
  "scripts": {
    "dev:server": "pnpm --filter @pool-control/server dev",
    "dev:client": "pnpm --filter @pool-control/client dev",
    "build": "pnpm --filter \"./packages/**\" build",
    "prisma:generate": "pnpm --filter @pool-control/server prisma:generate",
    "prisma:migrate": "pnpm --filter @pool-control/server prisma:migrate --",
    "prisma:studio": "pnpm --filter @pool-control/server prisma:studio"
  },
  "devDependencies": {
    "typescript": "^5.4.5"
  },
  "engines": {
    "node": ">=20.0.0",
    "pnpm": ">=9.0.0"
  }
}


// ====== [5] packages/client/index.html ======
<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pool-Control Professional</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


// ====== [6] packages/client/package.json ======
{
  "name": "@pool-control/client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite --host",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "@dnd-kit/core": "^6.3.1",
    "@mantine/core": "^8.1.3",
    "@mantine/dates": "^8.1.3",
    "@mantine/form": "^8.1.3",
    "@mantine/hooks": "^8.1.3",
    "axios": "^1.7.2",
    "date-fns": "^4.1.0",
    "dayjs": "^1.11.13",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.23.1"
  },
  "devDependencies": {
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@typescript-eslint/eslint-plugin": "^7.13.0",
    "@typescript-eslint/parser": "^7.13.0",
    "@vitejs/plugin-react": "^4.3.1",
    "eslint": "^8.57.0",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-react-refresh": "0.4.7",
    "typescript": "^5.4.5",
    "vite": "^5.3.1"
  }
}


// ====== [7] packages/client/src/App.tsx ======
import { MantineProvider } from '@mantine/core';
import { RouterProvider } from 'react-router-dom';
import { theme } from './styles/theme.js';
import { router } from './router/index.js';
import { AuthProvider } from './providers/AuthProvider.js';

// Importa los estilos base de Mantine
import '@mantine/core/styles.css';

function App() {
  return (
    <MantineProvider theme={theme}>
      <AuthProvider>
        <RouterProvider router={router} />
      </AuthProvider>
    </MantineProvider>
  );
}

export default App;


// ====== [8] packages/client/src/api/apiClient.ts ======
import axios from 'axios';

const apiClient = axios.create({
  // La URL base para todas las peticiones al API.
  // Gracias al proxy configurado en vite.config.ts, esto se
  // redirigir√° a http://localhost:3001/api en desarrollo.
  baseURL: '/api',

  // Permite que axios env√≠e y reciba cookies (como nuestro token JWT)
  // en las peticiones a dominios diferentes.
  withCredentials: true,
});

export default apiClient;


// ====== [9] packages/client/src/features/admin/pages/AdminDashboard.tsx ======
// filename: packages/client/src/features/admin/pages/AdminDashboard.tsx
// version: 1.1.4
// description: Corrige el acceso a los datos en la respuesta paginada de la API.

import { useEffect, useState } from 'react';
import { Container, Title, Grid, Paper, Text, Badge, Loader, Alert, Stack } from '@mantine/core';
import { useNavigate } from 'react-router-dom';
import apiClient from '../../../api/apiClient';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';

// --- Tipos de Datos ---
interface Visit {
  id: string;
  timestamp: string;
  status: 'PENDING' | 'COMPLETED' | 'CANCELLED';
  pool: { name: string; client: { name:string } };
  technician: { name: string } | null;
}

interface Notification {
  id: string;
  message: string;
  visitId: string | null;
  isCritical: boolean;
}

// --- Componente Principal ---
export function AdminDashboard() {
  const [visits, setVisits] = useState<Visit[]>([]);
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const navigate = useNavigate();

  useEffect(() => {
    const fetchData = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const [visitsResponse, notificationsResponse] = await Promise.all([
          apiClient.get('/visits/scheduled', { params: { date: new Date().toISOString() } }),
          apiClient.get('/notifications/history')
        ]);
        
        const today = new Date().toDateString();
        const todayVisits = visitsResponse.data.data.filter((v: Visit) => 
            new Date(v.timestamp).toDateString() === today
        );
        
        // --- CORRECCI√ìN AQU√ç ---
        // Extraemos el array 'notifications' del objeto de respuesta.
        const allNotifications = notificationsResponse.data.data.notifications;
        const pendingNotifications = allNotifications.filter((n: any) => n.status === 'PENDING');

        setVisits(todayVisits);
        setNotifications(pendingNotifications);
      } catch (err) {
        setError('No se pudo cargar la informaci√≥n del dashboard.');
        console.error(err);
      } finally {
        setIsLoading(false);
      }
    };

    fetchData();
  }, []);

  const handleIncidentClick = (notification: Notification) => {
    if (notification.visitId) {
      navigate(`/visits/${notification.visitId}`);
    }
  };


  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  return (
    <Container fluid>
      <Title order={2} mb="xl">
        Dashboard - {format(new Date(), 'eeee, d MMMM yyyy', { locale: es })}
      </Title>

      <Grid>
        {/* Columna de Visitas de Hoy */}
        <Grid.Col span={{ base: 12, md: 7 }}>
          <Paper withBorder p="md" shadow="sm">
            <Title order={4} mb="md">Visitas de Hoy ({visits.length})</Title>
            <Stack>
              {visits.length > 0 ? (
                visits.map(visit => (
                  <Paper 
                    key={visit.id} 
                    withBorder p="sm" radius="md"
                    style={{ opacity: visit.status === 'COMPLETED' ? 0.65 : 1 }}
                  >
                    <Grid align="center">
                      <Grid.Col span={8}>
                        <Text fw={500}>{visit.pool.name}</Text>
                        <Text size="sm" c="dimmed">{visit.pool.client.name}</Text>
                        <Text size="xs" c="dimmed">T√©cnico: {visit.technician?.name || 'Sin asignar'}</Text>
                      </Grid.Col>
                      <Grid.Col span={4} ta="right">
                        <Badge 
                          color={visit.status === 'COMPLETED' ? 'green' : 'blue'}
                          variant="light"
                        >
                          {visit.status}
                        </Badge>
                      </Grid.Col>
                    </Grid>
                  </Paper>
                ))
              ) : (
                <Text c="dimmed">No hay visitas programadas para hoy.</Text>
              )}
            </Stack>
          </Paper>
        </Grid.Col>

        {/* Columna de Incidencias */}
        <Grid.Col span={{ base: 12, md: 5 }}>
          <Paper withBorder p="md" shadow="sm">
            <Title order={4} mb="md">Incidencias Activas</Title>
             <Stack>
              {notifications.length > 0 ? (
                notifications.map(notification => (
                  <Paper 
                    key={notification.id} 
                    withBorder p="sm" radius="md" 
                    onClick={() => handleIncidentClick(notification)}
                    style={{ 
                      cursor: 'pointer',
                      backgroundColor: notification.isCritical ? 'var(--mantine-color-red-0)' : 'transparent'
                    }}
                    onMouseEnter={(e) => e.currentTarget.style.boxShadow = 'var(--mantine-shadow-md)'}
                    onMouseLeave={(e) => e.currentTarget.style.boxShadow = 'none'}
                  >
                    <Text size="sm">{notification.message}</Text>
                  </Paper>
                ))
              ) : (
                <Text c="dimmed">No hay incidencias activas.</Text>
              )}
            </Stack>
          </Paper>
        </Grid.Col>
      </Grid>
    </Container>
  );
}


// ====== [10] packages/client/src/features/admin/pages/IncidentsHistoryPage.tsx ======
// filename: packages/client/src/features/admin/pages/IncidentsHistoryPage.tsx
// version: 2.3.0
// description: Convierte las filas de la tabla en enlaces a la nueva p√°gina de detalles de la incidencia.

import { useEffect, useState, useRef } from 'react';
import { Container, Title, Table, Loader, Alert, Badge, ActionIcon, Tooltip, Text, Select, Grid, Pagination, Center } from '@mantine/core';
import { Link, useNavigate } from 'react-router-dom';
import apiClient from '../../../api/apiClient';
import { format, formatDistanceToNow } from 'date-fns';
import { es } from 'date-fns/locale';

// --- Tipos de Datos ---
type IncidentStatus = 'PENDING' | 'RESOLVED';
type IncidentPriority = 'LOW' | 'NORMAL' | 'HIGH' | 'CRITICAL';

interface IncidentHistoryItem {
  id: string;
  createdAt: string;
  message: string;
  status: IncidentStatus;
  priority: IncidentPriority | null;
  resolutionNotes: string | null;
  isCritical: boolean;
  visit: {
    id: string;
    technician: { name: string } | null;
    pool: { name: string; client: { id: string; name: string } };
  } | null;
}

interface PaginatedResponse {
    notifications: IncidentHistoryItem[];
    total: number;
}

interface ApiResponse<T> {
    success: boolean;
    data: T;
}

// --- Mapeo de colores ---
const priorityColors: Record<IncidentPriority, string> = { LOW: 'gray', NORMAL: 'blue', HIGH: 'orange', CRITICAL: 'red' };
const statusColors: Record<IncidentStatus, string> = { PENDING: 'orange', RESOLVED: 'green' };

// --- Componente Principal ---
export function IncidentsHistoryPage() {
  const [incidents, setIncidents] = useState<IncidentHistoryItem[]>([]);
  const [clientOptions, setClientOptions] = useState<{ value: string; label: string; }[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const [activePage, setPage] = useState(1);
  const [totalPages, setTotalPages] = useState(0);
  const PAGE_SIZE = 10;

  const [filterStatus, setFilterStatus] = useState<string | null>('PENDING');
  const [filterClient, setFilterClient] = useState<string | null>(null);

  const isInitialMount = useRef(true);
  const navigate = useNavigate(); // <-- Hook para la navegaci√≥n

  useEffect(() => {
    if (!isInitialMount.current) {
        setPage(1);
    }
  }, [filterStatus, filterClient]);


  useEffect(() => {
    const fetchHistory = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const params: Record<string, any> = { page: activePage, pageSize: PAGE_SIZE, status: filterStatus, clientId: filterClient };
        Object.keys(params).forEach(key => (params[key] == null || params[key] === '') && delete params[key]);

        const response = await apiClient.get<ApiResponse<PaginatedResponse>>('/notifications/history', { params });
        
        const { notifications, total } = response.data.data;
        setIncidents(notifications);
        setTotalPages(Math.ceil(total / PAGE_SIZE));
      } catch (err) {
        setError('No se pudo cargar el historial de incidencias.');
      } finally {
        setIsLoading(false);
        isInitialMount.current = false;
      }
    };

    fetchHistory();
  }, [activePage, filterStatus, filterClient]);

  useEffect(() => {
    const fetchClients = async () => {
        try {
            const response = await apiClient.get('/clients');
            const options = response.data.data.map((client: { id: string; name: string }) => ({
                value: client.id,
                label: client.name,
            }));
            setClientOptions(options);
        } catch (error) {
            console.error("Failed to fetch clients for filter");
        }
    };
    fetchClients();
  }, []);
  
  // --- Manejador para la navegaci√≥n ---
  const handleRowClick = (notificationId: string) => {
    navigate(`/incidents/${notificationId}`);
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;
  
  const rows = incidents.map((item) => (
    <Table.Tr 
      key={item.id} 
      style={{ 
        backgroundColor: item.isCritical ? 'var(--mantine-color-red-0)' : 'transparent',
        cursor: 'pointer' // <-- Cambia el cursor para indicar que es clicable
      }}
      onClick={() => handleRowClick(item.id)} // <-- A√±adimos el evento onClick
      onMouseEnter={(e) => e.currentTarget.style.backgroundColor = 'var(--mantine-color-gray-1)'}
      onMouseLeave={(e) => e.currentTarget.style.backgroundColor = item.isCritical ? 'var(--mantine-color-red-0)' : 'transparent'}
    >
      <Table.Td>
        <Tooltip label={format(new Date(item.createdAt), 'dd/MM/yyyy HH:mm')}>
            <Text size="sm">{formatDistanceToNow(new Date(item.createdAt), { addSuffix: true, locale: es })}</Text>
        </Tooltip>
      </Table.Td>
      <Table.Td>{item.visit?.pool?.client?.name || 'N/A'}</Table.Td>
      <Table.Td>{item.visit?.pool?.name || 'N/A'}</Table.Td>
      <Table.Td>{item.visit?.technician?.name || 'N/A'}</Table.Td>
      <Table.Td>
        <Badge color={item.priority ? priorityColors[item.priority] : 'gray'}>
          {item.priority || 'SIN ASIGNAR'}
        </Badge>
      </Table.Td>
      <Table.Td>
        <Badge color={statusColors[item.status]}>
          {item.status}
        </Badge>
      </Table.Td>
      <Table.Td>
        {item.visit && (
          <Tooltip label="Ver Parte de Trabajo Original">
            {/* Detenemos la propagaci√≥n para que al hacer clic en el icono no navegue a la p√°gina de detalle de incidencia */}
            <ActionIcon component={Link} to={`/visits/${item.visit.id}`} variant="subtle" onClick={(e) => e.stopPropagation()}>
              üìÑ
            </ActionIcon>
          </Tooltip>
        )}
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <Container fluid>
      <Title order={2} my="lg">Gesti√≥n de Incidencias</Title>
      
      <Grid align="flex-end" mb="md">
        <Grid.Col span={{ base: 12, sm: 4 }}>
          <Select
            label="Filtrar por Cliente" placeholder="Todos los clientes"
            value={filterClient} onChange={setFilterClient}
            data={clientOptions} clearable
          />
        </Grid.Col>
        <Grid.Col span={{ base: 12, sm: 4 }}>
          <Select
            label="Filtrar por Estado" placeholder="Todos los estados"
            value={filterStatus} onChange={setFilterStatus}
            data={[ { value: 'PENDING', label: 'Pendientes' }, { value: 'RESOLVED', label: 'Resueltas' } ]}
            clearable
          />
        </Grid.Col>
      </Grid>
      
      <Table striped withTableBorder withColumnBorders mt="md">
        <Table.Thead>
            <Table.Tr>
              <Table.Th>Antig√ºedad</Table.Th>
              <Table.Th>Cliente</Table.Th>
              <Table.Th>Piscina</Table.Th>
              <Table.Th>T√©cnico</Table.Th>
              <Table.Th>Prioridad</Table.Th>
              <Table.Th>Estado</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
        </Table.Thead>
        <Table.Tbody>
            {rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={7}>No se han encontrado incidencias con los filtros seleccionados.</Table.Td></Table.Tr>}
        </Table.Tbody>
      </Table>
      
      {totalPages > 1 && (
          <Center mt="xl">
              <Pagination value={activePage} onChange={setPage} total={totalPages} />
          </Center>
      )}
    </Container>
  );
}


// ====== [11] packages/client/src/features/admin/pages/ParameterCatalogPage.tsx ======
// filename: packages/client/src/features/admin/pages/ParameterCatalogPage.tsx
// Version: 1.2.0 (Implement TagsInput for SELECT options in the form)
import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  Select,
  TagsInput,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient.js';

// --- Tipos ---
const InputTypes = ['NUMBER', 'BOOLEAN', 'TEXT', 'SELECT'] as const;
type InputType = (typeof InputTypes)[number];

interface ParameterTemplate {
  id: string;
  name: string;
  unit: string | null;
  type: InputType;
  selectOptions: string[];
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function ParameterCatalogPage() {
  const [templates, setTemplates] = useState<ParameterTemplate[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingTemplate, setEditingTemplate] = useState<ParameterTemplate | null>(null);

  const form = useForm({
    initialValues: {
      name: '',
      unit: '',
      type: 'NUMBER' as InputType,
      selectOptions: [] as string[],
    },
    validate: {
      name: (value: string) => (value.trim().length < 2 ? 'El nombre es demasiado corto' : null),
      type: (value: string) => (InputTypes.includes(value as InputType) ? null : 'Tipo inv√°lido'),
      selectOptions: (value: string[], values) => {
        if (values.type === 'SELECT' && value.length === 0) {
          return 'Debe definir al menos una opci√≥n para el tipo SELECT';
        }
        return null;
      }
    },
  });

  const fetchTemplates = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<ParameterTemplate[]>>('/parameters');
      setTemplates(response.data.data);
    } catch (err) {
      setError('No se pudo cargar el cat√°logo de par√°metros.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchTemplates();
  }, []);

  const handleOpenModal = (template: ParameterTemplate | null = null) => {
    setEditingTemplate(template);
    if (template) {
      form.setValues({
        name: template.name,
        unit: template.unit || '',
        type: template.type,
        selectOptions: template.selectOptions || [],
      });
    } else {
      form.reset();
    }
    openModal();
  };

  const handleSubmit = async (values: typeof form.values) => {
    const payload = {
      ...values,
      selectOptions: values.type === 'SELECT' ? values.selectOptions : [],
    };
    try {
      if (editingTemplate) {
        await apiClient.patch(`/parameters/${editingTemplate.id}`, payload);
      } else {
        await apiClient.post('/parameters', payload);
      }
      await fetchTemplates();
      closeModal();
    } catch (err: any) {
      form.setErrors({ name: err.response?.data?.message || 'Error al guardar el par√°metro' });
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar este par√°metro?')) {
      try {
        await apiClient.delete(`/parameters/${id}`);
        setTemplates((current) => current.filter((t) => t.id !== id));
      } catch (err) {
        // TODO: Mostrar notificaci√≥n de error
        console.error('Failed to delete parameter', err);
      }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = templates.map((template) => (
    <Table.Tr key={template.id}>
      <Table.Td>{template.name}</Table.Td>
      <Table.Td>{template.unit || '-'}</Table.Td>
      <Table.Td>{template.type}</Table.Td>
      <Table.Td>
        <Group gap="xs">
          <Button variant="subtle" size="xs" onClick={() => handleOpenModal(template)}>Editar</Button>
          <Button variant="subtle" size="xs" color="red" onClick={() => handleDelete(template.id)}>Eliminar</Button>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingTemplate ? 'Editar Par√°metro' : 'Crear Nuevo Par√°metro'}
        centered
      >
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="Nombre del Par√°metro" {...form.getInputProps('name')} />
            <TextInput label="Unidad (ej. ppm, pH, ¬∞C)" {...form.getInputProps('unit')} />
            <Select
              label="Tipo de Input"
              required
              data={InputTypes as unknown as string[]}
              {...form.getInputProps('type')}
            />
            {form.values.type === 'SELECT' && (
              <TagsInput
                label="Opciones del Select"
                placeholder="A√±ade opciones y presiona Enter"
                description="Escribe una opci√≥n y presiona Enter para a√±adirla a la lista."
                required
                {...form.getInputProps('selectOptions')}
              />
            )}
            <Button type="submit" mt="md">{editingTemplate ? 'Guardar Cambios' : 'Crear Par√°metro'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Cat√°logo de Par√°metros</Title>
          <Button onClick={() => handleOpenModal()}>Crear Nuevo Par√°metro</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Unidad</Table.Th>
              <Table.Th>Tipo</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={4}>No hay par√°metros definidos en el cat√°logo.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [12] packages/client/src/features/admin/pages/ProductCatalogPage.tsx ======
// filename: packages/client/src/features/admin/pages/ProductCatalogPage.tsx
// version: 1.0.0
// description: P√°gina para la gesti√≥n completa (CRUD) del cat√°logo de productos.

import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  Textarea,
  NumberInput,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient';

// --- Tipos de Datos ---
// Define la estructura de un producto, que coincide con el modelo de Prisma
interface Product {
  id: string;
  name: string;
  description: string | null;
  unit: string;
  cost: number;
}

// Define la estructura de la respuesta de nuestra API
interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente Principal ---
export function ProductCatalogPage() {
  // --- Estados del Componente ---
  const [products, setProducts] = useState<Product[]>([]); // Almacena la lista de productos
  const [isLoading, setIsLoading] = useState(true); // Controla el estado de carga
  const [error, setError] = useState<string | null>(null); // Almacena cualquier error de la API
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false); // Controla la visibilidad del modal
  const [editingProduct, setEditingProduct] = useState<Product | null>(null); // Guarda el producto que se est√° editando, o null si es una creaci√≥n

  // --- Formulario (Mantine Form) ---
  // Se encarga de la gesti√≥n de estado y validaci√≥n de los inputs del modal
  const form = useForm({
    initialValues: {
      name: '',
      description: '',
      unit: '',
      cost: 0,
    },
    validate: {
      name: (value) => (value.trim().length < 2 ? 'El nombre del producto es demasiado corto.' : null),
      unit: (value) => (value.trim().length === 0 ? 'La unidad de medida es obligatoria.' : null),
      cost: (value) => (value < 0 ? 'El coste no puede ser un valor negativo.' : null),
    },
  });

  // --- L√≥gica de Datos (API Calls) ---
  const fetchProducts = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<Product[]>>('/products');
      setProducts(response.data.data);
    } catch (err) {
      setError('No se pudo cargar el cat√°logo de productos.');
    } finally {
      setIsLoading(false);
    }
  };

  // Carga inicial de datos cuando el componente se monta
  useEffect(() => {
    fetchProducts();
  }, []);

  // --- Manejadores de Eventos ---

  // Se ejecuta al hacer clic en "A√±adir Producto" o "Editar"
  const handleOpenModal = (product: Product | null = null) => {
    setEditingProduct(product);
    if (product) {
      // Si estamos editando, llenamos el formulario con los datos del producto
      form.setValues({
        name: product.name,
        description: product.description || '',
        unit: product.unit,
        cost: product.cost,
      });
    } else {
      // Si estamos creando, reseteamos el formulario a sus valores iniciales
      form.reset();
      form.setFieldValue('cost', 0);
    }
    openModal();
  };

  // Se ejecuta al enviar el formulario del modal
  const handleSubmit = async (values: typeof form.values) => {
    try {
      if (editingProduct) {
        // Si est√°bamos editando, hacemos una petici√≥n PATCH
        await apiClient.patch(`/products/${editingProduct.id}`, values);
      } else {
        // Si est√°bamos creando, hacemos una petici√≥n POST
        await apiClient.post('/products', values);
      }
      // Despu√©s de la operaci√≥n, refrescamos la lista y cerramos el modal
      await fetchProducts();
      closeModal();
    } catch (err: any) {
      form.setErrors({ name: err.response?.data?.message || 'Error al guardar el producto.' });
    }
  };

  // Se ejecuta al hacer clic en el bot√≥n "Eliminar"
  const handleDelete = async (id: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar este producto? Esta acci√≥n no se puede deshacer.')) {
      try {
        await apiClient.delete(`/products/${id}`);
        // Actualizaci√≥n optimista de la UI: eliminamos el producto del estado local
        setProducts((current) => current.filter((p) => p.id !== id));
      } catch (err) {
        alert('No se pudo eliminar el producto. Es probable que ya est√© en uso en alguna visita.');
        console.error('Failed to delete product', err);
      }
    }
  };

  // --- Renderizado del Componente ---

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  // Mapeamos los datos de los productos para generar las filas de la tabla
  const rows = products.map((product) => (
    <Table.Tr key={product.id}>
      <Table.Td>{product.name}</Table.Td>
      <Table.Td>{product.description || '-'}</Table.Td>
      <Table.Td>{product.unit}</Table.Td>
      <Table.Td>{product.cost.toFixed(2)} ‚Ç¨</Table.Td>
      <Table.Td>
        <Group gap="xs">
          <Button variant="subtle" size="xs" onClick={() => handleOpenModal(product)}>Editar</Button>
          <Button variant="subtle" size="xs" color="red" onClick={() => handleDelete(product.id)}>Eliminar</Button>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingProduct ? 'Editar Producto' : 'Crear Nuevo Producto'}
        centered
      >
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="Nombre del Producto" placeholder="Ej: Hipoclorito S√≥dico 25L" {...form.getInputProps('name')} />
            <Textarea label="Descripci√≥n (opcional)" placeholder="Detalles adicionales del producto" {...form.getInputProps('description')} />
            <TextInput required label="Unidad de Medida" placeholder="Ej: L, Kg, Saco, Unidad" {...form.getInputProps('unit')} />
            <NumberInput
                required
                label="Coste por Unidad (‚Ç¨)"
                placeholder="15.50"
                decimalScale={2}
                fixedDecimalScale
                step={0.5}
                min={0}
                {...form.getInputProps('cost')}
            />
            <Button type="submit" mt="md">{editingProduct ? 'Guardar Cambios' : 'Crear Producto'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Cat√°logo de Productos</Title>
          <Button onClick={() => handleOpenModal()}>A√±adir Nuevo Producto</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Descripci√≥n</Table.Th>
              <Table.Th>Unidad</Table.Th>
              <Table.Th>Coste</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={5}>No hay productos definidos en el cat√°logo.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [13] packages/client/src/features/admin/pages/TaskCatalogPage.tsx ======
// filename: packages/client/src/features/admin/pages/TaskCatalogPage.tsx
// Version: 1.0.0 (Initial implementation of the task template catalog page with full CRUD)
import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  Textarea,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient.js';

// --- Tipos ---
interface TaskTemplate {
  id: string;
  name: string;
  description: string | null;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function TaskCatalogPage() {
  const [templates, setTemplates] = useState<TaskTemplate[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingTemplate, setEditingTemplate] = useState<TaskTemplate | null>(null);

  const form = useForm({
    initialValues: {
      name: '',
      description: '',
    },
    validate: {
      name: (value: string) => (value.trim().length < 2 ? 'El nombre es demasiado corto' : null),
    },
  });

  const fetchTemplates = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<TaskTemplate[]>>('/tasks');
      setTemplates(response.data.data);
    } catch (err) {
      setError('No se pudo cargar el cat√°logo de tareas.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchTemplates();
  }, []);

  const handleOpenModal = (template: TaskTemplate | null = null) => {
    setEditingTemplate(template);
    if (template) {
      form.setValues({
        name: template.name,
        description: template.description || '',
      });
    } else {
      form.reset();
    }
    openModal();
  };

  const handleSubmit = async (values: typeof form.values) => {
    try {
      if (editingTemplate) {
        await apiClient.patch(`/tasks/${editingTemplate.id}`, values);
      } else {
        await apiClient.post('/tasks', values);
      }
      await fetchTemplates();
      closeModal();
    } catch (err: any) {
      form.setErrors({ name: err.response?.data?.message || 'Error al guardar la tarea' });
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar esta tarea?')) {
      try {
        await apiClient.delete(`/tasks/${id}`);
        setTemplates((current) => current.filter((t) => t.id !== id));
      } catch (err) {
        // TODO: Mostrar notificaci√≥n de error
        console.error('Failed to delete task', err);
      }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = templates.map((template) => (
    <Table.Tr key={template.id}>
      <Table.Td>{template.name}</Table.Td>
      <Table.Td>{template.description || '-'}</Table.Td>
      <Table.Td>
        <Group gap="xs">
          <Button variant="subtle" size="xs" onClick={() => handleOpenModal(template)}>Editar</Button>
          <Button variant="subtle" size="xs" color="red" onClick={() => handleDelete(template.id)}>Eliminar</Button>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingTemplate ? 'Editar Tarea' : 'Crear Nueva Tarea'}
        centered
      >
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="Nombre de la Tarea" {...form.getInputProps('name')} />
            <Textarea label="Descripci√≥n (opcional)" {...form.getInputProps('description')} />
            <Button type="submit" mt="md">{editingTemplate ? 'Guardar Cambios' : 'Crear Tarea'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Cat√°logo de Tareas</Title>
          <Button onClick={() => handleOpenModal()}>Crear Nueva Tarea</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Descripci√≥n</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={3}>No hay tareas definidas en el cat√°logo.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [14] packages/client/src/features/admin/pages/clients/ClientDetailPage.tsx ======
// filename: packages/client/src/features/admin/pages/clients/ClientDetailPage.tsx
// Version: 1.2.0 (Make pool names link to their future detail page)
import { useEffect, useState } from 'react';
import { useParams, Link } from 'react-router-dom';
import {
  Container,
  Title,
  Loader,
  Alert,
  Button,
  Group,
  Paper,
  Text,
  Table,
  Breadcrumbs,
  Modal,
  TextInput,
  Stack,
  NumberInput,
  Select,
  Anchor,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../../api/apiClient.js';

// --- Tipos ---
interface Pool {
  id: string;
  name: string;
  address: string;
  volume: number | null;
  type: string | null;
}

interface Client {
  id: string;
  name: string;
  contactPerson: string | null;
  email: string | null;
  phone: string | null;
  address: string | null;
  pools: Pool[];
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function ClientDetailPage() {
  const { id: clientId } = useParams<{ id: string }>();
  const [client, setClient] = useState<Client | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingPool, setEditingPool] = useState<Pool | null>(null);

  const poolForm = useForm({
    initialValues: {
      name: '',
      address: '',
      volume: null as number | null,
      type: '',
    },
    validate: {
      name: (value) => (value.trim().length < 2 ? 'El nombre es demasiado corto' : null),
      address: (value) => (value.trim().length < 5 ? 'La direcci√≥n es demasiado corta' : null),
    },
  });

  const fetchClient = async () => {
    if (!clientId) return;
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<Client>>(`/clients/${clientId}`);
      setClient(response.data.data);
    } catch (err) {
      setError('No se pudo cargar la informaci√≥n del cliente.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchClient();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [clientId]);

  const handleOpenModal = (pool: Pool | null = null) => {
    setEditingPool(pool);
    if (pool) {
      poolForm.setValues({
        name: pool.name,
        address: pool.address,
        volume: pool.volume,
        type: pool.type || '',
      });
    } else {
      poolForm.reset();
    }
    openModal();
  };

  const handlePoolSubmit = async (values: typeof poolForm.values) => {
    if (!clientId) return;
    try {
      const payload = { ...values, clientId };
      if (editingPool) {
        await apiClient.patch(`/pools/${editingPool.id}`, payload);
      } else {
        await apiClient.post('/pools', payload);
      }
      await fetchClient();
      closeModal();
    } catch (err: any) {
      poolForm.setErrors({ name: err.response?.data?.message || 'Error al guardar la piscina' });
    }
  };

  const handlePoolDelete = async (poolId: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar esta piscina?')) {
      try {
        await apiClient.delete(`/pools/${poolId}`);
        await fetchClient();
      } catch (err) {
        console.error('Failed to delete pool', err);
      }
    }
  };


  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;
  if (!client) return <Alert color="yellow" title="Aviso">Cliente no encontrado.</Alert>;

  const breadcrumbs = (
    <Breadcrumbs>
      <Link to="/clients">Clientes</Link>
      <Text>{client.name}</Text>
    </Breadcrumbs>
  );

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingPool ? 'Editar Piscina' : 'Crear Nueva Piscina'}
        centered
      >
        <form onSubmit={poolForm.onSubmit(handlePoolSubmit)}>
          <Stack>
            <TextInput required label="Nombre de la Piscina" placeholder="Ej. Piscina Principal" {...poolForm.getInputProps('name')} />
            <TextInput required label="Direcci√≥n de la Piscina" {...poolForm.getInputProps('address')} />
            <NumberInput label="Volumen (m¬≥)" placeholder="Ej. 50" min={0} {...poolForm.getInputProps('volume')} />
            <Select label="Tipo de Piscina" data={['Cloro', 'Sal']} {...poolForm.getInputProps('type')} />
            <Button type="submit" mt="md">{editingPool ? 'Guardar Cambios' : 'Crear Piscina'}</Button>
          </Stack>
        </form>
      </Modal>
    
      <Container fluid>
        {breadcrumbs}
        <Title order={2} my="lg">{client.name}</Title>
        <Paper withBorder p="md" mb="xl">
          <Title order={4} mb="xs">Informaci√≥n de Contacto</Title>
          <Text><strong>Persona de contacto:</strong> {client.contactPerson || '-'}</Text>
          <Text><strong>Email:</strong> {client.email || '-'}</Text>
          <Text><strong>Tel√©fono:</strong> {client.phone || '-'}</Text>
          <Text><strong>Direcci√≥n de facturaci√≥n:</strong> {client.address || '-'}</Text>
        </Paper>
        
        <Group justify="space-between" align="center" mb="md">
          <Title order={3}>Piscinas</Title>
          <Button onClick={() => handleOpenModal()}>Crear Nueva Piscina</Button>
        </Group>

        <Table striped withTableBorder>
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Direcci√≥n</Table.Th>
              <Table.Th>Volumen (m¬≥)</Table.Th>
              <Table.Th>Tipo</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>
            {client.pools.length > 0 ? (
              client.pools.map(pool => (
                <Table.Tr key={pool.id}>
                  <Table.Td>
                    <Anchor component={Link} to={`/pools/${pool.id}`}>
                      {pool.name}
                    </Anchor>
                  </Table.Td>
                  <Table.Td>{pool.address}</Table.Td>
                  <Table.Td>{pool.volume || '-'}</Table.Td>
                  <Table.Td>{pool.type || '-'}</Table.Td>
                  <Table.Td>
                    <Group gap="xs">
                      <Button variant="subtle" size="xs" onClick={() => handleOpenModal(pool)}>Editar</Button>
                      <Button variant="subtle" size="xs" color="red" onClick={() => handlePoolDelete(pool.id)}>Eliminar</Button>
                    </Group>
                  </Table.Td>
                </Table.Tr>
              ))
            ) : (
              <Table.Tr><Table.Td colSpan={5}>Este cliente no tiene piscinas asociadas.</Table.Td></Table.Tr>
            )}
          </Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [15] packages/client/src/features/admin/pages/clients/ClientsPage.tsx ======
// filename: packages/client/src/features/admin/pages/clients/ClientsPage.tsx
// Version: 1.1.0 (Make client names link to their detail page)
import { useEffect, useState } from 'react';
import { Link } from 'react-router-dom';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  NumberInput,
  Anchor,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../../api/apiClient.js';

// --- Tipos ---
interface Client {
  id: string;
  name: string;
  contactPerson: string | null;
  email: string | null;
  phone: string | null;
  address: string | null;
  priceModifier: number;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function ClientsPage() {
  const [clients, setClients] = useState<Client[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingClient, setEditingClient] = useState<Client | null>(null);

  const form = useForm({
    initialValues: {
      name: '',
      contactPerson: '',
      email: '',
      phone: '',
      address: '',
      priceModifier: 1.0,
    },
    validate: {
      name: (value) => (value.trim().length < 2 ? 'El nombre es demasiado corto' : null),
      email: (value) => (value && !/^\S+@\S+$/.test(value) ? 'Email inv√°lido' : null),
      priceModifier: (value) => (value <= 0 ? 'El modificador debe ser mayor que 0' : null),
    },
  });

  const fetchClients = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<Client[]>>('/clients');
      setClients(response.data.data);
    } catch (err) {
      setError('No se pudo cargar la lista de clientes.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchClients();
  }, []);

  const handleOpenModal = (client: Client | null = null) => {
    setEditingClient(client);
    if (client) {
      form.setValues({
        name: client.name,
        contactPerson: client.contactPerson || '',
        email: client.email || '',
        phone: client.phone || '',
        address: client.address || '',
        priceModifier: client.priceModifier,
      });
    } else {
      form.reset();
    }
    openModal();
  };

  const handleSubmit = async (values: typeof form.values) => {
    try {
      if (editingClient) {
        await apiClient.patch(`/clients/${editingClient.id}`, values);
      } else {
        await apiClient.post('/clients', values);
      }
      await fetchClients();
      closeModal();
    } catch (err: any) {
      form.setErrors({ name: err.response?.data?.message || 'Error al guardar el cliente' });
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar este cliente? Se borrar√°n tambi√©n todas sus piscinas asociadas.')) {
      try {
        await apiClient.delete(`/clients/${id}`);
        setClients((current) => current.filter((c) => c.id !== id));
      } catch (err) {
        console.error('Failed to delete client', err);
      }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = clients.map((client) => (
    <Table.Tr key={client.id}>
      <Table.Td>
        <Anchor component={Link} to={`/clients/${client.id}`}>
          {client.name}
        </Anchor>
      </Table.Td>
      <Table.Td>{client.contactPerson || '-'}</Table.Td>
      <Table.Td>{client.phone || '-'}</Table.Td>
      <Table.Td>{client.email || '-'}</Table.Td>
      <Table.Td>
        <Group gap="xs">
          <Button variant="subtle" size="xs" onClick={() => handleOpenModal(client)}>Editar</Button>
          <Button variant="subtle" size="xs" color="red" onClick={() => handleDelete(client.id)}>Eliminar</Button>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingClient ? 'Editar Cliente' : 'Crear Nuevo Cliente'}
        centered
      >
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="Nombre del Cliente" {...form.getInputProps('name')} />
            <TextInput label="Persona de Contacto" {...form.getInputProps('contactPerson')} />
            <TextInput label="Email" type="email" {...form.getInputProps('email')} />
            <TextInput label="Tel√©fono" {...form.getInputProps('phone')} />
            <TextInput label="Direcci√≥n" {...form.getInputProps('address')} />
            <NumberInput 
              label="Modificador de Precio" 
              description="1.0 es normal, 0.9 es 10% dto, 1.1 es 10% recargo." 
              defaultValue={1.0} 
              step={0.05} 
              min={0} 
              decimalScale={2} 
              {...form.getInputProps('priceModifier')} 
            />
            <Button type="submit" mt="md">{editingClient ? 'Guardar Cambios' : 'Crear Cliente'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Gesti√≥n de Clientes</Title>
          <Button onClick={() => handleOpenModal()}>Crear Nuevo Cliente</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Contacto</Table.Th>
              <Table.Th>Tel√©fono</Table.Th>
              <Table.Th>Email</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={5}>No hay clientes creados.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [16] packages/client/src/features/admin/pages/incidents/IncidentDetailPage.tsx ======
// filename: packages/client/src/features/admin/pages/incidents/IncidentDetailPage.tsx
// version: 2.3.4 (FINAL, FINAL FIX)

import { useEffect, useState } from 'react';
import { useParams, Link } from 'react-router-dom';
import {
  Container, Title, Loader, Alert, Paper, Text, Breadcrumbs, Button, Group,
  Modal, TextInput, Stack, Textarea, Select, Badge, Card, ActionIcon, Divider, SimpleGrid, Image
} from '@mantine/core';
import { DateTimePicker } from '@mantine/dates';
import 'dayjs/locale/es';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../../api/apiClient';
import { format } from 'date-fns';
import { es } from 'date-fns/locale';
import { useAuth } from '../../../../providers/AuthProvider';

// --- Tipos, Interfaces y Mapeos ---
type IncidentStatus = 'PENDING' | 'RESOLVED';
type IncidentPriority = 'LOW' | 'NORMAL' | 'HIGH' | 'CRITICAL';
type IncidentTaskStatus = 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'CANCELLED';
interface User { id: string; name: string; }
interface IncidentImage { id: string; url: string; }
interface IncidentTaskLog { id: string, action: string, details: string, createdAt: string, user: { name: string } }
interface IncidentTask {
  id: string; title: string; description: string | null; status: IncidentTaskStatus;
  priority: IncidentPriority; deadline: string | null; assignedTo: User | null; resolutionNotes: string | null;
}
interface NotificationDetails {
  id: string; message: string; status: IncidentStatus; priority: IncidentPriority | null; createdAt: string;
  images: IncidentImage[];
  visit: { id: string; pool: { name: string; }; technician: { name: string } | null; } | null;
}
interface ApiResponse<T> { success: boolean; data: T; }
const taskStatusColors: Record<IncidentTaskStatus, string> = { PENDING: 'gray', IN_PROGRESS: 'blue', COMPLETED: 'green', CANCELLED: 'red' };
const priorityColors: Record<IncidentPriority, string> = { LOW: 'gray', NORMAL: 'blue', HIGH: 'orange', CRITICAL: 'red' };

// ===================================================================
// --- VISTA PARA EL T√âCNICO ---
// ===================================================================
const TechnicianTaskView = ({ tasks, onUpdate }: { tasks: IncidentTask[], onUpdate: () => void }) => {
  const { user } = useAuth();
  const myTask = tasks.find(t => t.assignedTo?.id === user?.id);

  const [comment, setComment] = useState('');
  const [newDeadline, setNewDeadline] = useState<Date | null>(null);
  
  const handleStatusChange = async (status: IncidentTaskStatus, resolutionNotes?: string) => {
    if (!myTask) return;
    await apiClient.patch(`/incident-tasks/${myTask.id}/status`, { status, resolutionNotes });
    onUpdate();
  };

  const handleAddLog = async () => {
    if (!myTask || !comment) return;
    await apiClient.post(`/incident-tasks/${myTask.id}/log`, {
      details: comment,
      newDeadline: newDeadline ? newDeadline.toISOString() : undefined,
    });
    setComment('');
    setNewDeadline(null);
    onUpdate();
  };

  if (!myTask) {
    return <Alert color="orange">No tienes una tarea espec√≠fica asignada para esta incidencia.</Alert>
  }

  return (
    <Stack>
      <Title order={3}>Tarea Asignada: {myTask.title}</Title>
      <Text c="dimmed">{myTask.description}</Text>
      <Group>
        <Badge color={taskStatusColors[myTask.status]}>{myTask.status}</Badge>
        <Badge color={priorityColors[myTask.priority]}>Prioridad: {myTask.priority}</Badge>
      </Group>

      <Paper withBorder p="md" mt="lg">
        <Title order={4} mb="md">Acciones</Title>
        <Group>
          <Button disabled={myTask.status !== 'PENDING'} onClick={() => handleStatusChange('IN_PROGRESS')}>Empezar Tarea</Button>
          <Button color="green" disabled={myTask.status === 'COMPLETED'} onClick={() => {
            const notes = prompt("A√±ade notas de resoluci√≥n para completar la tarea:");
            if (notes) handleStatusChange('COMPLETED', notes);
          }}>Completar Tarea</Button>
        </Group>

        <Divider my="lg" label="A√±adir Actualizaci√≥n o Solicitar Aplazamiento" />
        <Textarea
          placeholder="Ej: No hay stock de la pieza necesaria..."
          label="Comentario"
          value={comment}
          onChange={(e) => setComment(e.currentTarget.value)}
        />
        <DateTimePicker
          label="Sugerir nuevo plazo (opcional)"
          locale="es"
          clearable
          value={newDeadline}
          onChange={setNewDeadline} // <-- CORRECCI√ìN APLICADA
          mt="sm"
        />
        <Button mt="md" onClick={handleAddLog} disabled={!comment}>Enviar Actualizaci√≥n</Button>
      </Paper>
    </Stack>
  );
};


// ===================================================================
// --- VISTA PARA EL ADMIN ---
// ===================================================================
const AdminIncidentView = ({ notification, tasks, technicians, onUpdate }: { notification: NotificationDetails, tasks: IncidentTask[], technicians: User[], onUpdate: () => void }) => {
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingTask, setEditingTask] = useState<IncidentTask | null>(null);
  const [logs, setLogs] = useState<IncidentTaskLog[]>([]);
  const [selectedTaskForLogs, setSelectedTaskForLogs] = useState<IncidentTask | null>(null);
  
  const form = useForm({ initialValues: { title: '', description: '', priority: 'NORMAL' as IncidentPriority, assignedToId: null as string | null, deadline: null as Date | null, }, validate: { title: (value) => (value.trim().length < 5 ? 'El t√≠tulo es demasiado corto.' : null) } });

  const handleOpenModal = (task: IncidentTask | null = null) => {
    setEditingTask(task);
    if (task) {
      form.setValues({ title: task.title, description: task.description || '', priority: task.priority, assignedToId: task.assignedTo?.id || null, deadline: task.deadline ? new Date(task.deadline) : null, });
    } else {
      form.reset();
      form.setFieldValue('priority', 'NORMAL');
    }
    openModal();
  };

  const handleSubmit = async (values: typeof form.values) => {
    if (!notification.id) return;
    const payload = { ...values, deadline: values.deadline instanceof Date ? values.deadline.toISOString() : null };
    try {
      if (editingTask) { await apiClient.patch(`/incident-tasks/${editingTask.id}`, payload);
      } else { await apiClient.post('/incident-tasks', { ...payload, notificationId: notification.id }); }
      onUpdate();
      closeModal();
    } catch (err: any) { form.setErrors({ title: err.response?.data?.message || 'Error al guardar la tarea.' }); }
  };

  const handleDelete = async (taskId: string) => {
    if (window.confirm('¬øEst√°s seguro?')) { try { await apiClient.delete(`/incident-tasks/${taskId}`); onUpdate(); } catch (err) { alert('No se pudo eliminar la tarea.'); } }
  };

  const handleViewLogs = async (task: IncidentTask) => {
    if (selectedTaskForLogs?.id === task.id) {
      setSelectedTaskForLogs(null);
      return;
    }
    setSelectedTaskForLogs(task);
    const response = await apiClient.get<ApiResponse<IncidentTaskLog[]>>(`/incident-tasks/${task.id}/logs`);
    setLogs(response.data.data);
  };
  
  const technicianOptions = technicians.map(t => ({ value: t.id, label: t.name }));

  return (
    <>
      <Modal opened={modalOpened} onClose={closeModal} title={editingTask ? 'Editar Tarea' : 'Crear Tarea'} centered>
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="T√≠tulo" {...form.getInputProps('title')} />
            <Textarea label="Descripci√≥n" {...form.getInputProps('description')} />
            <Select label="Prioridad" data={['LOW', 'NORMAL', 'HIGH', 'CRITICAL']} required {...form.getInputProps('priority')} />
            <Select label="Asignar a" data={technicianOptions} clearable {...form.getInputProps('assignedToId')} />
            <DateTimePicker label="Plazo L√≠mite" locale="es" clearable {...form.getInputProps('deadline')} />
            <Button type="submit" mt="md">{editingTask ? 'Guardar Cambios' : 'Crear Tarea'}</Button>
          </Stack>
        </form>
      </Modal>

      <Group justify="space-between" align="center" mb="md"><Title order={3}>Tareas de Seguimiento</Title><Button onClick={() => handleOpenModal()}>+ Crear Tarea</Button></Group>
      
      <Stack>
        {tasks.length > 0 ? (
          tasks.map(task => {
            const isOverdue = task.deadline && new Date(task.deadline) < new Date() && task.status === 'PENDING';
            return (
              <Card key={task.id} withBorder shadow="sm" p="md" style={ isOverdue ? { borderLeft: '4px solid var(--mantine-color-red-7)' } : {}}>
                <Group justify="space-between" align="flex-start">
                  <Stack gap="xs" style={{ flex: 1 }}>
                    <Title order={5}>{task.title}</Title>
                    {task.description && <Text size="sm" c="dimmed">{task.description}</Text>}
                    <Divider />
                    <Group gap="sm">
                      <Badge color={taskStatusColors[task.status]} variant="light">{task.status}</Badge>
                      <Badge color={priorityColors[task.priority]} variant="light">Prioridad: {task.priority}</Badge>
                      {task.assignedTo && <Text size="xs">Asignado a: <strong>{task.assignedTo.name}</strong></Text>}
                    </Group>
                    {task.deadline && <Text size="xs" c={isOverdue ? 'red' : 'dimmed'} fw={isOverdue ? 700 : 400}>Plazo: {format(new Date(task.deadline), 'd MMM yyyy, HH:mm', { locale: es })} {isOverdue && '(VENCIDA)'}</Text>}
                    {task.resolutionNotes && <Textarea value={task.resolutionNotes} readOnly label="Notas de Resoluci√≥n" mt="xs" />}
                    {selectedTaskForLogs?.id === task.id && logs.length > 0 && (
                      <Paper withBorder p="xs" mt="sm" radius="md">
                        <Text size="xs" fw={700} mb="xs">Historial de la Tarea:</Text>
                        <Stack gap="xs">
                          {logs.map(log => <Text size="xs" key={log.id}><strong>{log.user.name}</strong> ({format(new Date(log.createdAt), 'dd/MM HH:mm')}) - {log.details}</Text>)}
                        </Stack>
                      </Paper>
                    )}
                  </Stack>
                  <Stack>
                    <Button.Group orientation="vertical">
                      <Button variant="subtle" size="xs" onClick={() => handleOpenModal(task)}>Editar</Button>
                      <Button variant="subtle" size="xs" onClick={() => handleViewLogs(task)}>Ver Historial</Button>
                      <ActionIcon color="red" variant="subtle" onClick={() => handleDelete(task.id)}>üóëÔ∏è</ActionIcon>
                    </Button.Group>
                  </Stack>
                </Group>
              </Card>
            )
          })
        ) : (<Text c="dimmed">No hay tareas de seguimiento para esta incidencia.</Text>)}
      </Stack>
    </>
  );
};


// ===================================================================
// --- COMPONENTE PRINCIPAL (DESPACHADOR) ---
// ===================================================================
export function IncidentDetailPage() {
  const { notificationId } = useParams<{ notificationId: string }>();
  const { user } = useAuth();
  
  const [notification, setNotification] = useState<NotificationDetails | null>(null);
  const [tasks, setTasks] = useState<IncidentTask[]>([]);
  const [technicians, setTechnicians] = useState<User[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [imageModalOpened, { open: openImageModal, close: closeImageModal }] = useDisclosure(false);
  const [selectedImage, setSelectedImage] = useState<string | null>(null);

  const fetchData = async () => {
    if (!notificationId) return;
    setIsLoading(true);
    setError(null);
    try {
      const [notificationRes, tasksRes, techniciansRes] = await Promise.all([
        apiClient.get<ApiResponse<NotificationDetails>>(`/notifications/${notificationId}`),
        apiClient.get<ApiResponse<IncidentTask[]>>(`/incident-tasks/by-notification/${notificationId}`),
        apiClient.get<ApiResponse<User[]>>('/users/technicians')
      ]);
      setNotification(notificationRes.data.data);
      setTasks(tasksRes.data.data);
      setTechnicians(techniciansRes.data.data.map(t => ({ id: t.id, name: t.name })));
    } catch (err) {
      setError('No se pudo cargar la informaci√≥n de la incidencia.');
    } finally { setIsLoading(false); }
  };

  const handleImageClick = (url: string) => { setSelectedImage(url); openImageModal(); };

  useEffect(() => { fetchData(); // eslint-disable-next-line
  }, [notificationId]);
  
  if (isLoading) return <Container p="xl" style={{ display: 'flex', justifyContent: 'center' }}><Loader /></Container>;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;
  if (!notification) return <Alert color="yellow">Incidencia no encontrada.</Alert>;

  const breadcrumbs = (<Breadcrumbs><Link to={user?.role === 'ADMIN' ? "/incidents-history" : "/my-route"}>{user?.role === 'ADMIN' ? "Gesti√≥n de Incidencias" : "Mi Trabajo de Hoy"}</Link><Text>Detalle</Text></Breadcrumbs>);

  return (
    <Container fluid>
      <Modal opened={imageModalOpened} onClose={closeImageModal} title="Imagen de la Incidencia" centered size="xl">{selectedImage && <Image src={selectedImage} />}</Modal>
      {breadcrumbs}
      <Title order={2} my="lg">Incidencia en {notification.visit?.pool.name}</Title>

      <Paper withBorder p="md" mb="xl">
        <Group justify="space-between"><Title order={4}>Reporte Original</Title><Badge color={notification.status === 'PENDING' ? 'orange' : 'green'} size="lg">{notification.status}</Badge></Group>
        <Text size="sm" c="dimmed" mt="xs">Reportado por {notification.visit?.technician?.name || 'N/A'} el {format(new Date(notification.createdAt), 'd MMM yyyy, HH:mm', { locale: es })}</Text>
        <Textarea value={notification.message} readOnly minRows={2} mt="md" label="Mensaje del t√©cnico" />
        {notification.images && notification.images.length > 0 && (
          <><Text fw={500} size="sm" mt="md">Im√°genes Adjuntas:</Text><SimpleGrid cols={{ base: 2, sm: 4, lg: 6 }} mt="xs">{notification.images.map(image => (<Paper key={image.id} withBorder radius="md" style={{ cursor: 'pointer' }} onClick={() => handleImageClick(image.url)}><Image src={image.url} height={100} radius="md" fit="cover" /></Paper>))}</SimpleGrid></>
        )}
        {notification.visit && <Button component={Link} to={`/visits/${notification.visit.id}`} variant="subtle" size="xs" mt="sm">Ver Parte de Trabajo Original</Button>}
      </Paper>
      
      {user?.role === 'ADMIN' 
        ? <AdminIncidentView notification={notification} tasks={tasks} technicians={technicians} onUpdate={fetchData} />
        : <TechnicianTaskView tasks={tasks} onUpdate={fetchData} />
      }
    </Container>
  );
}


// ====== [17] packages/client/src/features/admin/pages/planner/PlannerPage.tsx ======
// filename: packages/client/src/features/admin/pages/planner/PlannerPage.tsx
// version: 1.6.3 (Fix conditional styling merge with dnd-kit styles)
import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Loader,
  Alert,
  Paper,
  Text,
  Grid,
  Card,
  Group,
  ActionIcon,
  Stack,
  Badge,
} from '@mantine/core';
import { useAuth } from '../../../../providers/AuthProvider.js';
import apiClient from '../../../../api/apiClient.js';
import { startOfWeek, endOfWeek, format, addDays, subDays } from 'date-fns';
import { es } from 'date-fns/locale';
import { DndContext, useDraggable, useDroppable } from '@dnd-kit/core';
import type { DragEndEvent } from '@dnd-kit/core';
import { useNavigate } from 'react-router-dom';

// --- Tipos ---
interface Visit {
  id: string;
  timestamp: string;
  status: 'PENDING' | 'COMPLETED' | 'CANCELLED';
  hasIncident: boolean;
  pool: { name: string; client: { name: string; }; };
  technicianId: string | null;
}
interface Technician { id: string; name: string; }
interface ApiResponse<T> { success: boolean; data: T; }

// --- Componentes de Drag and Drop ---
function DraggableVisit({ visit }: { visit: Visit }) {
  const { attributes, listeners, setNodeRef, transform } = useDraggable({ id: visit.id, data: visit });
  const navigate = useNavigate();
  
  const isCompleted = visit.status === 'COMPLETED';

  // --- L√ìGICA DE ESTILOS CORREGIDA ---
  // 1. Estilos base para la transformaci√≥n del drag-and-drop
  const dndStyle = transform ? { transform: `translate3d(${transform.x}px, ${transform.y}px, 0)`, zIndex: 100 } : undefined;

  // 2. Nuestros estilos condicionales personalizados
  const customCardStyles: React.CSSProperties = {
    cursor: 'pointer',
  };
  
  if (isCompleted) {
    customCardStyles.opacity = 0.65;
    if (visit.hasIncident) {
      customCardStyles.borderLeft = '4px solid var(--mantine-color-red-6)';
    } else {
      customCardStyles.borderLeft = '4px solid var(--mantine-color-green-6)';
    }
  }

  // 3. Unimos ambos objetos de estilo
  const combinedDivStyle = { ...dndStyle, ...customCardStyles };

  const titleStyle = isCompleted ? { textDecoration: 'line-through' } : {};
  
  const handleCardClick = () => {
    navigate(`/visits/${visit.id}`);
  };

  return (
    // Aplicamos los estilos combinados al div exterior
    <div 
      ref={setNodeRef} 
      style={combinedDivStyle} 
      {...attributes} 
      {...listeners}
      onClick={handleCardClick} // El onClick ahora est√° en el div que se arrastra
    >
      <Card 
        shadow="sm" 
        p="xs" 
        withBorder 
        style={{ width: '100%', height: '100%' }} // La tarjeta ocupa todo el div
      >
        <Group justify="space-between">
          <Text fw={500} style={titleStyle}>{visit.pool.name}</Text>
          {isCompleted && (
            visit.hasIncident 
              ? <Badge size="sm" color="red" variant="light">‚ö†Ô∏è Incidencia</Badge>
              : <Badge size="sm" color="green" variant="light">OK</Badge>
          )}
        </Group>
        <Text size="sm" c="dimmed">{visit.pool.client.name}</Text>
        <Text size="xs" mt={4}>{format(new Date(visit.timestamp), 'eeee d', { locale: es })}</Text>
      </Card>
    </div>
  );
}

function DroppableArea({ id, children, title }: { id: string; children: React.ReactNode; title: string }) {
  const { setNodeRef, isOver } = useDroppable({ id });
  return (
    <Paper ref={setNodeRef} withBorder p="sm" style={{ minHeight: 400, backgroundColor: isOver ? '#e7f5ff' : '#f1f3f5', transition: 'background-color 0.2s ease' }}>
      <Title order={5} ta="center" mb="md">{title}</Title>
      <Stack>{children}</Stack>
    </Paper>
  );
}

// --- Componente Principal ---
export function PlannerPage() {
  const { user } = useAuth();
  const [visits, setVisits] = useState<Visit[]>([]);
  const [technicians, setTechnicians] = useState<Technician[]>([]);
  const [currentDate, setCurrentDate] = useState(new Date());
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const weekStart = startOfWeek(currentDate, { weekStartsOn: 1 });
  const weekEnd = endOfWeek(currentDate, { weekStartsOn: 1 });

  const fetchData = async () => {
    if (!user) return;
    setIsLoading(true);
    try {
      const [visitsRes, techsRes] = await Promise.all([
        apiClient.get<ApiResponse<Visit[]>>('/visits/scheduled', { params: { date: currentDate.toISOString() } }),
        apiClient.get<ApiResponse<Technician[]>>('/users/technicians'),
      ]);
      setVisits(visitsRes.data.data);
      setTechnicians(techsRes.data.data);
    } catch (err) { setError('No se pudo cargar la planificaci√≥n.'); } finally { setIsLoading(false); }
  };

  useEffect(() => { fetchData(); // eslint-disable-next-line
  }, [currentDate, user]);

  const handleDragEnd = async (event: DragEndEvent) => {
    const { over, active } = event;
    if (!over) return;

    const visitId = active.id as string;
    const targetId = String(over.id);
    const [type, id] = targetId.split('-');

    let technicianId: string | null = null;
    
    if (type === 'tech' && id) {
        technicianId = id;
    }

    const originalVisits = [...visits];
    const visitToUpdate = visits.find(v => v.id === visitId);
    if (!visitToUpdate || visitToUpdate.technicianId === technicianId) return;

    setVisits(prev => prev.map(v => v.id === visitId ? { ...v, technicianId } : v));

    try {
      await apiClient.post('/visits/assign', { visitId, technicianId });
    } catch (err) {
      setError('No se pudo asignar la visita.');
      setVisits(originalVisits);
    }
  };

  if (isLoading) return <Loader size="xl" />;
  
  const weekRange = `${format(weekStart, 'd')} - ${format(weekEnd, 'd MMMM yyyy', { locale: es })}`;

  return (
    <DndContext onDragEnd={handleDragEnd}>
      <Container fluid>
        {error && <Alert color="red" title="Error" mb="md">{error}</Alert>}
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Planificador Semanal</Title>
          <Group>
            <ActionIcon variant="default" onClick={() => setCurrentDate(subDays(currentDate, 7))}>{'<'}</ActionIcon>
            <Text size="lg" fw={500}>{weekRange}</Text>
            <ActionIcon variant="default" onClick={() => setCurrentDate(addDays(currentDate, 7))}>{'<'}</ActionIcon>
          </Group>
        </Group>

        <Grid grow>
          <Grid.Col span={{ base: 12, md: 2 }}>
            <DroppableArea id="tech-null" title="Visitas Pendientes">
              {visits.filter(v => !v.technicianId).map(visit => <DraggableVisit key={visit.id} visit={visit} />)}
            </DroppableArea>
          </Grid.Col>

          <Grid.Col span={{ base: 12, md: 10 }}>
            <Grid>
              {technicians.map(tech => (
                <Grid.Col key={tech.id} span={{ base: 12, md: 6, lg: 4 }}>
                   <DroppableArea id={`tech-${tech.id}`} title={tech.name}>
                    {visits
                      .filter(v => v.technicianId === tech.id)
                      .sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime())
                      .map(visit => <DraggableVisit key={visit.id} visit={visit} />)
                    }
                   </DroppableArea>
                </Grid.Col>
              ))}
            </Grid>
          </Grid.Col>
        </Grid>
      </Container>
    </DndContext>
  );
}


// ====== [18] packages/client/src/features/admin/pages/pools/PoolDetailPage.tsx ======
// filename: packages/client/src/features/admin/pages/pools/PoolDetailPage.tsx
// Version: 1.2.0 (Implement Edit functionality for Pool Configurations)
import { useEffect, useState } from 'react';
import { useParams, Link } from 'react-router-dom';
import {
  Container,
  Title,
  Loader,
  Alert,
  Paper,
  Text,
  Table,
  Breadcrumbs,
  Grid,
  Card,
  Button,
  Group,
  Modal,
  Select,
  NumberInput,
  Stack,
  Menu,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../../api/apiClient.js';

// --- Tipos ---
const Frequencies = ['DIARIA', 'SEMANAL', 'QUINCENAL', 'MENSUAL', 'TRIMESTRAL', 'SEMESTRAL', 'ANUAL'] as const;
type Frequency = (typeof Frequencies)[number];

interface Pool { id: string; name: string; clientId: string; }
interface ParameterTemplate { id: string; name: string; unit: string | null; type: 'NUMBER' | 'BOOLEAN' | 'TEXT' | 'SELECT'; }
interface TaskTemplate { id: string; name: string; }
interface PoolConfiguration {
  id: string;
  frequency: Frequency;
  minThreshold: number | null;
  maxThreshold: number | null;
  parameterTemplate?: ParameterTemplate;
  taskTemplate?: TaskTemplate;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function PoolDetailPage() {
  const { id: poolId } = useParams<{ id: string }>();
  const [pool, ] = useState<Pool | null>(null);
  const [configurations, setConfigurations] = useState<PoolConfiguration[]>([]);
  const [parameterCatalog, setParameterCatalog] = useState<ParameterTemplate[]>([]);
  const [taskCatalog, setTaskCatalog] = useState<TaskTemplate[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  // Estado para saber qu√© estamos configurando (un nuevo √≠tem o editando uno existente)
  const [editingConfig, setEditingConfig] = useState<PoolConfiguration | null>(null);
  const [itemToAdd, setItemToAdd] = useState<{ id: string; name: string; type: 'parameter' | 'task' } | null>(null);

  const configForm = useForm({
    initialValues: {
      frequency: 'SEMANAL' as Frequency,
      minThreshold: null as number | null,
      maxThreshold: null as number | null,
    },
    validate: {
      frequency: (value) => (Frequencies.includes(value) ? null : 'Frecuencia inv√°lida'),
    },
  });

  const fetchData = async () => {
    if (!poolId) return;
    setIsLoading(true);
    try {
      const [configsRes, paramsRes, tasksRes] = await Promise.all([
        apiClient.get<ApiResponse<PoolConfiguration[]>>(`/pool-configurations/by-pool/${poolId}`),
        apiClient.get<ApiResponse<ParameterTemplate[]>>('/parameters'),
        apiClient.get<ApiResponse<TaskTemplate[]>>('/tasks'),
      ]);
      setConfigurations(configsRes.data.data);
      setParameterCatalog(paramsRes.data.data);
      setTaskCatalog(tasksRes.data.data);
    } catch (err) {
      setError('No se pudo cargar la configuraci√≥n de la piscina.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [poolId]);

  const handleOpenModal = (config: PoolConfiguration | null, item: { id: string; name: string; } | null, type: 'parameter' | 'task' | null) => {
    setEditingConfig(config);
    setItemToAdd(item ? { ...item, type: type as 'parameter' | 'task' } : null);
    
    if (config) { // Estamos editando
      configForm.setValues({
        frequency: config.frequency,
        minThreshold: config.minThreshold,
        maxThreshold: config.maxThreshold,
      });
    } else { // Estamos creando
      configForm.reset();
    }
    openModal();
  };

  const handleConfigSubmit = async (values: typeof configForm.values) => {
    if (!poolId) return;
    try {
      if (editingConfig) { // L√≥gica para actualizar
        const payload = { frequency: values.frequency, minThreshold: values.minThreshold, maxThreshold: values.maxThreshold };
        await apiClient.patch(`/pool-configurations/${editingConfig.id}`, payload);
      } else if (itemToAdd) { // L√≥gica para crear
        const payload = {
          poolId,
          frequency: values.frequency,
          ...(itemToAdd.type === 'parameter' && { parameterTemplateId: itemToAdd.id, minThreshold: values.minThreshold, maxThreshold: values.maxThreshold }),
          ...(itemToAdd.type === 'task' && { taskTemplateId: itemToAdd.id }),
        };
        await apiClient.post('/pool-configurations', payload);
      }
      await fetchData();
      closeModal();
    } catch (err: any) {
      configForm.setErrors({ frequency: err.response?.data?.message || 'Error al guardar la configuraci√≥n' });
    }
  };
  
  const handleConfigDelete = async (configId: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres quitar este √≠tem de la ficha?')) {
      try {
        await apiClient.delete(`/pool-configurations/${configId}`);
        await fetchData();
      } catch (err) {}
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const currentItem = editingConfig?.parameterTemplate || editingConfig?.taskTemplate || itemToAdd;
  const modalTitle = editingConfig ? `Editar: ${currentItem?.name}` : `A√±adir: ${currentItem?.name}`;
  const isParameter = (editingConfig && editingConfig.parameterTemplate) || (itemToAdd?.type === 'parameter');
  
  const breadcrumbs = (
    <Breadcrumbs>
      <Link to="/clients">Clientes</Link>
      <Text>Cliente (TODO)</Text>
      <Text>{pool?.name || 'Piscina'}</Text>
    </Breadcrumbs>
  );

  return (
    <>
      <Modal opened={modalOpened} onClose={closeModal} title={modalTitle} centered>
        <form onSubmit={configForm.onSubmit(handleConfigSubmit)}>
          <Stack>
            <Select label="Frecuencia" required data={[...Frequencies]} {...configForm.getInputProps('frequency')} />
            {isParameter && (
              <>
                <NumberInput label="Umbral M√≠nimo (opcional)" {...configForm.getInputProps('minThreshold')} />
                <NumberInput label="Umbral M√°ximo (opcional)" {...configForm.getInputProps('maxThreshold')} />
              </>
            )}
            <Button type="submit" mt="md">{editingConfig ? 'Guardar Cambios' : 'A√±adir a la Ficha'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        {breadcrumbs}
        <Title order={2} my="lg">Constructor de Ficha: {pool?.name || ''}</Title>
        <Grid>
          <Grid.Col span={{ base: 12, md: 6 }}>
            <Paper withBorder p="md">
              <Title order={4} mb="md">Ficha de Mantenimiento Actual</Title>
              <Table>
                <Table.Thead><Table.Tr><Table.Th>√çtem</Table.Th><Table.Th>Frecuencia</Table.Th><Table.Th>Acciones</Table.Th></Table.Tr></Table.Thead>
                <Table.Tbody>
                  {configurations.length > 0 ? configurations.map(config => (
                    <Table.Tr key={config.id}>
                      <Table.Td>{config.parameterTemplate?.name || config.taskTemplate?.name}</Table.Td>
                      <Table.Td>{config.frequency}</Table.Td>
                      <Table.Td>
                        <Menu shadow="md" width={200}>
                          <Menu.Target><Button variant="outline" size="xs">Acciones</Button></Menu.Target>
                          <Menu.Dropdown>
                            <Menu.Item onClick={() => handleOpenModal(config, null, null)}>Editar</Menu.Item>
                            <Menu.Item color="red" onClick={() => handleConfigDelete(config.id)}>Quitar</Menu.Item>
                          </Menu.Dropdown>
                        </Menu>
                      </Table.Td>
                    </Table.Tr>
                  )) : <Table.Tr><Table.Td colSpan={3}>La ficha est√° vac√≠a. A√±ade √≠tems desde los cat√°logos.</Table.Td></Table.Tr>}
                </Table.Tbody>
              </Table>
            </Paper>
          </Grid.Col>

          <Grid.Col span={{ base: 12, md: 6 }}>
            <Paper withBorder p="md" mb="md">
              <Title order={4} mb="md">Cat√°logo de Par√°metros Disponibles</Title>
              {parameterCatalog.map(param => (
                <Card key={param.id} shadow="sm" p="sm" mb="xs" withBorder>
                  <Group justify="space-between">
                    <Text>{param.name} {param.unit ? `(${param.unit})` : ''}</Text>
                    <Button size="xs" onClick={() => handleOpenModal(null, param, 'parameter')}>A√±adir</Button>
                  </Group>
                </Card>
              ))}
            </Paper>
            <Paper withBorder p="md">
              <Title order={4} mb="md">Cat√°logo de Tareas Disponibles</Title>
              {taskCatalog.map(task => (
                <Card key={task.id} shadow="sm" p="sm" mb="xs" withBorder>
                  <Group justify="space-between">
                    <Text>{task.name}</Text>
                    <Button size="xs" onClick={() => handleOpenModal(null, task, 'task')}>A√±adir</Button>
                  </Group>
                </Card>
              ))}
            </Paper>
          </Grid.Col>
        </Grid>
      </Container>
    </>
  );
}


// ====== [19] packages/client/src/features/auth/pages/LoginPage.tsx ======
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Container,
  Title,
  Paper,
  TextInput,
  PasswordInput,
  Button,
  Stack,
  Alert,
} from '@mantine/core';
import { useAuth } from '../../../providers/AuthProvider.js';

export function LoginPage() {
  const { login } = useAuth();
  const navigate = useNavigate();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setError(null);
    try {
      await login({ email, password });
      navigate('/'); // Redirige al dashboard en un login exitoso
    } catch (err) {
      setError('El email o la contrase√±a son incorrectos.');
      console.error(err);
    }
  };

  return (
    <Container size={420} my={40}>
      <Title ta="center">¬°Bienvenido!</Title>
      <Paper withBorder shadow="md" p={30} mt={30} radius="md">
        <form onSubmit={handleSubmit}>
          <Stack>
            <TextInput
              required
              label="Email"
              placeholder="tu@email.com"
              value={email}
              onChange={(event) => setEmail(event.currentTarget.value)}
              radius="md"
            />
            <PasswordInput
              required
              label="Contrase√±a"
              placeholder="Tu contrase√±a"
              value={password}
              onChange={(event) => setPassword(event.currentTarget.value)}
              radius="md"
            />
            {error && (
              <Alert title="Error de autenticaci√≥n" color="red" withCloseButton onClose={() => setError(null)}>
                {error}
              </Alert>
            )}
            <Button type="submit" fullWidth mt="xl" radius="md">
              Iniciar Sesi√≥n
            </Button>
          </Stack>
        </form>
      </Paper>
    </Container>
  );
}


// ====== [20] packages/client/src/features/superadmin/pages/TenantsPage.tsx ======
import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Badge,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  PasswordInput,
  Menu,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient.js';

// --- Tipos ---
type SubscriptionStatus = 'TRIAL' | 'ACTIVE' | 'PAYMENT_PENDING' | 'INACTIVE';

interface Tenant {
  id: string;
  companyName: string;
  subdomain: string;
  subscriptionStatus: SubscriptionStatus;
  createdAt: string;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function TenantsPage() {
  const [tenants, setTenants] = useState<Tenant[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);

  const form = useForm({
    initialValues: {
      companyName: '',
      subdomain: '',
      adminUser: {
        name: '',
        email: '',
        password: '',
      },
    },
    validate: {
      companyName: (value: string) => (value.length < 2 ? 'El nombre debe tener al menos 2 caracteres' : null),
      subdomain: (value: string) => (/^[a-z0-9]+(?:-[a-z0-9]+)*$/.test(value) ? null : 'Subdominio inv√°lido'),
      adminUser: {
        email: (value: string) => (/^\S+@\S+$/.test(value) ? null : 'Email inv√°lido'),
        password: (value: string) => (value.length < 8 ? 'La contrase√±a debe tener al menos 8 caracteres' : null),
      },
    },
  });

  const fetchTenants = async () => {
    if (tenants.length === 0) setIsLoading(true);
    setError(null);
    try {
      const response = await apiClient.get<ApiResponse<Tenant[]>>('/tenants');
      setTenants(response.data.data);
    } catch (err) {
      setError('No se pudo obtener la lista de tenants.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchTenants();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handleCreateTenant = async (values: typeof form.values) => {
    try {
      await apiClient.post<ApiResponse<Tenant>>('/tenants', values);
      await fetchTenants();
      closeModal();
      form.reset();
    } catch (err: any) {
      form.setErrors({ companyName: err.response?.data?.message || 'Error al crear el tenant' });
    }
  };

  const handleUpdateStatus = async (tenantId: string, status: SubscriptionStatus) => {
    try {
      setTenants((current) =>
        current.map((t) => (t.id === tenantId ? { ...t, subscriptionStatus: status } : t))
      );
      await apiClient.patch(`/tenants/${tenantId}/status`, { status });
    } catch (err) {
      console.error('Failed to update tenant status', err);
      await fetchTenants();
    }
  };

  const handleDeleteTenant = async (tenantId: string) => {
    if (window.confirm('¬øEst√°s seguro? Esta acci√≥n eliminar√° el tenant y todos sus datos (usuarios, clientes, piscinas, etc.) de forma irreversible.')) {
      try {
        await apiClient.delete(`/tenants/${tenantId}`);
        setTenants((current) => current.filter((t) => t.id !== tenantId));
      } catch (err) {
        console.error('Failed to delete tenant', err);
        // TODO: Mostrar notificaci√≥n de error al usuario
      }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = tenants.map((tenant) => (
    <Table.Tr key={tenant.id}>
      <Table.Td>{tenant.companyName}</Table.Td>
      <Table.Td>{tenant.subdomain}.pool-control.pro</Table.Td>
      <Table.Td>
        <Badge
          color={
            {
              ACTIVE: 'green',
              TRIAL: 'blue',
              PAYMENT_PENDING: 'orange',
              INACTIVE: 'gray',
            }[tenant.subscriptionStatus]
          }
        >
          {tenant.subscriptionStatus}
        </Badge>
      </Table.Td>
      <Table.Td>{new Date(tenant.createdAt).toLocaleDateString()}</Table.Td>
      <Table.Td>
        <Menu shadow="md" width={200}>
          <Menu.Target>
            <Button variant="outline" size="xs">Acciones</Button>
          </Menu.Target>
          <Menu.Dropdown>
            <Menu.Label>Cambiar estado</Menu.Label>
            <Menu.Item onClick={() => handleUpdateStatus(tenant.id, 'ACTIVE')}>Activar</Menu.Item>
            <Menu.Item onClick={() => handleUpdateStatus(tenant.id, 'TRIAL')}>Poner en Trial</Menu.Item>
            <Menu.Item onClick={() => handleUpdateStatus(tenant.id, 'PAYMENT_PENDING')}>Pago Pendiente</Menu.Item>
            <Menu.Item onClick={() => handleUpdateStatus(tenant.id, 'INACTIVE')}>Desactivar</Menu.Item>
            <Menu.Divider />
            <Menu.Label>Zona de Peligro</Menu.Label>
            <Menu.Item color="red" onClick={() => handleDeleteTenant(tenant.id)}>
              Eliminar Tenant
            </Menu.Item>
          </Menu.Dropdown>
        </Menu>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal opened={modalOpened} onClose={closeModal} title="Crear Nuevo Tenant" centered>
        <form onSubmit={form.onSubmit(handleCreateTenant)}>
          <Stack>
            <TextInput required label="Nombre de la Empresa" placeholder="Ej. Piscinas Mart√≠nez" {...form.getInputProps('companyName')} />
            <TextInput required label="Subdominio" placeholder="ej. martinez" {...form.getInputProps('subdomain')} />
            <Title order={4} mt="md">Usuario Administrador</Title>
            <TextInput required label="Nombre del Admin" placeholder="Ej. Juan Mart√≠nez" {...form.getInputProps('adminUser.name')} />
            <TextInput required label="Email del Admin" placeholder="ej. juan@piscinasmartinez.com" {...form.getInputProps('adminUser.email')} />
            <PasswordInput required label="Contrase√±a del Admin" {...form.getInputProps('adminUser.password')} />
            <Button type="submit" mt="md">Crear Tenant</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Gesti√≥n de Tenants</Title>
          <Button onClick={openModal}>Crear Nuevo Tenant</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Empresa</Table.Th>
              <Table.Th>Subdominio</Table.Th>
              <Table.Th>Estado</Table.Th>
              <Table.Th>Fecha de Creaci√≥n</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={5}>No hay tenants creados.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [21] packages/client/src/features/technician/pages/MyRoutePage.tsx ======
// filename: packages/client/src/features/technician/pages/MyRoutePage.tsx
// Version: 1.2.1 (FIXED - Decouple from @prisma/client)
import { useEffect, useState } from 'react';
import { Link, useLocation } from 'react-router-dom';
import {
  Container,
  Title,
  Loader,
  Alert,
  Stack,
  Card,
  Text,
  Group,
  Anchor,
  ThemeIcon,
  Badge,
  Divider,
} from '@mantine/core';
import apiClient from '../../../api/apiClient';

// --- Tipos del Frontend ---
// Definimos los tipos aqu√≠, bas√°ndonos en lo que esperamos de la API,
// sin acoplar el frontend al backend.
type IncidentPriority = 'LOW' | 'NORMAL' | 'HIGH' | 'CRITICAL';

interface Visit {
  id: string;
  timestamp: string;
  pool: {
    id: string;
    name: string;
    address: string;
    client: { name: string; };
  };
}

interface AssignedTask {
  id: string;
  title: string;
  priority: IncidentPriority;
  notification: {
    id: string;
    visit: {
      pool: { name: string; };
    } | null;
  };
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function MyRoutePage() {
  const [visits, setVisits] = useState<Visit[]>([]);
  const [tasks, setTasks] = useState<AssignedTask[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const location = useLocation();

  const fetchData = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const [visitsResponse, tasksResponse] = await Promise.all([
        apiClient.get<ApiResponse<Visit[]>>('/visits/my-route'),
        apiClient.get<ApiResponse<AssignedTask[]>>('/incident-tasks/my-tasks'),
      ]);
      setVisits(visitsResponse.data.data);
      setTasks(tasksResponse.data.data);
    } catch (err) {
      setError('No se pudo cargar tu trabajo del d√≠a.');
      console.error(err);
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchData();
  }, [location.key]);

  if (isLoading) {
    return (
      <Container style={{ textAlign: 'center', paddingTop: '50px' }}>
        <Loader size="xl" />
        <Text mt="md">Cargando tu trabajo del d√≠a...</Text>
      </Container>
    );
  }

  if (error) {
    return <Alert color="red" title="Error">{error}</Alert>;
  }

  const taskCards = tasks.map((task) => (
    <Card key={task.id} shadow="sm" padding="lg" radius="md" withBorder>
      <Link to={`/incidents/${task.notification.id}`} style={{ textDecoration: 'none', color: 'inherit' }}>
        <Group justify="space-between" mb="xs">
          <Text fw={500} size="lg">{task.title}</Text>
          <Badge color={task.priority === 'HIGH' || task.priority === 'CRITICAL' ? 'red' : 'orange'}>
            {task.priority}
          </Badge>
        </Group>
        <Text size="sm" c="dimmed">
          Incidencia en: {task.notification.visit?.pool.name || 'Piscina no especificada'}
        </Text>
      </Link>
    </Card>
  ));

  const visitCards = visits.map((visit) => (
    <Card key={visit.id} shadow="sm" padding="lg" radius="md" withBorder>
      <Link to={`/visits/${visit.id}`} style={{ textDecoration: 'none', color: 'inherit' }}>
        <Group justify="space-between" mb="xs">
          <Text fw={500} size="lg">{visit.pool.name}</Text>
          <ThemeIcon variant="light" radius="md" size="lg"><span>üìç</span></ThemeIcon>
        </Group>
        <Text size="sm" c="dimmed">Cliente: {visit.pool.client.name}</Text>
      </Link>
      <Anchor href={`https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(visit.pool.address)}`} target="_blank" rel="noopener noreferrer" size="sm" mt="sm">
        {visit.pool.address}
      </Anchor>
    </Card>
  ));

  return (
    <Container>
      <Title order={2} my="lg">Mi Trabajo de Hoy</Title>
      
      <Stack gap="xl">
        {tasks.length > 0 && (
          <Stack>
            <Title order={4} c="orange.7">Tareas Especiales</Title>
            {taskCards}
          </Stack>
        )}

        {visits.length > 0 && tasks.length > 0 && <Divider my="md" />}
        
        {visits.length > 0 && (
          <Stack>
            <Title order={4}>Visitas Programadas</Title>
            {visitCards}
          </Stack>
        )}

        {visits.length === 0 && tasks.length === 0 && (
          <Text>No tienes trabajo asignado para hoy.</Text>
        )}
      </Stack>
    </Container>
  );
}


// ====== [22] packages/client/src/features/technician/pages/WorkOrderPage.tsx ======
// filename: packages/client/src/features/technician/pages/WorkOrderPage.tsx
// version: 2.0.0
// description: Integra la subida de im√°genes para incidencias y su visualizaci√≥n.

import { useEffect, useState } from 'react';
import { useParams, Link, useNavigate } from 'react-router-dom';
import {
  Container,
  Title,
  Loader,
  Alert,
  Paper,
  Text,
  Breadcrumbs,
  Button,
  Stack,
  Checkbox,
  NumberInput,
  Switch,
  TextInput,
  Select,
  Textarea,
  Badge,
  Grid,
  Modal,
  Group,
  Divider,
  ActionIcon,
  FileInput,
  Progress,
  ThemeIcon,
  SimpleGrid,
  Image,
} from '@mantine/core';
import { DateTimePicker } from '@mantine/dates';
import 'dayjs/locale/es';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient';
import axios from 'axios';

// --- Tipos ---
type IncidentPriority = 'LOW' | 'NORMAL' | 'HIGH' | 'CRITICAL';

interface IncidentImage {
  id: string;
  url: string;
}

interface Notification {
    id: string;
    status: 'PENDING' | 'RESOLVED';
    resolutionNotes: string | null;
    priority: IncidentPriority | null;
    resolutionDeadline: string | null;
    images: IncidentImage[];
}

// (Otros tipos se mantienen igual)
interface VisitResult { parameterName: string; parameterUnit: string | null; value: string; }
interface Product { id: string; name: string; unit: string; }
interface Consumption { quantity: number; product: Product; }
interface VisitDetails {
  id: string; status: 'PENDING' | 'COMPLETED' | 'CANCELLED'; notes: string | null; hasIncident: boolean;
  completedTasks: string[]; results: VisitResult[]; notifications: Notification[]; consumptions: Consumption[];
  pool: {
    name: string; address: string; client: { name: string };
    configurations: {
      id: string;
      parameterTemplate?: { id: string; name: string; unit: string | null; type: 'NUMBER' | 'BOOLEAN' | 'TEXT' | 'SELECT'; selectOptions: string[]; };
      taskTemplate?: { id: string; name: string; };
    }[];
  };
}
interface ApiResponse<T> { success: boolean; data: T; }

// --- Componente de Solo Lectura (para el Admin) ---
const ReadOnlyWorkOrder = ({ visit }: { visit: VisitDetails }) => {
  const navigate = useNavigate();
  const [resolutionModalOpened, { open: openResolutionModal, close: closeResolutionModal }] = useDisclosure(false);
  const [classifyModalOpened, { open: openClassifyModal, close: closeClassifyModal }] = useDisclosure(false);
  const [imageModalOpened, { open: openImageModal, close: closeImageModal }] = useDisclosure(false);
  const [selectedImage, setSelectedImage] = useState<string | null>(null);

  const incidentNotification = visit.notifications.length > 0 ? visit.notifications[0] : null;

  const handleImageClick = (url: string) => {
    setSelectedImage(url);
    openImageModal();
  };

  // (L√≥gica de formularios de resoluci√≥n y clasificaci√≥n sin cambios)
  const resolutionForm = useForm({ initialValues: { resolutionNotes: '' }, validate: { resolutionNotes: (value) => value.trim().length < 10 ? 'Las notas de resoluci√≥n son demasiado cortas.' : null },});
  const classificationForm = useForm({ initialValues: { priority: incidentNotification?.priority || 'NORMAL', deadline: incidentNotification?.resolutionDeadline ? new Date(incidentNotification.resolutionDeadline) : null, }, validate: { priority: (value) => !value ? 'Debe seleccionar una prioridad.' : null } });
  const handleResolveIncident = async (values: { resolutionNotes: string }) => { if (!incidentNotification) return; await apiClient.post(`/notifications/${incidentNotification.id}/resolve`, values); closeResolutionModal(); navigate('/incidents-history'); };
  const handleClassifyIncident = async (values: { priority: IncidentPriority, deadline: Date | null }) => { if (!incidentNotification) return; const deadlineDate = values.deadline ? new Date(values.deadline) : null; await apiClient.patch(`/notifications/${incidentNotification.id}/classify`, { priority: values.priority, deadline: deadlineDate ? deadlineDate.toISOString() : null }); closeClassifyModal(); navigate('/incidents-history'); };

  return (
    <>
      <Modal opened={imageModalOpened} onClose={closeImageModal} title="Imagen de la Incidencia" centered size="xl">
        {selectedImage && <Image src={selectedImage} />}
      </Modal>
      {/* (Modales de resoluci√≥n y clasificaci√≥n sin cambios) */}
      <Modal opened={resolutionModalOpened} onClose={closeResolutionModal} title="Gestionar Incidencia" centered><form onSubmit={resolutionForm.onSubmit(handleResolveIncident)}><Stack><Text c="dimmed">Notas del T√©cnico:</Text><Paper withBorder p="sm" bg="gray.0">{visit.notes || 'N/A'}</Paper><Textarea label="Notas de Resoluci√≥n (Admin)" placeholder="Ej: Cliente contactado..." required minRows={3} {...resolutionForm.getInputProps('resolutionNotes')}/><Button type="submit" mt="md" color="green">Marcar como Resuelta</Button></Stack></form></Modal>
      <Modal opened={classifyModalOpened} onClose={closeClassifyModal} title="Clasificar Incidencia" centered><form onSubmit={classificationForm.onSubmit(handleClassifyIncident)}><Stack><Select label="Establecer Prioridad" data={['LOW', 'NORMAL', 'HIGH', 'CRITICAL']} required {...classificationForm.getInputProps('priority')} /><DateTimePicker label="Establecer Plazo de Resoluci√≥n (opcional)" placeholder="Seleccione fecha y hora" locale="es" clearable {...classificationForm.getInputProps('deadline')} /><Button type="submit" mt="md">Guardar Clasificaci√≥n</Button></Stack></form></Modal>

      <Container>
          <Breadcrumbs><Link to="/">Dashboard</Link><Text>{visit.pool.name}</Text></Breadcrumbs>
          <Grid align="center" justify="space-between" my="lg"><Grid.Col span="auto"><Title order={2}>Resumen de Visita: {visit.pool.name}</Title></Grid.Col><Grid.Col span="content"><Badge color="green" size="lg">COMPLETADA</Badge></Grid.Col></Grid>
          <Text c="dimmed">{visit.pool.client.name} - {visit.pool.address}</Text>

          <Paper withBorder p="md" mt="xl">
              <Stack>
                  {visit.results.length > 0 && (<div><Title order={4} mb="sm">Resultados de Mediciones</Title>{visit.results.map(r => <Text key={r.parameterName}><strong>{r.parameterName}:</strong> {r.value} {r.parameterUnit || ''}</Text>)}</div>)}
                  {visit.completedTasks.length > 0 && (<div><Title order={4} mt="lg" mb="sm">Tareas Realizadas</Title>{visit.completedTasks.map(t => <Text key={t}>‚úÖ {t}</Text>)}</div>)}
                  {visit.consumptions.length > 0 && (<div><Title order={4} mt="lg" mb="sm">Productos Consumidos</Title>{visit.consumptions.map(c => <Text key={c.product.id}>- {c.quantity} {c.product.unit} de {c.product.name}</Text>)}</div>)}
                  <Divider my="sm" />
                  <div>
                      <Title order={4}>Observaciones e Incidencia</Title>
                      <Text fw={500} mt="sm">Notas del T√©cnico:</Text>
                      <Paper withBorder p="sm" bg="gray.0" mt="xs"><Text>{visit.notes || 'No se dejaron notas.'}</Text></Paper>
                      
                      {/* --- NUEVA SECCI√ìN: VISUALIZACI√ìN DE IM√ÅGENES --- */}
                      {incidentNotification && incidentNotification.images.length > 0 && (
                        <>
                          <Text fw={500} mt="lg">Im√°genes Adjuntas:</Text>
                          <SimpleGrid cols={{ base: 2, sm: 3, lg: 4 }} mt="xs">
                            {incidentNotification.images.map(image => (
                              <Paper key={image.id} withBorder radius="md" style={{ cursor: 'pointer' }} onClick={() => handleImageClick(image.url)}>
                                <Image src={image.url} height={120} radius="md" />
                              </Paper>
                            ))}
                          </SimpleGrid>
                        </>
                      )}

                      {visit.hasIncident && incidentNotification && (
                        <>
                            {incidentNotification.status === 'RESOLVED' ? (
                                <Stack mt="md" gap="xs"><Badge color="green" size="lg">INCIDENCIA RESUELTA</Badge><Text fw={500} mt="sm">Notas de Resoluci√≥n (Admin):</Text><Paper withBorder p="sm" bg="green.0" mt="xs"><Text>{incidentNotification.resolutionNotes}</Text></Paper></Stack>
                            ) : (
                                <Group mt="md"><Badge color="red" size="lg">INCIDENCIA PENDIENTE</Badge><Button onClick={openClassifyModal} variant="outline">Clasificar</Button><Button onClick={openResolutionModal} color="green">Resolver</Button></Group>
                            )}
                        </>
                      )}
                  </div>
              </Stack>
          </Paper>
        </Container>
    </>
  );
};


// --- Componente de Formulario Editable (para el T√©cnico) ---
interface UploadedFile { file: File; progress: number; url?: string; error?: string; }
const EditableWorkOrder = ({ visit, products, onSubmit }: { visit: VisitDetails; products: Product[], onSubmit: (values: any) => Promise<void> }) => {
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [uploadedFiles, setUploadedFiles] = useState<UploadedFile[]>([]);

  const form = useForm({
    initialValues: {
      results: visit.pool.configurations.filter(c => c.parameterTemplate).reduce((acc, c) => ({ ...acc, [c.id]: '' }), {}),
      completedTasks: visit.pool.configurations.filter(c => c.taskTemplate).reduce((acc, c) => ({ ...acc, [c.id]: false }), {}),
      consumptions: [] as { productId: string; quantity: number | '' }[],
      notes: '',
      hasIncident: false,
    },
  });

  const handleImageUpload = async (files: File[]) => {
    if (!files || files.length === 0) return;
    const newFiles = files.map(file => ({ file, progress: 0 }));
    setUploadedFiles(prev => [...prev, ...newFiles]);

    try {
      const { data: signatureData } = await apiClient.get('/uploads/signature');
      const { signature, timestamp, apiKey, cloudName } = signatureData.data;

      for (const fileObj of newFiles) {
        const formData = new FormData();
        formData.append('file', fileObj.file);
        formData.append('signature', signature);
        formData.append('timestamp', timestamp);
        formData.append('api_key', apiKey);

        try {
          const response = await axios.post(
            `https://api.cloudinary.com/v1_1/${cloudName}/image/upload`,
            formData,
            { onUploadProgress: (event) => {
                const progress = event.total ? Math.round((100 * event.loaded) / event.total) : 0;
                setUploadedFiles(prev => prev.map(f => f.file === fileObj.file ? { ...f, progress } : f));
            }}
          );
          setUploadedFiles(prev => prev.map(f => f.file === fileObj.file ? { ...f, url: response.data.secure_url } : f));
        } catch (uploadError) {
          setUploadedFiles(prev => prev.map(f => f.file === fileObj.file ? { ...f, error: 'Error al subir' } : f));
        }
      }
    } catch (signatureError) {
      console.error("Error al obtener la firma", signatureError);
    }
  };

  const handleSubmit = async (values: typeof form.values) => {
    setIsSubmitting(true);
    const successfulUrls = uploadedFiles.filter(f => f.url).map(f => f.url!);
    const payload = { ...values, imageUrls: successfulUrls };
    await onSubmit(payload);
    setIsSubmitting(false);
  };
  
  // (Renderizado de campos de par√°metros, tareas y consumos sin cambios)
  const productOptions = products.map(p => ({ value: p.id, label: `${p.name} (${p.unit})` }));
  const consumptionFields = form.values.consumptions.map((_, index) => <Grid key={index} align="flex-end"><Grid.Col span={7}><Select label={index === 0 ? 'Producto' : ''} placeholder="Seleccione un producto" data={productOptions} {...form.getInputProps(`consumptions.${index}.productId`)} required /></Grid.Col><Grid.Col span={3}><NumberInput label={index === 0 ? 'Cantidad' : ''} placeholder="0.0" min={0} decimalScale={2} {...form.getInputProps(`consumptions.${index}.quantity`)} required /></Grid.Col><Grid.Col span={2}><ActionIcon color="red" onClick={() => form.removeListItem('consumptions', index)}>üóëÔ∏è</ActionIcon></Grid.Col></Grid>);
  const parametersToMeasure = visit.pool.configurations.filter(c => c.parameterTemplate);
  const tasksToComplete = visit.pool.configurations.filter(c => c.taskTemplate);
  const renderParameterInput = (config: typeof parametersToMeasure[0]) => { const param = config.parameterTemplate; if (!param) return null; const label = `${param.name}${param.unit ? ` (${param.unit})` : ''}`; switch (param.type) { case 'NUMBER': return <NumberInput label={label} {...form.getInputProps(`results.${config.id}`)} />; case 'BOOLEAN': return <Switch mt="md" label={label} {...form.getInputProps(`results.${config.id}`, { type: 'checkbox' })} />; case 'TEXT': return <TextInput label={label} {...form.getInputProps(`results.${config.id}`)} />; case 'SELECT': return <Select label={label} data={param.selectOptions} {...form.getInputProps(`results.${config.id}`)} />; default: return <Text c="red">Tipo no soportado: {param.type}</Text>; } };

  return (
      <Container>
        <Breadcrumbs><Link to="/my-route">Mi Ruta</Link><Text>{visit.pool.name}</Text></Breadcrumbs>
        <Title order={2} my="lg">Parte de Trabajo: {visit.pool.name}</Title>
        <Text c="dimmed">{visit.pool.client.name} - {visit.pool.address}</Text>
        <Paper withBorder p="md" mt="xl">
          <form onSubmit={form.onSubmit(handleSubmit)}>
            <Stack>
              {parametersToMeasure.length > 0 && (<div><Title order={4} mb="sm">Mediciones</Title><Stack>{parametersToMeasure.map(p => <div key={p.id}>{renderParameterInput(p)}</div>)}</Stack></div>)}
              {tasksToComplete.length > 0 && (<div><Title order={4} mt="lg" mb="sm">Tareas</Title><Stack>{tasksToComplete.map(t => <Checkbox key={t.id} label={t.taskTemplate?.name} {...form.getInputProps(`completedTasks.${t.id}`, { type: 'checkbox' })} />)}</Stack></div>)}
              <Divider my="md" label="Consumo de Productos" labelPosition="center" />
              {consumptionFields}
              <Button mt="xs" variant="outline" onClick={() => form.insertListItem('consumptions', { productId: '', quantity: '' })}>+ A√±adir Producto</Button>
              <Divider my="md" />
              <Title order={4} mb="sm">Observaciones e Incidencias</Title>
              <Textarea label="Notas de la visita" placeholder="Cualquier observaci√≥n relevante..." {...form.getInputProps('notes')} />
              <Checkbox label="Reportar como Incidencia" description="Marcar si hay un problema para el administrador." {...form.getInputProps('hasIncident', { type: 'checkbox' })} />
              
              {/* --- NUEVO COMPONENTE: SUBIDA DE IM√ÅGENES --- */}
              {form.values.hasIncident && (
                <Stack mt="sm" gap="xs">
                  <FileInput label="Adjuntar Fotos" placeholder="Seleccionar im√°genes..." multiple accept="image/png,image/jpeg" onChange={handleImageUpload} />
                  {uploadedFiles.length > 0 && (
                    <Stack gap="xs">
                      {uploadedFiles.map((fileObj, index) => (
                        <Paper key={index} withBorder p="xs" radius="sm">
                          <Group justify="space-between">
                            <Text size="sm" truncate style={{flex: 1}}>{fileObj.file.name}</Text>
                            {fileObj.progress < 100 && !fileObj.error && <Progress value={fileObj.progress} striped animated size="lg" style={{width: '100px'}} />}
                            {fileObj.url && <ThemeIcon color="green" variant="light">‚úì</ThemeIcon>}
                            {fileObj.error && <ThemeIcon color="red" variant="light">‚úó</ThemeIcon>}
                          </Group>
                        </Paper>
                      ))}
                    </Stack>
                  )}
                </Stack>
              )}
              
              <Button type="submit" mt="xl" size="lg" loading={isSubmitting}>Guardar y Finalizar Visita</Button>
            </Stack>
          </form>
        </Paper>
      </Container>
  );
};


// --- Componente Principal ---
export function WorkOrderPage() {
  const { visitId } = useParams<{ visitId: string }>();
  const navigate = useNavigate();
  const [visit, setVisit] = useState<VisitDetails | null>(null);
  const [products, setProducts] = useState<Product[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!visitId) { setError('No se ha proporcionado un ID de visita.'); setIsLoading(false); return; }
    
    const fetchAllData = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const [visitResponse, productsResponse] = await Promise.all([
          apiClient.get<ApiResponse<VisitDetails>>(`/visits/${visitId}`),
          apiClient.get<ApiResponse<Product[]>>('/products')
        ]);
        setVisit(visitResponse.data.data);
        setProducts(productsResponse.data.data);
      } catch (err) { setError('No se pudo cargar la informaci√≥n de la visita o los productos.'); } finally { setIsLoading(false); }
    };
    fetchAllData();
  }, [visitId]);

  const handleSubmit = async (values: any) => {
    if (!visitId) return;
    try {
      await apiClient.post(`/visits/${visitId}/complete`, values);
      navigate('/my-route');
    } catch (err) { console.error('Error submitting work order', err); }
  };

  if (isLoading) return <Container style={{ textAlign: 'center', paddingTop: '50px' }}><Loader size="xl" /></Container>;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;
  if (!visit) return <Alert color="yellow" title="Aviso">Visita no encontrada.</Alert>;
  
  if (visit.status === 'COMPLETED') {
    return <ReadOnlyWorkOrder visit={visit} />;
  }
  
  return <EditableWorkOrder visit={visit} products={products} onSubmit={handleSubmit} />;
}


// ====== [23] packages/client/src/main.tsx ======
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.js';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


// ====== [24] packages/client/src/providers/AuthProvider.tsx ======
import {
  createContext,
  useContext,
  useState,
  useEffect,
  useCallback,
} from 'react';
import type { PropsWithChildren } from 'react';
import apiClient from '../api/apiClient.js';

// --- Types ---
type LoginCredentials = {
  email: string;
  password: string;
};

interface User {
  id: string;
  name: string;
  email: string;
  role: string;
}

interface AuthContextType {
  user: User | null;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => Promise<void>;
  isLoading: boolean;
  isAuthenticated: boolean;
}

// --- Context ---
const AuthContext = createContext<AuthContextType | undefined>(undefined);

// --- Provider Component ---
export const AuthProvider = ({ children }: PropsWithChildren) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  const checkAuthStatus = useCallback(async () => {
    setIsLoading(true);
    try {
      // Este endpoint ahora existe y funciona gracias a los pasos anteriores
      const response = await apiClient.get('/auth/me');
      setUser(response.data.data);
    } catch (error) {
      setUser(null);
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    // Activamos la comprobaci√≥n de la sesi√≥n al cargar la app
    checkAuthStatus();
  }, [checkAuthStatus]);

  const login = async (credentials: LoginCredentials) => {
    const response = await apiClient.post('/auth/login', credentials);
    setUser(response.data.data);
  };

  const logout = async () => {
    await apiClient.post('/auth/logout');
    setUser(null);
  };

  const value: AuthContextType = {
    user,
    login,
    logout,
    isLoading,
    isAuthenticated: !!user,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

// --- Custom Hook ---
export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};


// ====== [25] packages/client/src/router/components.tsx ======
// filename: packages/client/src/router/components.tsx
// version: 1.6.5 (Add navigation link to Product Catalog page)
import { AppShell, Burger, Group, NavLink, Title, Button, Indicator, ActionIcon, Popover, Text, Stack } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { Navigate, Outlet, Link, useNavigate } from 'react-router-dom';
import { useAuth } from '../providers/AuthProvider.js';
import { useEffect, useState } from 'react';
import apiClient from '../api/apiClient.js';

// --- Tipos para la notificaci√≥n ---
interface Notification {
  id: string;
  message: string;
  visitId: string | null;
  isRead: boolean;
}

// --- Componente de Notificaciones (la campana y su l√≥gica) ---
const NotificationBell = () => {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const [popoverOpened, setPopoverOpened] = useState(false);
  const navigate = useNavigate();

  const fetchNotifications = async () => {
    try {
      const response = await apiClient.get<{ success: boolean; data: Notification[] }>('/notifications');
      setNotifications(response.data.data);
    } catch (error) {
      console.error('Failed to fetch notifications', error);
    }
  };

  useEffect(() => {
    fetchNotifications();
    const interval = setInterval(fetchNotifications, 60000);
    return () => clearInterval(interval);
  }, []);

  const handleNotificationClick = async (notification: Notification) => {
    if (!notification.isRead) {
      setNotifications(current =>
        current.map(n =>
          n.id === notification.id ? { ...n, isRead: true } : n
        )
      );
      try {
        await apiClient.post(`/notifications/${notification.id}/read`);
      } catch (error) {
        console.error('Failed to mark notification as read', error);
        fetchNotifications();
      }
    }
    
    if (notification.visitId) {
      navigate(`/visits/${notification.visitId}`);
    }
    
    setPopoverOpened(false);
  };
  
  const hasUnread = notifications.some(n => !n.isRead);

  return (
    <Popover opened={popoverOpened} onChange={setPopoverOpened} width={300} position="bottom-end" withArrow shadow="md">
      <Popover.Target>
        <Indicator color="red" disabled={!hasUnread} withBorder processing>
          <ActionIcon variant="default" size="lg" onClick={() => setPopoverOpened((o) => !o)}>
            üîî
          </ActionIcon>
        </Indicator>
      </Popover.Target>

      <Popover.Dropdown>
        <Stack>
          <Text fw={500}>Notificaciones</Text>
          {notifications.length > 0 ? (
            notifications.map(notification => (
              <Text
                key={notification.id}
                size="sm"
                onClick={() => handleNotificationClick(notification)}
                style={{
                  cursor: 'pointer',
                  padding: '5px',
                  borderRadius: '4px',
                  fontWeight: notification.isRead ? 400 : 700,
                  color: notification.isRead ? 'gray' : 'black',
                }}
                onMouseEnter={(e) => e.currentTarget.style.backgroundColor = '#f1f3f5'}
                onMouseLeave={(e) => e.currentTarget.style.backgroundColor = 'transparent'}
              >
                {notification.message}
              </Text>
            ))
          ) : (
            <Text size="sm" c="dimmed">No hay notificaciones pendientes.</Text>
          )}
        </Stack>
      </Popover.Dropdown>
    </Popover>
  );
};


/**
 * Componente de layout principal para las p√°ginas autenticadas.
 */
export const AppLayout = () => {
  const [opened, { toggle }] = useDisclosure();
  const { user, logout } = useAuth();
  const navigate = useNavigate();

  const handleLogout = async () => {
    await logout();
    navigate('/login');
  };

  return (
    <AppShell
      header={{ height: 60 }}
      navbar={{ width: 300, breakpoint: 'sm', collapsed: { mobile: !opened } }}
      padding="md"
    >
      <AppShell.Header>
        <Group h="100%" px="md" justify="space-between">
          <Group>
            <Burger opened={opened} onClick={toggle} hiddenFrom="sm" size="sm" />
            <Title order={3}>Pool Control Professional</Title>
          </Group>
          <Group>
            {user?.role === 'ADMIN' && <NotificationBell />}
            <Button variant="light" onClick={handleLogout}>Cerrar Sesi√≥n</Button>
          </Group>
        </Group>
      </AppShell.Header>

      <AppShell.Navbar p="md">
        <NavLink
          component={Link}
          to="/"
          label="Dashboard"
          onClick={toggle}
        />
        
        {/* Enlaces solo para el rol ADMIN */}
        {user?.role === 'ADMIN' && (
          <>
            <NavLink
              component={Link}
              to="/planner"
              label="Planificador"
              onClick={toggle}
            />
            <NavLink
              component={Link}
              to="/clients"
              label="Clientes"
              onClick={toggle}
            />
            <NavLink
              component={Link}
              to="/incidents-history"
              label="Historial de Incidencias"
              onClick={toggle}
            />
            <NavLink label="Cat√°logos" defaultOpened>
              <NavLink 
                component={Link} 
                to="/catalog/parameters" 
                label="Par√°metros" 
                onClick={toggle} 
              />
              <NavLink 
                component={Link} 
                to="/catalog/tasks" 
                label="Tareas" 
                onClick={toggle} 
              />
              <NavLink 
                component={Link} 
                to="/catalog/products" 
                label="Productos" 
                onClick={toggle} 
              />
            </NavLink>
          </>
        )}

        {/* Enlaces solo para el rol TECHNICIAN */}
        {user?.role === 'TECHNICIAN' && (
          <NavLink
            component={Link}
            to="/my-route"
            label="Mi Ruta de Hoy"
            onClick={toggle}
          />
        )}

        {/* Enlaces solo para el rol SUPER_ADMIN */}
        {user?.role === 'SUPER_ADMIN' && (
           <NavLink 
              component={Link} 
              to="/superadmin/tenants" 
              label="Gesti√≥n de Tenants" 
              onClick={toggle} 
            />
        )}
      </AppShell.Navbar>

      <AppShell.Main>
        <Outlet />
      </AppShell.Main>
    </AppShell>
  );
};

/**
 * Componente que protege rutas gen√©ricas de usuarios no autenticados.
 */
export const ProtectedRoute = () => {
  const { isAuthenticated, isLoading } = useAuth();
  if (isLoading) return <div>Cargando...</div>;
  if (!isAuthenticated) return <Navigate to="/login" replace />;
  return <Outlet />;
};

/**
 * Componente que protege rutas espec√≠ficas para el rol SUPER_ADMIN.
 */
export const SuperAdminRoute = () => {
  const { user, isLoading } = useAuth();
  if (isLoading) return <div>Cargando...</div>;
  if (user?.role !== 'SUPER_ADMIN') return <Navigate to="/" replace />;
  return <Outlet />;
};

/**
 * Componente que protege rutas espec√≠ficas para los roles ADMIN y SUPER_ADMIN.
 */
export const AdminRoute = () => {
  const { user, isLoading } = useAuth();
  if (isLoading) return <div>Cargando...</div>;
  if (user?.role !== 'ADMIN' && user?.role !== 'SUPER_ADMIN') {
    return <Navigate to="/" replace />;
  }
  return <Outlet />;
};

/**
 * Componente que protege rutas espec√≠ficas para el rol TECHNICIAN.
 */
export const TechnicianRoute = () => {
  const { user, isLoading } = useAuth();
  if (isLoading) return <div>Cargando...</div>;
  if (user?.role !== 'TECHNICIAN') {
    return <Navigate to="/" replace />;
  }
  return <Outlet />;
};


// ====== [26] packages/client/src/router/index.tsx ======
// filename: packages/client/src/router/index.tsx
// Version: 1.9.0 (Add route for IncidentDetailPage)
import { createBrowserRouter } from 'react-router-dom';
import { LoginPage } from '../features/auth/pages/LoginPage.js';
import { TenantsPage } from '../features/superadmin/pages/TenantsPage.js';
import { ParameterCatalogPage } from '../features/admin/pages/ParameterCatalogPage.js';
import { TaskCatalogPage } from '../features/admin/pages/TaskCatalogPage.js';
import { ProductCatalogPage } from '../features/admin/pages/ProductCatalogPage.js';
import { ClientsPage } from '../features/admin/pages/clients/ClientsPage.js';
import { ClientDetailPage } from '../features/admin/pages/clients/ClientDetailPage.js';
import { PoolDetailPage } from '../features/admin/pages/pools/PoolDetailPage.js';
import { PlannerPage } from '../features/admin/pages/planner/PlannerPage.js';
import { MyRoutePage } from '../features/technician/pages/MyRoutePage.js';
import { WorkOrderPage } from '../features/technician/pages/WorkOrderPage.js';
import { AdminDashboard } from '../features/admin/pages/AdminDashboard.js';
import { IncidentsHistoryPage } from '../features/admin/pages/IncidentsHistoryPage.js';
import { IncidentDetailPage } from '../features/admin/pages/incidents/IncidentDetailPage.js'; // <-- 1. Importar la nueva p√°gina
import { useAuth } from '../providers/AuthProvider.js';
import {
  AppLayout,
  ProtectedRoute,
  SuperAdminRoute,
  AdminRoute,
  TechnicianRoute,
} from './components.js';

// --- Componente Despachador de Dashboard ---
// Este componente decide qu√© p√°gina principal mostrar seg√∫n el rol del usuario.
const RoleBasedDashboard = () => {
  const { user } = useAuth();

  switch (user?.role) {
    case 'ADMIN':
      return <AdminDashboard />;
    case 'TECHNICIAN':
      return <MyRoutePage />;
    case 'SUPER_ADMIN':
      return <TenantsPage />;
    default:
      return <div>Bienvenido.</div>;
  }
};


export const router = createBrowserRouter([
  {
    path: '/login',
    element: <LoginPage />,
  },
  {
    path: '/',
    element: <ProtectedRoute />,
    children: [
      {
        element: <AppLayout />,
        children: [
          {
            index: true,
            element: <RoleBasedDashboard />,
          },
          // --- Secci√≥n de SuperAdmin ---
          {
            path: 'superadmin',
            element: <SuperAdminRoute />,
            children: [
              {
                path: 'tenants',
                element: <TenantsPage />,
              },
            ],
          },
          // --- Secci√≥n de Administraci√≥n ---
          {
            path: 'planner',
            element: <AdminRoute />,
            children: [
              {
                index: true,
                element: <PlannerPage />,
              },
            ],
          },
          {
            path: 'clients',
            element: <AdminRoute />,
            children: [
              {
                index: true,
                element: <ClientsPage />,
              },
              {
                path: ':id', 
                element: <ClientDetailPage />,
              },
            ],
          },
          {
            path: 'pools/:id', 
            element: <AdminRoute />,
            children: [
              {
                index: true,
                element: <PoolDetailPage />
              }
            ]
          },
          {
            path: 'incidents-history',
            element: <AdminRoute />,
            children: [
              {
                index: true,
                element: <IncidentsHistoryPage />,
              },
            ],
          },
          // --- NUEVA RUTA PARA EL DETALLE DE INCIDENCIA ---
          {
            path: 'incidents/:notificationId',
            element: <AdminRoute />,
            children: [
              {
                index: true,
                element: <IncidentDetailPage />,
              }
            ]
          },
          {
            path: 'catalog',
            element: <AdminRoute />,
            children: [
              {
                path: 'parameters',
                element: <ParameterCatalogPage />,
              },
              {
                path: 'tasks',
                element: <TaskCatalogPage />,
              },
              {
                path: 'products',
                element: <ProductCatalogPage />,
              },
            ],
          },
          // --- Secci√≥n de T√©cnico ---
          {
            path: 'my-route',
            element: <TechnicianRoute />,
            children: [
              {
                index: true,
                element: <MyRoutePage />,
              },
            ],
          },
          {
            path: 'visits/:visitId',
            element: <ProtectedRoute />,
            children: [
              {
                index: true,
                element: <WorkOrderPage />,
              },
            ],
          },
        ],
      },
    ],
  },
]);


// ====== [27] packages/client/src/styles/theme.ts ======
import { createTheme } from '@mantine/core';
import type { MantineColorsTuple } from '@mantine/core';

// Definimos una paleta de colores personalizada para nuestra marca.
// Puedes generar las tuyas en https://mantine.dev/colors-generator/
const brandBlue: MantineColorsTuple = [
  '#e7f5ff',
  '#d0ebff',
  '#a5d8ff',
  '#74c0fc',
  '#4dabf7',
  '#339af0',
  '#228be6',
  '#1c7ed6',
  '#1572c3',
  '#1068b1',
];

export const theme = createTheme({
  fontFamily: 'Inter, sans-serif',
  primaryColor: 'brandBlue',

  colors: {
    brandBlue,
  },

  headings: {
    fontFamily: 'Inter, sans-serif',
  },
});


// ====== [28] packages/client/tsconfig.json ======
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "allowJs": false,
    "skipLibCheck": true,
    "esModuleInterop": false,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}


// ====== [29] packages/client/tsconfig.node.json ======
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}


// ====== [30] packages/client/vite.config.ts ======
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    // Configuramos un proxy para evitar problemas de CORS en desarrollo.
    // Todas las peticiones del frontend a '/api' ser√°n redirigidas
    // a nuestro servidor de backend en el puerto 3001.
    proxy: {
      '/api': {
        target: 'http://localhost:3001',
        changeOrigin: true,
      },
    },
  },
});


// ====== [31] packages/server/package.json ======
{
  "name": "@pool-control/server",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "main": "dist/server.js",
  "scripts": {
    "dev": "tsx watch src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate",
    "prisma:studio": "prisma studio",
    "db:seed": "tsx prisma/seed.ts"
  },
  "prisma": {
    "seed": "tsx prisma/seed.ts"
  },
  "dependencies": {
    "@prisma/client": "^5.15.0",
    "bcryptjs": "^2.4.3",
    "cloudinary": "^2.7.0",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "date-fns": "^4.1.0",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "jsonwebtoken": "^9.0.2",
    "ms": "^2.1.3"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cookie-parser": "^1.4.7",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.6",
    "@types/ms": "^0.7.34",
    "@types/node": "^20.14.2",
    "prisma": "^5.15.0",
    "tsx": "^4.15.4",
    "typescript": "^5.4.5"
  }
}


// ====== [32] packages/server/prisma/data/catalogs.ts ======
// filename: packages/server/prisma/data/catalogs.ts
// version: 1.0.1
// description: Datos de semilla para los cat√°logos de Par√°metros y Tareas de "Piscival S.L.".

import type { InputType } from '@prisma/client';

/**
 * Define la librer√≠a central de todos los servicios (mediciones y acciones).
 * Se especifica el tipo InputType para cumplir con la validaci√≥n estricta de Prisma.
 */

// --- CAT√ÅLOGO DE PAR√ÅMETROS A MEDIR ---
export const parameterData: { name: string; unit?: string | null; type: InputType; selectOptions?: string[] }[] = [
  // Par√°metros Qu√≠micos Esenciales (Tipo NUMBER)
  { name: 'Nivel de pH', unit: 'pH', type: 'NUMBER' },
  { name: 'Cloro Libre (DPD-1)', unit: 'ppm', type: 'NUMBER' },
  { name: 'Cloro Total (DPD-3)', unit: 'ppm', type: 'NUMBER' },
  { name: 'Alcalinidad Total (TA)', unit: 'ppm', type: 'NUMBER' },
  { name: 'Dureza C√°lcica (TH)', unit: 'ppm', type: 'NUMBER' },
  { name: '√Åcido Cian√∫rico (Estabilizante)', unit: 'ppm', type: 'NUMBER' },
  { name: 'Nivel de Sal (para piscinas de sal)', unit: 'ppm', type: 'NUMBER' },

  // Par√°metros F√≠sicos (Tipo NUMBER)
  { name: 'Temperatura del Agua', unit: '¬∞C', type: 'NUMBER' },
  { name: 'Presi√≥n del Filtro', unit: 'bar', type: 'NUMBER' },

  // Par√°metros de Observaci√≥n (Tipos SELECT y BOOLEAN para probar la UI)
  {
    name: 'Estado del Agua',
    type: 'SELECT',
    selectOptions: ['Cristalina', 'Ligeramente turbia', 'Muy turbia', 'Verde', 'Blanquecina'],
  },
  {
    name: 'Nivel del Agua en Skimmer',
    type: 'SELECT',
    selectOptions: ['Correcto', 'Alto', 'Bajo'],
  },
  {
    name: 'Fondo de la piscina limpio',
    type: 'BOOLEAN',
  },
];

// --- CAT√ÅLOGO DE TAREAS A REALIZAR ---
export const taskData = [
  // Tareas de Limpieza Rutinaria
  {
    name: 'Limpieza de cestos de skimmers',
    description: 'Vaciar y limpiar los cestos de los skimmers de hojas y otros residuos.',
  },
  {
    name: 'Limpieza de cesto de bomba',
    description: 'Vaciar y limpiar el pre-filtro de la bomba para asegurar un buen flujo.',
  },
  {
    name: 'Pasar limpiafondos manual',
    description: 'Aspirar el fondo de la piscina manualmente para recoger la suciedad sedimentada.',
  },
  {
    name: 'Cepillado de paredes y l√≠nea de flotaci√≥n',
    description: 'Cepillar las superficies para prevenir la adhesi√≥n de algas y dep√≥sitos calc√°reos.',
  },

  // Tareas de Mantenimiento T√©cnico
  {
    name: 'Contralavado de filtro (Backwash)',
    description: 'Realizar un backwash completo del sistema de filtraci√≥n seguido de un enjuague.',
  },
  {
    name: 'Revisi√≥n y ajuste de dosificadores autom√°ticos',
    description: 'Comprobar el funcionamiento de bombas dosificadoras de pH y cloro.',
  },
  {
    name: 'Revisi√≥n de clorador salino',
    description: 'Verificar la producci√≥n de cloro y el estado de la c√©lula del clorador salino.',
  },
  {
    name: 'Comprobaci√≥n visual de fugas en local t√©cnico',
    description: 'Inspeccionar tuber√≠as, bomba y filtro en busca de goteos o fugas de agua.',
  },
  
  // Tareas de Adici√≥n de Productos (para futuro control de stock)
  {
    name: 'A√±adir producto alguicida',
    description: 'Dosificar la cantidad necesaria de alguicida preventivo.',
  },
  {
    name: 'A√±adir producto floculante',
    description: 'Dosificar floculante para ayudar a clarificar el agua si es necesario.',
  },
];


// ====== [33] packages/server/prisma/data/clients.ts ======
// filename: packages/server/prisma/data/clients.ts
// version: 1.0.0
// description: Datos de semilla para la cartera de clientes y sus piscinas de "Piscival S.L.".

/**
 * Define la cartera de clientes de la empresa de prueba.
 * Cada cliente tiene un array de piscinas asociadas. Esta estructura anidada
 * facilita la creaci√≥n de ambas entidades y sus relaciones en el script de seed.
 * La variedad de clientes (comunidad, chalet, hotel, gimnasio) y piscinas
 * (cloro/sal, tama√±o, ubicaci√≥n) permite probar m√∫ltiples escenarios.
 */
export const clientsData = [
  // --- Cliente 1: Comunidad de Propietarios (M√∫ltiples piscinas) ---
  {
    client: {
      name: 'Comunidad de Propietarios "El Oasis"',
      contactPerson: 'Sr. Garc√≠a (Presidente)',
      email: 'comunidad.oasis@email.com',
      phone: '611223344',
      address: 'Calle de la Concordia, 1, 28080 Madrid',
      priceModifier: 1.0,
    },
    pools: [
      {
        name: 'Piscina Comunitaria Grande',
        address: 'Calle de la Concordia, 1, Zonas Comunes, 28080 Madrid',
        volume: 150,
        type: 'Cloro',
      },
      {
        name: 'Piscina Infantil',
        address: 'Calle de la Concordia, 1, Zona Infantil, 28080 Madrid',
        volume: 25,
        type: 'Cloro',
      },
    ],
  },

  // --- Cliente 2: Chalet Privado (Piscina de Sal) ---
  {
    client: {
      name: 'Chalet "Villa Sol"',
      contactPerson: 'Familia P√©rez-L√≥pez',
      email: 'perez.lopez.familia@email.com',
      phone: '655667788',
      address: 'Avenida de la Brisa, 45, Urbanizaci√≥n Mirasierra, 28035 Madrid',
      priceModifier: 1.1, // Cliente premium, paga un 10% m√°s
    },
    pools: [
      {
        name: 'Piscina Privada con Jacuzzi',
        address: 'Avenida de la Brisa, 45, 28035 Madrid',
        volume: 75,
        type: 'Sal',
      },
    ],
  },

  // --- Cliente 3: Hotel (Gran volumen, uso intensivo) ---
  {
    client: {
      name: 'Hotel "Costa Serena"',
      contactPerson: 'Dpto. de Mantenimiento',
      email: 'mantenimiento@costaserena-hotel.com',
      phone: '911223344',
      address: 'Paseo del Relax, 2, 28010 Madrid',
      priceModifier: 0.95, // Cliente grande con descuento del 5%
    },
    pools: [
      {
        name: 'Piscina Exterior Principal',
        address: 'Paseo del Relax, 2, Zona de Jardines, 28010 Madrid',
        volume: 250,
        type: 'Cloro',
      },
    ],
  },

  // --- Cliente 4: Gimnasio (Piscina interior, "problem√°tica") ---
  {
    client: {
      name: 'Gimnasio "Fisic-Center"',
      contactPerson: 'Gerencia',
      email: 'gerencia@fisic-center.es',
      phone: '918765432',
      address: 'Calle del M√∫sculo, 12, 28020 Madrid',
      priceModifier: 1.0,
    },
    pools: [
      {
        name: 'Piscina Climatizada Interior',
        address: 'Calle del M√∫sculo, 12, S√≥tano, 28020 Madrid',
        volume: 100,
        type: 'Cloro', // Las piscinas interiores con cloro suelen generar cloraminas (olor a cloro)
      },
    ],
  },
];


// ====== [34] packages/server/prisma/data/incident-tasks.ts ======
// filename: packages/server/prisma/data/incident-tasks.ts
// version: 1.0.0
// description: Datos de semilla para las Tareas de Incidencia (Ticketing).

import { IncidentPriority, IncidentTaskStatus } from '@prisma/client';
import { addDays, subDays } from 'date-fns';

const today = new Date();
const tomorrow = addDays(today, 1);
const yesterday = subDays(today, 1);
const nextWeek = addDays(today, 7);

/**
 * Define un conjunto de tareas de incidencia de prueba.
 * Cada objeto tiene una propiedad 'notificationMessage' que usaremos en el script
 * de seed para encontrar la notificaci√≥n padre correcta a la que asociar la tarea.
 */
export const incidentTasksData = [
  {
    // Tarea para la incidencia CR√çTICA de la fuga. Es urgente y ya est√° en progreso.
    notificationMessage: 'Fuga de agua detectada en la tuber√≠a principal del skimmer.',
    task: {
      title: 'Contactar a fontanero para presupuesto de reparaci√≥n de fuga',
      description: 'Llamar a Fontaner√≠a Express (91 123 45 67) y pedir presupuesto urgente. Mencionar que es para la Comunidad "El Oasis".',
      priority: 'CRITICAL' as IncidentPriority,
      status: 'IN_PROGRESS' as IncidentTaskStatus,
      deadline: tomorrow, // Plazo para ma√±ana
      // La asignaci√≥n se har√° en el script de seed.
    },
  },
  {
    // Tarea secundaria para la misma incidencia de la fuga.
    notificationMessage: 'Fuga de agua detectada en la tuber√≠a principal del skimmer.',
    task: {
      title: 'Cerrar llave de paso del skimmer afectado',
      description: 'Para minimizar la p√©rdida de agua hasta que venga el fontanero, cerrar la llave de paso correspondiente en el local t√©cnico.',
      priority: 'HIGH' as IncidentPriority,
      status: 'COMPLETED' as IncidentTaskStatus,
      resolutionNotes: 'Llave de paso cerrada a las 10:30. Ya no gotea. Se ha informado al presidente.',
      // La asignaci√≥n se har√° en el script de seed.
    },
  },
  {
    // Tarea para la incidencia de falta de sal.
    notificationMessage: 'El nivel de sal es bajo, pero no hay producto en el almac√©n. Avisar para reponer.',
    task: {
      title: 'Comprar sacos de sal para el almac√©n',
      description: 'Ir al proveedor habitual (PRO-PISCINAS) y comprar 5 sacos de sal especial para clorador. Guardar factura.',
      priority: 'NORMAL' as IncidentPriority,
      status: 'PENDING' as IncidentTaskStatus,
      deadline: nextWeek, // Plazo de una semana
      // La asignaci√≥n se har√° en el script de seed.
    },
  },
  {
    // Tarea para la incidencia del ruido de la bomba de calor. Plazo vencido.
    notificationMessage: 'La bomba de calor hace un ruido met√°lico muy fuerte al arrancar.',
    task: {
      title: 'Revisar rodamientos de la bomba de calor',
      description: 'Desmontar la carcasa y verificar si los rodamientos del motor tienen holgura o est√°n oxidados. Engrasar si es posible.',
      priority: 'HIGH' as IncidentPriority,
      status: 'PENDING' as IncidentTaskStatus, // Sigue pendiente
      deadline: yesterday, // El plazo era para ayer, por lo que est√° VENCIDA.
      // La asignaci√≥n se har√° en el script de seed.
    },
  },
];


// ====== [35] packages/server/prisma/data/products.ts ======
// filename: packages/server/prisma/data/products.ts
// version: 1.0.0
// description: Datos de semilla para el cat√°logo de productos de "Piscival S.L.".

export const productData = [
  // --- Desinfectantes ---
  {
    name: 'Hipoclorito S√≥dico 15%',
    description: 'Cloro l√≠quido para desinfecci√≥n de choque y mantenimiento.',
    unit: 'L', // Litros
    cost: 1.20,
  },
  {
    name: 'Cloro Granulado (Dicloro 55%)',
    description: 'Cloro de disoluci√≥n r√°pida para tratamientos de choque.',
    unit: 'Kg', // Kilogramos
    cost: 8.50,
  },
  {
    name: 'Pastillas Multiacci√≥n 250g',
    description: 'Pastillas de cloro de disoluci√≥n lenta con acci√≥n desinfectante, alguicida y floculante.',
    unit: 'Unidad', // Por pastilla
    cost: 2.75,
  },

  // --- Reguladores de pH ---
  {
    name: 'Reductor de pH L√≠quido',
    description: '√Åcido sulf√∫rico para bajar el nivel de pH del agua.',
    unit: 'L',
    cost: 2.10,
  },
  {
    name: 'Incrementador de pH S√≥lido',
    description: 'Producto en polvo para subir el nivel de pH del agua.',
    unit: 'Kg',
    cost: 4.50,
  },

  // --- Productos Espec√≠ficos y de Mantenimiento ---
  {
    name: 'Alguicida Concentrado',
    description: 'Tratamiento preventivo y de choque contra todo tipo de algas.',
    unit: 'L',
    cost: 9.70,
  },
  {
    name: 'Floculante L√≠quido Clarificante',
    description: 'Agrupa las part√≠culas en suspensi√≥n para mejorar la filtraci√≥n y dar transparencia al agua.',
    unit: 'L',
    cost: 5.80,
  },
  {
    name: 'Sal para Piscinas (Saco)',
    description: 'Sal especial para equipos de cloraci√≥n salina.',
    unit: 'Saco 25Kg',
    cost: 12.50,
  },
];


// ====== [36] packages/server/prisma/data/users.ts ======
// filename: packages/server/prisma/data/users.ts
// version: 1.0.1
// description: Datos de semilla para los usuarios del tenant de prueba "Piscival S.L.".

import type { UserRole } from '@prisma/client';

/**
 * Define los usuarios que se crear√°n para el tenant principal de prueba.
 * Se especifica el tipo UserRole para cumplir con la validaci√≥n estricta de Prisma.
 */
export const usersData: { name: string; email: string; password: string; role: UserRole }[] = [
  // --- ROL: Administradora ---
  {
    name: 'Isa Gestora',
    email: 'admin@piscival.com',
    password: 'password123',
    role: 'ADMIN',
  },

  // --- ROL: T√©cnicos de Campo ---
  {
    name: 'Carlos T√©cnico',
    email: 'carlos.t@piscival.com',
    password: 'password123',
    role: 'TECHNICIAN',
  },
  {
    name: 'Ana T√©cnica',
    email: 'ana.t@piscival.com',
    password: 'password123',
    role: 'TECHNICIAN',
  },
  {
    name: 'Leo Ayudante',
    email: 'leo.a@piscival.com',
    password: 'password123',
    role: 'TECHNICIAN',
  },

  // --- ROL: Gerencia/Supervisor (para futuras funcionalidades) ---
  {
    name: 'Jorge Supervisor',
    email: 'manager@piscival.com',
    password: 'password123',
    role: 'MANAGER',
  },
];


// ====== [37] packages/server/prisma/seed.ts ======
// filename: packages/server/prisma/seed.ts
// version: 3.4.2 (FIXED - Removed redundant deleteMany calls)
// description: Versi√≥n corregida que elimina la limpieza inicial para ser compatible con `prisma migrate reset`.

import { PrismaClient } from '@prisma/client';
import type { Frequency, ParameterTemplate, ScheduledTaskTemplate, User, Pool, Product } from '@prisma/client';
import { hashPassword } from '../src/utils/password.utils.js';
import { subDays, addDays } from 'date-fns';

// --- Importaci√≥n de los datos modulares ---
import { usersData } from './data/users.js';
import { parameterData, taskData } from './data/catalogs.js';
import { clientsData } from './data/clients.js';
import { productData } from './data/products.js';
import { incidentTasksData } from './data/incident-tasks.js';

const prisma = new PrismaClient();

// --- Funciones de ayuda ---
const getRandomItems = <T>(arr: T[], count: number): T[] => {
  if (arr.length < count) {
    throw new Error(`No se pueden obtener ${count} elementos de un array con solo ${arr.length} elementos.`);
  }
  const shuffled = [...arr].sort(() => 0.5 - Math.random());
  return shuffled.slice(0, count);
};

// --- Script Principal ---
async function main() {
  console.log('üå± Empezando el proceso de seeding para la demo...');

  // La limpieza de la base de datos la realiza el comando `prisma migrate reset`.
  // No es necesario (y es problem√°tico) hacerlo aqu√≠ de nuevo.

  // 1. --- CREACI√ìN DE ENTIDADES DEL SISTEMA ---
  const systemTenant = await prisma.tenant.create({
    data: { companyName: 'SYSTEM_INTERNAL', subdomain: 'system', subscriptionStatus: 'ACTIVE' },
  });
  const superAdminPassword = await hashPassword('superadmin123');
  await prisma.user.create({
    data: { email: 'super@admin.com', name: 'Super Admin', password: superAdminPassword, role: 'SUPER_ADMIN', tenantId: systemTenant.id },
  });
  console.log('üëë SuperAdmin y Tenant del sistema creados.');

  // 2. --- CREACI√ìN DEL TENANT DE PRUEBA Y USUARIOS ---
  const mainTenant = await prisma.tenant.create({
    data: { companyName: 'Piscival S.L.', subdomain: 'piscival', subscriptionStatus: 'ACTIVE' },
  });
  console.log(`\nüè¢ Tenant de prueba creado: ${mainTenant.companyName}`);
  
  const createdUsers: User[] = [];
  for (const userData of usersData) {
    const hashedPassword = await hashPassword(userData.password);
    const user = await prisma.user.create({ data: { ...userData, password: hashedPassword, tenantId: mainTenant.id } });
    createdUsers.push(user);
    console.log(`   üë§ Usuario creado: ${userData.name} (${userData.role})`);
  }
  const adminUser = createdUsers.find(u => u.role === 'ADMIN');
  const technicians = createdUsers.filter(u => u.role === 'TECHNICIAN');
  if (!adminUser || technicians.length < 3) throw new Error('Seeding fallido: No se encontraron suficientes usuarios admin o t√©cnicos.');

  // 3. --- CREACI√ìN DE CAT√ÅLOGOS ---
  const createdParams = await prisma.parameterTemplate.createManyAndReturn({ data: parameterData.map(p => ({ ...p, tenantId: mainTenant.id })) });
  console.log(`\nüìä Creados ${createdParams.length} par√°metros en el cat√°logo de Par√°metros.`);
  const createdTasks = await prisma.scheduledTaskTemplate.createManyAndReturn({ data: taskData.map(t => ({ ...t, tenantId: mainTenant.id })) });
  console.log(`üìã Creadas ${createdTasks.length} tareas en el cat√°logo de Tareas.`);
  
  const createdProducts: Product[] = [];
  for (const prodData of productData) {
      const product = await prisma.product.create({ data: { ...prodData, tenantId: mainTenant.id }});
      createdProducts.push(product);
  }
  console.log(`üì¶ Creados ${createdProducts.length} productos en el cat√°logo de Productos.`);

  // 4. --- CREACI√ìN DE CLIENTES Y PISCINAS ---
  const allPools: Pool[] = [];
  for (const data of clientsData) {
    const client = await prisma.client.create({ data: { ...data.client, tenantId: mainTenant.id } });
    console.log(`\nüë®‚Äçüíº Cliente creado: ${client.name}`);
    for (const poolData of data.pools) {
      const pool = await prisma.pool.create({ data: { ...poolData, clientId: client.id, tenantId: mainTenant.id } });
      allPools.push(pool);
      console.log(`   üèä Piscina creada: ${pool.name}`);
      const configsToCreate = createPoolMaintenanceSheet(pool.id, createdParams, createdTasks, poolData.type);
      await prisma.poolConfiguration.createMany({ data: configsToCreate, skipDuplicates: true });
      console.log(`      üìù Ficha de mantenimiento creada para ${pool.name} con ${configsToCreate.length} √≠tems.`);
    }
  }
  if (allPools.length < 5) throw new Error('Seeding fallido: No se crearon suficientes piscinas.');

  // 5. --- SIMULACI√ìN DE ACTIVIDAD RECIENTE ---
  console.log('\n‚öôÔ∏è  Simulando escenario de demo...');
  const today = new Date();
  const threeDaysAgo = subDays(today, 3);
  const tomorrow = addDays(today, 1);
  
  await prisma.visit.create({ data: { timestamp: today, poolId: allPools[1]!.id, technicianId: technicians[0]!.id, status: 'PENDING' } });
  await prisma.visit.create({ data: { timestamp: today, poolId: allPools[3]!.id, technicianId: technicians[1]!.id, status: 'PENDING' } });
  console.log('   - 2 visitas PENDIENTES para hoy creadas.');

  const okVisit = await prisma.visit.create({ data: { timestamp: today, poolId: allPools[2]!.id, technicianId: technicians[1]!.id, status: 'COMPLETED', hasIncident: false, notes: 'Todo en orden. Valores perfectos. El cliente ha comentado que est√° muy contento con el servicio.', completedTasks: ['Limpieza de cestos de skimmers', 'Revisi√≥n de clorador salino'] } });
  await prisma.visitResult.createMany({ data: [ { visitId: okVisit.id, parameterName: 'Nivel de pH', value: '7.4', parameterUnit: 'pH' }, { visitId: okVisit.id, parameterName: 'Nivel de Sal (para piscinas de sal)', value: '4500', parameterUnit: 'ppm' } ] });
  const salProduct = createdProducts.find(p => p.name.includes('Sal para Piscinas'));
  if(salProduct) { await prisma.consumption.create({ data: { visitId: okVisit.id, productId: salProduct.id, quantity: 1 }}); }
  console.log('   - 1 visita COMPLETADA OK (con consumo de sal) creada.');
  
  const criticalVisitNotes = 'Fuga de agua detectada en la tuber√≠a principal del skimmer. Gotea constantemente, el nivel de la piscina ha bajado notablemente.';
  const criticalVisit = await prisma.visit.create({ data: { timestamp: threeDaysAgo, poolId: allPools[0]!.id, technicianId: technicians[0]!.id, status: 'COMPLETED', hasIncident: true, notes: criticalVisitNotes, completedTasks: ['Limpieza de cestos de skimmers'] } });
  await prisma.visitResult.createMany({ data: [ { visitId: criticalVisit.id, parameterName: 'Nivel del Agua en Skimmer', value: 'Bajo' }, { visitId: criticalVisit.id, parameterName: 'Nivel de pH', value: '7.9' }, ] });
  await prisma.notification.create({ data: { message: criticalVisitNotes, visitId: criticalVisit.id, tenantId: mainTenant.id, userId: adminUser.id, createdAt: threeDaysAgo, } });
  console.log('   - 1 incidencia CR√çTICA (de hace 3 d√≠as) creada.');

  const pendingVisitNotes = 'El nivel de sal es bajo, pero no hay producto en el almac√©n. Avisar para reponer.';
  const pendingVisit = await prisma.visit.create({ data: { timestamp: today, poolId: allPools[1]!.id, technicianId: technicians[1]!.id, status: 'COMPLETED', hasIncident: true, notes: pendingVisitNotes, completedTasks: ['Limpieza de cestos de skimmers'] } });
  await prisma.visitResult.createMany({ data: [{ visitId: pendingVisit.id, parameterName: 'Nivel de Sal (para piscinas de sal)', value: '3800', parameterUnit: 'ppm' }] });
  await prisma.notification.create({ data: { message: pendingVisitNotes, visitId: pendingVisit.id, tenantId: mainTenant.id, userId: adminUser.id, } });
  console.log('   - 1 incidencia PENDIENTE (de hoy) creada.');
  
  const classifiedVisitNotes = 'La bomba de calor hace un ruido met√°lico muy fuerte al arrancar. Podr√≠a romperse. Recomiendo no encenderla hasta que se revise.';
  const classifiedVisit = await prisma.visit.create({ data: { timestamp: today, poolId: allPools[4]!.id, technicianId: technicians[2]!.id, status: 'COMPLETED', hasIncident: true, notes: classifiedVisitNotes, completedTasks: ['Limpieza de cestos de skimmers', 'Cepillado de paredes y l√≠nea de flotaci√≥n'] } });
  await prisma.visitResult.createMany({ data: [ { visitId: classifiedVisit.id, parameterName: 'Temperatura del Agua', value: '24', parameterUnit: '¬∞C' }, { visitId: classifiedVisit.id, parameterName: 'Presi√≥n del Filtro', value: '1.5', parameterUnit: 'bar' }, ] });
  await prisma.notification.create({ data: { message: classifiedVisitNotes, visitId: classifiedVisit.id, tenantId: mainTenant.id, userId: adminUser.id, priority: 'HIGH',  resolutionDeadline: tomorrow, } });
  console.log('   - 1 incidencia PENDIENTE CLASIFICADA (Prioridad ALTA) creada.');

  // 6. --- SIMULACI√ìN DE TICKETING AVANZADO ---
  console.log('   - Creando tareas de incidencia y logs de auditor√≠a...');
  const allNotifications = await prisma.notification.findMany({ where: { tenantId: mainTenant.id } });
  let taskCount = 0;
  for (const taskSeed of incidentTasksData) {
    const parentNotification = allNotifications.find(n => n.message.includes(taskSeed.notificationMessage));
    if (!parentNotification) { console.warn(`   - ‚ö†Ô∏è  No se encontr√≥ la notificaci√≥n padre para la tarea: "${taskSeed.task.title}"`); continue; }
    
    const assignedUser = taskSeed.task.title.includes('Contactar') ? adminUser : technicians[taskCount % technicians.length];
    if (!assignedUser) continue;

    const taskData = { ...taskSeed.task, notificationId: parentNotification.id, assignedToId: assignedUser.id, tenantId: mainTenant.id };
    const createdTask = await prisma.incidentTask.create({ data: taskData });
    taskCount++;

    await prisma.incidentTaskLog.create({ data: { action: 'CREATION', details: `Tarea creada por ${adminUser.name}. Asignada a ${assignedUser.name}.`, incidentTaskId: createdTask.id, userId: adminUser.id, }});
    if (createdTask.status !== 'PENDING') {
      await prisma.incidentTaskLog.create({ data: { action: 'STATUS_CHANGE', details: `Estado cambiado a ${createdTask.status}.`, incidentTaskId: createdTask.id, userId: assignedUser.id, }});
    }
  }
  console.log(`     - ${taskCount} tareas de incidencia creadas con sus logs.`);


  console.log('\n\n‚úÖ Seeding de demostraci√≥n completado con √©xito!');
  console.log('--- Credenciales de prueba ---');
  console.log('SuperAdmin: super@admin.com / superadmin123');
  console.log('Admin:      admin@piscival.com / password123');
  console.log('T√©cnicos:   carlos.t@piscival.com, ana.t@piscival.com, leo.a@piscival.com (pass: password123)');
  console.log('Manager:    manager@piscival.com / password123');
}

function createPoolMaintenanceSheet(
  poolId: string,
  allParams: ParameterTemplate[],
  allTasks: ScheduledTaskTemplate[],
  poolType: string | null
): any[] {
  const configs: any[] = [];
  const commonParams = allParams.filter(p => ['Nivel de pH', 'Alcalinidad Total (TA)', 'Estado del Agua'].includes(p.name));
  for (const param of commonParams) {
    configs.push({ poolId, parameterTemplateId: param.id, frequency: 'SEMANAL' as Frequency, minThreshold: param.name.includes('pH') ? 7.2 : null, maxThreshold: param.name.includes('pH') ? 7.6 : null, });
  }
  const commonTasks = allTasks.filter(t => ['Limpieza de cestos de skimmers', 'Cepillado de paredes y l√≠nea de flotaci√≥n'].includes(t.name));
  for (const task of commonTasks) {
    configs.push({ poolId, taskTemplateId: task.id, frequency: 'SEMANAL' as Frequency });
  }
  const backwashTask = allTasks.find(t => t.name.includes('Contralavado'));
  if (backwashTask) {
    configs.push({ poolId, taskTemplateId: backwashTask.id, frequency: 'QUINCENAL' as Frequency });
  }
  if (poolType === 'Cloro') {
    const cloroParams = allParams.filter(p => p.name.includes('Cloro Libre') || p.name.includes('Cloro Total'));
    for (const param of cloroParams) {
      configs.push({ poolId, parameterTemplateId: param.id, frequency: 'SEMANAL' as Frequency });
    }
  } else if (poolType === 'Sal') {
    const salParam = allParams.find(p => p.name.includes('Nivel de Sal'));
    const salTask = allTasks.find(t => t.name.includes('Revisi√≥n de clorador salino'));
    if (salParam) { configs.push({ poolId, parameterTemplateId: salParam.id, frequency: 'MENSUAL' as Frequency }); }
    if (salTask) { configs.push({ poolId, taskTemplateId: salTask.id, frequency: 'QUINCENAL' as Frequency }); }
  }
  const availableExtraParams = allParams.filter(p => !configs.some(c => c.parameterTemplateId === p.id));
  if (availableExtraParams.length >= 2) {
    const extraParams = getRandomItems(availableExtraParams, 2);
    for (const param of extraParams) {
      configs.push({ poolId, parameterTemplateId: param.id, frequency: 'MENSUAL' as Frequency });
    }
  }
  return configs;
}

main().catch((e) => { console.error('‚ùå Error fatal durante el proceso de seeding:', e); process.exit(1); }).finally(async () => { await prisma.$disconnect(); });


// ====== [38] packages/server/src/api/auth/auth.controller.ts ======
import type { Response, NextFunction } from 'express';
import { register, login } from './auth.service.js';
import { signToken } from '../../utils/jwt.utils.js';
import config from '../../config/index.js';
import type { CookieOptions, Request } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';

const cookieOptions: CookieOptions = {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'lax',
  maxAge: config.JWT_EXPIRES_IN * 1000, // maxAge est√° en milisegundos
};

/**
 * Maneja la petici√≥n de registro de un nuevo usuario.
 */
export const registerHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const user = await register(req.body);
    res.status(201).json({
      success: true,
      data: user,
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la petici√≥n de login de un usuario.
 */
export const loginHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const user = await login(req.body);
    const token = signToken({ id: user.id, role: user.role });
    res.cookie('token', token, cookieOptions);
    res.status(200).json({
      success: true,
      data: user,
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n del usuario actualmente autenticado (a trav√©s del token).
 */
export const getMeHandler = (req: AuthRequest, res: Response) => {
  // El middleware 'protect' se ejecuta antes que este manejador.
  // Si llega hasta aqu√≠, significa que el token es v√°lido y 'req.user' existe.
  res.status(200).json({
    success: true,
    data: req.user,
  });
};


// ====== [39] packages/server/src/api/auth/auth.routes.ts ======
import { Router } from 'express';
import type { Response } from 'express';
import {
  registerHandler,
  loginHandler,
  getMeHandler,
} from './auth.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const authRouter = Router();

/**
 * @route   POST /api/auth/register
 * @desc    Registra un nuevo usuario
 * @access  Public
 */
authRouter.post('/register', registerHandler);

/**
 * @route   POST /api/auth/login
 * @desc    Inicia sesi√≥n y devuelve un token en una cookie
 * @access  Public
 */
authRouter.post('/login', loginHandler);

/**
 * @route   GET /api/auth/me
 * @desc    Obtiene los datos del usuario logueado a partir de su token
 * @access  Private
 */
authRouter.get('/me', protect, getMeHandler);

/**
 * @route   POST /api/auth/logout
 * @desc    Cierra la sesi√≥n del usuario eliminando la cookie
 * @access  Public
 */
authRouter.post('/logout', (_req, res: Response) => {
  res.cookie('token', '', {
    httpOnly: true,
    expires: new Date(0),
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
  });
  res.status(200).json({ success: true, message: 'Sesi√≥n cerrada con √©xito.' });
});

export default authRouter;


// ====== [40] packages/server/src/api/auth/auth.service.ts ======
import { PrismaClient } from '@prisma/client';
import type { User } from '@prisma/client';
import { hashPassword, comparePassword } from '../../utils/password.utils.js';

const prisma = new PrismaClient();

// Tipo para la entrada de datos del registro.
export type RegisterUserInput = Omit<User, 'id' | 'createdAt' | 'updatedAt'>;

// Tipo para la entrada de datos del login.
export type LoginUserInput = {
  email: string;
  password: string;
};

/**
 * Registra un nuevo usuario en la base de datos.
 * @param input - Datos del usuario para el registro.
 * @returns El objeto de usuario creado (sin la contrase√±a).
 */
export const register = async (input: RegisterUserInput) => {
  const { email, password, ...rest } = input;

  const existingUser = await prisma.user.findUnique({
    where: { email },
  });

  if (existingUser) {
    throw new Error('Ya existe un usuario con este correo electr√≥nico.');
  }

  const hashedPassword = await hashPassword(password);

  const user = await prisma.user.create({
    data: {
      email,
      password: hashedPassword,
      ...rest,
    },
    select: {
      id: true,
      email: true,
      name: true,
      role: true,
      tenantId: true,
      createdAt: true,
      updatedAt: true,
    },
  });

  return user;
};

/**
 * Valida las credenciales de un usuario para el login.
 * @param input - Email y contrase√±a del usuario.
 * @returns El objeto de usuario autenticado (sin la contrase√±a).
 */
export const login = async (input: LoginUserInput): Promise<Omit<User, 'password'>> => {
  const user = await prisma.user.findUnique({
    where: { email: input.email },
  });

  if (!user) {
    throw new Error('El email o la contrase√±a son incorrectos.');
  }

  const isPasswordValid = await comparePassword(input.password, user.password);

  if (!isPasswordValid) {
    throw new Error('El email o la contrase√±a son incorrectos.');
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const { password, ...userWithoutPassword } = user;

  return userWithoutPassword;
};


// ====== [41] packages/server/src/api/clients/clients.controller.ts ======
// filename: packages/server/src/api/clients/clients.controller.ts
// Version: 1.0.0 (Initial creation of the controller for Client management)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createClient,
  deleteClient,
  getClientById,
  getClientsByTenant,
  updateClient,
} from './clients.service.js';

/**
 * Maneja la creaci√≥n de un nuevo cliente.
 */
export const createClientHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acci√≥n no permitida.' });
    }

    const input = { ...req.body, tenantId };
    const newClient = await createClient(input);
    res.status(201).json({ success: true, data: newClient });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todos los clientes de un tenant.
 */
export const getClientsByTenantHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acci√≥n no permitida.' });
    }

    const clients = await getClientsByTenant(tenantId);
    res.status(200).json({ success: true, data: clients });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de un cliente espec√≠fico por ID.
 */
export const getClientByIdHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    const { id: clientId } = req.params;

    if (!tenantId) {
      return res.status(403).json({ message: 'Acci√≥n no permitida.' });
    }
    if (!clientId) {
      return res.status(400).json({ message: 'El ID del cliente es requerido.' });
    }

    const client = await getClientById(clientId, tenantId);
    if (!client) {
      return res.status(404).json({ message: 'Cliente no encontrado.' });
    }

    res.status(200).json({ success: true, data: client });
  } catch (error) {
    next(error);
  }
};


/**
 * Maneja la actualizaci√≥n de un cliente.
 */
export const updateClientHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID del cliente es requerido.' });
    }
    // TODO: Verificar que el cliente que se quiere editar pertenece al tenant del usuario logueado.
    
    const updatedClient = await updateClient(id, req.body);
    res.status(200).json({ success: true, data: updatedClient });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de un cliente.
 */
export const deleteClientHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID del cliente es requerido.' });
    }
    // TODO: Verificar que el cliente que se quiere eliminar pertenece al tenant del usuario logueado.

    await deleteClient(id);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [42] packages/server/src/api/clients/clients.routes.ts ======
// filename: packages/server/src/api/clients/clients.routes.ts
// Version: 1.0.0 (Initial creation of routes for Client management)
import { Router } from 'express';
import {
  createClientHandler,
  deleteClientHandler,
  getClientByIdHandler,
  getClientsByTenantHandler,
  updateClientHandler,
} from './clients.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const clientsRouter = Router();

// Aplicamos el middleware 'protect' a TODAS las rutas de este enrutador.
clientsRouter.use(protect);

// TODO: A√±adir un middleware de autorizaci√≥n para asegurar que el rol sea 'ADMIN'.

clientsRouter.route('/')
  .get(getClientsByTenantHandler)
  .post(createClientHandler);

clientsRouter.route('/:id')
  .get(getClientByIdHandler)
  .patch(updateClientHandler)
  .delete(deleteClientHandler);

export default clientsRouter;


// ====== [43] packages/server/src/api/clients/clients.service.ts ======
// filename: packages/server/src/api/clients/clients.service.ts
// Version: 1.0.0 (Initial creation of the service for Client management)
import { PrismaClient } from '@prisma/client';
import type { Client } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateClientInput = Omit<Client, 'id' | 'createdAt' | 'updatedAt'>;
export type UpdateClientInput = Partial<CreateClientInput>;

// --- Funciones del Servicio ---

/**
 * Crea un nuevo cliente para un tenant espec√≠fico.
 * @param data - Datos del nuevo cliente.
 * @returns El cliente creado.
 */
export const createClient = async (data: CreateClientInput): Promise<Client> => {
  return prisma.client.create({
    data,
  });
};

/**
 * Obtiene todos los clientes de un tenant espec√≠fico.
 * @param tenantId - El ID del tenant.
 * @returns Un array de clientes.
 */
export const getClientsByTenant = async (tenantId: string): Promise<Client[]> => {
  return prisma.client.findMany({
    where: { tenantId },
    orderBy: { name: 'asc' },
    // Incluimos las piscinas asociadas a cada cliente
    include: {
      pools: true,
    },
  });
};

/**
 * Obtiene un cliente espec√≠fico por su ID.
 * @param id - El ID del cliente a buscar.
 * @param tenantId - El ID del tenant para asegurar la pertenencia.
 * @returns El objeto del cliente o null si no se encuentra o no pertenece al tenant.
 */
export const getClientById = async (id: string, tenantId: string): Promise<Client | null> => {
  return prisma.client.findFirst({
    where: { id, tenantId },
     include: {
      pools: true,
    },
  });
};


/**
 * Actualiza un cliente existente.
 * @param id - El ID del cliente a actualizar.
 * @param data - Los datos a actualizar.
 * @returns El cliente actualizado.
 */
export const updateClient = async (id: string, data: UpdateClientInput): Promise<Client> => {
  return prisma.client.update({
    where: { id },
    data,
  });
};

/**
 * Elimina un cliente.
 * @param id - El ID del cliente a eliminar.
 * @returns El cliente que fue eliminado.
 */
export const deleteClient = async (id: string): Promise<Client> => {
  // Al borrar el cliente, se borrar√°n en cascada sus piscinas asociadas.
  return prisma.client.delete({
    where: { id },
  });
};


// ====== [44] packages/server/src/api/incident-tasks/incident-tasks.controller.ts ======
// filename: packages/server/src/api/incident-tasks/incident-tasks.controller.ts
// version: 1.2.1 (FIXED - Removed actorId from updateIncidentTask call)

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createIncidentTask,
  getTasksByNotificationId,
  updateIncidentTask,
  deleteIncidentTask,
  getTasksAssignedToUser,
  updateTaskStatus,
  addTaskLog,
  getTaskLogs,
} from './incident-tasks.service.js';

export const getMyAssignedTasksHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const userId = req.user?.id;
    if (!userId) { return res.status(401).json({ success: false, message: 'Usuario no autenticado.' }); }
    const tasks = await getTasksAssignedToUser(userId);
    res.status(200).json({ success: true, data: tasks });
  } catch (error) { next(error); }
};

export const createIncidentTaskHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const tenantId = req.user?.tenantId;
    const actorId = req.user?.id;
    if (!tenantId || !actorId) { return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' }); }

    const input = { ...req.body, tenantId };
    const newTask = await createIncidentTask(input, actorId);
    res.status(201).json({ success: true, data: newTask });
  } catch (error) { next(error); }
};

export const getTasksByNotificationHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) { return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' }); }
    const { notificationId } = req.params;
    if (!notificationId) { return res.status(400).json({ success: false, message: 'El ID de la notificaci√≥n es requerido.' }); }
    const tasks = await getTasksByNotificationId(notificationId, tenantId);
    res.status(200).json({ success: true, data: tasks });
  } catch (error) { next(error); }
};

export const updateIncidentTaskHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const { id } = req.params;
    if (!id) { return res.status(400).json({ success: false, message: 'El ID de la tarea es requerido.' }); }
    
    // --- CORRECCI√ìN: Se elimina el `actorId` de la llamada ---
    const updatedTask = await updateIncidentTask(id, req.body);
    res.status(200).json({ success: true, data: updatedTask });
  } catch (error) { next(error); }
};

export const deleteIncidentTaskHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const { id } = req.params;
    if (!id) { return res.status(400).json({ success: false, message: 'El ID de la tarea es requerido.' }); }
    await deleteIncidentTask(id);
    res.status(204).send();
  } catch (error) { next(error); }
};

export const updateTaskStatusHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
    try {
        const { id: taskId } = req.params;
        const actorId = req.user?.id;
        const { status, resolutionNotes } = req.body;
        if (!taskId) { return res.status(400).json({ success: false, message: 'El ID de la tarea es requerido.'}); }
        if (!actorId) { return res.status(401).json({ success: false, message: 'Usuario no autenticado.'}); }
        if (!status) { return res.status(400).json({ success: false, message: 'El estado es requerido.'}); }

        const updatedTask = await updateTaskStatus(taskId, actorId, status, resolutionNotes);
        res.status(200).json({ success: true, data: updatedTask });
    } catch (error) {
        next(error);
    }
};

export const addTaskLogHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
    try {
        const { id: taskId } = req.params;
        const actorId = req.user?.id;
        if (!taskId) { return res.status(400).json({ success: false, message: 'El ID de la tarea es requerido.'}); }
        if (!actorId) { return res.status(401).json({ success: false, message: 'Usuario no autenticado.'}); }
        
        const log = await addTaskLog(taskId, actorId, req.body);
        res.status(201).json({ success: true, data: log });
    } catch (error) {
        next(error);
    }
};

export const getTaskLogsHandler = async (req: AuthRequest, res: Response, next: NextFunction) => {
    try {
        const { id: taskId } = req.params;
        if (!taskId) { return res.status(400).json({ success: false, message: 'El ID de la tarea es requerido.'}); }
        
        const logs = await getTaskLogs(taskId);
        res.status(200).json({ success: true, data: logs });
    } catch (error) {
        next(error);
    }
};


// ====== [45] packages/server/src/api/incident-tasks/incident-tasks.routes.ts ======
// filename: packages/server/src/api/incident-tasks/incident-tasks.routes.ts
// version: 1.2.0 (Adds status, log, and get-logs routes)
// description: A√±ade los endpoints para el ciclo de vida y auditor√≠a de una tarea.

import { Router } from 'express';
import {
  createIncidentTaskHandler,
  getTasksByNotificationHandler,
  updateIncidentTaskHandler,
  deleteIncidentTaskHandler,
  getMyAssignedTasksHandler,
  updateTaskStatusHandler, // <-- Importar
  addTaskLogHandler,       // <-- Importar
  getTaskLogsHandler,      // <-- Importar
} from './incident-tasks.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const incidentTasksRouter = Router();

incidentTasksRouter.use(protect);

// --- Rutas Generales y de Listado ---
incidentTasksRouter.get('/my-tasks', getMyAssignedTasksHandler);
incidentTasksRouter.get('/by-notification/:notificationId', getTasksByNotificationHandler);
incidentTasksRouter.post('/', createIncidentTaskHandler);

// --- Rutas para una Tarea Espec√≠fica por ID ---
incidentTasksRouter.get('/:id/logs', getTaskLogsHandler); // Obtener historial de una tarea
incidentTasksRouter.post('/:id/log', addTaskLogHandler);   // A√±adir un comentario/log
incidentTasksRouter.patch('/:id/status', updateTaskStatusHandler); // Cambiar estado
incidentTasksRouter.patch('/:id', updateIncidentTaskHandler);      // Editar detalles generales
incidentTasksRouter.delete('/:id', deleteIncidentTaskHandler);     // Eliminar tarea

export default incidentTasksRouter;


// ====== [46] packages/server/src/api/incident-tasks/incident-tasks.service.ts ======
// filename: packages/server/src/api/incident-tasks/incident-tasks.service.ts
// version: 1.2.1 (FIXED - Removed unused actorId parameter)

import { PrismaClient } from '@prisma/client';
import type { IncidentTask, IncidentPriority, IncidentTaskStatus, IncidentTaskLog } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateIncidentTaskInput = {
  title: string;
  notificationId: string;
  tenantId: string;
  description?: string;
  priority?: IncidentPriority;
  assignedToId?: string;
};
export type UpdateIncidentTaskInput = {
  title?: string;
  description?: string;
  status?: IncidentTaskStatus;
  priority?: IncidentPriority;
  assignedToId?: string | null;
  resolutionNotes?: string;
  deadline?: string | null;
};
export type AddLogInput = {
  details: string;
  newDeadline?: string;
};

// --- Funciones del Servicio ---

export const createIncidentTask = async (data: CreateIncidentTaskInput, actorId: string): Promise<IncidentTask> => {
  const task = await prisma.incidentTask.create({
    data: {
      title: data.title,
      description: data.description,
      priority: data.priority,
      notificationId: data.notificationId,
      assignedToId: data.assignedToId,
      tenantId: data.tenantId,
    },
  });

  await prisma.incidentTaskLog.create({
    data: {
      action: 'CREATION',
      details: `Tarea creada.`,
      incidentTaskId: task.id,
      userId: actorId,
    }
  });

  return task;
};

export const getTasksByNotificationId = async (notificationId: string, tenantId: string): Promise<IncidentTask[]> => {
  return prisma.incidentTask.findMany({ where: { notificationId, tenantId }, include: { assignedTo: { select: { id: true, name: true, }, }, }, orderBy: { createdAt: 'asc', }, });
};
export const getTasksAssignedToUser = async (userId: string): Promise<IncidentTask[]> => {
  return prisma.incidentTask.findMany({ where: { assignedToId: userId, status: { in: ['PENDING', 'IN_PROGRESS'], }, }, include: { notification: { include: { visit: { include: { pool: { select: { name: true } } } } } } }, orderBy: { priority: 'desc', }, });
};

// --- CORRECCI√ìN: Se elimina el par√°metro `actorId` no utilizado ---
export const updateIncidentTask = async (id: string, data: UpdateIncidentTaskInput): Promise<IncidentTask> => {
    return prisma.incidentTask.update({
        where: { id },
        data,
    });
};

export const deleteIncidentTask = async (id: string): Promise<void> => {
  await prisma.incidentTask.delete({ where: { id } });
};

export const updateTaskStatus = async (taskId: string, actorId: string, status: IncidentTaskStatus, resolutionNotes?: string) => {
  return prisma.$transaction(async (tx) => {
    const task = await tx.incidentTask.update({
      where: { id: taskId },
      data: { status, resolutionNotes },
      include: { assignedTo: true, notification: true },
    });

    if (!task.assignedTo) throw new Error("La tarea no tiene un asignado.");
    
    await tx.incidentTaskLog.create({
      data: {
        action: 'STATUS_CHANGE',
        details: `Estado cambiado a ${status} por ${task.assignedTo.name}.`,
        incidentTaskId: taskId,
        userId: actorId,
      }
    });

    if (status === 'COMPLETED') {
      await tx.notification.create({
        data: {
          message: `La tarea "${task.title}" ha sido completada.`,
          tenantId: task.tenantId,
          userId: task.notification.userId, 
        }
      });
    }
    return task;
  });
};

export const addTaskLog = async (taskId: string, actorId: string, data: AddLogInput) => {
  return prisma.$transaction(async (tx) => {
    const task = await tx.incidentTask.update({
      where: { id: taskId },
      data: { deadline: data.newDeadline ? new Date(data.newDeadline) : undefined },
      include: { assignedTo: true, notification: true },
    });

    if (!task.assignedTo) throw new Error("La tarea no tiene un asignado.");

    const log = await tx.incidentTaskLog.create({
      data: {
        action: 'COMMENT',
        details: data.details,
        incidentTaskId: taskId,
        userId: actorId,
      }
    });

    await tx.notification.create({
      data: {
        message: `Actualizaci√≥n de ${task.assignedTo.name} en la tarea "${task.title}": ${data.details}`,
        tenantId: task.tenantId,
        userId: task.notification.userId,
      }
    });

    return log;
  });
};

export const getTaskLogs = async (taskId: string): Promise<IncidentTaskLog[]> => {
    return prisma.incidentTaskLog.findMany({
        where: { incidentTaskId: taskId },
        include: { user: { select: { name: true } } },
        orderBy: { createdAt: 'asc' },
    });
};


// ====== [47] packages/server/src/api/notifications/notifications.controller.ts ======
// filename: packages/server/src/api/notifications/notifications.controller.ts
// version: 1.6.0 (Adds getNotificationByIdHandler)
// description: A√±ade el manejador para obtener una √∫nica notificaci√≥n por su ID.

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { 
  getNotificationsForUser, 
  markNotificationAsRead, 
  resolveNotification, 
  getNotificationHistory,
  classifyNotification,
  getNotificationById, // <-- Importar la nueva funci√≥n
} from './notifications.service.js';
import { IncidentPriority, NotificationStatus } from '@prisma/client';

/**
 * Maneja la obtenci√≥n de las notificaciones PENDIENTES para el usuario autenticado.
 */
export const getNotificationsHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ message: 'Usuario no autenticado.' });
    }
    const notifications = await getNotificationsForUser(userId);
    res.status(200).json({ success: true, data: notifications });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n del HISTORIAL COMPLETO de notificaciones para el tenant, con paginaci√≥n y filtros.
 */
export const getHistoryHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(401).json({ message: 'Usuario no autenticado o sin tenant.' });
    }
    const page = parseInt(req.query.page as string) || 1;
    const pageSize = parseInt(req.query.pageSize as string) || 10;
    const status = req.query.status as NotificationStatus | undefined;
    const clientId = req.query.clientId as string | undefined;

    if (status && !Object.values(NotificationStatus).includes(status)) {
        return res.status(400).json({ message: 'El estado proporcionado no es v√°lido.' });
    }
    const historyData = await getNotificationHistory(tenantId, page, pageSize, status, clientId);
    res.status(200).json({ success: true, data: historyData });
  } catch (error) {
    next(error);
  }
};

/**
 * --- NUEVO MANEJADOR ---
 * Maneja la obtenci√≥n de una notificaci√≥n espec√≠fica por su ID.
 */
export const getNotificationByIdHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { notificationId } = req.params;
    if (!notificationId) {
      return res.status(400).json({ message: 'El ID de la notificaci√≥n es requerido.' });
    }
    // TODO: A√±adir una capa de seguridad para verificar que el usuario
    // tiene permiso para ver esta notificaci√≥n (pertenece a su tenant).
    const notification = await getNotificationById(notificationId);
    if (!notification) {
      return res.status(404).json({ message: 'Notificaci√≥n no encontrada.' });
    }
    res.status(200).json({ success: true, data: notification });
  } catch (error) {
    next(error);
  }
};


/**
 * Maneja la acci√≥n de marcar una notificaci√≥n como le√≠da.
 */
export const markAsReadHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const userId = req.user?.id;
    const { notificationId } = req.params;
    if (!userId) { return res.status(401).json({ message: 'Usuario no autenticado.' }); }
    if (!notificationId) { return res.status(400).json({ message: 'El ID de la notificaci√≥n es requerido.' }); }
    const updatedNotification = await markNotificationAsRead(notificationId, userId);
    res.status(200).json({ success: true, data: updatedNotification });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la acci√≥n de resolver una notificaci√≥n.
 */
export const resolveNotificationHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const userId = req.user?.id;
    const { notificationId } = req.params;
    const { resolutionNotes } = req.body;
    if (!userId) { return res.status(401).json({ message: 'Usuario no autenticado.' }); }
    if (!notificationId) { return res.status(400).json({ message: 'El ID de la notificaci√≥n es requerido.' }); }
    if (typeof resolutionNotes !== 'string') { return res.status(400).json({ message: 'Se requieren notas de resoluci√≥n.' }); }
    const resolvedNotification = await resolveNotification(notificationId, userId, resolutionNotes);
    res.status(200).json({ success: true, data: resolvedNotification });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la acci√≥n de clasificar una notificaci√≥n (establecer prioridad y plazo).
 */
export const classifyNotificationHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
    try {
        const userId = req.user?.id;
        const { notificationId } = req.params;
        const { priority, deadline } = req.body;
        if (!userId) { return res.status(401).json({ message: 'Usuario no autenticado.' }); }
        if (!notificationId) { return res.status(400).json({ message: 'El ID de la notificaci√≥n es requerido.' }); }
        if (!priority || !Object.values(IncidentPriority).includes(priority)) { return res.status(400).json({ message: 'La prioridad proporcionada no es v√°lida.' }); }
        const deadlineDate = deadline ? new Date(deadline) : undefined;
        if (deadlineDate && isNaN(deadlineDate.getTime())) { return res.status(400).json({ message: 'El plazo proporcionado no es una fecha v√°lida.'}); }
        const classifiedNotification = await classifyNotification(notificationId, userId, priority, deadlineDate);
        res.status(200).json({ success: true, data: classifiedNotification });
    } catch (error) {
        next(error);
    }
};


// ====== [48] packages/server/src/api/notifications/notifications.routes.ts ======
// filename: packages/server/src/api/notifications/notifications.routes.ts
// version: 1.4.0 (Adds route to get a single notification by ID)
// description: A√±ade el endpoint para obtener los detalles de una notificaci√≥n espec√≠fica.

import { Router } from 'express';
import { 
  getNotificationsHandler, 
  markAsReadHandler, 
  resolveNotificationHandler,
  getHistoryHandler,
  classifyNotificationHandler,
  getNotificationByIdHandler, // <-- 1. Importar el nuevo manejador
} from './notifications.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const notificationsRouter = Router();

// --- Middleware de Protecci√≥n ---
notificationsRouter.use(protect);

/**
 * @route   GET /api/notifications/history
 * @desc    Obtiene el historial completo de notificaciones del tenant.
 * @access  Private (Admin)
 */
notificationsRouter.get('/history', getHistoryHandler);

/**
 * @route   GET /api/notifications
 * @desc    Obtiene todas las notificaciones PENDIENTES para el usuario autenticado.
 * @access  Private
 */
notificationsRouter.get('/', getNotificationsHandler);

/**
 * @route   POST /api/notifications/:notificationId/read
 * @desc    Marca una notificaci√≥n espec√≠fica como le√≠da.
 * @access  Private
 */
notificationsRouter.post('/:notificationId/read', markAsReadHandler);

/**
 * @route   POST /api/notifications/:notificationId/resolve
 * @desc    Resuelve una notificaci√≥n, cambiando su estado y a√±adiendo notas.
 * @access  Private (Admin)
 */
notificationsRouter.post('/:notificationId/resolve', resolveNotificationHandler);

/**
 * @route   PATCH /api/notifications/:notificationId/classify
 * @desc    Clasifica una notificaci√≥n (establece prioridad y/o plazo).
 * @access  Private (Admin)
 */
notificationsRouter.patch('/:notificationId/classify', classifyNotificationHandler);

/**
 * @route   GET /api/notifications/:notificationId
 * @desc    Obtiene los detalles de una notificaci√≥n espec√≠fica.
 * @access  Private (Admin)
 * @note    Esta ruta debe ir al final para no interferir con otras sub-rutas como '/history'.
 */
notificationsRouter.get('/:notificationId', getNotificationByIdHandler); // <-- 2. A√±adir la nueva ruta


export default notificationsRouter;


// ====== [49] packages/server/src/api/notifications/notifications.service.ts ======
// filename: packages/server/src/api/notifications/notifications.service.ts
// version: 1.6.1 (FIXED - Based on v1.5.1, adds getNotificationById)

import { PrismaClient } from '@prisma/client';
import type { Notification, IncidentPriority, NotificationStatus } from '@prisma/client';
import { subHours } from 'date-fns';

const prisma = new PrismaClient();

// --- Tipos ---
export type NotificationWithCriticality = Notification & { isCritical: boolean };

export type PaginatedNotifications = {
    notifications: (Notification & { visit: any })[]; // Ajustado para que coincida con el include
    total: number;
};

/**
 * Obtiene todas las notificaciones con estado PENDING para un usuario espec√≠fico.
 */
export const getNotificationsForUser = async (userId: string): Promise<Notification[]> => {
  return prisma.notification.findMany({
    where: { userId, status: 'PENDING' },
    orderBy: { createdAt: 'desc' },
  });
};

/**
 * Obtiene el historial de notificaciones para un tenant con filtros y paginaci√≥n.
 */
export const getNotificationHistory = async (
  tenantId: string,
  page: number,
  pageSize: number,
  status?: NotificationStatus,
  clientId?: string
): Promise<PaginatedNotifications> => {
    
    const skip = (page - 1) * pageSize;

    const whereClause: any = { tenantId };
    if (status) {
        whereClause.status = status;
    }
    if (clientId) {
        whereClause.visit = { pool: { clientId: clientId } };
    }
    
    const [notifications, total] = await prisma.$transaction([
        prisma.notification.findMany({
            where: whereClause,
            skip: skip,
            take: pageSize,
            include: {
                visit: {
                    include: {
                        pool: {
                            include: { client: { select: { id: true, name: true } } }
                        },
                        technician: { select: { name: true } }
                    }
                },
                images: true, // Incluimos las im√°genes
            }
        }),
        prisma.notification.count({ where: whereClause })
    ]);
    
    const now = new Date();
    const criticalThreshold = subHours(now, 48); 

    const enrichedAndSortedNotifications = notifications
        .map(notification => {
            const isOverdueByDeadline = notification.resolutionDeadline && notification.resolutionDeadline < now;
            const isOverdueByDefault = !notification.resolutionDeadline && notification.createdAt < criticalThreshold;
            return {
                ...notification,
                isCritical: (isOverdueByDeadline || isOverdueByDefault) && notification.status === 'PENDING',
            };
        })
        .sort((a, b) => {
            if (a.isCritical && !b.isCritical) return -1;
            if (!a.isCritical && b.isCritical) return 1;
            if (a.status === 'PENDING' && b.status === 'RESOLVED') return -1;
            if (a.status === 'RESOLVED' && b.status === 'PENDING') return 1;
            return b.createdAt.getTime() - a.createdAt.getTime();
        });

    return { notifications: enrichedAndSortedNotifications, total };
};


/**
 * Marca una notificaci√≥n espec√≠fica como le√≠da.
 */
export const markNotificationAsRead = async (
  notificationId: string,
  userId: string
): Promise<Notification> => {
  await prisma.notification.updateMany({
    where: { id: notificationId, userId: userId },
    data: { isRead: true },
  });
  return prisma.notification.findUniqueOrThrow({ where: { id: notificationId } });
};


/**
 * Resuelve una notificaci√≥n.
 */
export const resolveNotification = async (
    notificationId: string,
    userId: string,
    resolutionNotes: string,
): Promise<Notification> => {
    return prisma.notification.update({
        where: { id: notificationId, userId: userId },
        data: { status: 'RESOLVED', resolutionNotes: resolutionNotes },
    });
};

/**
 * Clasifica una notificaci√≥n.
 */
export const classifyNotification = async (
    notificationId: string,
    userId: string,
    priority: IncidentPriority,
    deadline?: Date,
): Promise<Notification> => {
    return prisma.notification.update({
        where: { id: notificationId, userId: userId },
        data: { priority: priority, resolutionDeadline: deadline },
    });
};


/**
 * --- NUEVA FUNCI√ìN ---
 * Obtiene los detalles de una √∫nica notificaci√≥n por su ID.
 * @param notificationId - El ID de la notificaci√≥n a buscar.
 * @returns El objeto de la notificaci√≥n con sus relaciones, o null si no se encuentra.
 */
export const getNotificationById = async (notificationId: string) => {
  return prisma.notification.findUnique({
    where: { id: notificationId },
    include: {
      images: true,
      visit: {
        include: {
          pool: { select: { name: true } },
          technician: { select: { name: true } },
        },
      },
    },
  });
};


// ====== [50] packages/server/src/api/parameters/parameters.controller.ts ======
// filename: packages/server/src/api/parameters/parameters.controller.ts
// Version: 1.0.0 (Initial creation of the controller for Parameter Templates)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
createParameterTemplate,
deleteParameterTemplate,
getParameterTemplatesByTenant,
updateParameterTemplate,
} from './parameters.service.js';
/**
Maneja la creaci√≥n de una nueva plantilla de par√°metro.
*/
export const createParameterTemplateHandler = async (
req: AuthRequest,
res: Response,
next: NextFunction
) => {
try {
// Aseguramos que el usuario est√© autenticado y tenga un tenantId
const tenantId = req.user?.tenantId;
if (!tenantId) {
return res.status(403).json({ message: 'Acci√≥n no permitida.' });
}
const input = { ...req.body, tenantId };
const newTemplate = await createParameterTemplate(input);
res.status(201).json({ success: true, data: newTemplate });
} catch (error) {
next(error);
}
};
/**
Maneja la obtenci√≥n de todas las plantillas de un tenant.
*/
export const getParameterTemplatesByTenantHandler = async (
req: AuthRequest,
res: Response,
next: NextFunction
) => {
try {
const tenantId = req.user?.tenantId;
if (!tenantId) {
return res.status(403).json({ message: 'Acci√≥n no permitida.' });
}
const templates = await getParameterTemplatesByTenant(tenantId);
res.status(200).json({ success: true, data: templates });
} catch (error) {
next(error);
}
};
/**
Maneja la actualizaci√≥n de una plantilla de par√°metro.
*/
export const updateParameterTemplateHandler = async (
req: AuthRequest,
res: Response,
next: NextFunction
) => {
try {
const { id } = req.params;
if (!id) {
return res.status(400).json({ message: 'El ID de la plantilla es requerido.' });
}
// TODO: Verificar que la plantilla que se quiere editar pertenece al tenant del usuario logueado.
const updatedTemplate = await updateParameterTemplate(id, req.body);
res.status(200).json({ success: true, data: updatedTemplate });
} catch (error) {
next(error);
}
};
/**
Maneja la eliminaci√≥n de una plantilla de par√°metro.
*/
export const deleteParameterTemplateHandler = async (
req: AuthRequest,
res: Response,
next: NextFunction
) => {
try {
const { id } = req.params;
if (!id) {
return res.status(400).json({ message: 'El ID de la plantilla es requerido.' });
}
// TODO: Verificar que la plantilla que se quiere eliminar pertenece al tenant del usuario logueado.
await deleteParameterTemplate(id);
res.status(204).send();
} catch (error) {
next(error);
}
};


// ====== [51] packages/server/src/api/parameters/parameters.routes.ts ======
// filename: packages/server/src/api/parameters/parameters.routes.ts
// Version: 1.0.0 (Initial creation of routes for Parameter Templates)
import { Router } from 'express';
import {
  createParameterTemplateHandler,
  deleteParameterTemplateHandler,
  getParameterTemplatesByTenantHandler,
  updateParameterTemplateHandler,
} from './parameters.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const parametersRouter = Router();

// Aplicamos el middleware 'protect' a TODAS las rutas definidas en este archivo.
// Esto asegura que solo los usuarios autenticados pueden gestionar el cat√°logo.
parametersRouter.use(protect);

// TODO: A√±adir un middleware de autorizaci√≥n para asegurar que el rol sea 'ADMIN'.

parametersRouter.route('/')
  .get(getParameterTemplatesByTenantHandler)
  .post(createParameterTemplateHandler);

parametersRouter.route('/:id')
  .patch(updateParameterTemplateHandler)
  .delete(deleteParameterTemplateHandler);

export default parametersRouter;


// ====== [52] packages/server/src/api/parameters/parameters.service.ts ======
// filename: packages/server/src/api/parameters/parameters.service.ts
// Version: 1.0.0 (Initial creation of the service with CRUD functions)
import { PrismaClient } from '@prisma/client';
import type { ParameterTemplate, InputType } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateParameterTemplateInput = {
  name: string;
  tenantId: string; // Cada plantilla pertenece a un tenant
  unit?: string;
  type?: InputType;
  selectOptions?: string[];
};

export type UpdateParameterTemplateInput = Partial<Omit<CreateParameterTemplateInput, 'tenantId'>>;

// --- Funciones del Servicio ---

/**
 * Crea una nueva plantilla de par√°metro para un tenant espec√≠fico.
 * @param input - Datos de la nueva plantilla.
 * @returns La plantilla de par√°metro creada.
 */
export const createParameterTemplate = async (
  input: CreateParameterTemplateInput
): Promise<ParameterTemplate> => {
  return prisma.parameterTemplate.create({
    data: input,
  });
};

/**
 * Obtiene todas las plantillas de par√°metros para un tenant espec√≠fico.
 * @param tenantId - El ID del tenant.
 * @returns Un array de plantillas de par√°metros.
 */
export const getParameterTemplatesByTenant = async (
  tenantId: string
): Promise<ParameterTemplate[]> => {
  return prisma.parameterTemplate.findMany({
    where: { tenantId },
    orderBy: { name: 'asc' },
  });
};

/**
 * Actualiza una plantilla de par√°metro existente.
 * @param id - El ID de la plantilla a actualizar.
 * @param data - Los datos a actualizar.
 * @returns La plantilla de par√°metro actualizada.
 */
export const updateParameterTemplate = async (
  id: string,
  data: UpdateParameterTemplateInput
): Promise<ParameterTemplate> => {
  return prisma.parameterTemplate.update({
    where: { id },
    data,
  });
};

/**
 * Elimina una plantilla de par√°metro.
 * @param id - El ID de la plantilla a eliminar.
 * @returns La plantilla de par√°metro que fue eliminada.
 */
export const deleteParameterTemplate = async (
  id: string
): Promise<ParameterTemplate> => {
  // TODO: A√±adir l√≥gica para verificar que esta plantilla no est√° siendo
  // usada en ninguna PoolConfiguration antes de permitir el borrado.
  return prisma.parameterTemplate.delete({
    where: { id },
  });
};


// ====== [53] packages/server/src/api/pool-configurations/pool-configurations.controller.ts ======
// filename: packages/server/src/api/pool-configurations/pool-configurations.controller.ts
// Version: 1.1.0 (Add handler for update functionality)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createPoolConfiguration,
  deletePoolConfiguration,
  getConfigurationsByPool,
  updatePoolConfiguration,
} from './pool-configurations.service.js';

/**
 * Maneja la creaci√≥n de una nueva configuraci√≥n de mantenimiento.
 */
export const createPoolConfigurationHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acci√≥n no permitida.' });
    }
    const newConfig = await createPoolConfiguration(req.body);
    res.status(201).json({ success: true, data: newConfig });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todas las configuraciones para una piscina.
 */
export const getConfigurationsByPoolHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { poolId } = req.params;
    if (!poolId) {
      return res.status(400).json({ message: 'El ID de la piscina es requerido.' });
    }
    const configs = await getConfigurationsByPool(poolId);
    res.status(200).json({ success: true, data: configs });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n de una configuraci√≥n de mantenimiento.
 */
export const updatePoolConfigurationHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la configuraci√≥n es requerido.' });
    }
    // TODO: Verificar que la configuraci√≥n que se quiere editar pertenece al tenant del usuario.
    const updatedConfig = await updatePoolConfiguration(id, req.body);
    res.status(200).json({ success: true, data: updatedConfig });
  } catch (error) {
    next(error);
  }
};


/**
 * Maneja la eliminaci√≥n de una configuraci√≥n de mantenimiento.
 */
export const deletePoolConfigurationHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la configuraci√≥n es requerido.' });
    }
    await deletePoolConfiguration(id);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [54] packages/server/src/api/pool-configurations/pool-configurations.routes.ts ======
// filename: packages/server/src/api/pool-configurations/pool-configurations.routes.ts
// Version: 1.1.0 (Add PATCH route for update functionality)
import { Router } from 'express';
import {
  createPoolConfigurationHandler,
  deletePoolConfigurationHandler,
  getConfigurationsByPoolHandler,
  updatePoolConfigurationHandler,
} from './pool-configurations.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const poolConfigurationsRouter = Router();

poolConfigurationsRouter.use(protect);

// TODO: A√±adir un middleware de autorizaci√≥n para asegurar que el rol sea 'ADMIN'.

poolConfigurationsRouter.route('/')
  .post(createPoolConfigurationHandler);

poolConfigurationsRouter.route('/by-pool/:poolId')
  .get(getConfigurationsByPoolHandler);

poolConfigurationsRouter.route('/:id')
  .patch(updatePoolConfigurationHandler) // Nueva ruta PATCH
  .delete(deletePoolConfigurationHandler);

export default poolConfigurationsRouter;


// ====== [55] packages/server/src/api/pool-configurations/pool-configurations.service.ts ======
// filename: packages/server/src/api/pool-configurations/pool-configurations.service.ts
// Version: 1.1.0 (Add update functionality)
import { PrismaClient } from '@prisma/client';
import type { PoolConfiguration, Frequency } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreatePoolConfigurationInput = {
  poolId: string;
  frequency: Frequency;
  minThreshold?: number;
  maxThreshold?: number;
  parameterTemplateId?: string;
  taskTemplateId?: string;
};

export type UpdatePoolConfigurationInput = Partial<Omit<CreatePoolConfigurationInput, 'poolId' | 'parameterTemplateId' | 'taskTemplateId'>>;


// --- Funciones del Servicio ---

/**
 * Crea una nueva configuraci√≥n de mantenimiento para una piscina.
 */
export const createPoolConfiguration = async (
  data: CreatePoolConfigurationInput
): Promise<PoolConfiguration> => {
  if (data.parameterTemplateId && data.taskTemplateId) {
    throw new Error('Una configuraci√≥n solo puede estar asociada a un par√°metro O a una tarea, no a ambos.');
  }
  if (!data.parameterTemplateId && !data.taskTemplateId) {
    throw new Error('La configuraci√≥n debe estar asociada a un par√°metro o a una tarea.');
  }

  return prisma.poolConfiguration.create({
    data,
  });
};

/**
 * Obtiene todas las configuraciones para una piscina espec√≠fica.
 */
export const getConfigurationsByPool = async (poolId: string): Promise<PoolConfiguration[]> => {
  return prisma.poolConfiguration.findMany({
    where: { poolId },
    include: {
      parameterTemplate: true,
      taskTemplate: true,
    },
  });
};

/**
 * Actualiza una configuraci√≥n de mantenimiento existente.
 * @param id - El ID de la configuraci√≥n a actualizar.
 * @param data - Los datos a actualizar.
 * @returns La configuraci√≥n actualizada.
 */
export const updatePoolConfiguration = async (
  id: string,
  data: UpdatePoolConfigurationInput
): Promise<PoolConfiguration> => {
  return prisma.poolConfiguration.update({
    where: { id },
    data,
  });
};


/**
 * Elimina una configuraci√≥n de mantenimiento de una piscina.
 */
export const deletePoolConfiguration = async (id: string): Promise<PoolConfiguration> => {
  return prisma.poolConfiguration.delete({
    where: { id },
  });
};


// ====== [56] packages/server/src/api/pools/pools.controller.ts ======
// filename: packages/server/src/api/pools/pools.controller.ts
// Version: 1.0.0 (Initial creation of the controller for Pool management)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { createPool, deletePool, updatePool } from './pools.service.js';

/**
 * Maneja la creaci√≥n de una nueva piscina.
 */
export const createPoolHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acci√≥n no permitida.' });
    }

    // Aseguramos que la piscina se asigne al tenant del usuario.
    const input = { ...req.body, tenantId };
    const newPool = await createPool(input);
    res.status(201).json({ success: true, data: newPool });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n de una piscina.
 */
export const updatePoolHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la piscina es requerido.' });
    }
    // TODO: Verificar que la piscina que se quiere editar pertenece al tenant del usuario logueado.

    const updatedPool = await updatePool(id, req.body);
    res.status(200).json({ success: true, data: updatedPool });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de una piscina.
 */
export const deletePoolHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la piscina es requerido.' });
    }
    // TODO: Verificar que la piscina que se quiere eliminar pertenece al tenant del usuario logueado.

    await deletePool(id);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [57] packages/server/src/api/pools/pools.routes.ts ======
// filename: packages/server/src/api/pools/pools.routes.ts
// Version: 1.0.0 (Initial creation of routes for Pool management)
import { Router } from 'express';
import {
  createPoolHandler,
  deletePoolHandler,
  updatePoolHandler,
} from './pools.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const poolsRouter = Router();

// Aplicamos el middleware 'protect' a TODAS las rutas de este enrutador.
poolsRouter.use(protect);

// TODO: A√±adir un middleware de autorizaci√≥n para asegurar que el rol sea 'ADMIN'.

// No hay una ruta GET / aqu√≠ porque las piscinas se obtienen
// a trav√©s de la ruta del cliente (/api/clients/:id) para mantener el contexto.
poolsRouter.route('/')
  .post(createPoolHandler);

poolsRouter.route('/:id')
  .patch(updatePoolHandler)
  .delete(deletePoolHandler);

export default poolsRouter;


// ====== [58] packages/server/src/api/pools/pools.service.ts ======
// filename: packages/server/src/api/pools/pools.service.ts
// Version: 1.0.0 (Initial creation of the service for Pool management)
import { PrismaClient } from '@prisma/client';
import type { Pool } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
// Omitimos los campos autogenerados por la base de datos (id, qrCode, timestamps)
export type CreatePoolInput = Omit<Pool, 'id' | 'qrCode' | 'createdAt' | 'updatedAt'>;
export type UpdatePoolInput = Partial<CreatePoolInput>;

// --- Funciones del Servicio ---

/**
 * Crea una nueva piscina para un cliente y tenant espec√≠ficos.
 * @param data - Datos de la nueva piscina.
 * @returns La piscina creada.
 */
export const createPool = async (data: CreatePoolInput): Promise<Pool> => {
  return prisma.pool.create({
    data,
  });
};

/**
 * Actualiza una piscina existente.
 * @param id - El ID de la piscina a actualizar.
 * @param data - Los datos a actualizar.
 * @returns La piscina actualizada.
 */
export const updatePool = async (id: string, data: UpdatePoolInput): Promise<Pool> => {
  return prisma.pool.update({
    where: { id },
    data,
  });
};

/**
 * Elimina una piscina.
 * @param id - El ID de la piscina a eliminar.
 * @returns La piscina que fue eliminada.
 */
export const deletePool = async (id: string): Promise<Pool> => {
  // Al borrar la piscina, se borrar√°n en cascada sus visitas, etc.
  return prisma.pool.delete({
    where: { id },
  });
};


// ====== [59] packages/server/src/api/products/products.controller.ts ======
// filename: packages/server/src/api/products/products.controller.ts
// version: 1.0.0
// description: Controlador para manejar las peticiones HTTP del cat√°logo de productos.

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createProduct,
  getProductsByTenant,
  updateProduct,
  deleteProduct,
} from './products.service.js';

/**
 * Maneja la creaci√≥n de un nuevo producto.
 */
export const createProductHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }

    // El tenantId se a√±ade al cuerpo de la petici√≥n para asegurar la pertenencia.
    const input = { ...req.body, tenantId };
    const newProduct = await createProduct(input);
    res.status(201).json({ success: true, data: newProduct });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todos los productos de un tenant.
 */
export const getProductsHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ success: false, message: 'Acci√≥n no permitida.' });
    }

    const products = await getProductsByTenant(tenantId);
    res.status(200).json({ success: true, data: products });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n de un producto.
 */
export const updateProductHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ success: false, message: 'El ID del producto es requerido.' });
    }
    
    const updatedProduct = await updateProduct(id, req.body);
    res.status(200).json({ success: true, data: updatedProduct });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de un producto.
 */
export const deleteProductHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ success: false, message: 'El ID del producto es requerido.' });
    }

    await deleteProduct(id);
    res.status(204).send(); // 204 No Content es la respuesta est√°ndar para un DELETE exitoso.
  } catch (error) {
    // Si Prisma lanza un error de restricci√≥n de clave for√°nea (P2003),
    // el errorHandler global lo capturar√°. Podr√≠amos a√±adir un manejo m√°s espec√≠fico aqu√≠ si quisi√©ramos.
    next(error);
  }
};


// ====== [60] packages/server/src/api/products/products.routes.ts ======
// filename: packages/server/src/api/products/products.routes.ts
// version: 1.0.0
// description: Define los endpoints de la API para el cat√°logo de productos.

import { Router } from 'express';
import {
  createProductHandler,
  getProductsHandler,
  updateProductHandler,
  deleteProductHandler,
} from './products.controller.js';
import { protect } from '../../middleware/auth.middleware.js';
// TODO: Importar y usar un middleware de autorizaci√≥n para 'ADMIN'

const productsRouter = Router();

// Aplicamos el middleware 'protect' a todas las rutas de este enrutador.
// Solo los usuarios autenticados podr√°n interactuar con el cat√°logo de productos.
productsRouter.use(protect);

// Definimos las rutas para el recurso /api/products
productsRouter.route('/')
  .get(getProductsHandler)      // GET /api/products -> Obtiene todos los productos
  .post(createProductHandler);   // POST /api/products -> Crea un nuevo producto

// Definimos las rutas para un recurso espec√≠fico /api/products/:id
productsRouter.route('/:id')
  .patch(updateProductHandler)  // PATCH /api/products/:id -> Actualiza un producto
  .delete(deleteProductHandler); // DELETE /api/products/:id -> Elimina un producto

export default productsRouter;


// ====== [61] packages/server/src/api/products/products.service.ts ======
// filename: packages/server/src/api/products/products.service.ts
// version: 1.0.0
// description: Servicio para la l√≥gica de negocio del cat√°logo de productos.

import { PrismaClient } from '@prisma/client';
import type { Product } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) para la creaci√≥n y actualizaci√≥n ---
export type CreateProductInput = Omit<Product, 'id' | 'createdAt' | 'updatedAt' | 'consumptions'>;
export type UpdateProductInput = Partial<CreateProductInput>;

/**
 * Crea un nuevo producto para un tenant espec√≠fico.
 * @param data - Los datos del producto a crear.
 * @returns El producto reci√©n creado.
 */
export const createProduct = async (data: CreateProductInput): Promise<Product> => {
  return prisma.product.create({
    data,
  });
};

/**
 * Obtiene todos los productos de un tenant espec√≠fico.
 * @param tenantId - El ID del tenant.
 * @returns Un array con todos los productos del tenant, ordenados por nombre.
 */
export const getProductsByTenant = async (tenantId: string): Promise<Product[]> => {
  return prisma.product.findMany({
    where: { tenantId },
    orderBy: { name: 'asc' },
  });
};

/**
 * Actualiza un producto existente.
 * @param id - El ID del producto a actualizar.
 * @param data - Los datos a modificar.
 * @returns El producto actualizado.
 */
export const updateProduct = async (id: string, data: UpdateProductInput): Promise<Product> => {
  // TODO: A√±adir una verificaci√≥n para asegurar que el producto pertenece al tenant del usuario que realiza la acci√≥n.
  return prisma.product.update({
    where: { id },
    data,
  });
};

/**
 * Elimina un producto.
 * La operaci√≥n fallar√° si el producto ya ha sido usado en alg√∫n registro de consumo,
 * gracias a la restricci√≥n 'onDelete: Restrict' en el schema.
 * @param id - El ID del producto a eliminar.
 * @returns El producto que fue eliminado.
 */
export const deleteProduct = async (id: string): Promise<Product> => {
  // TODO: A√±adir una verificaci√≥n para asegurar que el producto pertenece al tenant del usuario que realiza la acci√≥n.
  return prisma.product.delete({
    where: { id },
  });
};


// ====== [62] packages/server/src/api/tasks/tasks.controller.ts ======
// filename: packages/server/src/api/tasks/tasks.controller.ts
// Version: 1.0.0 (Initial creation of the controller for Scheduled Tasks)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createTaskTemplate,
  deleteTaskTemplate,
  getTaskTemplatesByTenant,
  updateTaskTemplate,
} from './tasks.service.js';

/**
 * Maneja la creaci√≥n de una nueva plantilla de tarea.
 */
export const createTaskTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acci√≥n no permitida.' });
    }

    const input = { ...req.body, tenantId };
    const newTemplate = await createTaskTemplate(input);
    res.status(201).json({ success: true, data: newTemplate });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todas las plantillas de tareas de un tenant.
 */
export const getTaskTemplatesByTenantHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acci√≥n no permitida.' });
    }

    const templates = await getTaskTemplatesByTenant(tenantId);
    res.status(200).json({ success: true, data: templates });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n de una plantilla de tarea.
 */
export const updateTaskTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la plantilla es requerido.' });
    }
    // TODO: Verificar que la plantilla que se quiere editar pertenece al tenant del usuario logueado.

    const updatedTemplate = await updateTaskTemplate(id, req.body);
    res.status(200).json({ success: true, data: updatedTemplate });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de una plantilla de tarea.
 */
export const deleteTaskTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la plantilla es requerido.' });
    }
    // TODO: Verificar que la plantilla que se quiere eliminar pertenece al tenant del usuario logueado.

    await deleteTaskTemplate(id);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [63] packages/server/src/api/tasks/tasks.routes.ts ======
// filename: packages/server/src/api/tasks/tasks.routes.ts
// Version: 1.0.0 (Initial creation of routes for Scheduled Tasks)
import { Router } from 'express';
import {
  createTaskTemplateHandler,
  deleteTaskTemplateHandler,
  getTaskTemplatesByTenantHandler,
  updateTaskTemplateHandler,
} from './tasks.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const tasksRouter = Router();

// Aplicamos el middleware 'protect' a TODAS las rutas de este enrutador.
tasksRouter.use(protect);

// TODO: A√±adir un middleware de autorizaci√≥n para asegurar que el rol sea 'ADMIN'.

tasksRouter.route('/')
  .get(getTaskTemplatesByTenantHandler)
  .post(createTaskTemplateHandler);

tasksRouter.route('/:id')
  .patch(updateTaskTemplateHandler)
  .delete(deleteTaskTemplateHandler);

export default tasksRouter;


// ====== [64] packages/server/src/api/tasks/tasks.service.ts ======
// filename: packages/server/src/api/tasks/tasks.service.ts
// Version: 1.0.0 (Initial creation of the service for Scheduled Tasks)
import { PrismaClient } from '@prisma/client';
import type { ScheduledTaskTemplate } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateTaskTemplateInput = {
  name: string;
  tenantId: string; // Cada plantilla pertenece a un tenant
  description?: string;
};

export type UpdateTaskTemplateInput = Partial<Omit<CreateTaskTemplateInput, 'tenantId'>>;

// --- Funciones del Servicio ---

/**
 * Crea una nueva plantilla de tarea para un tenant espec√≠fico.
 * @param input - Datos de la nueva plantilla.
 * @returns La plantilla de tarea creada.
 */
export const createTaskTemplate = async (
  input: CreateTaskTemplateInput
): Promise<ScheduledTaskTemplate> => {
  return prisma.scheduledTaskTemplate.create({
    data: input,
  });
};

/**
 * Obtiene todas las plantillas de tareas para un tenant espec√≠fico.
 * @param tenantId - El ID del tenant.
 * @returns Un array de plantillas de tareas.
 */
export const getTaskTemplatesByTenant = async (
  tenantId: string
): Promise<ScheduledTaskTemplate[]> => {
  return prisma.scheduledTaskTemplate.findMany({
    where: { tenantId },
    orderBy: { name: 'asc' },
  });
};

/**
 * Actualiza una plantilla de tarea existente.
 * @param id - El ID de la plantilla a actualizar.
 * @param data - Los datos a actualizar.
 * @returns La plantilla de tarea actualizada.
 */
export const updateTaskTemplate = async (
  id: string,
  data: UpdateTaskTemplateInput
): Promise<ScheduledTaskTemplate> => {
  return prisma.scheduledTaskTemplate.update({
    where: { id },
    data,
  });
};

/**
 * Elimina una plantilla de tarea.
 * @param id - El ID de la plantilla a eliminar.
 * @returns La plantilla de tarea que fue eliminada.
 */
export const deleteTaskTemplate = async (
  id: string
): Promise<ScheduledTaskTemplate> => {
  // TODO: A√±adir l√≥gica para verificar que esta plantilla no est√° siendo
  // usada en ninguna PoolConfiguration antes de permitir el borrado.
  return prisma.scheduledTaskTemplate.delete({
    where: { id },
  });
};


// ====== [65] packages/server/src/api/tenants/tenants.controller.ts ======
import type { Request, Response, NextFunction } from 'express';
import {
  createTenant,
  getAllTenants,
  getTenantById,
  updateTenantStatus,
  deleteTenant,
} from './tenants.service.js';

/**
 * Maneja la creaci√≥n de un nuevo tenant.
 */
export const createTenantHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenant = await createTenant(req.body);
    res.status(201).json({ success: true, data: tenant });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todos los tenants.
 */
export const getAllTenantsHandler = async (
  _req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenants = await getAllTenants();
    res.status(200).json({ success: true, data: tenants });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de un tenant por su ID.
 */
export const getTenantByIdHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID del tenant es requerido.' });
    }

    const tenant = await getTenantById(id);

    if (!tenant) {
      const error: any = new Error('Tenant no encontrado.');
      error.statusCode = 404;
      return next(error);
    }

    res.status(200).json({ success: true, data: tenant });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n del estado de un tenant.
 */
export const updateTenantStatusHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID del tenant es requerido.' });
    }

    const { status } = req.body;
    // TODO: A√±adir validaci√≥n para asegurar que 'status' es un valor v√°lido del enum SubscriptionStatus

    const updatedTenant = await updateTenantStatus(id, status);
    res.status(200).json({ success: true, data: updatedTenant });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de un tenant.
 */
export const deleteTenantHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID del tenant es requerido.' });
    }

    await deleteTenant(id);

    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [66] packages/server/src/api/tenants/tenants.routes.ts ======
import { Router } from 'express';
import {
  createTenantHandler,
  getAllTenantsHandler,
  getTenantByIdHandler,
  updateTenantStatusHandler,
  deleteTenantHandler,
} from './tenants.controller.js';

const tenantsRouter = Router();

// TODO: Proteger todas estas rutas para que solo sean accesibles por un SUPER_ADMIN.

/**
 * @route   GET /api/tenants
 * @desc    Obtiene todos los tenants
 * @access  Private (SuperAdmin)
 */
tenantsRouter.get('/', getAllTenantsHandler);

/**
 * @route   POST /api/tenants
 * @desc    Crea un nuevo tenant y su primer usuario admin
 * @access  Private (SuperAdmin)
 */
tenantsRouter.post('/', createTenantHandler);

/**
 * @route   GET /api/tenants/:id
 * @desc    Obtiene un tenant espec√≠fico por su ID
 * @access  Private (SuperAdmin)
 */
tenantsRouter.get('/:id', getTenantByIdHandler);

/**
 * @route   PATCH /api/tenants/:id/status
 * @desc    Actualiza el estado de la suscripci√≥n de un tenant
 * @access  Private (SuperAdmin)
 */
tenantsRouter.patch('/:id/status', updateTenantStatusHandler);

/**
 * @route   DELETE /api/tenants/:id
 * @desc    Elimina un tenant y toda su informaci√≥n asociada
 * @access  Private (SuperAdmin)
 */
tenantsRouter.delete('/:id', deleteTenantHandler);

export default tenantsRouter;


// ====== [67] packages/server/src/api/tenants/tenants.service.ts ======
import { PrismaClient } from '@prisma/client';
import type { Tenant, SubscriptionStatus } from '@prisma/client';
import { hashPassword } from '../../utils/password.utils.js';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
type AdminUserInput = {
  name: string;
  email: string;
  password: string;
};

export type CreateTenantInput = {
  companyName: string;
  subdomain: string;
  adminUser: AdminUserInput;
};

// --- Funciones del Servicio ---

/**
 * Crea un nuevo Tenant y su primer usuario Administrador de forma at√≥mica.
 * @param input - Datos para el nuevo tenant y su admin.
 * @returns El objeto del Tenant reci√©n creado.
 */
export const createTenant = async (input: CreateTenantInput): Promise<Tenant> => {
  const { companyName, subdomain, adminUser } = input;

  const newTenant = await prisma.$transaction(async (tx) => {
    const existingSubdomain = await tx.tenant.findUnique({ where: { subdomain } });
    if (existingSubdomain) {
      throw new Error('El subdominio ya est√° en uso.');
    }

    const existingEmail = await tx.user.findUnique({ where: { email: adminUser.email } });
    if (existingEmail) {
      throw new Error('El correo electr√≥nico ya est√° en uso por otro usuario.');
    }

    const tenant = await tx.tenant.create({
      data: {
        companyName,
        subdomain,
      },
    });

    const hashedPassword = await hashPassword(adminUser.password);
    await tx.user.create({
      data: {
        name: adminUser.name,
        email: adminUser.email,
        password: hashedPassword,
        role: 'ADMIN',
        tenantId: tenant.id,
      },
    });

    return tenant;
  });

  return newTenant;
};

/**
 * Obtiene un listado de todos los tenants.
 * @returns Un array de todos los tenants.
 */
export const getAllTenants = async (): Promise<Tenant[]> => {
  return prisma.tenant.findMany({
    orderBy: {
      createdAt: 'desc',
    },
  });
};

/**
 * Busca un tenant espec√≠fico por su ID.
 * @param id - El ID del tenant a buscar.
 * @returns El objeto del tenant o null si no se encuentra.
 */
export const getTenantById = async (id: string): Promise<Tenant | null> => {
  return prisma.tenant.findUnique({
    where: { id },
  });
};

/**
 * Actualiza el estado de la suscripci√≥n de un tenant.
 * @param id - El ID del tenant a actualizar.
 * @param status - El nuevo estado de la suscripci√≥n.
 * @returns El objeto del tenant actualizado.
 */
export const updateTenantStatus = async (
  id: string,
  status: SubscriptionStatus
): Promise<Tenant> => {
  return prisma.tenant.update({
    where: { id },
    data: {
      subscriptionStatus: status,
    },
  });
};

/**
 * Elimina un tenant y toda su informaci√≥n asociada (cascade).
 * @param id - El ID del tenant a eliminar.
 * @returns El objeto del tenant que fue eliminado.
 */
export const deleteTenant = async (id: string): Promise<Tenant> => {
  // Gracias a 'onDelete: Cascade' en el schema, al borrar un tenant,
  // se borrar√°n en cascada todos sus usuarios, clientes, piscinas, etc.
  return prisma.tenant.delete({
    where: { id },
  });
};


// ====== [68] packages/server/src/api/uploads/uploads.controller.ts ======
// filename: packages/server/src/api/uploads/uploads.controller.ts
// version: 1.0.0
// description: Controlador para manejar las peticiones HTTP de firma de subidas.

import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { generateUploadSignature } from './uploads.service.js';

/**
 * Maneja la petici√≥n del frontend para obtener una firma de subida.
 * Llama al servicio, obtiene la firma y la devuelve como respuesta JSON.
 */
export const getUploadSignatureHandler = (
  _req: AuthRequest, // No necesitamos la request, pero la incluimos por consistencia
  res: Response,
  next: NextFunction
) => {
  try {
    const signatureData = generateUploadSignature();
    res.status(200).json({ success: true, data: signatureData });
  } catch (error) {
    // Aunque es poco probable que la generaci√≥n de la firma falle si la config es correcta,
    // es buena pr√°ctica tener el manejo de errores.
    next(error);
  }
};


// ====== [69] packages/server/src/api/uploads/uploads.routes.ts ======
// filename: packages/server/src/api/uploads/uploads.routes.ts
// version: 1.0.0
// description: Define el endpoint para obtener la firma de subida.

import { Router } from 'express';
import { getUploadSignatureHandler } from './uploads.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const uploadsRouter = Router();

// Protegemos la ruta para que solo los usuarios autenticados (ej. un t√©cnico logueado)
// puedan obtener firmas y subir archivos. Esto previene el abuso del servicio.
uploadsRouter.use(protect);

/**
 * @route   GET /api/uploads/signature
 * @desc    Obtiene una firma y timestamp para autorizar una subida a Cloudinary.
 * @access  Private
 */
uploadsRouter.get('/signature', getUploadSignatureHandler);

export default uploadsRouter;


// ====== [70] packages/server/src/api/uploads/uploads.service.ts ======
// filename: packages/server/src/api/uploads/uploads.service.ts
// version: 1.0.0
// description: Servicio para generar firmas seguras para la subida de archivos a Cloudinary.

import { v2 as cloudinary } from 'cloudinary';
import config from '../../config/index.js';

// --- Configuraci√≥n del SDK de Cloudinary ---
// Se configura una √∫nica vez al cargar el m√≥dulo, utilizando las credenciales
// de nuestro archivo de configuraci√≥n centralizado.
cloudinary.config({
  cloud_name: config.CLOUDINARY_CLOUD_NAME,
  api_key: config.CLOUDINARY_API_KEY,
  api_secret: config.CLOUDINARY_API_SECRET,
  secure: true, // Siempre usar https para las URLs
});

/**
 * Genera una firma segura para autorizar una subida desde el cliente.
 * Este m√©todo no sube ning√∫n archivo, solo crea las credenciales temporales.
 * @returns Un objeto que contiene la firma, el timestamp y la api_key.
 */
export const generateUploadSignature = () => {
  // El timestamp es necesario para que Cloudinary pueda verificar que la firma
  // no es demasiado antigua y prevenir ataques de repetici√≥n.
  const timestamp = Math.round(new Date().getTime() / 1000);

  // Utilizamos la utilidad de Cloudinary para firmar los par√°metros.
  // En este caso, solo necesitamos firmar el timestamp, pero se podr√≠an
  // a√±adir m√°s par√°metros como transformaciones, carpetas, etc.
  const signature = cloudinary.utils.api_sign_request(
    {
      timestamp: timestamp,
    },
    config.CLOUDINARY_API_SECRET
  );

  // El frontend necesitar√° estos tres datos para poder autenticar
  // la petici√≥n de subida directamente contra la API de Cloudinary.
  return {
    timestamp,
    signature,
    apiKey: config.CLOUDINARY_API_KEY,
    cloudName: config.CLOUDINARY_CLOUD_NAME,
  };
};


// ====== [71] packages/server/src/api/users/users.controller.ts ======
// filename: packages/server/src/api/users/users.controller.ts
// Version: 1.0.0 (Initial creation of the controller for User queries)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { getTechniciansByTenant } from './users.service.js';

/**
 * Maneja la obtenci√≥n de todos los t√©cnicos de un tenant.
 */
export const getTechniciansByTenantHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acci√≥n no permitida.' });
    }

    const technicians = await getTechniciansByTenant(tenantId);
    res.status(200).json({ success: true, data: technicians });
  } catch (error) {
    next(error);
  }
};


// ====== [72] packages/server/src/api/users/users.routes.ts ======
// filename: packages/server/src/api/users/users.routes.ts
// Version: 1.0.0 (Initial creation of routes for User queries)
import { Router } from 'express';
import { getTechniciansByTenantHandler } from './users.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const usersRouter = Router();

// Aplicamos el middleware 'protect' a TODAS las rutas de este enrutador.
usersRouter.use(protect);

// TODO: A√±adir un middleware de autorizaci√≥n para asegurar que el rol sea 'ADMIN'.

/**
 * @route   GET /api/users/technicians
 * @desc    Obtiene una lista de todos los t√©cnicos del tenant.
 * @access  Private (Admin)
 */
usersRouter.get('/technicians', getTechniciansByTenantHandler);


export default usersRouter;


// ====== [73] packages/server/src/api/users/users.service.ts ======
// filename: packages/server/src/api/users/users.service.ts
// Version: 1.0.0 (Initial creation of the service for User queries)
import { PrismaClient } from '@prisma/client';
import type { User } from '@prisma/client';

const prisma = new PrismaClient();

// --- Funciones del Servicio ---

/**
 * Obtiene todos los usuarios con el rol de TECHNICIAN para un tenant espec√≠fico.
 * @param tenantId - El ID del tenant.
 * @returns Un array de usuarios t√©cnicos (sin la contrase√±a).
 */
export const getTechniciansByTenant = async (
  tenantId: string
): Promise<Omit<User, 'password'>[]> => {
  return prisma.user.findMany({
    where: {
      tenantId,
      role: 'TECHNICIAN',
    },
    select: {
      id: true,
      email: true,
      name: true,
      role: true,
      tenantId: true,
      createdAt: true,
      updatedAt: true,
    },
    orderBy: {
      name: 'asc',
    },
  });
};


// ====== [74] packages/server/src/api/visits/visits.controller.ts ======
// filename: packages/server/src/api/visits/visits.controller.ts
// Version: 1.7.0 (Adapt assignTechnicianHandler to new logic)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { 
  getScheduledVisitsForWeek, 
  assignTechnicianToVisit,
  getVisitsForTechnicianOnDate,
  getVisitDetails,
  submitWorkOrder,
} from './visits.service.js';

/**
 * Maneja la obtenci√≥n de las visitas programadas para una semana.
 */
export const getScheduledVisitsForWeekHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acci√≥n no permitida.' });
    }

    const { date } = req.query;
    if (!date || typeof date !== 'string') {
      return res.status(400).json({ message: 'Se requiere un par√°metro de fecha v√°lido.' });
    }

    const weekDate = new Date(date);
    const visits = await getScheduledVisitsForWeek(tenantId, weekDate);

    res.status(200).json({ success: true, data: visits });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la asignaci√≥n de un t√©cnico a una visita.
 */
export const assignTechnicianHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { visitId, technicianId } = req.body;
    if (!visitId) {
      return res.status(400).json({ message: 'visitId es requerido.' });
    }
    
    // TODO: Verificar que la visita pertenece al tenant del admin
    
    const assignedVisit = await assignTechnicianToVisit(visitId, technicianId);
    
    res.status(200).json({ success: true, data: assignedVisit });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de la ruta diaria para el t√©cnico autenticado.
 */
export const getMyRouteHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const technicianId = req.user?.id;
    if (!technicianId || req.user?.role !== 'TECHNICIAN') {
      return res.status(403).json({ message: 'Acceso denegado.' });
    }
    
    const today = new Date();
    const visits = await getVisitsForTechnicianOnDate(technicianId, today);
    
    res.status(200).json({ success: true, data: visits });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de los detalles de una visita espec√≠fica.
 */
export const getVisitDetailsHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la visita es requerido.' });
    }
    
    const visitDetails = await getVisitDetails(id);
    if (!visitDetails) {
      return res.status(404).json({ message: 'Visita no encontrada.' });
    }

    res.status(200).json({ success: true, data: visitDetails });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja el env√≠o de un parte de trabajo.
 */
export const submitWorkOrderHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la visita es requerido.' });
    }
    
    await submitWorkOrder(id, req.body);

    res.status(200).json({ success: true, message: 'Parte de trabajo guardado con √©xito.' });
  } catch (error) {
    console.error('ERROR AL PROCESAR PARTE DE TRABAJO:', error); 
    next(error);
  }
};


// ====== [75] packages/server/src/api/visits/visits.routes.ts ======
// filename: packages/server/src/api/visits/visits.routes.ts
// Version: 1.4.4 (Clean up unused imports and finalize route order)
import { Router } from 'express';
import { 
  getScheduledVisitsForWeekHandler,
  assignTechnicianHandler,
  getMyRouteHandler,
  getVisitDetailsHandler,
  submitWorkOrderHandler,
} from './visits.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const visitsRouter = Router();

visitsRouter.use(protect);

// --- Rutas para ADMIN ---
visitsRouter.get('/scheduled', getScheduledVisitsForWeekHandler);
visitsRouter.post('/assign', assignTechnicianHandler);

// --- Rutas para TECHNICIAN ---
visitsRouter.get('/my-route', getMyRouteHandler);

/**
 * @route   POST /api/visits/:id/complete
 * @desc    Env√≠a y procesa los datos de un Parte de Trabajo.
 * @access  Private (Technician)
 */
visitsRouter.post('/:id/complete', submitWorkOrderHandler);

/**
 * @route   GET /api/visits/:id
 * @desc    Obtiene los detalles de una visita espec√≠fica (para el Parte de Trabajo)
 * @access  Private (Technician/Admin)
 */
visitsRouter.get('/:id', getVisitDetailsHandler);

export default visitsRouter;


// ====== [76] packages/server/src/api/visits/visits.service.ts ======
// filename: packages/server/src/api/visits/visits.service.ts
// version: 2.0.1 (FIXED)
// description: Corrige los errores de tipo y se alinea con el schema v2.2.0.

import { PrismaClient } from '@prisma/client';
import type { Visit } from '@prisma/client';
import { 
  startOfWeek, endOfWeek, eachDayOfInterval, isSameDay, startOfDay, endOfDay,
} from 'date-fns';

const prisma = new PrismaClient();

// --- Tipos ---
export type WorkOrderInput = {
  results: Record<string, string | number | boolean>;
  completedTasks: Record<string, boolean>;
  consumptions?: { productId: string; quantity: number }[];
  notes?: string;
  hasIncident?: boolean;
  imageUrls?: string[]; 
};


export const getScheduledVisitsForWeek = async (tenantId: string, weekDate: Date): Promise<Visit[]> => {
  const start = startOfWeek(weekDate, { weekStartsOn: 1 });
  const end = endOfWeek(weekDate, { weekStartsOn: 1 });
  const weekDays = eachDayOfInterval({ start, end });

  const pools = await prisma.pool.findMany({
    where: { tenantId, configurations: { some: {} } },
    include: { configurations: true },
  });

  const existingVisits = await prisma.visit.findMany({
    where: { pool: { tenantId }, timestamp: { gte: start, lte: end } },
  });

  const visitsToCreate: { poolId: string; timestamp: Date }[] = [];

  for (const day of weekDays) {
    for (const pool of pools) {
      
      const shouldVisitToday = pool.configurations.some(config => {
        if (config.frequency === 'DIARIA') return true;
        if (config.frequency === 'SEMANAL' && day.getDay() === 1) return true;
        return false;
      });

      if (shouldVisitToday) {
        const alreadyExists = existingVisits.some(
          (v) => v.poolId === pool.id && isSameDay(v.timestamp, day)
        );
        const alreadyInQueue = visitsToCreate.some(
          (v) => v.poolId === pool.id && isSameDay(v.timestamp, day)
        );

        if (!alreadyExists && !alreadyInQueue) {
          visitsToCreate.push({ poolId: pool.id, timestamp: day });
        }
      }
    }
  }

  if (visitsToCreate.length > 0) {
    await prisma.visit.createMany({
      data: visitsToCreate.map(v => ({ ...v, status: 'PENDING' })),
      skipDuplicates: true,
    });
  }

  return prisma.visit.findMany({
    where: { pool: { tenantId }, timestamp: { gte: start, lte: end } },
    include: { 
      pool: { include: { client: true } },
      technician: { select: { name: true } },
    },
    orderBy: { timestamp: 'asc' },
  });
};

export const assignTechnicianToVisit = async (visitId: string, technicianId: string | null) => {
    return prisma.visit.update({
        where: { id: visitId },
        data: { technicianId },
    });
};

export const getVisitsForTechnicianOnDate = async (
  technicianId: string,
  date: Date
): Promise<Visit[]> => {
  const dayStart = startOfDay(date);
  const dayEnd = endOfDay(date);

  return prisma.visit.findMany({
    where: {
      technicianId,
      status: 'PENDING',
      timestamp: {
        gte: dayStart,
        lte: dayEnd,
      },
    },
    include: {
      pool: {
        include: {
          client: true,
        },
      },
    },
    orderBy: {
      timestamp: 'asc',
    },
  });
};

export const getVisitDetails = async (visitId: string) => {
  return prisma.visit.findUnique({
    where: { id: visitId },
    include: {
      results: true, 
      notifications: {
        include: {
          images: true, // Esto es correcto, 'images' es la relaci√≥n en el modelo Notification
        }
      },
      consumptions: {
        include: {
          product: true,
        }
      },
      pool: {
        include: {
          client: true,
          configurations: {
            include: {
              parameterTemplate: true,
              taskTemplate: true,
            },
          },
        },
      },
    },
  });
};

export const submitWorkOrder = async (visitId: string, data: WorkOrderInput) => {
  return prisma.$transaction(async (tx) => {
    const visit = await tx.visit.findUnique({
      where: { id: visitId },
      include: { 
        pool: { 
          include: { 
            configurations: { include: { parameterTemplate: true, taskTemplate: true } } 
          } 
        },
        technician: true
      },
    });
    if (!visit || !visit.technicianId) throw new Error('Visita o t√©cnico no encontrados');
    
    const { results, completedTasks, notes, hasIncident, consumptions = [], imageUrls = [] } = data;

    if (consumptions && consumptions.length > 0) {
        const validConsumptions = consumptions
            .filter(c => c.productId && c.quantity && c.quantity > 0)
            .map(c => ({
                quantity: c.quantity,
                productId: c.productId,
                visitId: visitId,
            }));

        if (validConsumptions.length > 0) {
            await tx.consumption.createMany({
                data: validConsumptions,
            });
        }
    }

    for (const [configId, value] of Object.entries(results)) {
      if(value === '' || value === null) continue;
      const config = visit.pool.configurations.find(c => c.id === configId);
      if (config?.parameterTemplate) {
        await tx.visitResult.create({
          data: { visitId, value: String(value), parameterName: config.parameterTemplate.name, parameterUnit: config.parameterTemplate.unit, },
        });
      }
    }
    
    const completedTaskNames = Object.entries(completedTasks)
      .filter(([, completed]) => completed)
      .map(([configId]) => {
        const config = visit.pool.configurations.find(c => c.id === configId);
        return config?.taskTemplate?.name || 'Tarea desconocida';
      });
    
    await tx.visit.update({
      where: { id: visitId },
      data: { notes, hasIncident: hasIncident || false, completedTasks: completedTaskNames, status: 'COMPLETED', },
    });

    if (hasIncident) {
      const admin = await tx.user.findFirst({
        where: { tenantId: visit.pool.tenantId, role: 'ADMIN' },
      });
      if (admin) {
        const notificationMessage = notes && notes.trim().length > 0 
            ? notes 
            : `Incidencia reportada en ${visit.pool.name} por ${visit.technician?.name || 'un t√©cnico'}`;

        const newNotification = await tx.notification.create({
          data: { message: notificationMessage, tenantId: visit.pool.tenantId, userId: admin.id, visitId: visit.id, status: 'PENDING', },
        });
        
        if (imageUrls.length > 0) {
          // Aqu√≠ usamos el nombre correcto del modelo: `incidentImage`
          await tx.incidentImage.createMany({
            data: imageUrls.map(url => ({
              url: url,
              notificationId: newNotification.id,
              uploaderId: visit.technicianId!,
            })),
          });
        }
      }
    }
    
    const configIdsToUpdate = [...Object.keys(results).filter(k => results[k] !== ''), ...Object.keys(completedTasks).filter(k => completedTasks[k])];
    if(configIdsToUpdate.length > 0) {
        await tx.poolConfiguration.updateMany({
            where: { id: { in: configIdsToUpdate } },
            data: { lastCompleted: new Date() },
        });
    }
  });
};


// ====== [77] packages/server/src/app.ts ======
// filename: packages/server/src/app.ts
// version: 2.1.0 (Mount uploadsRouter)
import express from 'express';
import type { Request, Response } from 'express';
import cors from 'cors';
import cookieParser from 'cookie-parser';

import { errorHandler } from './middleware/error.middleware.js';
import authRouter from './api/auth/auth.routes.js';
import tenantsRouter from './api/tenants/tenants.routes.js';
import parametersRouter from './api/parameters/parameters.routes.js';
import tasksRouter from './api/tasks/tasks.routes.js';
import clientsRouter from './api/clients/clients.routes.js';
import poolsRouter from './api/pools/pools.routes.js';
import poolConfigurationsRouter from './api/pool-configurations/pool-configurations.routes.js';
import visitsRouter from './api/visits/visits.routes.js';
import usersRouter from './api/users/users.routes.js';
import notificationsRouter from './api/notifications/notifications.routes.js';
import productsRouter from './api/products/products.routes.js';
import incidentTasksRouter from './api/incident-tasks/incident-tasks.routes.js';
import uploadsRouter from './api/uploads/uploads.routes.js'; // <-- 1. Importar

// --- Instancia de la App ---
const app = express();

// --- Middlewares Esenciales ---
app.use(cors({
  origin: 'http://localhost:5173',
  credentials: true,
}));
app.use(cookieParser());
app.use(express.json());


// --- Rutas de la API ---

app.get('/api/health', (_req: Request, res: Response) => {
  res.status(200).json({ status: 'UP' });
});

app.use('/api/auth', authRouter);
app.use('/api/tenants', tenantsRouter);
app.use('/api/parameters', parametersRouter);
app.use('/api/tasks', tasksRouter);
app.use('/api/clients', clientsRouter);
app.use('/api/pools', poolsRouter);
app.use('/api/pool-configurations', poolConfigurationsRouter);
app.use('/api/visits', visitsRouter);
app.use('/api/users', usersRouter);
app.use('/api/notifications', notificationsRouter);
app.use('/api/products', productsRouter);
app.use('/api/incident-tasks', incidentTasksRouter);
app.use('/api/uploads', uploadsRouter); // <-- 2. Montar

// --- Gestor de Errores ---
app.use(errorHandler);

export default app;


// ====== [78] packages/server/src/config/index.ts ======
// filename: packages/server/src/config/index.ts
// version: 2.0.0 (Add Cloudinary credentials)

import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

// --- Recreaci√≥n de __dirname para ES Modules ---
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
// ---------------------------------------------

dotenv.config({ path: path.resolve(__dirname, '../../.env') });

const getEnvVar = (key: string): string => {
  const value = process.env[key];
  if (!value) {
    throw new Error(`Falta la variable de entorno requerida: ${key}`);
  }
  return value;
};

const config = {
  PORT: parseInt(getEnvVar('PORT'), 10),
  JWT_SECRET: getEnvVar('JWT_SECRET'),
  JWT_EXPIRES_IN: parseInt(getEnvVar('JWT_EXPIRES_IN'), 10),
  DATABASE_URL: getEnvVar('DATABASE_URL'),

  // --- Nuevas credenciales de Cloudinary ---
  CLOUDINARY_CLOUD_NAME: getEnvVar('CLOUDINARY_CLOUD_NAME'),
  CLOUDINARY_API_KEY: getEnvVar('CLOUDINARY_API_KEY'),
  CLOUDINARY_API_SECRET: getEnvVar('CLOUDINARY_API_SECRET'),
};

export default config;


// ====== [79] packages/server/src/middleware/auth.middleware.ts ======
import type { Request, Response, NextFunction } from 'express';
import { PrismaClient } from '@prisma/client';
import type { User } from '@prisma/client';
import { verifyToken } from '../utils/jwt.utils.js';

const prisma = new PrismaClient();

// Creamos un tipo "seguro" para el usuario, omitiendo la contrase√±a.
type SafeUser = Omit<User, 'password'>;

// Extendemos la interfaz Request de Express para que use nuestro tipo SafeUser.
export interface AuthRequest extends Request {
  user?: SafeUser;
}

/**
 * Middleware para proteger rutas. Verifica el token JWT de la cookie.
 * Si el token es v√°lido, adjunta el usuario a la request y pasa al siguiente middleware.
 * Si no, devuelve un error 401 (No autorizado).
 */
export const protect = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  const token = req.cookies.token;

  if (!token) {
    return res.status(401).json({ message: 'No autenticado: no hay token.' });
  }

  try {
    const decoded = verifyToken<{ id: string }>(token);

    if (!decoded) {
      return res.status(401).json({ message: 'No autenticado: token inv√°lido.' });
    }

    const user = await prisma.user.findUnique({
      where: { id: decoded.id },
      // Seleccionamos todos los campos EXCEPTO la contrase√±a.
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        tenantId: true,
        createdAt: true,
        updatedAt: true,
      },
    });

    if (!user) {
      return res.status(401).json({ message: 'No autenticado: usuario no encontrado.' });
    }

    // Ahora `user` coincide con el tipo `SafeUser`, por lo que la asignaci√≥n es v√°lida.
    req.user = user;
    next();
  } catch (error) {
    return res.status(401).json({ message: 'No autenticado: error en la validaci√≥n.' });
  }
};


// ====== [80] packages/server/src/middleware/error.middleware.ts ======
import type { Request, Response, NextFunction } from 'express';

// Interfaz para asegurar que nuestros errores puedan tener un c√≥digo de estado
interface HttpError extends Error {
  statusCode?: number;
}

export const errorHandler = (
  err: HttpError,
  _req: Request,
  res: Response,
  _next: NextFunction
) => {
  // Guardamos el error en la consola para depuraci√≥n
  console.error(err);

  const statusCode = err.statusCode || 500;
  const message = err.message || 'Ha ocurrido un error inesperado en el servidor.';

  res.status(statusCode).json({
    success: false,
    statusCode: statusCode,
    message: message,
  });
};


// ====== [81] packages/server/src/server.ts ======
import app from './app.js';
import config from './config/index.js';

const PORT = config.PORT || 3001;

app.listen(PORT, () => {
  console.log(`üöÄ Servidor escuchando en http://localhost:${PORT}`);
});


// ====== [82] packages/server/src/utils/jwt.utils.ts ======
import jwt from 'jsonwebtoken';
import type { SignOptions } from 'jsonwebtoken';
import config from '../config/index.js';

/**
 * Firma un payload para crear un token JWT.
 * @param payload El objeto que se incluir√° en el token (ej. { userId: '...' }).
 * @returns El token JWT como una cadena de texto.
 */
export const signToken = (payload: object): string => {
  const options: SignOptions = {
    expiresIn: config.JWT_EXPIRES_IN,
  };

  return jwt.sign(payload, config.JWT_SECRET, options);
};

/**
 * Verifica un token JWT y devuelve su payload si es v√°lido.
 * @template T El tipo esperado del payload.
 * @param token El token JWT a verificar.
 * @returns El payload decodificado si el token es v√°lido; de lo contrario, null.
 */
export const verifyToken = <T>(token: string): T | null => {
  try {
    const decoded = jwt.verify(token, config.JWT_SECRET) as T;
    return decoded;
  } catch (error) {
    return null;
  }
};


// ====== [83] packages/server/src/utils/password.utils.ts ======
import bcrypt from 'bcryptjs';

const SALT_ROUNDS = 12;

/**
 * Genera el hash de una contrase√±a en texto plano.
 * @param password La contrase√±a en texto plano.
 * @returns Una promesa que resuelve en el hash de la contrase√±a.
 */
export const hashPassword = (password: string): Promise<string> => {
  return bcrypt.hash(password, SALT_ROUNDS);
};

/**
 * Compara una contrase√±a en texto plano con un hash.
 * @param password La contrase√±a en texto plano a comparar.
 * @param hash El hash almacenado en la base de datos.
 * @returns Una promesa que resuelve en `true` si las contrase√±as coinciden, `false` en caso contrario.
 */
export const comparePassword = (password: string, hash: string): Promise<boolean> => {
  return bcrypt.compare(password, hash);
};


// ====== [84] packages/server/tsconfig.json ======
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist"
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules"]
}


// ====== [85] tsconfig.json ======
{
  "compilerOptions": {
    /* Base Options */
    "esModuleInterop": true,
    "skipLibCheck": true,
    "target": "ES2022",
    "allowJs": true,
    "resolveJsonModule": true,
    "moduleDetection": "force",
    "isolatedModules": true,
    "verbatimModuleSyntax": true,

    /* Strictness */
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitAny": true,

    /* Module Resolution */
    "moduleResolution": "NodeNext",
    "module": "NodeNext",

    /* Linter */
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true
  },
  "exclude": ["node_modules"]
}

