# √çNDICE DE ARCHIVOS (ESTRUCTURA REFACTORIZADA)

1. DEVELOPMENT_PLAN.md
2. PROJECT_STATUS.md
3. README.md
4. package.json
5. packages/client/index.html
6. packages/client/package.json
7. packages/client/src/App.tsx
8. packages/client/src/api/apiClient.ts
9. packages/client/src/features/admin/pages/ParameterCatalogPage.tsx
10. packages/client/src/features/admin/pages/TaskCatalogPage.tsx
11. packages/client/src/features/admin/pages/clients/ClientDetailPage.tsx
12. packages/client/src/features/admin/pages/clients/ClientsPage.tsx
13. packages/client/src/features/admin/pages/planner/PlannerPage.tsx
14. packages/client/src/features/admin/pages/pools/PoolDetailPage.tsx
15. packages/client/src/features/auth/pages/LoginPage.tsx
16. packages/client/src/features/superadmin/pages/TenantsPage.tsx
17. packages/client/src/features/technician/pages/MyRoutePage.tsx
18. packages/client/src/features/technician/pages/WorkOrderPage.tsx
19. packages/client/src/main.tsx
20. packages/client/src/providers/AuthProvider.tsx
21. packages/client/src/router/components.tsx
22. packages/client/src/router/index.tsx
23. packages/client/src/styles/theme.ts
24. packages/client/tsconfig.json
25. packages/client/tsconfig.node.json
26. packages/client/vite.config.ts
27. packages/server/package.json
28. packages/server/prisma/seed.ts
29. packages/server/src/api/auth/auth.controller.ts
30. packages/server/src/api/auth/auth.routes.ts
31. packages/server/src/api/auth/auth.service.ts
32. packages/server/src/api/clients/clients.controller.ts
33. packages/server/src/api/clients/clients.routes.ts
34. packages/server/src/api/clients/clients.service.ts
35. packages/server/src/api/parameters/parameters.controller.ts
36. packages/server/src/api/parameters/parameters.routes.ts
37. packages/server/src/api/parameters/parameters.service.ts
38. packages/server/src/api/pool-configurations/pool-configurations.controller.ts
39. packages/server/src/api/pool-configurations/pool-configurations.routes.ts
40. packages/server/src/api/pool-configurations/pool-configurations.service.ts
41. packages/server/src/api/pools/pools.controller.ts
42. packages/server/src/api/pools/pools.routes.ts
43. packages/server/src/api/pools/pools.service.ts
44. packages/server/src/api/tasks/tasks.controller.ts
45. packages/server/src/api/tasks/tasks.routes.ts
46. packages/server/src/api/tasks/tasks.service.ts
47. packages/server/src/api/tenants/tenants.controller.ts
48. packages/server/src/api/tenants/tenants.routes.ts
49. packages/server/src/api/tenants/tenants.service.ts
50. packages/server/src/api/users/users.controller.ts
51. packages/server/src/api/users/users.routes.ts
52. packages/server/src/api/users/users.service.ts
53. packages/server/src/api/visits/visits.controller.ts
54. packages/server/src/api/visits/visits.routes.ts
55. packages/server/src/api/visits/visits.service.ts
56. packages/server/src/app.ts
57. packages/server/src/config/index.ts
58. packages/server/src/middleware/auth.middleware.ts
59. packages/server/src/middleware/error.middleware.ts
60. packages/server/src/server.ts
61. packages/server/src/utils/jwt.utils.ts
62. packages/server/src/utils/password.utils.ts
63. packages/server/tsconfig.json
64. tsconfig.json


# CONTENIDO DE ARCHIVOS


// ====== [1] DEVELOPMENT_PLAN.md ======
# Plan de Desarrollo y Arquitectura: Pool-Control Professional

Este documento es la hoja de ruta arquitect√≥nica y el registro de implementaci√≥n para el proyecto. Sirve tanto de gu√≠a para el trabajo futuro como de cr√≥nica de las decisiones tomadas, garantizando un entendimiento profundo del sistema en cualquier punto de su ciclo de vida.

---

## ‚úÖ FASE 0: Fundaci√≥n del Entorno y Monorepo

- **Estado:** `COMPLETADA`
- **Intenci√≥n Arquitect√≥nica:** Establecer una base de desarrollo moderna, escalable y mantenible, donde el backend y el frontend, aunque desacoplados, pudieran ser gestionados desde un √∫nico repositorio para agilizar el desarrollo.
- **Entregables Clave:**
  - **Monorepo con PNPM:** Se adopt√≥ `pnpm` con `workspaces` para una gesti√≥n de dependencias ultra-eficiente y la capacidad de ejecutar scripts de forma centralizada.
  - **Configuraci√≥n Maestra de TypeScript:** Se defini√≥ un `tsconfig.json` ra√≠z con reglas estrictas (`strict: true`) y configuraci√≥n para ES Modules (`module: NodeNext`), forzando un c√≥digo de alta calidad y moderno desde el inicio.

---

## ‚úÖ FASE 1: Fundaci√≥n del Backend

- **Estado:** `COMPLETADA`
- **Intenci√≥n Arquitect√≥nica:** Construir un servidor API robusto, seguro y preparado para crecer. El objetivo era tener una base s√≥lida sobre la cual construir todos los m√≥dulos de negocio.
- **Entregables Clave:**
  - **Servidor Express.js:** Se mont√≥ un servidor con una estructura modular (`app.ts` para configuraci√≥n, `server.ts` para arranque), usando ES Modules nativos.
  - **Persistencia con Prisma:** Se defini√≥ el `schema.prisma` como la "√∫nica fuente de verdad" para el modelo de datos y se estableci√≥ la conexi√≥n con PostgreSQL.
  - **Seguridad y Autenticaci√≥n:** Se implement√≥ un sistema de autenticaci√≥n completo y seguro:
    - **Middleware `protect`:** Un guardi√°n para nuestras rutas, que verifica la validez de los tokens JWT enviados a trav√©s de cookies `httpOnly`.
    - **Endpoints de Autenticaci√≥n:** Se crearon las rutas `/api/auth/login`, `/logout`, `/register` y `/me`, que constituyen el portal de entrada a la aplicaci√≥n.
  - **Script de `seed`:** Se cre√≥ un script para poblar la base de datos con datos esenciales (como el `SUPER_ADMIN`), permitiendo un entorno de desarrollo consistente y eliminando la necesidad de creaci√≥n manual de datos cr√≠ticos.

---

## ‚úÖ FASE 2: Fundaci√≥n del Frontend

- **Estado:** `COMPLETADA`
- **Intenci√≥n Arquitect√≥nica:** Crear una aplicaci√≥n de cliente reactiva, r√°pida y con una excelente experiencia de usuario, estableciendo los patrones de dise√±o que se usar√≠an en todo el frontend.
- **Entregables Clave:**
  - **Aplicaci√≥n React con Vite:** Se eligi√≥ Vite por su velocidad y su excelente experiencia de desarrollo.
  - **Gesti√≥n de Estado Global (`AuthProvider`):** Se implement√≥ un `React Context` para gestionar el estado de autenticaci√≥n del usuario. Este provider es el responsable de mantener la sesi√≥n activa entre recargas de p√°gina, comunic√°ndose con el endpoint `/api/auth/me`.
  - **Enrutamiento Protegido:** Se cre√≥ un sistema de enrutamiento con `react-router-dom`, definiendo el concepto de `ProtectedRoute` y rutas espec√≠ficas por rol (`AdminRoute`, `SuperAdminRoute`), un pilar de la seguridad de la interfaz.
  - **Base de UI con Mantine:** Se estableci√≥ Mantine UI como la librer√≠a de componentes y se configur√≥ un `theme` personalizado para una est√©tica coherente.

---

## ‚úÖ FASE 3: M√≥dulo de Gesti√≥n (SuperAdmin y Admin)

- **Estado:** `COMPLETADA`
- **Intenci√≥n de Negocio:** Digitalizar y automatizar por completo las tareas de configuraci√≥n y planificaci√≥n, empoderando al `ADMIN` para que sea 100% aut√≥nomo.
- **Entregables Clave:**
  - **CRUD de Tenants (SuperAdmin):** API y UI para que el SuperAdmin gestione el ciclo de vida de sus clientes.
  - **CRUD de Cat√°logos (Admin):** API y UI para que el Admin defina sus `Par√°metros` y `Tareas` de servicio.
  - **CRUD de Clientes y Piscinas (Admin):** API y UI para gestionar la cartera de clientes y sus piscinas.
  - **Constructor de Fichas (Admin):** L√≥gica de negocio y UI para asociar √≠tems del cat√°logo a piscinas, definiendo `frecuencia` y `umbrales`.
  - **Planificador de Rutas (Admin):** Una de las funcionalidades m√°s complejas. Se implement√≥ una l√≥gica de backend que genera visitas y una interfaz `Drag and Drop` para la asignaci√≥n a t√©cnicos.

---

## ‚úÖ FASE 4: M√≥dulo de Ejecuci√≥n (T√©cnico)

- **Estado:** `COMPLETADA`
- **Intenci√≥n de Negocio:** Optimizar al m√°ximo el trabajo de campo del t√©cnico, proporcion√°ndole una herramienta clara, r√°pida y que elimina la necesidad de partes de trabajo en papel.
- **Entregables Clave:**
  - **"Mi Ruta de Hoy":** API y UI que presentan al t√©cnico una lista clara de sus visitas pendientes para el d√≠a actual.
  - **"Parte de Trabajo Din√°mico":** La funcionalidad estrella.
    - **Backend:** Se implement√≥ la l√≥gica `submitWorkOrder` dentro de una transacci√≥n de Prisma para garantizar la atomicidad de los datos. Guarda resultados, tareas completadas, notas, e incidencias.
    - **Frontend:** La `WorkOrderPage` renderiza un formulario a medida para cada visita, bas√°ndose en la configuraci√≥n definida por el `ADMIN`.
  - **Reporte de Incidencias:** Se implement√≥ el flujo completo, desde el `Checkbox` en el parte del t√©cnico hasta la creaci√≥n de un registro `Notification` en la base de datos.

---

## ‚ñ∂Ô∏è FASE 5: Cierre de Bucles y Experiencia de Usuario

- **Estado:** `EN CURSO`
- **Intenci√≥n de Negocio:** Conectar los flujos de informaci√≥n y mejorar la interfaz para proporcionar una experiencia de usuario cohesiva y completa.
- **Plan de Acci√≥n Detallado:**
  1.  **Sistema de Notificaciones (Admin):**
      - **Prop√≥sito:** Hacer visibles las incidencias reportadas por los t√©cnicos.
      - **Tareas:**
        - **Backend:** Crear la API CRUD para `/api/notifications`.
        - **Frontend:** A√±adir un componente "campana" en el `AppLayout` que muestre un indicador y un men√∫ desplegable con las notificaciones.
  2.  **Dashboard Principal (Admin):**
      - **Prop√≥sito:** Dar al `ADMIN` una vista r√°pida del estado de la operativa diaria.
      - **Tareas:** Reemplazar el `div` actual por un panel que muestre "Visitas de hoy" y "√öltimas Incidencias".
  3.  **Mejoras en el Planificador (Admin):**
      - **Prop√≥sito:** Proporcionar m√°s informaci√≥n visual al `ADMIN`.
      - **Tareas:** Diferenciar visualmente las visitas `PENDING` de las `COMPLETED` en el planificador (ej. con colores o transparencia).
  4.  **Gesti√≥n de Consumo de Productos (T√©cnico y Admin):**
      - **Prop√≥sito:** Empezar a registrar los costes asociados a cada visita.
      - **Tareas:**
        - **Backend y Frontend:** Implementar el CRUD para el cat√°logo de `Product`.
        - **Frontend:** A√±adir una secci√≥n en el `WorkOrderPage` para que el t√©cnico pueda registrar los productos consumidos.
        - **Backend:** Modificar `submitWorkOrder` para guardar los registros `Consumption`.

---

## üîÆ FASE 6 Y POSTERIORES: Funcionalidades Avanzadas

- **Estado:** `PLANIFICADO`
- **Intenci√≥n de Negocio:** A√±adir capas de inteligencia de negocio y expandir las capacidades de la plataforma.
- **Ideas Clave:**
  - **Modo Offline (PWA):** Implementar la capacidad de trabajo sin conexi√≥n para el t√©cnico.
  - **Dashboard de Gerencia (`MANAGER`):** Desarrollar los KPIs y gr√°ficos.
  - **Sistema de Facturaci√≥n:** Generar informes de consumo por cliente.



// ====== [2] PROJECT_STATUS.md ======
# Estado del Proyecto: Pool-Control Professional

_√öltima actualizaci√≥n: 9 de julio de 2025, 11:30 CEST_

---

## 1. Resumen Ejecutivo

El proyecto ha alcanzado un hito cr√≠tico: la finalizaci√≥n del **flujo operativo principal completo**. Desde la configuraci√≥n inicial por parte del Administrador hasta la ejecuci√≥n en campo por parte del T√©cnico, la aplicaci√≥n ahora soporta el ciclo de vida completo de una visita de mantenimiento. Se ha validado con √©xito la creaci√≥n, asignaci√≥n, ejecuci√≥n y finalizaci√≥n de tareas, incluyendo el reporte de incidencias.

La infraestructura de backend y frontend ha demostrado ser robusta y escalable. Los m√≥dulos de `SUPER_ADMIN` y `ADMIN` est√°n completos, y el m√≥dulo de `TECHNICIAN` tiene su funcionalidad esencial implementada.

Con el "camino feliz" del flujo de trabajo ya construido, el proyecto entra en una nueva fase centrada en **enriquecer la experiencia del usuario y cerrar los bucles de comunicaci√≥n**, comenzando por el desarrollo del sistema de notificaciones para el Administrador.

---

## 2. Hitos Completados y Entregables

### ‚úÖ **M√≥dulo de Ejecuci√≥n (T√©cnico): Parte de Trabajo**

- **Estado:** `COMPLETADO Y VALIDADO`.
- **Descripci√≥n Detallada:** Se ha construido la funcionalidad m√°s importante de la aplicaci√≥n, que permite al t√©cnico registrar su trabajo de forma digital.
  - **API de Soporte:** Se implementaron los endpoints necesarios en el backend (`GET /api/visits/:id` para obtener los detalles y `POST /api/visits/:id/complete` para guardar el trabajo).
  - **P√°gina del Parte de Trabajo:** Se cre√≥ la `WorkOrderPage.tsx`, que se enlaza desde la ruta del d√≠a.
  - **Renderizado Din√°mico:** La p√°gina es "inteligente": lee la configuraci√≥n espec√≠fica de la piscina (definida por el `ADMIN`) y construye el formulario sobre la marcha, mostrando √∫nicamente los par√°metros y tareas que corresponden.
  - **Gesti√≥n de Estado:** Se utiliza el hook `useForm` de Mantine para gestionar de forma eficiente todos los datos introducidos por el t√©cnico.
  - **L√≥gica de Finalizaci√≥n:** Al guardar, la API procesa todos los datos, crea los registros de `VisitResult` en la base de datos, actualiza el estado de la `Visit` a `COMPLETED` y, crucialmente, la visita desaparece de la lista de tareas pendientes del t√©cnico, confirmando que el ciclo se ha cerrado correctamente.

### ‚úÖ **Sistema de Reporte de Incidencias (Backend)**

- **Estado:** `COMPLETADO Y VALIDADO`.
- **Descripci√≥n Detallada:** Se ha implementado la mec√°nica para que un t√©cnico pueda escalar un problema al administrador.
  - **Modificaci√≥n del Schema:** Se a√±adi√≥ el campo `hasIncident` al modelo `Visit` y se cre√≥ el nuevo modelo `Notification`.
  - **L√≥gica en el Servidor:** La funci√≥n `submitWorkOrder` ahora comprueba si el `Checkbox` de incidencia fue marcado. Si es `true`, crea un nuevo registro en la tabla `Notification` asignado al `ADMIN` de ese tenant, con un mensaje descriptivo.
  - **Pr√≥ximos Pasos:** La creaci√≥n de la notificaci√≥n funciona, pero el `ADMIN` todav√≠a no tiene una forma de verla en la interfaz.

### ‚úÖ **Refactorizaci√≥n de la L√≥gica del Planificador**

- **Estado:** `COMPLETADO Y VALIDADO`.
- **Descripci√≥n Detallada:** Tras detectar inconsistencias en la generaci√≥n de visitas, se ha reescrito por completo la l√≥gica del servicio `getScheduledVisitsForWeek`. El nuevo sistema es m√°s robusto y predecible:
  - **Generaci√≥n Proactiva:** El sistema ahora crea registros `Visit` con estado `PENDING` si detecta que una visita deber√≠a ocurrir en un d√≠a de la semana y a√∫n no existe un registro para ella.
  - **Consistencia:** Esto asegura que tanto el Planificador del `ADMIN` como la "Ruta de Hoy" del `TECHNICIAN` operen sobre la misma fuente de datos (la tabla `Visit`), eliminando la fuente de errores anterior. Se ha validado que ahora el planificador muestra la semana completa correctamente.

---

## 3. Decisiones Arquitect√≥nicas y Funcionales Clave

- **Flujo de Datos del Planificador:** Se ha decidido que el Planificador no solo "visualiza" eventos futuros, sino que **materializa las visitas** creando registros en la base de datos con estado `PENDING`. Esto simplifica enormemente la l√≥gica de asignaci√≥n y seguimiento.
- **Modelo de Notificaciones:** Se opt√≥ por un sistema de notificaciones **interno y basado en la base de datos**, en lugar de depender de servicios externos como el email. Esto nos da un control total sobre el flujo y la presentaci√≥n de las alertas.
- **Modo Offline (PWA):** Sigue siendo una funcionalidad clave planificada para una fase posterior, utilizando Service Workers e IndexedDB.

---

## 4. Pr√≥ximo Paso Inmediato: Interfaz de Notificaciones

La siguiente tarea es cerrar el bucle del "Reporte de Incidencias", haciendo que sean visibles para el `ADMIN`.

- **Objetivo:** A√±adir un indicador visual de notificaciones en la interfaz del `ADMIN` y una vista para leerlas.
- **Plan de Acci√≥n:**
  1.  **Backend - API para Notificaciones:**
      - **Archivo:** Crear `packages/server/src/api/notifications/notifications.service.ts` y sus correspondientes controlador y rutas.
      - **Tarea:** Implementar un endpoint `GET /api/notifications` que devuelva las notificaciones del usuario logueado. Implementar otro endpoint `POST /api/notifications/:id/read` para marcarlas como le√≠das.
  2.  **Frontend - Componente de Notificaciones:**
      - **Archivo:** Modificar `packages/client/src/router/components.tsx` (`AppLayout`).
      - **Tarea:** A√±adir un icono de "campana" en la cabecera. Este icono har√° una llamada a la API de notificaciones y mostrar√° un punto rojo si hay notificaciones sin leer.
      - **Tarea:** Al hacer clic en la campana, se mostrar√° un `Popover` o `Menu` con la lista de mensajes. Al hacer clic en un mensaje, se marcar√° como le√≠do.

---

## 5. Bloqueos Actuales

- **Ninguno.** El proyecto est√° completamente desbloqueado y en un estado excelente para continuar.



// ====== [3] README.md ======
# Documento de Especificaci√≥n Funcional v2.1: Sistema "Pool-Control Professional"

**Documentos del Proyecto:**
[Ver Plan de Desarrollo](./DEVELOPMENT_PLAN.md) | [Ver Estado del Proyecto](./PROJECT_STATUS.md)

---

**Fecha:** 9 de julio de 2025
**Proyecto:** Plataforma Integral de Gesti√≥n para Empresas de Mantenimiento de Piscinas.

---

## 1. Visi√≥n y Objetivos de Negocio

**Pool-Control Professional** es una plataforma SaaS multi-tenant dise√±ada para ser el sistema nervioso central de una empresa de mantenimiento de piscinas. Su prop√≥sito es erradicar la ineficiencia, eliminar el papel, controlar los costes y elevar la calidad del servicio a trav√©s de la digitalizaci√≥n y automatizaci√≥n de todos los procesos operativos.

#### Objetivos Clave:

- **Eficiencia Operativa Absoluta:** Transformar horas de trabajo administrativo en minutos. La planificaci√≥n de rutas, la generaci√≥n de partes de trabajo y la recopilaci√≥n de datos deben ser procesos autom√°ticos o semi-autom√°ticos.
- **Control Total de la Rentabilidad:** Proporcionar una visi√≥n clara y en tiempo real del consumo de productos por visita, por piscina y por cliente, permitiendo un control de costes y una facturaci√≥n precisa.
- **Calidad de Servicio Estandarizada y Proactiva:** Garantizar que cada t√©cnico realice exactamente los mismos procedimientos definidos para cada piscina y que cualquier desviaci√≥n o incidencia sea notificada al instante, pasando de un modelo reactivo a uno proactivo.
- **Toma de Decisiones Basada en Datos:** Ofrecer a la gerencia KPIs y m√©tricas fiables sobre la operativa del negocio para identificar puntos de mejora, clientes m√°s rentables y t√©cnicos m√°s eficientes.

---

## 2. Definici√≥n de Roles y Flujos de Autorizaci√≥n

El sistema se estructura en torno a roles con permisos estrictos para garantizar la seguridad y la focalizaci√≥n de cada usuario en sus responsabilidades.

| Rol                  | Misi√≥n Principal                                  | Capacidades Clave                                                                                                                                                                                                                                                                                |
| -------------------- | ------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **SuperAdmin**       | Gestionar la plataforma y sus clientes (tenants). | CRUD completo sobre los **Tenants**. Gesti√≥n de suscripciones y ciclo de vida de las empresas que usan el software. No tiene visibilidad sobre los datos operativos (clientes, piscinas) de los tenants.                                                                                         |
| **Admin (Isa)**      | Configurar y dirigir la operativa de su empresa.  | Control absoluto sobre la configuraci√≥n del tenant: **definir el cat√°logo de servicios**, gestionar clientes y piscinas, **dise√±ar las fichas de mantenimiento**, planificar rutas, y supervisar toda la operativa a trav√©s de un **centro de notificaciones**. Es el "arquitecto" del servicio. |
| **T√©cnico**          | Ejecutar el trabajo en campo de forma eficiente.  | Acceso exclusivo a su **ruta de trabajo del d√≠a**. Su √∫nica misi√≥n es ejecutar las visitas asignadas y rellenar los **partes de trabajo** con los datos requeridos. Interfaz 100% optimizada para m√≥vil y dise√±ada para funcionar incluso en condiciones de baja conectividad (futuro).          |
| **Gerencia (Jorge)** | Supervisar la salud y rendimiento del negocio.    | Acceso de **solo lectura** a toda la configuraci√≥n y datos operativos del `ADMIN`. Su objetivo es el an√°lisis a trav√©s de dashboards y reportes, sin la capacidad de alterar ning√∫n dato, garantizando la integridad de la informaci√≥n.                                                          |

---

## 3. Flujo de Trabajo y Especificaci√≥n Funcional Detallada

El sistema est√° dise√±ado como un ciclo continuo donde la configuraci√≥n define la ejecuci√≥n y la ejecuci√≥n retroalimenta la supervisi√≥n.

### **ETAPA 1: Configuraci√≥n del Servicio (Rol: Admin)**

Esta etapa es el coraz√≥n del sistema. El `ADMIN` define "el qu√©, c√≥mo y cu√°ndo" del servicio que ofrece su empresa.

#### **Pantalla: Cat√°logo de Servicios (Par√°metros y Tareas)**

- **Prop√≥sito:** Crear una librer√≠a centralizada de todas las acciones y mediciones que la empresa puede realizar. Este es el primer paso y la base de todo.
- **Funcionalidad:**
  - **Gesti√≥n de Par√°metros:** El `ADMIN` crea plantillas para cada medici√≥n (ej. "Nivel de pH"). Para cada una, define su `Nombre`, `Unidad` y `Tipo de Input` (`NUMBER`, `BOOLEAN`, `TEXT` o `SELECT` con opciones).
  - **Gesti√≥n de Tareas:** El `ADMIN` crea plantillas para cada acci√≥n f√≠sica (ej. "Limpieza de cestos de skimmers").

#### **Pantalla: Gesti√≥n de Clientes y Piscinas**

- **Prop√≥sito:** Gestionar la cartera de clientes y sus activos (las piscinas).
- **Funcionalidad:**
  - **CRUD de Clientes:** El `ADMIN` gestiona la base de datos de clientes.
  - **CRUD de Piscinas:** Dentro de la ficha de cada cliente, el `ADMIN` puede a√±adir m√∫ltiples piscinas.

#### **Pantalla: Constructor de Fichas de Mantenimiento (Pool Detail Page)**

- **Prop√≥sito:** Definir el "contrato de servicio" espec√≠fico y √∫nico para **cada piscina**.
- **Flujo de Trabajo:** El `ADMIN` asocia √≠tems de los cat√°logos a la ficha de esa piscina y, para cada uno, establece las reglas de negocio: `Frecuencia` (¬øCada cu√°nto?) y `Umbrales de Alerta` (¬øCu√°l es el rango aceptable?).

### **ETAPA 2: Planificaci√≥n y Ejecuci√≥n (Roles: Admin y T√©cnico)**

#### **Pantalla: Planificador Semanal (Rol: Admin)**

- **Prop√≥sito:** Organizar la carga de trabajo de la semana y asignarla al equipo.
- **Flujo de Trabajo:** El sistema genera autom√°ticamente las visitas pendientes seg√∫n la frecuencia. El `ADMIN` las arrastra y suelta sobre el t√©cnico y d√≠a deseado.

#### **Pantalla: Mi Ruta de Hoy (Rol: T√©cnico)**

- **Prop√≥sito:** Proporcionar al t√©cnico un plan de acci√≥n diario, claro y directo.
- **Estado de Implementaci√≥n:** `COMPLETADA Y OPERATIVA`.
- **Flujo de Trabajo:** Al iniciar sesi√≥n, el t√©cnico ve una lista ordenada de sus visitas `PENDIENTES` para el d√≠a. La direcci√≥n es un enlace a Google Maps/Apple Maps y cada tarjeta de visita conduce al "Parte de Trabajo".

#### **Pantalla: Parte de Trabajo Din√°mico (Rol: T√©cnico)**

- **Prop√≥sito:** Registrar los datos de la visita de forma r√°pida, estructurada y a prueba de errores.
- **Estado de Implementaci√≥n:** `COMPLETADA Y OPERATIVA`.
- **Flujo de Trabajo:**
  1.  Al entrar, la p√°gina construye un **formulario din√°mico** basado en la configuraci√≥n de la piscina.
  2.  El t√©cnico rellena los valores. La UI le proporciona feedback instant√°neo si un valor est√° fuera de los umbrales.
  3.  **Reporte de Incidencias:** Junto a un campo de "Observaciones", el t√©cnico dispone de un **checkbox "Reportar como Incidencia"**. Si lo marca, al guardar el parte se generar√° una notificaci√≥n interna autom√°tica para el `ADMIN`, inform√°ndole del problema.
  4.  Al guardar, los datos se env√≠an a la API, la visita se marca como `COMPLETED` y desaparece de la lista de tareas pendientes del t√©cnico.
- **Mejora Futura Planificada:** Implementaci√≥n de un **Modo Offline** (PWA) que permitir√° rellenar y guardar el parte sin conexi√≥n a internet, sincroniz√°ndose autom√°ticamente al recuperar la se√±al.

### **ETAPA 3: Supervisi√≥n y An√°lisis (Roles: Admin y Gerencia)**

#### **Pantalla: Centro de Notificaciones (Rol: Admin)**

- **Prop√≥sito:** Centralizar y gestionar las incidencias reportadas por los t√©cnicos.
- **Estado de Implementaci√≥n:** `EN DESARROLLO`.
- **Funcionalidad Prevista:** El `ADMIN` tendr√° un icono de "campana" en la interfaz. Un indicador le avisar√° de nuevas notificaciones. Al hacer clic, podr√° ver una lista de las incidencias, acceder a los detalles de la visita asociada y marcarlas como le√≠das o gestionadas.

#### **Pantalla: Dashboards y Reportes (Rol: Gerencia)**

- **Prop√≥sito:** Ofrecer una visi√≥n de alto nivel para la toma de decisiones estrat√©gicas.
- **Funcionalidad Prevista:** Jorge, en modo **solo lectura**, acceder√° a paneles con KPIs sobre rentabilidad, costes, incidencias y rendimiento de los t√©cnicos.



// ====== [4] package.json ======
{
  "name": "pool-control-professional",
  "private": true,
  "version": "1.0.0",
  "description": "SaaS para la gesti√≥n integral de empresas de mantenimiento de piscinas.",
  "author": "",
  "license": "ISC",
  "scripts": {
    "dev:server": "pnpm --filter @pool-control/server dev",
    "dev:client": "pnpm --filter @pool-control/client dev",
    "build": "pnpm --filter \"./packages/**\" build",
    "prisma:generate": "pnpm --filter @pool-control/server prisma:generate",
    "prisma:migrate": "pnpm --filter @pool-control/server prisma:migrate",
    "prisma:studio": "pnpm --filter @pool-control/server prisma:studio"
  },
  "devDependencies": {
    "typescript": "^5.4.5"
  },
  "engines": {
    "node": ">=20.0.0",
    "pnpm": ">=9.0.0"
  }
}


// ====== [5] packages/client/index.html ======
<!doctype html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Pool-Control Professional</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>


// ====== [6] packages/client/package.json ======
{
  "name": "@pool-control/client",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite --host",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "@dnd-kit/core": "^6.3.1",
    "@mantine/core": "^7.10.1",
    "@mantine/form": "^8.1.3",
    "@mantine/hooks": "^7.10.1",
    "axios": "^1.7.2",
    "date-fns": "^4.1.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.23.1"
  },
  "devDependencies": {
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@typescript-eslint/eslint-plugin": "^7.13.0",
    "@typescript-eslint/parser": "^7.13.0",
    "@vitejs/plugin-react": "^4.3.1",
    "eslint": "^8.57.0",
    "eslint-plugin-react-hooks": "^4.6.2",
    "eslint-plugin-react-refresh": "0.4.7",
    "typescript": "^5.4.5",
    "vite": "^5.3.1"
  }
}


// ====== [7] packages/client/src/App.tsx ======
import { MantineProvider } from '@mantine/core';
import { RouterProvider } from 'react-router-dom';
import { theme } from './styles/theme.js';
import { router } from './router/index.js';
import { AuthProvider } from './providers/AuthProvider.js';

// Importa los estilos base de Mantine
import '@mantine/core/styles.css';

function App() {
  return (
    <MantineProvider theme={theme}>
      <AuthProvider>
        <RouterProvider router={router} />
      </AuthProvider>
    </MantineProvider>
  );
}

export default App;


// ====== [8] packages/client/src/api/apiClient.ts ======
import axios from 'axios';

const apiClient = axios.create({
  // La URL base para todas las peticiones al API.
  // Gracias al proxy configurado en vite.config.ts, esto se
  // redirigir√° a http://localhost:3001/api en desarrollo.
  baseURL: '/api',

  // Permite que axios env√≠e y reciba cookies (como nuestro token JWT)
  // en las peticiones a dominios diferentes.
  withCredentials: true,
});

export default apiClient;


// ====== [9] packages/client/src/features/admin/pages/ParameterCatalogPage.tsx ======
// filename: packages/client/src/features/admin/pages/ParameterCatalogPage.tsx
// Version: 1.2.0 (Implement TagsInput for SELECT options in the form)
import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  Select,
  TagsInput,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient.js';

// --- Tipos ---
const InputTypes = ['NUMBER', 'BOOLEAN', 'TEXT', 'SELECT'] as const;
type InputType = (typeof InputTypes)[number];

interface ParameterTemplate {
  id: string;
  name: string;
  unit: string | null;
  type: InputType;
  selectOptions: string[];
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function ParameterCatalogPage() {
  const [templates, setTemplates] = useState<ParameterTemplate[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingTemplate, setEditingTemplate] = useState<ParameterTemplate | null>(null);

  const form = useForm({
    initialValues: {
      name: '',
      unit: '',
      type: 'NUMBER' as InputType,
      selectOptions: [] as string[],
    },
    validate: {
      name: (value: string) => (value.trim().length < 2 ? 'El nombre es demasiado corto' : null),
      type: (value: string) => (InputTypes.includes(value as InputType) ? null : 'Tipo inv√°lido'),
      selectOptions: (value: string[], values) => {
        if (values.type === 'SELECT' && value.length === 0) {
          return 'Debe definir al menos una opci√≥n para el tipo SELECT';
        }
        return null;
      }
    },
  });

  const fetchTemplates = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<ParameterTemplate[]>>('/parameters');
      setTemplates(response.data.data);
    } catch (err) {
      setError('No se pudo cargar el cat√°logo de par√°metros.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchTemplates();
  }, []);

  const handleOpenModal = (template: ParameterTemplate | null = null) => {
    setEditingTemplate(template);
    if (template) {
      form.setValues({
        name: template.name,
        unit: template.unit || '',
        type: template.type,
        selectOptions: template.selectOptions || [],
      });
    } else {
      form.reset();
    }
    openModal();
  };

  const handleSubmit = async (values: typeof form.values) => {
    const payload = {
      ...values,
      selectOptions: values.type === 'SELECT' ? values.selectOptions : [],
    };
    try {
      if (editingTemplate) {
        await apiClient.patch(`/parameters/${editingTemplate.id}`, payload);
      } else {
        await apiClient.post('/parameters', payload);
      }
      await fetchTemplates();
      closeModal();
    } catch (err: any) {
      form.setErrors({ name: err.response?.data?.message || 'Error al guardar el par√°metro' });
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar este par√°metro?')) {
      try {
        await apiClient.delete(`/parameters/${id}`);
        setTemplates((current) => current.filter((t) => t.id !== id));
      } catch (err) {
        // TODO: Mostrar notificaci√≥n de error
        console.error('Failed to delete parameter', err);
      }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = templates.map((template) => (
    <Table.Tr key={template.id}>
      <Table.Td>{template.name}</Table.Td>
      <Table.Td>{template.unit || '-'}</Table.Td>
      <Table.Td>{template.type}</Table.Td>
      <Table.Td>
        <Group gap="xs">
          <Button variant="subtle" size="xs" onClick={() => handleOpenModal(template)}>Editar</Button>
          <Button variant="subtle" size="xs" color="red" onClick={() => handleDelete(template.id)}>Eliminar</Button>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingTemplate ? 'Editar Par√°metro' : 'Crear Nuevo Par√°metro'}
        centered
      >
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="Nombre del Par√°metro" {...form.getInputProps('name')} />
            <TextInput label="Unidad (ej. ppm, pH, ¬∞C)" {...form.getInputProps('unit')} />
            <Select
              label="Tipo de Input"
              required
              data={InputTypes as unknown as string[]}
              {...form.getInputProps('type')}
            />
            {form.values.type === 'SELECT' && (
              <TagsInput
                label="Opciones del Select"
                placeholder="A√±ade opciones y presiona Enter"
                description="Escribe una opci√≥n y presiona Enter para a√±adirla a la lista."
                required
                {...form.getInputProps('selectOptions')}
              />
            )}
            <Button type="submit" mt="md">{editingTemplate ? 'Guardar Cambios' : 'Crear Par√°metro'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Cat√°logo de Par√°metros</Title>
          <Button onClick={() => handleOpenModal()}>Crear Nuevo Par√°metro</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Unidad</Table.Th>
              <Table.Th>Tipo</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={4}>No hay par√°metros definidos en el cat√°logo.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [10] packages/client/src/features/admin/pages/TaskCatalogPage.tsx ======
// filename: packages/client/src/features/admin/pages/TaskCatalogPage.tsx
// Version: 1.0.0 (Initial implementation of the task template catalog page with full CRUD)
import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  Textarea,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient.js';

// --- Tipos ---
interface TaskTemplate {
  id: string;
  name: string;
  description: string | null;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function TaskCatalogPage() {
  const [templates, setTemplates] = useState<TaskTemplate[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingTemplate, setEditingTemplate] = useState<TaskTemplate | null>(null);

  const form = useForm({
    initialValues: {
      name: '',
      description: '',
    },
    validate: {
      name: (value: string) => (value.trim().length < 2 ? 'El nombre es demasiado corto' : null),
    },
  });

  const fetchTemplates = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<TaskTemplate[]>>('/tasks');
      setTemplates(response.data.data);
    } catch (err) {
      setError('No se pudo cargar el cat√°logo de tareas.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchTemplates();
  }, []);

  const handleOpenModal = (template: TaskTemplate | null = null) => {
    setEditingTemplate(template);
    if (template) {
      form.setValues({
        name: template.name,
        description: template.description || '',
      });
    } else {
      form.reset();
    }
    openModal();
  };

  const handleSubmit = async (values: typeof form.values) => {
    try {
      if (editingTemplate) {
        await apiClient.patch(`/tasks/${editingTemplate.id}`, values);
      } else {
        await apiClient.post('/tasks', values);
      }
      await fetchTemplates();
      closeModal();
    } catch (err: any) {
      form.setErrors({ name: err.response?.data?.message || 'Error al guardar la tarea' });
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar esta tarea?')) {
      try {
        await apiClient.delete(`/tasks/${id}`);
        setTemplates((current) => current.filter((t) => t.id !== id));
      } catch (err) {
        // TODO: Mostrar notificaci√≥n de error
        console.error('Failed to delete task', err);
      }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = templates.map((template) => (
    <Table.Tr key={template.id}>
      <Table.Td>{template.name}</Table.Td>
      <Table.Td>{template.description || '-'}</Table.Td>
      <Table.Td>
        <Group gap="xs">
          <Button variant="subtle" size="xs" onClick={() => handleOpenModal(template)}>Editar</Button>
          <Button variant="subtle" size="xs" color="red" onClick={() => handleDelete(template.id)}>Eliminar</Button>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingTemplate ? 'Editar Tarea' : 'Crear Nueva Tarea'}
        centered
      >
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="Nombre de la Tarea" {...form.getInputProps('name')} />
            <Textarea label="Descripci√≥n (opcional)" {...form.getInputProps('description')} />
            <Button type="submit" mt="md">{editingTemplate ? 'Guardar Cambios' : 'Crear Tarea'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Cat√°logo de Tareas</Title>
          <Button onClick={() => handleOpenModal()}>Crear Nueva Tarea</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Descripci√≥n</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={3}>No hay tareas definidas en el cat√°logo.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [11] packages/client/src/features/admin/pages/clients/ClientDetailPage.tsx ======
// filename: packages/client/src/features/admin/pages/clients/ClientDetailPage.tsx
// Version: 1.2.0 (Make pool names link to their future detail page)
import { useEffect, useState } from 'react';
import { useParams, Link } from 'react-router-dom';
import {
  Container,
  Title,
  Loader,
  Alert,
  Button,
  Group,
  Paper,
  Text,
  Table,
  Breadcrumbs,
  Modal,
  TextInput,
  Stack,
  NumberInput,
  Select,
  Anchor,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../../api/apiClient.js';

// --- Tipos ---
interface Pool {
  id: string;
  name: string;
  address: string;
  volume: number | null;
  type: string | null;
}

interface Client {
  id: string;
  name: string;
  contactPerson: string | null;
  email: string | null;
  phone: string | null;
  address: string | null;
  pools: Pool[];
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function ClientDetailPage() {
  const { id: clientId } = useParams<{ id: string }>();
  const [client, setClient] = useState<Client | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingPool, setEditingPool] = useState<Pool | null>(null);

  const poolForm = useForm({
    initialValues: {
      name: '',
      address: '',
      volume: null as number | null,
      type: '',
    },
    validate: {
      name: (value) => (value.trim().length < 2 ? 'El nombre es demasiado corto' : null),
      address: (value) => (value.trim().length < 5 ? 'La direcci√≥n es demasiado corta' : null),
    },
  });

  const fetchClient = async () => {
    if (!clientId) return;
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<Client>>(`/clients/${clientId}`);
      setClient(response.data.data);
    } catch (err) {
      setError('No se pudo cargar la informaci√≥n del cliente.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchClient();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [clientId]);

  const handleOpenModal = (pool: Pool | null = null) => {
    setEditingPool(pool);
    if (pool) {
      poolForm.setValues({
        name: pool.name,
        address: pool.address,
        volume: pool.volume,
        type: pool.type || '',
      });
    } else {
      poolForm.reset();
    }
    openModal();
  };

  const handlePoolSubmit = async (values: typeof poolForm.values) => {
    if (!clientId) return;
    try {
      const payload = { ...values, clientId };
      if (editingPool) {
        await apiClient.patch(`/pools/${editingPool.id}`, payload);
      } else {
        await apiClient.post('/pools', payload);
      }
      await fetchClient();
      closeModal();
    } catch (err: any) {
      poolForm.setErrors({ name: err.response?.data?.message || 'Error al guardar la piscina' });
    }
  };

  const handlePoolDelete = async (poolId: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar esta piscina?')) {
      try {
        await apiClient.delete(`/pools/${poolId}`);
        await fetchClient();
      } catch (err) {
        console.error('Failed to delete pool', err);
      }
    }
  };


  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;
  if (!client) return <Alert color="yellow" title="Aviso">Cliente no encontrado.</Alert>;

  const breadcrumbs = (
    <Breadcrumbs>
      <Link to="/clients">Clientes</Link>
      <Text>{client.name}</Text>
    </Breadcrumbs>
  );

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingPool ? 'Editar Piscina' : 'Crear Nueva Piscina'}
        centered
      >
        <form onSubmit={poolForm.onSubmit(handlePoolSubmit)}>
          <Stack>
            <TextInput required label="Nombre de la Piscina" placeholder="Ej. Piscina Principal" {...poolForm.getInputProps('name')} />
            <TextInput required label="Direcci√≥n de la Piscina" {...poolForm.getInputProps('address')} />
            <NumberInput label="Volumen (m¬≥)" placeholder="Ej. 50" min={0} {...poolForm.getInputProps('volume')} />
            <Select label="Tipo de Piscina" data={['Cloro', 'Sal']} {...poolForm.getInputProps('type')} />
            <Button type="submit" mt="md">{editingPool ? 'Guardar Cambios' : 'Crear Piscina'}</Button>
          </Stack>
        </form>
      </Modal>
    
      <Container fluid>
        {breadcrumbs}
        <Title order={2} my="lg">{client.name}</Title>
        <Paper withBorder p="md" mb="xl">
          <Title order={4} mb="xs">Informaci√≥n de Contacto</Title>
          <Text><strong>Persona de contacto:</strong> {client.contactPerson || '-'}</Text>
          <Text><strong>Email:</strong> {client.email || '-'}</Text>
          <Text><strong>Tel√©fono:</strong> {client.phone || '-'}</Text>
          <Text><strong>Direcci√≥n de facturaci√≥n:</strong> {client.address || '-'}</Text>
        </Paper>
        
        <Group justify="space-between" align="center" mb="md">
          <Title order={3}>Piscinas</Title>
          <Button onClick={() => handleOpenModal()}>Crear Nueva Piscina</Button>
        </Group>

        <Table striped withTableBorder>
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Direcci√≥n</Table.Th>
              <Table.Th>Volumen (m¬≥)</Table.Th>
              <Table.Th>Tipo</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>
            {client.pools.length > 0 ? (
              client.pools.map(pool => (
                <Table.Tr key={pool.id}>
                  <Table.Td>
                    <Anchor component={Link} to={`/pools/${pool.id}`}>
                      {pool.name}
                    </Anchor>
                  </Table.Td>
                  <Table.Td>{pool.address}</Table.Td>
                  <Table.Td>{pool.volume || '-'}</Table.Td>
                  <Table.Td>{pool.type || '-'}</Table.Td>
                  <Table.Td>
                    <Group gap="xs">
                      <Button variant="subtle" size="xs" onClick={() => handleOpenModal(pool)}>Editar</Button>
                      <Button variant="subtle" size="xs" color="red" onClick={() => handlePoolDelete(pool.id)}>Eliminar</Button>
                    </Group>
                  </Table.Td>
                </Table.Tr>
              ))
            ) : (
              <Table.Tr><Table.Td colSpan={5}>Este cliente no tiene piscinas asociadas.</Table.Td></Table.Tr>
            )}
          </Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [12] packages/client/src/features/admin/pages/clients/ClientsPage.tsx ======
// filename: packages/client/src/features/admin/pages/clients/ClientsPage.tsx
// Version: 1.1.0 (Make client names link to their detail page)
import { useEffect, useState } from 'react';
import { Link } from 'react-router-dom';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  NumberInput,
  Anchor,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../../api/apiClient.js';

// --- Tipos ---
interface Client {
  id: string;
  name: string;
  contactPerson: string | null;
  email: string | null;
  phone: string | null;
  address: string | null;
  priceModifier: number;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function ClientsPage() {
  const [clients, setClients] = useState<Client[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  const [editingClient, setEditingClient] = useState<Client | null>(null);

  const form = useForm({
    initialValues: {
      name: '',
      contactPerson: '',
      email: '',
      phone: '',
      address: '',
      priceModifier: 1.0,
    },
    validate: {
      name: (value) => (value.trim().length < 2 ? 'El nombre es demasiado corto' : null),
      email: (value) => (value && !/^\S+@\S+$/.test(value) ? 'Email inv√°lido' : null),
      priceModifier: (value) => (value <= 0 ? 'El modificador debe ser mayor que 0' : null),
    },
  });

  const fetchClients = async () => {
    setIsLoading(true);
    try {
      const response = await apiClient.get<ApiResponse<Client[]>>('/clients');
      setClients(response.data.data);
    } catch (err) {
      setError('No se pudo cargar la lista de clientes.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchClients();
  }, []);

  const handleOpenModal = (client: Client | null = null) => {
    setEditingClient(client);
    if (client) {
      form.setValues({
        name: client.name,
        contactPerson: client.contactPerson || '',
        email: client.email || '',
        phone: client.phone || '',
        address: client.address || '',
        priceModifier: client.priceModifier,
      });
    } else {
      form.reset();
    }
    openModal();
  };

  const handleSubmit = async (values: typeof form.values) => {
    try {
      if (editingClient) {
        await apiClient.patch(`/clients/${editingClient.id}`, values);
      } else {
        await apiClient.post('/clients', values);
      }
      await fetchClients();
      closeModal();
    } catch (err: any) {
      form.setErrors({ name: err.response?.data?.message || 'Error al guardar el cliente' });
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres eliminar este cliente? Se borrar√°n tambi√©n todas sus piscinas asociadas.')) {
      try {
        await apiClient.delete(`/clients/${id}`);
        setClients((current) => current.filter((c) => c.id !== id));
      } catch (err) {
        console.error('Failed to delete client', err);
      }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = clients.map((client) => (
    <Table.Tr key={client.id}>
      <Table.Td>
        <Anchor component={Link} to={`/clients/${client.id}`}>
          {client.name}
        </Anchor>
      </Table.Td>
      <Table.Td>{client.contactPerson || '-'}</Table.Td>
      <Table.Td>{client.phone || '-'}</Table.Td>
      <Table.Td>{client.email || '-'}</Table.Td>
      <Table.Td>
        <Group gap="xs">
          <Button variant="subtle" size="xs" onClick={() => handleOpenModal(client)}>Editar</Button>
          <Button variant="subtle" size="xs" color="red" onClick={() => handleDelete(client.id)}>Eliminar</Button>
        </Group>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal
        opened={modalOpened}
        onClose={closeModal}
        title={editingClient ? 'Editar Cliente' : 'Crear Nuevo Cliente'}
        centered
      >
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            <TextInput required label="Nombre del Cliente" {...form.getInputProps('name')} />
            <TextInput label="Persona de Contacto" {...form.getInputProps('contactPerson')} />
            <TextInput label="Email" type="email" {...form.getInputProps('email')} />
            <TextInput label="Tel√©fono" {...form.getInputProps('phone')} />
            <TextInput label="Direcci√≥n" {...form.getInputProps('address')} />
            <NumberInput 
              label="Modificador de Precio" 
              description="1.0 es normal, 0.9 es 10% dto, 1.1 es 10% recargo." 
              defaultValue={1.0} 
              step={0.05} 
              min={0} 
              decimalScale={2} 
              {...form.getInputProps('priceModifier')} 
            />
            <Button type="submit" mt="md">{editingClient ? 'Guardar Cambios' : 'Crear Cliente'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Gesti√≥n de Clientes</Title>
          <Button onClick={() => handleOpenModal()}>Crear Nuevo Cliente</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Nombre</Table.Th>
              <Table.Th>Contacto</Table.Th>
              <Table.Th>Tel√©fono</Table.Th>
              <Table.Th>Email</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={5}>No hay clientes creados.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [13] packages/client/src/features/admin/pages/planner/PlannerPage.tsx ======
// filename: packages/client/src/features/admin/pages/planner/PlannerPage.tsx
// Version: 1.4.1 (Fix typing errors and clean up unused variables)
import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Loader,
  Alert,
  Paper,
  Text,
  Grid,
  Card,
  Group,
  ActionIcon,
  Stack,
  Badge,
} from '@mantine/core';
import { useAuth } from '../../../../providers/AuthProvider.js';
import apiClient from '../../../../api/apiClient.js';
import { startOfWeek, endOfWeek, format, addDays, subDays } from 'date-fns';
import { es } from 'date-fns/locale';
import { DndContext, useDraggable, useDroppable } from '@dnd-kit/core';
import type { DragEndEvent } from '@dnd-kit/core';

// --- Tipos ---
interface Visit {
  id: string;
  timestamp: string;
  status: 'PENDING' | 'COMPLETED' | 'CANCELLED';
  pool: { name: string; client: { name: string; }; };
  technicianId: string | null;
}
interface Technician { id: string; name: string; }
interface ApiResponse<T> { success: boolean; data: T; }

// --- Componentes de Drag and Drop ---
function DraggableVisit({ visit }: { visit: Visit }) {
  const { attributes, listeners, setNodeRef, transform } = useDraggable({ id: visit.id, data: visit });
  const style = transform ? { transform: `translate3d(${transform.x}px, ${transform.y}px, 0)`, zIndex: 100 } : undefined;
  const visitDate = new Date(visit.timestamp);

  return (
    <div ref={setNodeRef} style={style} {...listeners} {...attributes}>
      <Card shadow="sm" p="xs" withBorder>
        <Group justify="space-between">
          <Text fw={500}>{visit.pool.name}</Text>
          {visit.status === 'COMPLETED' && <Badge size="sm" color="green">OK</Badge>}
        </Group>
        <Text size="sm" c="dimmed">{visit.pool.client.name}</Text>
        <Text size="xs" mt={4}>{format(visitDate, 'eeee d', { locale: es })}</Text>
      </Card>
    </div>
  );
}

function DroppableArea({ id, children, title }: { id: string; children: React.ReactNode; title: string }) {
  const { setNodeRef, isOver } = useDroppable({ id });
  return (
    <Paper ref={setNodeRef} withBorder p="sm" style={{ minHeight: 400, backgroundColor: isOver ? '#e7f5ff' : '#f1f3f5', transition: 'background-color 0.2s ease' }}>
      <Title order={5} ta="center" mb="md">{title}</Title>
      <Stack>{children}</Stack>
    </Paper>
  );
}

// --- Componente Principal ---
export function PlannerPage() {
  const { user } = useAuth();
  const [visits, setVisits] = useState<Visit[]>([]);
  const [technicians, setTechnicians] = useState<Technician[]>([]);
  const [currentDate, setCurrentDate] = useState(new Date());
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const weekStart = startOfWeek(currentDate, { weekStartsOn: 1 });
  const weekEnd = endOfWeek(currentDate, { weekStartsOn: 1 });

  const fetchData = async () => {
    if (!user) return;
    setIsLoading(true);
    try {
      const [visitsRes, techsRes] = await Promise.all([
        apiClient.get<ApiResponse<Visit[]>>('/visits/scheduled', { params: { date: currentDate.toISOString() } }),
        apiClient.get<ApiResponse<Technician[]>>('/users/technicians'),
      ]);
      setVisits(visitsRes.data.data);
      setTechnicians(techsRes.data.data);
    } catch (err) { setError('No se pudo cargar la planificaci√≥n.'); } finally { setIsLoading(false); }
  };

  useEffect(() => { fetchData(); // eslint-disable-next-line
  }, [currentDate, user]);

  const handleDragEnd = async (event: DragEndEvent) => {
    const { over, active } = event;
    if (!over) return;

    const visitId = active.id as string;
    const targetId = String(over.id);
    const [type, id] = targetId.split('-');

    let technicianId: string | null = null;
    
    // CORRECCI√ìN: Aseguramos que technicianId sea siempre string o null.
    if (type === 'tech' && id) {
        technicianId = id;
    }

    const originalVisits = [...visits];
    const visitToUpdate = visits.find(v => v.id === visitId);
    if (!visitToUpdate || visitToUpdate.technicianId === technicianId) return;

    setVisits(prev => prev.map(v => v.id === visitId ? { ...v, technicianId } : v));

    try {
      await apiClient.post('/visits/assign', { visitId, technicianId });
    } catch (err) {
      setError('No se pudo asignar la visita.');
      setVisits(originalVisits);
    }
  };

  if (isLoading) return <Loader size="xl" />;
  
  const weekRange = `${format(weekStart, 'd')} - ${format(weekEnd, 'd MMMM yyyy', { locale: es })}`;

  return (
    <DndContext onDragEnd={handleDragEnd}>
      <Container fluid>
        {error && <Alert color="red" title="Error" mb="md">{error}</Alert>}
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Planificador Semanal</Title>
          <Group>
            <ActionIcon variant="default" onClick={() => setCurrentDate(subDays(currentDate, 7))}>{'<'}</ActionIcon>
            <Text size="lg" fw={500}>{weekRange}</Text>
            <ActionIcon variant="default" onClick={() => setCurrentDate(addDays(currentDate, 7))}>{'<'}</ActionIcon>
          </Group>
        </Group>

        <Grid grow>
          <Grid.Col span={{ base: 12, md: 2 }}>
            <DroppableArea id="tech-null" title="Visitas Pendientes">
              {visits.filter(v => !v.technicianId).map(visit => <DraggableVisit key={visit.id} visit={visit} />)}
            </DroppableArea>
          </Grid.Col>

          <Grid.Col span={{ base: 12, md: 10 }}>
            <Grid>
              {technicians.map(tech => (
                <Grid.Col key={tech.id} span={{ base: 12, md: 6, lg: 4 }}>
                   <DroppableArea id={`tech-${tech.id}`} title={tech.name}>
                    {visits
                      .filter(v => v.technicianId === tech.id)
                      .map(visit => <DraggableVisit key={visit.id} visit={visit} />)
                    }
                   </DroppableArea>
                </Grid.Col>
              ))}
            </Grid>
          </Grid.Col>
        </Grid>
      </Container>
    </DndContext>
  );
}


// ====== [14] packages/client/src/features/admin/pages/pools/PoolDetailPage.tsx ======
// filename: packages/client/src/features/admin/pages/pools/PoolDetailPage.tsx
// Version: 1.2.0 (Implement Edit functionality for Pool Configurations)
import { useEffect, useState } from 'react';
import { useParams, Link } from 'react-router-dom';
import {
  Container,
  Title,
  Loader,
  Alert,
  Paper,
  Text,
  Table,
  Breadcrumbs,
  Grid,
  Card,
  Button,
  Group,
  Modal,
  Select,
  NumberInput,
  Stack,
  Menu,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../../api/apiClient.js';

// --- Tipos ---
const Frequencies = ['DIARIA', 'SEMANAL', 'QUINCENAL', 'MENSUAL', 'TRIMESTRAL', 'SEMESTRAL', 'ANUAL'] as const;
type Frequency = (typeof Frequencies)[number];

interface Pool { id: string; name: string; clientId: string; }
interface ParameterTemplate { id: string; name: string; unit: string | null; type: 'NUMBER' | 'BOOLEAN' | 'TEXT' | 'SELECT'; }
interface TaskTemplate { id: string; name: string; }
interface PoolConfiguration {
  id: string;
  frequency: Frequency;
  minThreshold: number | null;
  maxThreshold: number | null;
  parameterTemplate?: ParameterTemplate;
  taskTemplate?: TaskTemplate;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function PoolDetailPage() {
  const { id: poolId } = useParams<{ id: string }>();
  const [pool, ] = useState<Pool | null>(null);
  const [configurations, setConfigurations] = useState<PoolConfiguration[]>([]);
  const [parameterCatalog, setParameterCatalog] = useState<ParameterTemplate[]>([]);
  const [taskCatalog, setTaskCatalog] = useState<TaskTemplate[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);
  // Estado para saber qu√© estamos configurando (un nuevo √≠tem o editando uno existente)
  const [editingConfig, setEditingConfig] = useState<PoolConfiguration | null>(null);
  const [itemToAdd, setItemToAdd] = useState<{ id: string; name: string; type: 'parameter' | 'task' } | null>(null);

  const configForm = useForm({
    initialValues: {
      frequency: 'SEMANAL' as Frequency,
      minThreshold: null as number | null,
      maxThreshold: null as number | null,
    },
    validate: {
      frequency: (value) => (Frequencies.includes(value) ? null : 'Frecuencia inv√°lida'),
    },
  });

  const fetchData = async () => {
    if (!poolId) return;
    setIsLoading(true);
    try {
      const [configsRes, paramsRes, tasksRes] = await Promise.all([
        apiClient.get<ApiResponse<PoolConfiguration[]>>(`/pool-configurations/by-pool/${poolId}`),
        apiClient.get<ApiResponse<ParameterTemplate[]>>('/parameters'),
        apiClient.get<ApiResponse<TaskTemplate[]>>('/tasks'),
      ]);
      setConfigurations(configsRes.data.data);
      setParameterCatalog(paramsRes.data.data);
      setTaskCatalog(tasksRes.data.data);
    } catch (err) {
      setError('No se pudo cargar la configuraci√≥n de la piscina.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchData();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [poolId]);

  const handleOpenModal = (config: PoolConfiguration | null, item: { id: string; name: string; } | null, type: 'parameter' | 'task' | null) => {
    setEditingConfig(config);
    setItemToAdd(item ? { ...item, type: type as 'parameter' | 'task' } : null);
    
    if (config) { // Estamos editando
      configForm.setValues({
        frequency: config.frequency,
        minThreshold: config.minThreshold,
        maxThreshold: config.maxThreshold,
      });
    } else { // Estamos creando
      configForm.reset();
    }
    openModal();
  };

  const handleConfigSubmit = async (values: typeof configForm.values) => {
    if (!poolId) return;
    try {
      if (editingConfig) { // L√≥gica para actualizar
        const payload = { frequency: values.frequency, minThreshold: values.minThreshold, maxThreshold: values.maxThreshold };
        await apiClient.patch(`/pool-configurations/${editingConfig.id}`, payload);
      } else if (itemToAdd) { // L√≥gica para crear
        const payload = {
          poolId,
          frequency: values.frequency,
          ...(itemToAdd.type === 'parameter' && { parameterTemplateId: itemToAdd.id, minThreshold: values.minThreshold, maxThreshold: values.maxThreshold }),
          ...(itemToAdd.type === 'task' && { taskTemplateId: itemToAdd.id }),
        };
        await apiClient.post('/pool-configurations', payload);
      }
      await fetchData();
      closeModal();
    } catch (err: any) {
      configForm.setErrors({ frequency: err.response?.data?.message || 'Error al guardar la configuraci√≥n' });
    }
  };
  
  const handleConfigDelete = async (configId: string) => {
    if (window.confirm('¬øEst√°s seguro de que quieres quitar este √≠tem de la ficha?')) {
      try {
        await apiClient.delete(`/pool-configurations/${configId}`);
        await fetchData();
      } catch (err) {}
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const currentItem = editingConfig?.parameterTemplate || editingConfig?.taskTemplate || itemToAdd;
  const modalTitle = editingConfig ? `Editar: ${currentItem?.name}` : `A√±adir: ${currentItem?.name}`;
  const isParameter = (editingConfig && editingConfig.parameterTemplate) || (itemToAdd?.type === 'parameter');
  
  const breadcrumbs = (
    <Breadcrumbs>
      <Link to="/clients">Clientes</Link>
      <Text>Cliente (TODO)</Text>
      <Text>{pool?.name || 'Piscina'}</Text>
    </Breadcrumbs>
  );

  return (
    <>
      <Modal opened={modalOpened} onClose={closeModal} title={modalTitle} centered>
        <form onSubmit={configForm.onSubmit(handleConfigSubmit)}>
          <Stack>
            <Select label="Frecuencia" required data={[...Frequencies]} {...configForm.getInputProps('frequency')} />
            {isParameter && (
              <>
                <NumberInput label="Umbral M√≠nimo (opcional)" {...configForm.getInputProps('minThreshold')} />
                <NumberInput label="Umbral M√°ximo (opcional)" {...configForm.getInputProps('maxThreshold')} />
              </>
            )}
            <Button type="submit" mt="md">{editingConfig ? 'Guardar Cambios' : 'A√±adir a la Ficha'}</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        {breadcrumbs}
        <Title order={2} my="lg">Constructor de Ficha: {pool?.name || ''}</Title>
        <Grid>
          <Grid.Col span={{ base: 12, md: 6 }}>
            <Paper withBorder p="md">
              <Title order={4} mb="md">Ficha de Mantenimiento Actual</Title>
              <Table>
                <Table.Thead><Table.Tr><Table.Th>√çtem</Table.Th><Table.Th>Frecuencia</Table.Th><Table.Th>Acciones</Table.Th></Table.Tr></Table.Thead>
                <Table.Tbody>
                  {configurations.length > 0 ? configurations.map(config => (
                    <Table.Tr key={config.id}>
                      <Table.Td>{config.parameterTemplate?.name || config.taskTemplate?.name}</Table.Td>
                      <Table.Td>{config.frequency}</Table.Td>
                      <Table.Td>
                        <Menu shadow="md" width={200}>
                          <Menu.Target><Button variant="outline" size="xs">Acciones</Button></Menu.Target>
                          <Menu.Dropdown>
                            <Menu.Item onClick={() => handleOpenModal(config, null, null)}>Editar</Menu.Item>
                            <Menu.Item color="red" onClick={() => handleConfigDelete(config.id)}>Quitar</Menu.Item>
                          </Menu.Dropdown>
                        </Menu>
                      </Table.Td>
                    </Table.Tr>
                  )) : <Table.Tr><Table.Td colSpan={3}>La ficha est√° vac√≠a. A√±ade √≠tems desde los cat√°logos.</Table.Td></Table.Tr>}
                </Table.Tbody>
              </Table>
            </Paper>
          </Grid.Col>

          <Grid.Col span={{ base: 12, md: 6 }}>
            <Paper withBorder p="md" mb="md">
              <Title order={4} mb="md">Cat√°logo de Par√°metros Disponibles</Title>
              {parameterCatalog.map(param => (
                <Card key={param.id} shadow="sm" p="sm" mb="xs" withBorder>
                  <Group justify="space-between">
                    <Text>{param.name} {param.unit ? `(${param.unit})` : ''}</Text>
                    <Button size="xs" onClick={() => handleOpenModal(null, param, 'parameter')}>A√±adir</Button>
                  </Group>
                </Card>
              ))}
            </Paper>
            <Paper withBorder p="md">
              <Title order={4} mb="md">Cat√°logo de Tareas Disponibles</Title>
              {taskCatalog.map(task => (
                <Card key={task.id} shadow="sm" p="sm" mb="xs" withBorder>
                  <Group justify="space-between">
                    <Text>{task.name}</Text>
                    <Button size="xs" onClick={() => handleOpenModal(null, task, 'task')}>A√±adir</Button>
                  </Group>
                </Card>
              ))}
            </Paper>
          </Grid.Col>
        </Grid>
      </Container>
    </>
  );
}


// ====== [15] packages/client/src/features/auth/pages/LoginPage.tsx ======
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Container,
  Title,
  Paper,
  TextInput,
  PasswordInput,
  Button,
  Stack,
  Alert,
} from '@mantine/core';
import { useAuth } from '../../../providers/AuthProvider.js';

export function LoginPage() {
  const { login } = useAuth();
  const navigate = useNavigate();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (event: React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    setError(null);
    try {
      await login({ email, password });
      navigate('/'); // Redirige al dashboard en un login exitoso
    } catch (err) {
      setError('El email o la contrase√±a son incorrectos.');
      console.error(err);
    }
  };

  return (
    <Container size={420} my={40}>
      <Title ta="center">¬°Bienvenido!</Title>
      <Paper withBorder shadow="md" p={30} mt={30} radius="md">
        <form onSubmit={handleSubmit}>
          <Stack>
            <TextInput
              required
              label="Email"
              placeholder="tu@email.com"
              value={email}
              onChange={(event) => setEmail(event.currentTarget.value)}
              radius="md"
            />
            <PasswordInput
              required
              label="Contrase√±a"
              placeholder="Tu contrase√±a"
              value={password}
              onChange={(event) => setPassword(event.currentTarget.value)}
              radius="md"
            />
            {error && (
              <Alert title="Error de autenticaci√≥n" color="red" withCloseButton onClose={() => setError(null)}>
                {error}
              </Alert>
            )}
            <Button type="submit" fullWidth mt="xl" radius="md">
              Iniciar Sesi√≥n
            </Button>
          </Stack>
        </form>
      </Paper>
    </Container>
  );
}


// ====== [16] packages/client/src/features/superadmin/pages/TenantsPage.tsx ======
import { useEffect, useState } from 'react';
import {
  Container,
  Title,
  Table,
  Loader,
  Alert,
  Badge,
  Button,
  Group,
  Modal,
  TextInput,
  Stack,
  PasswordInput,
  Menu,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import { useDisclosure } from '@mantine/hooks';
import apiClient from '../../../api/apiClient.js';

// --- Tipos ---
type SubscriptionStatus = 'TRIAL' | 'ACTIVE' | 'PAYMENT_PENDING' | 'INACTIVE';

interface Tenant {
  id: string;
  companyName: string;
  subdomain: string;
  subscriptionStatus: SubscriptionStatus;
  createdAt: string;
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function TenantsPage() {
  const [tenants, setTenants] = useState<Tenant[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [modalOpened, { open: openModal, close: closeModal }] = useDisclosure(false);

  const form = useForm({
    initialValues: {
      companyName: '',
      subdomain: '',
      adminUser: {
        name: '',
        email: '',
        password: '',
      },
    },
    validate: {
      companyName: (value: string) => (value.length < 2 ? 'El nombre debe tener al menos 2 caracteres' : null),
      subdomain: (value: string) => (/^[a-z0-9]+(?:-[a-z0-9]+)*$/.test(value) ? null : 'Subdominio inv√°lido'),
      adminUser: {
        email: (value: string) => (/^\S+@\S+$/.test(value) ? null : 'Email inv√°lido'),
        password: (value: string) => (value.length < 8 ? 'La contrase√±a debe tener al menos 8 caracteres' : null),
      },
    },
  });

  const fetchTenants = async () => {
    if (tenants.length === 0) setIsLoading(true);
    setError(null);
    try {
      const response = await apiClient.get<ApiResponse<Tenant[]>>('/tenants');
      setTenants(response.data.data);
    } catch (err) {
      setError('No se pudo obtener la lista de tenants.');
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchTenants();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handleCreateTenant = async (values: typeof form.values) => {
    try {
      await apiClient.post<ApiResponse<Tenant>>('/tenants', values);
      await fetchTenants();
      closeModal();
      form.reset();
    } catch (err: any) {
      form.setErrors({ companyName: err.response?.data?.message || 'Error al crear el tenant' });
    }
  };

  const handleUpdateStatus = async (tenantId: string, status: SubscriptionStatus) => {
    try {
      setTenants((current) =>
        current.map((t) => (t.id === tenantId ? { ...t, subscriptionStatus: status } : t))
      );
      await apiClient.patch(`/tenants/${tenantId}/status`, { status });
    } catch (err) {
      console.error('Failed to update tenant status', err);
      await fetchTenants();
    }
  };

  const handleDeleteTenant = async (tenantId: string) => {
    if (window.confirm('¬øEst√°s seguro? Esta acci√≥n eliminar√° el tenant y todos sus datos (usuarios, clientes, piscinas, etc.) de forma irreversible.')) {
      try {
        await apiClient.delete(`/tenants/${tenantId}`);
        setTenants((current) => current.filter((t) => t.id !== tenantId));
      } catch (err) {
        console.error('Failed to delete tenant', err);
        // TODO: Mostrar notificaci√≥n de error al usuario
      }
    }
  };

  if (isLoading) return <Loader size="xl" />;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;

  const rows = tenants.map((tenant) => (
    <Table.Tr key={tenant.id}>
      <Table.Td>{tenant.companyName}</Table.Td>
      <Table.Td>{tenant.subdomain}.pool-control.pro</Table.Td>
      <Table.Td>
        <Badge
          color={
            {
              ACTIVE: 'green',
              TRIAL: 'blue',
              PAYMENT_PENDING: 'orange',
              INACTIVE: 'gray',
            }[tenant.subscriptionStatus]
          }
        >
          {tenant.subscriptionStatus}
        </Badge>
      </Table.Td>
      <Table.Td>{new Date(tenant.createdAt).toLocaleDateString()}</Table.Td>
      <Table.Td>
        <Menu shadow="md" width={200}>
          <Menu.Target>
            <Button variant="outline" size="xs">Acciones</Button>
          </Menu.Target>
          <Menu.Dropdown>
            <Menu.Label>Cambiar estado</Menu.Label>
            <Menu.Item onClick={() => handleUpdateStatus(tenant.id, 'ACTIVE')}>Activar</Menu.Item>
            <Menu.Item onClick={() => handleUpdateStatus(tenant.id, 'TRIAL')}>Poner en Trial</Menu.Item>
            <Menu.Item onClick={() => handleUpdateStatus(tenant.id, 'PAYMENT_PENDING')}>Pago Pendiente</Menu.Item>
            <Menu.Item onClick={() => handleUpdateStatus(tenant.id, 'INACTIVE')}>Desactivar</Menu.Item>
            <Menu.Divider />
            <Menu.Label>Zona de Peligro</Menu.Label>
            <Menu.Item color="red" onClick={() => handleDeleteTenant(tenant.id)}>
              Eliminar Tenant
            </Menu.Item>
          </Menu.Dropdown>
        </Menu>
      </Table.Td>
    </Table.Tr>
  ));

  return (
    <>
      <Modal opened={modalOpened} onClose={closeModal} title="Crear Nuevo Tenant" centered>
        <form onSubmit={form.onSubmit(handleCreateTenant)}>
          <Stack>
            <TextInput required label="Nombre de la Empresa" placeholder="Ej. Piscinas Mart√≠nez" {...form.getInputProps('companyName')} />
            <TextInput required label="Subdominio" placeholder="ej. martinez" {...form.getInputProps('subdomain')} />
            <Title order={4} mt="md">Usuario Administrador</Title>
            <TextInput required label="Nombre del Admin" placeholder="Ej. Juan Mart√≠nez" {...form.getInputProps('adminUser.name')} />
            <TextInput required label="Email del Admin" placeholder="ej. juan@piscinasmartinez.com" {...form.getInputProps('adminUser.email')} />
            <PasswordInput required label="Contrase√±a del Admin" {...form.getInputProps('adminUser.password')} />
            <Button type="submit" mt="md">Crear Tenant</Button>
          </Stack>
        </form>
      </Modal>

      <Container fluid>
        <Group justify="space-between" align="center">
          <Title order={2} my="lg">Gesti√≥n de Tenants</Title>
          <Button onClick={openModal}>Crear Nuevo Tenant</Button>
        </Group>
        <Table striped withTableBorder withColumnBorders mt="md">
          <Table.Thead>
            <Table.Tr>
              <Table.Th>Empresa</Table.Th>
              <Table.Th>Subdominio</Table.Th>
              <Table.Th>Estado</Table.Th>
              <Table.Th>Fecha de Creaci√≥n</Table.Th>
              <Table.Th>Acciones</Table.Th>
            </Table.Tr>
          </Table.Thead>
          <Table.Tbody>{rows.length > 0 ? rows : <Table.Tr><Table.Td colSpan={5}>No hay tenants creados.</Table.Td></Table.Tr>}</Table.Tbody>
        </Table>
      </Container>
    </>
  );
}


// ====== [17] packages/client/src/features/technician/pages/MyRoutePage.tsx ======
// filename: packages/client/src/features/technician/pages/MyRoutePage.tsx
// Version: 1.1.1 (Fix invalid HTML nesting and implement state-based refresh)
import { useEffect, useState } from 'react';
import { Link, useLocation } from 'react-router-dom';
import {
  Container,
  Title,
  Loader,
  Alert,
  Stack,
  Card,
  Text,
  Group,
  Anchor,
  ThemeIcon,
} from '@mantine/core';
import apiClient from '../../../api/apiClient';

// --- Tipos ---
interface Visit {
  id: string;
  timestamp: string;
  pool: {
    id: string;
    name: string;
    address: string;
    client: {
      name: string;
    };
  };
}

interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function MyRoutePage() {
  const [visits, setVisits] = useState<Visit[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const location = useLocation(); // Hook para detectar cambios en la navegaci√≥n

  const fetchMyRoute = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const response = await apiClient.get<ApiResponse<Visit[]>>('/visits/my-route');
      setVisits(response.data.data);
    } catch (err) {
      setError('No se pudo cargar tu ruta del d√≠a.');
      console.error(err);
    } finally {
      setIsLoading(false);
    }
  };

  // Este useEffect ahora se ejecutar√° al cargar la p√°gina Y cada vez que volvamos a ella
  // desde otra ruta, gracias a que "location.key" cambia.
  useEffect(() => {
    fetchMyRoute();
  }, [location.key]);

  if (isLoading) {
    return (
      <Container style={{ textAlign: 'center', paddingTop: '50px' }}>
        <Loader size="xl" />
        <Text mt="md">Cargando tu ruta...</Text>
      </Container>
    );
  }

  if (error) {
    return <Alert color="red" title="Error">{error}</Alert>;
  }

  const visitCards = visits.map((visit) => (
    // CORRECCI√ìN: La Card es un div, y el contenido principal un Link para evitar anidamiento <a> en <a>.
    <Card key={visit.id} shadow="sm" padding="lg" radius="md" withBorder>
      <Link to={`/visits/${visit.id}`} style={{ textDecoration: 'none', color: 'inherit' }}>
        <Group justify="space-between" mt="md" mb="xs">
          <Text fw={500} size="lg">{visit.pool.name}</Text>
          <ThemeIcon variant="light" radius="md" size="lg">
            <span>üìç</span>
          </ThemeIcon>
        </Group>
        <Text size="sm" c="dimmed">
          Cliente: {visit.pool.client.name}
        </Text>
      </Link>
      <Anchor
        href={`https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(visit.pool.address)}`}
        target="_blank"
        rel="noopener noreferrer"
        size="sm"
        mt="sm"
      >
        {visit.pool.address}
      </Anchor>
    </Card>
  ));

  return (
    <Container>
      <Title order={2} my="lg">Mi Ruta de Hoy</Title>
      {visits.length > 0 ? (
        <Stack gap="md">{visitCards}</Stack>
      ) : (
        <Text>No tienes visitas asignadas para hoy.</Text>
      )}
    </Container>
  );
}


// ====== [18] packages/client/src/features/technician/pages/WorkOrderPage.tsx ======
// filename: packages/client/src/features/technician/pages/WorkOrderPage.tsx
// Version: 1.2.2 (Remove window.location.reload and rely on router state)
import { useEffect, useState } from 'react';
import { useParams, Link, useNavigate } from 'react-router-dom';
import {
  Container,
  Title,
  Loader,
  Alert,
  Paper,
  Text,
  Breadcrumbs,
  Button,
  Stack,
  Checkbox,
  NumberInput,
  Switch,
  TextInput,
  Select,
  Textarea,
} from '@mantine/core';
import { useForm } from '@mantine/form';
import apiClient from '../../../api/apiClient';

// --- Tipos ---
interface ParameterConfig {
  id: string;
  name: string;
  unit: string | null;
  type: 'NUMBER' | 'BOOLEAN' | 'TEXT' | 'SELECT';
  selectOptions: string[];
}
interface TaskConfig {
  id: string;
  name: string;
}
interface VisitDetails {
  id: string;
  pool: {
    configurations: {
      id: string;
      parameterTemplate?: ParameterConfig;
      taskTemplate?: TaskConfig;
    }[];
    name: string;
    address: string;
    client: { name: string };
  };
}
interface ApiResponse<T> {
  success: boolean;
  data: T;
}

// --- Componente ---
export function WorkOrderPage() {
  const { visitId } = useParams<{ visitId: string }>();
  const navigate = useNavigate();
  const [visit, setVisit] = useState<VisitDetails | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const form = useForm({
    initialValues: {
      results: {} as Record<string, string | number | boolean>,
      completedTasks: {} as Record<string, boolean>,
      notes: '',
      hasIncident: false,
    },
  });

  useEffect(() => {
    if (!visitId) {
      setError('No se ha proporcionado un ID de visita.');
      setIsLoading(false);
      return;
    }
    const fetchVisitDetails = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const response = await apiClient.get<ApiResponse<VisitDetails>>(`/visits/${visitId}`);
        const visitData = response.data.data;
        setVisit(visitData);
        
        form.setInitialValues({
          results: visitData.pool.configurations
            .filter(c => c.parameterTemplate)
            .reduce((acc, c) => ({ ...acc, [c.id]: '' }), {}),
          completedTasks: visitData.pool.configurations
            .filter(c => c.taskTemplate)
            .reduce((acc, c) => ({ ...acc, [c.id]: false }), {}),
          notes: '',
          hasIncident: false,
        });
        form.reset();
      } catch (err) {
        setError('No se pudo cargar la informaci√≥n de la visita.');
      } finally {
        setIsLoading(false);
      }
    };
    fetchVisitDetails();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [visitId]);

  const handleSubmit = async (values: typeof form.values) => {
    if (!visitId) return;
    setIsSubmitting(true);
    try {
      await apiClient.post(`/visits/${visitId}/complete`, values);
      // Simplemente navegamos de vuelta.
      navigate('/my-route');
    } catch (err) {
      console.error('Error submitting work order', err);
      setIsSubmitting(false);
    }
  };

  if (isLoading) return <Container style={{ textAlign: 'center', paddingTop: '50px' }}><Loader size="xl" /></Container>;
  if (error) return <Alert color="red" title="Error">{error}</Alert>;
  if (!visit) return <Alert color="yellow" title="Aviso">Visita no encontrada.</Alert>;
  
  const breadcrumbs = (
    <Breadcrumbs>
      <Link to="/my-route">Mi Ruta</Link>
      <Text>{visit.pool.name}</Text>
    </Breadcrumbs>
  );

  const parametersToMeasure = visit.pool.configurations.filter(c => c.parameterTemplate);
  const tasksToComplete = visit.pool.configurations.filter(c => c.taskTemplate);

  const renderParameterInput = (config: typeof parametersToMeasure[0]) => {
    const { parameterTemplate: param } = config;
    if (!param) return null;
    const label = `${param.name}${param.unit ? ` (${param.unit})` : ''}`;

    switch (param.type) {
      case 'NUMBER': return <NumberInput label={label} {...form.getInputProps(`results.${config.id}`)} />;
      case 'BOOLEAN': return <Switch mt="md" label={label} {...form.getInputProps(`results.${config.id}`, { type: 'checkbox' })} />;
      case 'TEXT': return <TextInput label={label} {...form.getInputProps(`results.${config.id}`)} />;
      case 'SELECT': return <Select label={label} data={param.selectOptions} {...form.getInputProps(`results.${config.id}`)} />;
      default: return <Text c="red">Tipo de par√°metro no soportado: {param.type}</Text>;
    }
  };

  return (
    <Container>
      {breadcrumbs}
      <Title order={2} my="lg">Parte de Trabajo: {visit.pool.name}</Title>
      <Text c="dimmed">{visit.pool.client.name} - {visit.pool.address}</Text>

      <Paper withBorder p="md" mt="xl">
        <form onSubmit={form.onSubmit(handleSubmit)}>
          <Stack>
            {parametersToMeasure.length > 0 && (
              <div>
                <Title order={4} mb="sm">Mediciones de Par√°metros</Title>
                <Stack>{parametersToMeasure.map(p => <div key={p.id}>{renderParameterInput(p)}</div>)}</Stack>
              </div>
            )}
            {tasksToComplete.length > 0 && (
              <div>
                <Title order={4} mt="lg" mb="sm">Tareas a Realizar</Title>
                <Stack>{tasksToComplete.map(t => <Checkbox key={t.id} label={t.taskTemplate?.name} {...form.getInputProps(`completedTasks.${t.id}`, { type: 'checkbox' })} />)}</Stack>
              </div>
            )}
            
            <Title order={4} mt="lg" mb="sm">Observaciones e Incidencias</Title>
            <Textarea label="Notas de la visita (opcional)" placeholder="Cualquier observaci√≥n relevante..." {...form.getInputProps('notes')} />
            <Checkbox label="Reportar como Incidencia" description="Marca esta casilla si hay un problema que requiera la atenci√≥n del administrador." {...form.getInputProps('hasIncident', { type: 'checkbox' })} />
            
            <Button type="submit" mt="xl" size="lg" loading={isSubmitting}>
              Guardar y Finalizar Visita
            </Button>
          </Stack>
        </form>
      </Paper>
    </Container>
  );
}


// ====== [19] packages/client/src/main.tsx ======
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.js';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


// ====== [20] packages/client/src/providers/AuthProvider.tsx ======
import {
  createContext,
  useContext,
  useState,
  useEffect,
  useCallback,
} from 'react';
import type { PropsWithChildren } from 'react';
import apiClient from '../api/apiClient.js';

// --- Types ---
type LoginCredentials = {
  email: string;
  password: string;
};

interface User {
  id: string;
  name: string;
  email: string;
  role: string;
}

interface AuthContextType {
  user: User | null;
  login: (credentials: LoginCredentials) => Promise<void>;
  logout: () => Promise<void>;
  isLoading: boolean;
  isAuthenticated: boolean;
}

// --- Context ---
const AuthContext = createContext<AuthContextType | undefined>(undefined);

// --- Provider Component ---
export const AuthProvider = ({ children }: PropsWithChildren) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  const checkAuthStatus = useCallback(async () => {
    setIsLoading(true);
    try {
      // Este endpoint ahora existe y funciona gracias a los pasos anteriores
      const response = await apiClient.get('/auth/me');
      setUser(response.data.data);
    } catch (error) {
      setUser(null);
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    // Activamos la comprobaci√≥n de la sesi√≥n al cargar la app
    checkAuthStatus();
  }, [checkAuthStatus]);

  const login = async (credentials: LoginCredentials) => {
    const response = await apiClient.post('/auth/login', credentials);
    setUser(response.data.data);
  };

  const logout = async () => {
    await apiClient.post('/auth/logout');
    setUser(null);
  };

  const value: AuthContextType = {
    user,
    login,
    logout,
    isLoading,
    isAuthenticated: !!user,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

// --- Custom Hook ---
export const useAuth = (): AuthContextType => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};


// ====== [21] packages/client/src/router/components.tsx ======
// filename: packages/client/src/router/components.tsx
// Version: 1.5.0 (Add TechnicianRoute and navigation link)
import { AppShell, Burger, Group, NavLink, Title, Button } from '@mantine/core';
import { useDisclosure } from '@mantine/hooks';
import { Navigate, Outlet, Link, useNavigate } from 'react-router-dom';
import { useAuth } from '../providers/AuthProvider.js';

/**
 * Componente de layout principal para las p√°ginas autenticadas.
 */
export const AppLayout = () => {
  const [opened, { toggle }] = useDisclosure();
  const { user, logout } = useAuth();
  const navigate = useNavigate();

  const handleLogout = async () => {
    await logout();
    navigate('/login');
  };

  return (
    <AppShell
      header={{ height: 60 }}
      navbar={{ width: 300, breakpoint: 'sm', collapsed: { mobile: !opened } }}
      padding="md"
    >
      <AppShell.Header>
        <Group h="100%" px="md" justify="space-between">
          <Group>
            <Burger opened={opened} onClick={toggle} hiddenFrom="sm" size="sm" />
            <Title order={3}>Pool Control Professional</Title>
          </Group>
          <Button variant="light" onClick={handleLogout}>Cerrar Sesi√≥n</Button>
        </Group>
      </AppShell.Header>

      <AppShell.Navbar p="md">
        <NavLink
          component={Link}
          to="/"
          label="Dashboard"
          onClick={toggle}
        />
        
        {/* Enlaces solo para el rol ADMIN */}
        {user?.role === 'ADMIN' && (
          <>
            <NavLink
              component={Link}
              to="/planner"
              label="Planificador"
              onClick={toggle}
            />
            <NavLink
              component={Link}
              to="/clients"
              label="Clientes"
              onClick={toggle}
            />
            <NavLink label="Cat√°logos">
              <NavLink 
                component={Link} 
                to="/catalog/parameters" 
                label="Par√°metros" 
                onClick={toggle} 
              />
              <NavLink 
                component={Link} 
                to="/catalog/tasks" 
                label="Tareas" 
                onClick={toggle} 
              />
            </NavLink>
          </>
        )}

        {/* Enlaces solo para el rol TECHNICIAN */}
        {user?.role === 'TECHNICIAN' && (
          <NavLink
            component={Link}
            to="/my-route"
            label="Mi Ruta de Hoy"
            onClick={toggle}
          />
        )}

        {/* Enlaces solo para el rol SUPER_ADMIN */}
        {user?.role === 'SUPER_ADMIN' && (
           <NavLink 
              component={Link} 
              to="/superadmin/tenants" 
              label="Gesti√≥n de Tenants" 
              onClick={toggle} 
            />
        )}
      </AppShell.Navbar>

      <AppShell.Main>
        <Outlet />
      </AppShell.Main>
    </AppShell>
  );
};

/**
 * Componente que protege rutas gen√©ricas de usuarios no autenticados.
 */
export const ProtectedRoute = () => {
  const { isAuthenticated, isLoading } = useAuth();
  if (isLoading) return <div>Cargando...</div>;
  if (!isAuthenticated) return <Navigate to="/login" replace />;
  return <Outlet />;
};

/**
 * Componente que protege rutas espec√≠ficas para el rol SUPER_ADMIN.
 */
export const SuperAdminRoute = () => {
  const { user, isLoading } = useAuth();
  if (isLoading) return <div>Cargando...</div>;
  if (user?.role !== 'SUPER_ADMIN') return <Navigate to="/" replace />;
  return <Outlet />;
};

/**
 * Componente que protege rutas espec√≠ficas para los roles ADMIN y SUPER_ADMIN.
 */
export const AdminRoute = () => {
  const { user, isLoading } = useAuth();
  if (isLoading) return <div>Cargando...</div>;
  if (user?.role !== 'ADMIN' && user?.role !== 'SUPER_ADMIN') {
    return <Navigate to="/" replace />;
  }
  return <Outlet />;
};

/**
 * Componente que protege rutas espec√≠ficas para el rol TECHNICIAN.
 */
export const TechnicianRoute = () => {
  const { user, isLoading } = useAuth();
  if (isLoading) return <div>Cargando...</div>;
  // Solo permite acceso si el rol es TECHNICIAN
  if (user?.role !== 'TECHNICIAN') {
    return <Navigate to="/" replace />;
  }
  return <Outlet />;
};


// ====== [22] packages/client/src/router/index.tsx ======
// filename: packages/client/src/router/index.tsx
// Version: 1.8.0 (Add WorkOrderPage route for Technician)
import { createBrowserRouter } from 'react-router-dom';
import { LoginPage } from '../features/auth/pages/LoginPage.js';
import { TenantsPage } from '../features/superadmin/pages/TenantsPage.js';
import { ParameterCatalogPage } from '../features/admin/pages/ParameterCatalogPage.js';
import { TaskCatalogPage } from '../features/admin/pages/TaskCatalogPage.js';
import { ClientsPage } from '../features/admin/pages/clients/ClientsPage.js';
import { ClientDetailPage } from '../features/admin/pages/clients/ClientDetailPage.js';
import { PoolDetailPage } from '../features/admin/pages/pools/PoolDetailPage.js';
import { PlannerPage } from '../features/admin/pages/planner/PlannerPage.js';
import { MyRoutePage } from '../features/technician/pages/MyRoutePage.js';
import { WorkOrderPage } from '../features/technician/pages/WorkOrderPage.js'; // <-- Importamos la nueva p√°gina
import {
  AppLayout,
  ProtectedRoute,
  SuperAdminRoute,
  AdminRoute,
  TechnicianRoute,
} from './components.js';

export const router = createBrowserRouter([
  {
    path: '/login',
    element: <LoginPage />,
  },
  {
    path: '/',
    element: <ProtectedRoute />,
    children: [
      {
        element: <AppLayout />,
        children: [
          {
            index: true,
            element: <div>Dashboard Principal</div>,
          },
          // --- Secci√≥n de SuperAdmin ---
          {
            path: 'superadmin',
            element: <SuperAdminRoute />,
            children: [
              {
                path: 'tenants',
                element: <TenantsPage />,
              },
            ],
          },
          // --- Secci√≥n de Administraci√≥n ---
          {
            path: 'planner',
            element: <AdminRoute />,
            children: [
              {
                index: true,
                element: <PlannerPage />,
              },
            ],
          },
          {
            path: 'clients',
            element: <AdminRoute />,
            children: [
              {
                index: true,
                element: <ClientsPage />,
              },
              {
                path: ':id', 
                element: <ClientDetailPage />,
              },
            ],
          },
          {
            path: 'pools/:id', 
            element: <AdminRoute />,
            children: [
              {
                index: true,
                element: <PoolDetailPage />
              }
            ]
          },
          {
            path: 'catalog',
            element: <AdminRoute />,
            children: [
              {
                path: 'parameters',
                element: <ParameterCatalogPage />,
              },
              {
                path: 'tasks',
                element: <TaskCatalogPage />,
              },
            ],
          },
          // --- Secci√≥n de T√©cnico ---
          {
            path: 'my-route',
            element: <TechnicianRoute />,
            children: [
              {
                index: true,
                element: <MyRoutePage />,
              },
            ],
          },
          {
            path: 'visits/:visitId', // <-- A√±adimos la nueva ruta
            element: <TechnicianRoute />,
            children: [
              {
                index: true,
                element: <WorkOrderPage />,
              },
            ],
          },
        ],
      },
    ],
  },
]);


// ====== [23] packages/client/src/styles/theme.ts ======
import { createTheme } from '@mantine/core';
import type { MantineColorsTuple } from '@mantine/core';

// Definimos una paleta de colores personalizada para nuestra marca.
// Puedes generar las tuyas en https://mantine.dev/colors-generator/
const brandBlue: MantineColorsTuple = [
  '#e7f5ff',
  '#d0ebff',
  '#a5d8ff',
  '#74c0fc',
  '#4dabf7',
  '#339af0',
  '#228be6',
  '#1c7ed6',
  '#1572c3',
  '#1068b1',
];

export const theme = createTheme({
  fontFamily: 'Inter, sans-serif',
  primaryColor: 'brandBlue',

  colors: {
    brandBlue,
  },

  headings: {
    fontFamily: 'Inter, sans-serif',
  },
});


// ====== [24] packages/client/tsconfig.json ======
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "allowJs": false,
    "skipLibCheck": true,
    "esModuleInterop": false,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}


// ====== [25] packages/client/tsconfig.node.json ======
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}


// ====== [26] packages/client/vite.config.ts ======
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 5173,
    // Configuramos un proxy para evitar problemas de CORS en desarrollo.
    // Todas las peticiones del frontend a '/api' ser√°n redirigidas
    // a nuestro servidor de backend en el puerto 3001.
    proxy: {
      '/api': {
        target: 'http://localhost:3001',
        changeOrigin: true,
      },
    },
  },
});


// ====== [27] packages/server/package.json ======
{
  "name": "@pool-control/server",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "main": "dist/server.js",
  "scripts": {
    "dev": "tsx watch src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev",
    "prisma:studio": "prisma studio",
    "db:seed": "tsx prisma/seed.ts"
  },
  "dependencies": {
    "@prisma/client": "^5.15.0",
    "bcryptjs": "^2.4.3",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "date-fns": "^4.1.0",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "jsonwebtoken": "^9.0.2",
    "ms": "^2.1.3"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/cookie-parser": "^1.4.7",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.6",
    "@types/ms": "^0.7.34",
    "@types/node": "^20.14.2",
    "prisma": "^5.15.0",
    "tsx": "^4.15.4",
    "typescript": "^5.4.5"
  }
}


// ====== [28] packages/server/prisma/seed.ts ======
import { PrismaClient } from '@prisma/client';
import { hashPassword } from '../src/utils/password.utils.js';

const prisma = new PrismaClient();

async function main() {
  console.log('üå± Empezando el proceso de seeding...');

  // 1. Eliminar datos antiguos para asegurar un estado limpio
  // La eliminaci√≥n debe ser en el orden correcto para no violar las restricciones de clave for√°nea.
  await prisma.user.deleteMany({});
  await prisma.tenant.deleteMany({});
  console.log('üóëÔ∏è Datos antiguos eliminados.');

  // 2. Crear el Tenant del Sistema
  const systemTenant = await prisma.tenant.create({
    data: {
      companyName: 'SYSTEM_INTERNAL',
      subdomain: 'system',
      subscriptionStatus: 'ACTIVE',
    },
  });
  console.log(`üè¢ Tenant del sistema creado: ${systemTenant.companyName}`);

  // 3. Hashear la contrase√±a del SuperAdmin
  const password = 'superadmin123';
  const hashedPassword = await hashPassword(password);
  console.log('üîë Contrase√±a del SuperAdmin hasheada.');

  // 4. Crear el usuario SuperAdmin
  const superAdmin = await prisma.user.create({
    data: {
      email: 'super@admin.com',
      name: 'Super Admin',
      password: hashedPassword,
      role: 'SUPER_ADMIN',
      tenantId: systemTenant.id, // Se asigna al tenant del sistema
    },
  });
  console.log(`üë§ Usuario SuperAdmin creado: ${superAdmin.email}`);

  console.log('‚úÖ Seeding completado con √©xito.');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });


// ====== [29] packages/server/src/api/auth/auth.controller.ts ======
import type { Response, NextFunction } from 'express';
import { register, login } from './auth.service.js';
import { signToken } from '../../utils/jwt.utils.js';
import config from '../../config/index.js';
import type { CookieOptions, Request } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';

const cookieOptions: CookieOptions = {
  httpOnly: true,
  secure: process.env.NODE_ENV === 'production',
  sameSite: 'lax',
  maxAge: config.JWT_EXPIRES_IN * 1000, // maxAge est√° en milisegundos
};

/**
 * Maneja la petici√≥n de registro de un nuevo usuario.
 */
export const registerHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const user = await register(req.body);
    res.status(201).json({
      success: true,
      data: user,
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la petici√≥n de login de un usuario.
 */
export const loginHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const user = await login(req.body);
    const token = signToken({ id: user.id, role: user.role });
    res.cookie('token', token, cookieOptions);
    res.status(200).json({
      success: true,
      data: user,
    });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n del usuario actualmente autenticado (a trav√©s del token).
 */
export const getMeHandler = (req: AuthRequest, res: Response) => {
  // El middleware 'protect' se ejecuta antes que este manejador.
  // Si llega hasta aqu√≠, significa que el token es v√°lido y 'req.user' existe.
  res.status(200).json({
    success: true,
    data: req.user,
  });
};


// ====== [30] packages/server/src/api/auth/auth.routes.ts ======
import { Router } from 'express';
import type { Response } from 'express';
import {
  registerHandler,
  loginHandler,
  getMeHandler,
} from './auth.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const authRouter = Router();

/**
 * @route   POST /api/auth/register
 * @desc    Registra un nuevo usuario
 * @access  Public
 */
authRouter.post('/register', registerHandler);

/**
 * @route   POST /api/auth/login
 * @desc    Inicia sesi√≥n y devuelve un token en una cookie
 * @access  Public
 */
authRouter.post('/login', loginHandler);

/**
 * @route   GET /api/auth/me
 * @desc    Obtiene los datos del usuario logueado a partir de su token
 * @access  Private
 */
authRouter.get('/me', protect, getMeHandler);

/**
 * @route   POST /api/auth/logout
 * @desc    Cierra la sesi√≥n del usuario eliminando la cookie
 * @access  Public
 */
authRouter.post('/logout', (_req, res: Response) => {
  res.cookie('token', '', {
    httpOnly: true,
    expires: new Date(0),
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
  });
  res.status(200).json({ success: true, message: 'Sesi√≥n cerrada con √©xito.' });
});

export default authRouter;


// ====== [31] packages/server/src/api/auth/auth.service.ts ======
import { PrismaClient } from '@prisma/client';
import type { User } from '@prisma/client';
import { hashPassword, comparePassword } from '../../utils/password.utils.js';

const prisma = new PrismaClient();

// Tipo para la entrada de datos del registro.
export type RegisterUserInput = Omit<User, 'id' | 'createdAt' | 'updatedAt'>;

// Tipo para la entrada de datos del login.
export type LoginUserInput = {
  email: string;
  password: string;
};

/**
 * Registra un nuevo usuario en la base de datos.
 * @param input - Datos del usuario para el registro.
 * @returns El objeto de usuario creado (sin la contrase√±a).
 */
export const register = async (input: RegisterUserInput) => {
  const { email, password, ...rest } = input;

  const existingUser = await prisma.user.findUnique({
    where: { email },
  });

  if (existingUser) {
    throw new Error('Ya existe un usuario con este correo electr√≥nico.');
  }

  const hashedPassword = await hashPassword(password);

  const user = await prisma.user.create({
    data: {
      email,
      password: hashedPassword,
      ...rest,
    },
    select: {
      id: true,
      email: true,
      name: true,
      role: true,
      tenantId: true,
      createdAt: true,
      updatedAt: true,
    },
  });

  return user;
};

/**
 * Valida las credenciales de un usuario para el login.
 * @param input - Email y contrase√±a del usuario.
 * @returns El objeto de usuario autenticado (sin la contrase√±a).
 */
export const login = async (input: LoginUserInput): Promise<Omit<User, 'password'>> => {
  const user = await prisma.user.findUnique({
    where: { email: input.email },
  });

  if (!user) {
    throw new Error('El email o la contrase√±a son incorrectos.');
  }

  const isPasswordValid = await comparePassword(input.password, user.password);

  if (!isPasswordValid) {
    throw new Error('El email o la contrase√±a son incorrectos.');
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const { password, ...userWithoutPassword } = user;

  return userWithoutPassword;
};


// ====== [32] packages/server/src/api/clients/clients.controller.ts ======
// filename: packages/server/src/api/clients/clients.controller.ts
// Version: 1.0.0 (Initial creation of the controller for Client management)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createClient,
  deleteClient,
  getClientById,
  getClientsByTenant,
  updateClient,
} from './clients.service.js';

/**
 * Maneja la creaci√≥n de un nuevo cliente.
 */
export const createClientHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acci√≥n no permitida.' });
    }

    const input = { ...req.body, tenantId };
    const newClient = await createClient(input);
    res.status(201).json({ success: true, data: newClient });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todos los clientes de un tenant.
 */
export const getClientsByTenantHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acci√≥n no permitida.' });
    }

    const clients = await getClientsByTenant(tenantId);
    res.status(200).json({ success: true, data: clients });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de un cliente espec√≠fico por ID.
 */
export const getClientByIdHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    const { id: clientId } = req.params;

    if (!tenantId) {
      return res.status(403).json({ message: 'Acci√≥n no permitida.' });
    }
    if (!clientId) {
      return res.status(400).json({ message: 'El ID del cliente es requerido.' });
    }

    const client = await getClientById(clientId, tenantId);
    if (!client) {
      return res.status(404).json({ message: 'Cliente no encontrado.' });
    }

    res.status(200).json({ success: true, data: client });
  } catch (error) {
    next(error);
  }
};


/**
 * Maneja la actualizaci√≥n de un cliente.
 */
export const updateClientHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID del cliente es requerido.' });
    }
    // TODO: Verificar que el cliente que se quiere editar pertenece al tenant del usuario logueado.
    
    const updatedClient = await updateClient(id, req.body);
    res.status(200).json({ success: true, data: updatedClient });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de un cliente.
 */
export const deleteClientHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID del cliente es requerido.' });
    }
    // TODO: Verificar que el cliente que se quiere eliminar pertenece al tenant del usuario logueado.

    await deleteClient(id);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [33] packages/server/src/api/clients/clients.routes.ts ======
// filename: packages/server/src/api/clients/clients.routes.ts
// Version: 1.0.0 (Initial creation of routes for Client management)
import { Router } from 'express';
import {
  createClientHandler,
  deleteClientHandler,
  getClientByIdHandler,
  getClientsByTenantHandler,
  updateClientHandler,
} from './clients.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const clientsRouter = Router();

// Aplicamos el middleware 'protect' a TODAS las rutas de este enrutador.
clientsRouter.use(protect);

// TODO: A√±adir un middleware de autorizaci√≥n para asegurar que el rol sea 'ADMIN'.

clientsRouter.route('/')
  .get(getClientsByTenantHandler)
  .post(createClientHandler);

clientsRouter.route('/:id')
  .get(getClientByIdHandler)
  .patch(updateClientHandler)
  .delete(deleteClientHandler);

export default clientsRouter;


// ====== [34] packages/server/src/api/clients/clients.service.ts ======
// filename: packages/server/src/api/clients/clients.service.ts
// Version: 1.0.0 (Initial creation of the service for Client management)
import { PrismaClient } from '@prisma/client';
import type { Client } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateClientInput = Omit<Client, 'id' | 'createdAt' | 'updatedAt'>;
export type UpdateClientInput = Partial<CreateClientInput>;

// --- Funciones del Servicio ---

/**
 * Crea un nuevo cliente para un tenant espec√≠fico.
 * @param data - Datos del nuevo cliente.
 * @returns El cliente creado.
 */
export const createClient = async (data: CreateClientInput): Promise<Client> => {
  return prisma.client.create({
    data,
  });
};

/**
 * Obtiene todos los clientes de un tenant espec√≠fico.
 * @param tenantId - El ID del tenant.
 * @returns Un array de clientes.
 */
export const getClientsByTenant = async (tenantId: string): Promise<Client[]> => {
  return prisma.client.findMany({
    where: { tenantId },
    orderBy: { name: 'asc' },
    // Incluimos las piscinas asociadas a cada cliente
    include: {
      pools: true,
    },
  });
};

/**
 * Obtiene un cliente espec√≠fico por su ID.
 * @param id - El ID del cliente a buscar.
 * @param tenantId - El ID del tenant para asegurar la pertenencia.
 * @returns El objeto del cliente o null si no se encuentra o no pertenece al tenant.
 */
export const getClientById = async (id: string, tenantId: string): Promise<Client | null> => {
  return prisma.client.findFirst({
    where: { id, tenantId },
     include: {
      pools: true,
    },
  });
};


/**
 * Actualiza un cliente existente.
 * @param id - El ID del cliente a actualizar.
 * @param data - Los datos a actualizar.
 * @returns El cliente actualizado.
 */
export const updateClient = async (id: string, data: UpdateClientInput): Promise<Client> => {
  return prisma.client.update({
    where: { id },
    data,
  });
};

/**
 * Elimina un cliente.
 * @param id - El ID del cliente a eliminar.
 * @returns El cliente que fue eliminado.
 */
export const deleteClient = async (id: string): Promise<Client> => {
  // Al borrar el cliente, se borrar√°n en cascada sus piscinas asociadas.
  return prisma.client.delete({
    where: { id },
  });
};


// ====== [35] packages/server/src/api/parameters/parameters.controller.ts ======
// filename: packages/server/src/api/parameters/parameters.controller.ts
// Version: 1.0.0 (Initial creation of the controller for Parameter Templates)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
createParameterTemplate,
deleteParameterTemplate,
getParameterTemplatesByTenant,
updateParameterTemplate,
} from './parameters.service.js';
/**
Maneja la creaci√≥n de una nueva plantilla de par√°metro.
*/
export const createParameterTemplateHandler = async (
req: AuthRequest,
res: Response,
next: NextFunction
) => {
try {
// Aseguramos que el usuario est√© autenticado y tenga un tenantId
const tenantId = req.user?.tenantId;
if (!tenantId) {
return res.status(403).json({ message: 'Acci√≥n no permitida.' });
}
const input = { ...req.body, tenantId };
const newTemplate = await createParameterTemplate(input);
res.status(201).json({ success: true, data: newTemplate });
} catch (error) {
next(error);
}
};
/**
Maneja la obtenci√≥n de todas las plantillas de un tenant.
*/
export const getParameterTemplatesByTenantHandler = async (
req: AuthRequest,
res: Response,
next: NextFunction
) => {
try {
const tenantId = req.user?.tenantId;
if (!tenantId) {
return res.status(403).json({ message: 'Acci√≥n no permitida.' });
}
const templates = await getParameterTemplatesByTenant(tenantId);
res.status(200).json({ success: true, data: templates });
} catch (error) {
next(error);
}
};
/**
Maneja la actualizaci√≥n de una plantilla de par√°metro.
*/
export const updateParameterTemplateHandler = async (
req: AuthRequest,
res: Response,
next: NextFunction
) => {
try {
const { id } = req.params;
if (!id) {
return res.status(400).json({ message: 'El ID de la plantilla es requerido.' });
}
// TODO: Verificar que la plantilla que se quiere editar pertenece al tenant del usuario logueado.
const updatedTemplate = await updateParameterTemplate(id, req.body);
res.status(200).json({ success: true, data: updatedTemplate });
} catch (error) {
next(error);
}
};
/**
Maneja la eliminaci√≥n de una plantilla de par√°metro.
*/
export const deleteParameterTemplateHandler = async (
req: AuthRequest,
res: Response,
next: NextFunction
) => {
try {
const { id } = req.params;
if (!id) {
return res.status(400).json({ message: 'El ID de la plantilla es requerido.' });
}
// TODO: Verificar que la plantilla que se quiere eliminar pertenece al tenant del usuario logueado.
await deleteParameterTemplate(id);
res.status(204).send();
} catch (error) {
next(error);
}
};


// ====== [36] packages/server/src/api/parameters/parameters.routes.ts ======
// filename: packages/server/src/api/parameters/parameters.routes.ts
// Version: 1.0.0 (Initial creation of routes for Parameter Templates)
import { Router } from 'express';
import {
  createParameterTemplateHandler,
  deleteParameterTemplateHandler,
  getParameterTemplatesByTenantHandler,
  updateParameterTemplateHandler,
} from './parameters.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const parametersRouter = Router();

// Aplicamos el middleware 'protect' a TODAS las rutas definidas en este archivo.
// Esto asegura que solo los usuarios autenticados pueden gestionar el cat√°logo.
parametersRouter.use(protect);

// TODO: A√±adir un middleware de autorizaci√≥n para asegurar que el rol sea 'ADMIN'.

parametersRouter.route('/')
  .get(getParameterTemplatesByTenantHandler)
  .post(createParameterTemplateHandler);

parametersRouter.route('/:id')
  .patch(updateParameterTemplateHandler)
  .delete(deleteParameterTemplateHandler);

export default parametersRouter;


// ====== [37] packages/server/src/api/parameters/parameters.service.ts ======
// filename: packages/server/src/api/parameters/parameters.service.ts
// Version: 1.0.0 (Initial creation of the service with CRUD functions)
import { PrismaClient } from '@prisma/client';
import type { ParameterTemplate, InputType } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateParameterTemplateInput = {
  name: string;
  tenantId: string; // Cada plantilla pertenece a un tenant
  unit?: string;
  type?: InputType;
  selectOptions?: string[];
};

export type UpdateParameterTemplateInput = Partial<Omit<CreateParameterTemplateInput, 'tenantId'>>;

// --- Funciones del Servicio ---

/**
 * Crea una nueva plantilla de par√°metro para un tenant espec√≠fico.
 * @param input - Datos de la nueva plantilla.
 * @returns La plantilla de par√°metro creada.
 */
export const createParameterTemplate = async (
  input: CreateParameterTemplateInput
): Promise<ParameterTemplate> => {
  return prisma.parameterTemplate.create({
    data: input,
  });
};

/**
 * Obtiene todas las plantillas de par√°metros para un tenant espec√≠fico.
 * @param tenantId - El ID del tenant.
 * @returns Un array de plantillas de par√°metros.
 */
export const getParameterTemplatesByTenant = async (
  tenantId: string
): Promise<ParameterTemplate[]> => {
  return prisma.parameterTemplate.findMany({
    where: { tenantId },
    orderBy: { name: 'asc' },
  });
};

/**
 * Actualiza una plantilla de par√°metro existente.
 * @param id - El ID de la plantilla a actualizar.
 * @param data - Los datos a actualizar.
 * @returns La plantilla de par√°metro actualizada.
 */
export const updateParameterTemplate = async (
  id: string,
  data: UpdateParameterTemplateInput
): Promise<ParameterTemplate> => {
  return prisma.parameterTemplate.update({
    where: { id },
    data,
  });
};

/**
 * Elimina una plantilla de par√°metro.
 * @param id - El ID de la plantilla a eliminar.
 * @returns La plantilla de par√°metro que fue eliminada.
 */
export const deleteParameterTemplate = async (
  id: string
): Promise<ParameterTemplate> => {
  // TODO: A√±adir l√≥gica para verificar que esta plantilla no est√° siendo
  // usada en ninguna PoolConfiguration antes de permitir el borrado.
  return prisma.parameterTemplate.delete({
    where: { id },
  });
};


// ====== [38] packages/server/src/api/pool-configurations/pool-configurations.controller.ts ======
// filename: packages/server/src/api/pool-configurations/pool-configurations.controller.ts
// Version: 1.1.0 (Add handler for update functionality)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createPoolConfiguration,
  deletePoolConfiguration,
  getConfigurationsByPool,
  updatePoolConfiguration,
} from './pool-configurations.service.js';

/**
 * Maneja la creaci√≥n de una nueva configuraci√≥n de mantenimiento.
 */
export const createPoolConfigurationHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acci√≥n no permitida.' });
    }
    const newConfig = await createPoolConfiguration(req.body);
    res.status(201).json({ success: true, data: newConfig });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todas las configuraciones para una piscina.
 */
export const getConfigurationsByPoolHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { poolId } = req.params;
    if (!poolId) {
      return res.status(400).json({ message: 'El ID de la piscina es requerido.' });
    }
    const configs = await getConfigurationsByPool(poolId);
    res.status(200).json({ success: true, data: configs });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n de una configuraci√≥n de mantenimiento.
 */
export const updatePoolConfigurationHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la configuraci√≥n es requerido.' });
    }
    // TODO: Verificar que la configuraci√≥n que se quiere editar pertenece al tenant del usuario.
    const updatedConfig = await updatePoolConfiguration(id, req.body);
    res.status(200).json({ success: true, data: updatedConfig });
  } catch (error) {
    next(error);
  }
};


/**
 * Maneja la eliminaci√≥n de una configuraci√≥n de mantenimiento.
 */
export const deletePoolConfigurationHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la configuraci√≥n es requerido.' });
    }
    await deletePoolConfiguration(id);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [39] packages/server/src/api/pool-configurations/pool-configurations.routes.ts ======
// filename: packages/server/src/api/pool-configurations/pool-configurations.routes.ts
// Version: 1.1.0 (Add PATCH route for update functionality)
import { Router } from 'express';
import {
  createPoolConfigurationHandler,
  deletePoolConfigurationHandler,
  getConfigurationsByPoolHandler,
  updatePoolConfigurationHandler,
} from './pool-configurations.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const poolConfigurationsRouter = Router();

poolConfigurationsRouter.use(protect);

// TODO: A√±adir un middleware de autorizaci√≥n para asegurar que el rol sea 'ADMIN'.

poolConfigurationsRouter.route('/')
  .post(createPoolConfigurationHandler);

poolConfigurationsRouter.route('/by-pool/:poolId')
  .get(getConfigurationsByPoolHandler);

poolConfigurationsRouter.route('/:id')
  .patch(updatePoolConfigurationHandler) // Nueva ruta PATCH
  .delete(deletePoolConfigurationHandler);

export default poolConfigurationsRouter;


// ====== [40] packages/server/src/api/pool-configurations/pool-configurations.service.ts ======
// filename: packages/server/src/api/pool-configurations/pool-configurations.service.ts
// Version: 1.1.0 (Add update functionality)
import { PrismaClient } from '@prisma/client';
import type { PoolConfiguration, Frequency } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreatePoolConfigurationInput = {
  poolId: string;
  frequency: Frequency;
  minThreshold?: number;
  maxThreshold?: number;
  parameterTemplateId?: string;
  taskTemplateId?: string;
};

export type UpdatePoolConfigurationInput = Partial<Omit<CreatePoolConfigurationInput, 'poolId' | 'parameterTemplateId' | 'taskTemplateId'>>;


// --- Funciones del Servicio ---

/**
 * Crea una nueva configuraci√≥n de mantenimiento para una piscina.
 */
export const createPoolConfiguration = async (
  data: CreatePoolConfigurationInput
): Promise<PoolConfiguration> => {
  if (data.parameterTemplateId && data.taskTemplateId) {
    throw new Error('Una configuraci√≥n solo puede estar asociada a un par√°metro O a una tarea, no a ambos.');
  }
  if (!data.parameterTemplateId && !data.taskTemplateId) {
    throw new Error('La configuraci√≥n debe estar asociada a un par√°metro o a una tarea.');
  }

  return prisma.poolConfiguration.create({
    data,
  });
};

/**
 * Obtiene todas las configuraciones para una piscina espec√≠fica.
 */
export const getConfigurationsByPool = async (poolId: string): Promise<PoolConfiguration[]> => {
  return prisma.poolConfiguration.findMany({
    where: { poolId },
    include: {
      parameterTemplate: true,
      taskTemplate: true,
    },
  });
};

/**
 * Actualiza una configuraci√≥n de mantenimiento existente.
 * @param id - El ID de la configuraci√≥n a actualizar.
 * @param data - Los datos a actualizar.
 * @returns La configuraci√≥n actualizada.
 */
export const updatePoolConfiguration = async (
  id: string,
  data: UpdatePoolConfigurationInput
): Promise<PoolConfiguration> => {
  return prisma.poolConfiguration.update({
    where: { id },
    data,
  });
};


/**
 * Elimina una configuraci√≥n de mantenimiento de una piscina.
 */
export const deletePoolConfiguration = async (id: string): Promise<PoolConfiguration> => {
  return prisma.poolConfiguration.delete({
    where: { id },
  });
};


// ====== [41] packages/server/src/api/pools/pools.controller.ts ======
// filename: packages/server/src/api/pools/pools.controller.ts
// Version: 1.0.0 (Initial creation of the controller for Pool management)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { createPool, deletePool, updatePool } from './pools.service.js';

/**
 * Maneja la creaci√≥n de una nueva piscina.
 */
export const createPoolHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acci√≥n no permitida.' });
    }

    // Aseguramos que la piscina se asigne al tenant del usuario.
    const input = { ...req.body, tenantId };
    const newPool = await createPool(input);
    res.status(201).json({ success: true, data: newPool });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n de una piscina.
 */
export const updatePoolHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la piscina es requerido.' });
    }
    // TODO: Verificar que la piscina que se quiere editar pertenece al tenant del usuario logueado.

    const updatedPool = await updatePool(id, req.body);
    res.status(200).json({ success: true, data: updatedPool });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de una piscina.
 */
export const deletePoolHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la piscina es requerido.' });
    }
    // TODO: Verificar que la piscina que se quiere eliminar pertenece al tenant del usuario logueado.

    await deletePool(id);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [42] packages/server/src/api/pools/pools.routes.ts ======
// filename: packages/server/src/api/pools/pools.routes.ts
// Version: 1.0.0 (Initial creation of routes for Pool management)
import { Router } from 'express';
import {
  createPoolHandler,
  deletePoolHandler,
  updatePoolHandler,
} from './pools.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const poolsRouter = Router();

// Aplicamos el middleware 'protect' a TODAS las rutas de este enrutador.
poolsRouter.use(protect);

// TODO: A√±adir un middleware de autorizaci√≥n para asegurar que el rol sea 'ADMIN'.

// No hay una ruta GET / aqu√≠ porque las piscinas se obtienen
// a trav√©s de la ruta del cliente (/api/clients/:id) para mantener el contexto.
poolsRouter.route('/')
  .post(createPoolHandler);

poolsRouter.route('/:id')
  .patch(updatePoolHandler)
  .delete(deletePoolHandler);

export default poolsRouter;


// ====== [43] packages/server/src/api/pools/pools.service.ts ======
// filename: packages/server/src/api/pools/pools.service.ts
// Version: 1.0.0 (Initial creation of the service for Pool management)
import { PrismaClient } from '@prisma/client';
import type { Pool } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
// Omitimos los campos autogenerados por la base de datos (id, qrCode, timestamps)
export type CreatePoolInput = Omit<Pool, 'id' | 'qrCode' | 'createdAt' | 'updatedAt'>;
export type UpdatePoolInput = Partial<CreatePoolInput>;

// --- Funciones del Servicio ---

/**
 * Crea una nueva piscina para un cliente y tenant espec√≠ficos.
 * @param data - Datos de la nueva piscina.
 * @returns La piscina creada.
 */
export const createPool = async (data: CreatePoolInput): Promise<Pool> => {
  return prisma.pool.create({
    data,
  });
};

/**
 * Actualiza una piscina existente.
 * @param id - El ID de la piscina a actualizar.
 * @param data - Los datos a actualizar.
 * @returns La piscina actualizada.
 */
export const updatePool = async (id: string, data: UpdatePoolInput): Promise<Pool> => {
  return prisma.pool.update({
    where: { id },
    data,
  });
};

/**
 * Elimina una piscina.
 * @param id - El ID de la piscina a eliminar.
 * @returns La piscina que fue eliminada.
 */
export const deletePool = async (id: string): Promise<Pool> => {
  // Al borrar la piscina, se borrar√°n en cascada sus visitas, etc.
  return prisma.pool.delete({
    where: { id },
  });
};


// ====== [44] packages/server/src/api/tasks/tasks.controller.ts ======
// filename: packages/server/src/api/tasks/tasks.controller.ts
// Version: 1.0.0 (Initial creation of the controller for Scheduled Tasks)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import {
  createTaskTemplate,
  deleteTaskTemplate,
  getTaskTemplatesByTenant,
  updateTaskTemplate,
} from './tasks.service.js';

/**
 * Maneja la creaci√≥n de una nueva plantilla de tarea.
 */
export const createTaskTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acci√≥n no permitida.' });
    }

    const input = { ...req.body, tenantId };
    const newTemplate = await createTaskTemplate(input);
    res.status(201).json({ success: true, data: newTemplate });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todas las plantillas de tareas de un tenant.
 */
export const getTaskTemplatesByTenantHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acci√≥n no permitida.' });
    }

    const templates = await getTaskTemplatesByTenant(tenantId);
    res.status(200).json({ success: true, data: templates });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n de una plantilla de tarea.
 */
export const updateTaskTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la plantilla es requerido.' });
    }
    // TODO: Verificar que la plantilla que se quiere editar pertenece al tenant del usuario logueado.

    const updatedTemplate = await updateTaskTemplate(id, req.body);
    res.status(200).json({ success: true, data: updatedTemplate });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de una plantilla de tarea.
 */
export const deleteTaskTemplateHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la plantilla es requerido.' });
    }
    // TODO: Verificar que la plantilla que se quiere eliminar pertenece al tenant del usuario logueado.

    await deleteTaskTemplate(id);
    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [45] packages/server/src/api/tasks/tasks.routes.ts ======
// filename: packages/server/src/api/tasks/tasks.routes.ts
// Version: 1.0.0 (Initial creation of routes for Scheduled Tasks)
import { Router } from 'express';
import {
  createTaskTemplateHandler,
  deleteTaskTemplateHandler,
  getTaskTemplatesByTenantHandler,
  updateTaskTemplateHandler,
} from './tasks.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const tasksRouter = Router();

// Aplicamos el middleware 'protect' a TODAS las rutas de este enrutador.
tasksRouter.use(protect);

// TODO: A√±adir un middleware de autorizaci√≥n para asegurar que el rol sea 'ADMIN'.

tasksRouter.route('/')
  .get(getTaskTemplatesByTenantHandler)
  .post(createTaskTemplateHandler);

tasksRouter.route('/:id')
  .patch(updateTaskTemplateHandler)
  .delete(deleteTaskTemplateHandler);

export default tasksRouter;


// ====== [46] packages/server/src/api/tasks/tasks.service.ts ======
// filename: packages/server/src/api/tasks/tasks.service.ts
// Version: 1.0.0 (Initial creation of the service for Scheduled Tasks)
import { PrismaClient } from '@prisma/client';
import type { ScheduledTaskTemplate } from '@prisma/client';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
export type CreateTaskTemplateInput = {
  name: string;
  tenantId: string; // Cada plantilla pertenece a un tenant
  description?: string;
};

export type UpdateTaskTemplateInput = Partial<Omit<CreateTaskTemplateInput, 'tenantId'>>;

// --- Funciones del Servicio ---

/**
 * Crea una nueva plantilla de tarea para un tenant espec√≠fico.
 * @param input - Datos de la nueva plantilla.
 * @returns La plantilla de tarea creada.
 */
export const createTaskTemplate = async (
  input: CreateTaskTemplateInput
): Promise<ScheduledTaskTemplate> => {
  return prisma.scheduledTaskTemplate.create({
    data: input,
  });
};

/**
 * Obtiene todas las plantillas de tareas para un tenant espec√≠fico.
 * @param tenantId - El ID del tenant.
 * @returns Un array de plantillas de tareas.
 */
export const getTaskTemplatesByTenant = async (
  tenantId: string
): Promise<ScheduledTaskTemplate[]> => {
  return prisma.scheduledTaskTemplate.findMany({
    where: { tenantId },
    orderBy: { name: 'asc' },
  });
};

/**
 * Actualiza una plantilla de tarea existente.
 * @param id - El ID de la plantilla a actualizar.
 * @param data - Los datos a actualizar.
 * @returns La plantilla de tarea actualizada.
 */
export const updateTaskTemplate = async (
  id: string,
  data: UpdateTaskTemplateInput
): Promise<ScheduledTaskTemplate> => {
  return prisma.scheduledTaskTemplate.update({
    where: { id },
    data,
  });
};

/**
 * Elimina una plantilla de tarea.
 * @param id - El ID de la plantilla a eliminar.
 * @returns La plantilla de tarea que fue eliminada.
 */
export const deleteTaskTemplate = async (
  id: string
): Promise<ScheduledTaskTemplate> => {
  // TODO: A√±adir l√≥gica para verificar que esta plantilla no est√° siendo
  // usada en ninguna PoolConfiguration antes de permitir el borrado.
  return prisma.scheduledTaskTemplate.delete({
    where: { id },
  });
};


// ====== [47] packages/server/src/api/tenants/tenants.controller.ts ======
import type { Request, Response, NextFunction } from 'express';
import {
  createTenant,
  getAllTenants,
  getTenantById,
  updateTenantStatus,
  deleteTenant,
} from './tenants.service.js';

/**
 * Maneja la creaci√≥n de un nuevo tenant.
 */
export const createTenantHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenant = await createTenant(req.body);
    res.status(201).json({ success: true, data: tenant });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de todos los tenants.
 */
export const getAllTenantsHandler = async (
  _req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenants = await getAllTenants();
    res.status(200).json({ success: true, data: tenants });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de un tenant por su ID.
 */
export const getTenantByIdHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID del tenant es requerido.' });
    }

    const tenant = await getTenantById(id);

    if (!tenant) {
      const error: any = new Error('Tenant no encontrado.');
      error.statusCode = 404;
      return next(error);
    }

    res.status(200).json({ success: true, data: tenant });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la actualizaci√≥n del estado de un tenant.
 */
export const updateTenantStatusHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID del tenant es requerido.' });
    }

    const { status } = req.body;
    // TODO: A√±adir validaci√≥n para asegurar que 'status' es un valor v√°lido del enum SubscriptionStatus

    const updatedTenant = await updateTenantStatus(id, status);
    res.status(200).json({ success: true, data: updatedTenant });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la eliminaci√≥n de un tenant.
 */
export const deleteTenantHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID del tenant es requerido.' });
    }

    await deleteTenant(id);

    res.status(204).send();
  } catch (error) {
    next(error);
  }
};


// ====== [48] packages/server/src/api/tenants/tenants.routes.ts ======
import { Router } from 'express';
import {
  createTenantHandler,
  getAllTenantsHandler,
  getTenantByIdHandler,
  updateTenantStatusHandler,
  deleteTenantHandler,
} from './tenants.controller.js';

const tenantsRouter = Router();

// TODO: Proteger todas estas rutas para que solo sean accesibles por un SUPER_ADMIN.

/**
 * @route   GET /api/tenants
 * @desc    Obtiene todos los tenants
 * @access  Private (SuperAdmin)
 */
tenantsRouter.get('/', getAllTenantsHandler);

/**
 * @route   POST /api/tenants
 * @desc    Crea un nuevo tenant y su primer usuario admin
 * @access  Private (SuperAdmin)
 */
tenantsRouter.post('/', createTenantHandler);

/**
 * @route   GET /api/tenants/:id
 * @desc    Obtiene un tenant espec√≠fico por su ID
 * @access  Private (SuperAdmin)
 */
tenantsRouter.get('/:id', getTenantByIdHandler);

/**
 * @route   PATCH /api/tenants/:id/status
 * @desc    Actualiza el estado de la suscripci√≥n de un tenant
 * @access  Private (SuperAdmin)
 */
tenantsRouter.patch('/:id/status', updateTenantStatusHandler);

/**
 * @route   DELETE /api/tenants/:id
 * @desc    Elimina un tenant y toda su informaci√≥n asociada
 * @access  Private (SuperAdmin)
 */
tenantsRouter.delete('/:id', deleteTenantHandler);

export default tenantsRouter;


// ====== [49] packages/server/src/api/tenants/tenants.service.ts ======
import { PrismaClient } from '@prisma/client';
import type { Tenant, SubscriptionStatus } from '@prisma/client';
import { hashPassword } from '../../utils/password.utils.js';

const prisma = new PrismaClient();

// --- Tipos de Entrada (DTOs) ---
type AdminUserInput = {
  name: string;
  email: string;
  password: string;
};

export type CreateTenantInput = {
  companyName: string;
  subdomain: string;
  adminUser: AdminUserInput;
};

// --- Funciones del Servicio ---

/**
 * Crea un nuevo Tenant y su primer usuario Administrador de forma at√≥mica.
 * @param input - Datos para el nuevo tenant y su admin.
 * @returns El objeto del Tenant reci√©n creado.
 */
export const createTenant = async (input: CreateTenantInput): Promise<Tenant> => {
  const { companyName, subdomain, adminUser } = input;

  const newTenant = await prisma.$transaction(async (tx) => {
    const existingSubdomain = await tx.tenant.findUnique({ where: { subdomain } });
    if (existingSubdomain) {
      throw new Error('El subdominio ya est√° en uso.');
    }

    const existingEmail = await tx.user.findUnique({ where: { email: adminUser.email } });
    if (existingEmail) {
      throw new Error('El correo electr√≥nico ya est√° en uso por otro usuario.');
    }

    const tenant = await tx.tenant.create({
      data: {
        companyName,
        subdomain,
      },
    });

    const hashedPassword = await hashPassword(adminUser.password);
    await tx.user.create({
      data: {
        name: adminUser.name,
        email: adminUser.email,
        password: hashedPassword,
        role: 'ADMIN',
        tenantId: tenant.id,
      },
    });

    return tenant;
  });

  return newTenant;
};

/**
 * Obtiene un listado de todos los tenants.
 * @returns Un array de todos los tenants.
 */
export const getAllTenants = async (): Promise<Tenant[]> => {
  return prisma.tenant.findMany({
    orderBy: {
      createdAt: 'desc',
    },
  });
};

/**
 * Busca un tenant espec√≠fico por su ID.
 * @param id - El ID del tenant a buscar.
 * @returns El objeto del tenant o null si no se encuentra.
 */
export const getTenantById = async (id: string): Promise<Tenant | null> => {
  return prisma.tenant.findUnique({
    where: { id },
  });
};

/**
 * Actualiza el estado de la suscripci√≥n de un tenant.
 * @param id - El ID del tenant a actualizar.
 * @param status - El nuevo estado de la suscripci√≥n.
 * @returns El objeto del tenant actualizado.
 */
export const updateTenantStatus = async (
  id: string,
  status: SubscriptionStatus
): Promise<Tenant> => {
  return prisma.tenant.update({
    where: { id },
    data: {
      subscriptionStatus: status,
    },
  });
};

/**
 * Elimina un tenant y toda su informaci√≥n asociada (cascade).
 * @param id - El ID del tenant a eliminar.
 * @returns El objeto del tenant que fue eliminado.
 */
export const deleteTenant = async (id: string): Promise<Tenant> => {
  // Gracias a 'onDelete: Cascade' en el schema, al borrar un tenant,
  // se borrar√°n en cascada todos sus usuarios, clientes, piscinas, etc.
  return prisma.tenant.delete({
    where: { id },
  });
};


// ====== [50] packages/server/src/api/users/users.controller.ts ======
// filename: packages/server/src/api/users/users.controller.ts
// Version: 1.0.0 (Initial creation of the controller for User queries)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { getTechniciansByTenant } from './users.service.js';

/**
 * Maneja la obtenci√≥n de todos los t√©cnicos de un tenant.
 */
export const getTechniciansByTenantHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acci√≥n no permitida.' });
    }

    const technicians = await getTechniciansByTenant(tenantId);
    res.status(200).json({ success: true, data: technicians });
  } catch (error) {
    next(error);
  }
};


// ====== [51] packages/server/src/api/users/users.routes.ts ======
// filename: packages/server/src/api/users/users.routes.ts
// Version: 1.0.0 (Initial creation of routes for User queries)
import { Router } from 'express';
import { getTechniciansByTenantHandler } from './users.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const usersRouter = Router();

// Aplicamos el middleware 'protect' a TODAS las rutas de este enrutador.
usersRouter.use(protect);

// TODO: A√±adir un middleware de autorizaci√≥n para asegurar que el rol sea 'ADMIN'.

/**
 * @route   GET /api/users/technicians
 * @desc    Obtiene una lista de todos los t√©cnicos del tenant.
 * @access  Private (Admin)
 */
usersRouter.get('/technicians', getTechniciansByTenantHandler);


export default usersRouter;


// ====== [52] packages/server/src/api/users/users.service.ts ======
// filename: packages/server/src/api/users/users.service.ts
// Version: 1.0.0 (Initial creation of the service for User queries)
import { PrismaClient } from '@prisma/client';
import type { User } from '@prisma/client';

const prisma = new PrismaClient();

// --- Funciones del Servicio ---

/**
 * Obtiene todos los usuarios con el rol de TECHNICIAN para un tenant espec√≠fico.
 * @param tenantId - El ID del tenant.
 * @returns Un array de usuarios t√©cnicos (sin la contrase√±a).
 */
export const getTechniciansByTenant = async (
  tenantId: string
): Promise<Omit<User, 'password'>[]> => {
  return prisma.user.findMany({
    where: {
      tenantId,
      role: 'TECHNICIAN',
    },
    select: {
      id: true,
      email: true,
      name: true,
      role: true,
      tenantId: true,
      createdAt: true,
      updatedAt: true,
    },
    orderBy: {
      name: 'asc',
    },
  });
};


// ====== [53] packages/server/src/api/visits/visits.controller.ts ======
// filename: packages/server/src/api/visits/visits.controller.ts
// Version: 1.7.0 (Adapt assignTechnicianHandler to new logic)
import type { Response, NextFunction } from 'express';
import type { AuthRequest } from '../../middleware/auth.middleware.js';
import { 
  getScheduledVisitsForWeek, 
  assignTechnicianToVisit,
  getVisitsForTechnicianOnDate,
  getVisitDetails,
  submitWorkOrder,
} from './visits.service.js';

/**
 * Maneja la obtenci√≥n de las visitas programadas para una semana.
 */
export const getScheduledVisitsForWeekHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const tenantId = req.user?.tenantId;
    if (!tenantId) {
      return res.status(403).json({ message: 'Acci√≥n no permitida.' });
    }

    const { date } = req.query;
    if (!date || typeof date !== 'string') {
      return res.status(400).json({ message: 'Se requiere un par√°metro de fecha v√°lido.' });
    }

    const weekDate = new Date(date);
    const visits = await getScheduledVisitsForWeek(tenantId, weekDate);

    res.status(200).json({ success: true, data: visits });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la asignaci√≥n de un t√©cnico a una visita.
 */
export const assignTechnicianHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { visitId, technicianId } = req.body;
    if (!visitId) {
      return res.status(400).json({ message: 'visitId es requerido.' });
    }
    
    // TODO: Verificar que la visita pertenece al tenant del admin
    
    const assignedVisit = await assignTechnicianToVisit(visitId, technicianId);
    
    res.status(200).json({ success: true, data: assignedVisit });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de la ruta diaria para el t√©cnico autenticado.
 */
export const getMyRouteHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const technicianId = req.user?.id;
    if (!technicianId || req.user?.role !== 'TECHNICIAN') {
      return res.status(403).json({ message: 'Acceso denegado.' });
    }
    
    const today = new Date();
    const visits = await getVisitsForTechnicianOnDate(technicianId, today);
    
    res.status(200).json({ success: true, data: visits });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja la obtenci√≥n de los detalles de una visita espec√≠fica.
 */
export const getVisitDetailsHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la visita es requerido.' });
    }
    
    const visitDetails = await getVisitDetails(id);
    if (!visitDetails) {
      return res.status(404).json({ message: 'Visita no encontrada.' });
    }

    res.status(200).json({ success: true, data: visitDetails });
  } catch (error) {
    next(error);
  }
};

/**
 * Maneja el env√≠o de un parte de trabajo.
 */
export const submitWorkOrderHandler = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  try {
    const { id } = req.params;
    if (!id) {
      return res.status(400).json({ message: 'El ID de la visita es requerido.' });
    }
    
    await submitWorkOrder(id, req.body);

    res.status(200).json({ success: true, message: 'Parte de trabajo guardado con √©xito.' });
  } catch (error) {
    console.error('ERROR AL PROCESAR PARTE DE TRABAJO:', error); 
    next(error);
  }
};


// ====== [54] packages/server/src/api/visits/visits.routes.ts ======
// filename: packages/server/src/api/visits/visits.routes.ts
// Version: 1.4.4 (Clean up unused imports and finalize route order)
import { Router } from 'express';
import { 
  getScheduledVisitsForWeekHandler,
  assignTechnicianHandler,
  getMyRouteHandler,
  getVisitDetailsHandler,
  submitWorkOrderHandler,
} from './visits.controller.js';
import { protect } from '../../middleware/auth.middleware.js';

const visitsRouter = Router();

visitsRouter.use(protect);

// --- Rutas para ADMIN ---
visitsRouter.get('/scheduled', getScheduledVisitsForWeekHandler);
visitsRouter.post('/assign', assignTechnicianHandler);

// --- Rutas para TECHNICIAN ---
visitsRouter.get('/my-route', getMyRouteHandler);

/**
 * @route   POST /api/visits/:id/complete
 * @desc    Env√≠a y procesa los datos de un Parte de Trabajo.
 * @access  Private (Technician)
 */
visitsRouter.post('/:id/complete', submitWorkOrderHandler);

/**
 * @route   GET /api/visits/:id
 * @desc    Obtiene los detalles de una visita espec√≠fica (para el Parte de Trabajo)
 * @access  Private (Technician/Admin)
 */
visitsRouter.get('/:id', getVisitDetailsHandler);

export default visitsRouter;


// ====== [55] packages/server/src/api/visits/visits.service.ts ======
// filename: packages/server/src/api/visits/visits.service.ts
// Version: 1.7.7 (Clean up unused imports after frequency logic fix)
import { PrismaClient } from '@prisma/client';
import type { Visit } from '@prisma/client'; // <-- Frequency eliminado
import { 
  startOfWeek, endOfWeek, eachDayOfInterval, isSameDay, startOfDay, endOfDay,
} from 'date-fns';

const prisma = new PrismaClient();

// --- Tipos ---
export type WorkOrderInput = {
  results: Record<string, string | number | boolean>;
  completedTasks: Record<string, boolean>;
  notes?: string;
  hasIncident?: boolean;
};


export const getScheduledVisitsForWeek = async (tenantId: string, weekDate: Date): Promise<Visit[]> => {
  const start = startOfWeek(weekDate, { weekStartsOn: 1 }); // Lunes
  const end = endOfWeek(weekDate, { weekStartsOn: 1 });   // Domingo
  const weekDays = eachDayOfInterval({ start, end });

  const pools = await prisma.pool.findMany({
    where: { tenantId, configurations: { some: {} } },
    include: { configurations: true },
  });

  const existingVisits = await prisma.visit.findMany({
    where: { pool: { tenantId }, timestamp: { gte: start, lte: end } },
  });

  const visitsToCreate: { poolId: string; timestamp: Date }[] = [];

  for (const day of weekDays) {
    for (const pool of pools) {
      
      const shouldVisitToday = pool.configurations.some(config => {
        if (config.frequency === 'DIARIA') return true;
        if (config.frequency === 'SEMANAL' && day.getDay() === 1) return true;
        return false;
      });

      if (shouldVisitToday) {
        const alreadyExists = existingVisits.some(
          (v) => v.poolId === pool.id && isSameDay(v.timestamp, day)
        );
        const alreadyInQueue = visitsToCreate.some(
          (v) => v.poolId === pool.id && isSameDay(v.timestamp, day)
        );

        if (!alreadyExists && !alreadyInQueue) {
          visitsToCreate.push({ poolId: pool.id, timestamp: day });
        }
      }
    }
  }

  if (visitsToCreate.length > 0) {
    await prisma.visit.createMany({
      data: visitsToCreate.map(v => ({ ...v, status: 'PENDING' })),
      skipDuplicates: true,
    });
  }

  return prisma.visit.findMany({
    where: { pool: { tenantId }, timestamp: { gte: start, lte: end } },
    include: { pool: { include: { client: true } } },
    orderBy: { timestamp: 'asc' },
  });
};

export const assignTechnicianToVisit = async (visitId: string, technicianId: string | null) => {
    return prisma.visit.update({
        where: { id: visitId },
        data: { technicianId },
    });
};

export const getVisitsForTechnicianOnDate = async (
  technicianId: string,
  date: Date
): Promise<Visit[]> => {
  const dayStart = startOfDay(date);
  const dayEnd = endOfDay(date);

  return prisma.visit.findMany({
    where: {
      technicianId,
      status: 'PENDING',
      timestamp: {
        gte: dayStart,
        lte: dayEnd,
      },
    },
    include: {
      pool: {
        include: {
          client: true,
        },
      },
    },
    orderBy: {
      timestamp: 'asc',
    },
  });
};

export const getVisitDetails = async (visitId: string) => {
  return prisma.visit.findUnique({
    where: { id: visitId },
    include: {
      pool: {
        include: {
          client: true,
          configurations: {
            include: {
              parameterTemplate: true,
              taskTemplate: true,
            },
          },
        },
      },
    },
  });
};

export const submitWorkOrder = async (visitId: string, data: WorkOrderInput) => {
  return prisma.$transaction(async (tx) => {
    const visit = await tx.visit.findUnique({
      where: { id: visitId },
      include: { 
        pool: { 
          include: { 
            configurations: { include: { parameterTemplate: true, taskTemplate: true } } 
          } 
        },
        technician: true
      },
    });
    if (!visit) throw new Error('Visita no encontrada');
    
    const { results, completedTasks, notes, hasIncident } = data;

    for (const [configId, value] of Object.entries(results)) {
      if(value === '' || value === null) continue;
      const config = visit.pool.configurations.find(c => c.id === configId);
      if (config?.parameterTemplate) {
        await tx.visitResult.create({
          data: {
            visitId,
            value: String(value),
            parameterName: config.parameterTemplate.name,
            parameterUnit: config.parameterTemplate.unit,
          },
        });
      }
    }
    
    const completedTaskNames = Object.entries(completedTasks)
      .filter(([, completed]) => completed)
      .map(([configId]) => {
        const config = visit.pool.configurations.find(c => c.id === configId);
        return config?.taskTemplate?.name || 'Tarea desconocida';
      });
    
    await tx.visit.update({
      where: { id: visitId },
      data: {
        notes,
        hasIncident: hasIncident || false,
        completedTasks: completedTaskNames,
        status: 'COMPLETED',
      },
    });

    if (hasIncident) {
      const admin = await tx.user.findFirst({
        where: { tenantId: visit.pool.tenantId, role: 'ADMIN' },
      });
      if (admin) {
        const technicianName = visit.technician ? visit.technician.name : 'Un t√©cnico';
        await tx.notification.create({
          data: {
            message: `Nueva incidencia reportada por ${technicianName} en la piscina ${visit.pool.name}.`,
            tenantId: visit.pool.tenantId,
            userId: admin.id,
          },
        });
      }
    }
    
    const configIdsToUpdate = [...Object.keys(results).filter(k => results[k] !== ''), ...Object.keys(completedTasks).filter(k => completedTasks[k])];
    if(configIdsToUpdate.length > 0) {
        await tx.poolConfiguration.updateMany({
            where: { id: { in: configIdsToUpdate } },
            data: { lastCompleted: new Date() },
        });
    }
  });
};


// ====== [56] packages/server/src/app.ts ======
// filename: packages/server/src/app.ts
// Version: 1.7.0 (Mount usersRouter for Admin module)
import express from 'express';
import type { Request, Response } from 'express';
import cors from 'cors';
import cookieParser from 'cookie-parser';

import { errorHandler } from './middleware/error.middleware.js';
import authRouter from './api/auth/auth.routes.js';
import tenantsRouter from './api/tenants/tenants.routes.js';
import parametersRouter from './api/parameters/parameters.routes.js';
import tasksRouter from './api/tasks/tasks.routes.js';
import clientsRouter from './api/clients/clients.routes.js';
import poolsRouter from './api/pools/pools.routes.js';
import poolConfigurationsRouter from './api/pool-configurations/pool-configurations.routes.js';
import visitsRouter from './api/visits/visits.routes.js';
import usersRouter from './api/users/users.routes.js';

// --- Instancia de la App ---
const app = express();

// --- Middlewares Esenciales ---
app.use(cors({
  origin: 'http://localhost:5173',
  credentials: true,
}));
app.use(cookieParser());
app.use(express.json());


// --- Rutas de la API ---

// Ruta de health-check para verificar que el servidor est√° vivo.
app.get('/api/health', (_req: Request, res: Response) => {
  res.status(200).json({ status: 'UP' });
});

// Montamos los enrutadores de cada m√≥dulo
app.use('/api/auth', authRouter);
app.use('/api/tenants', tenantsRouter);
app.use('/api/parameters', parametersRouter);
app.use('/api/tasks', tasksRouter);
app.use('/api/clients', clientsRouter);
app.use('/api/pools', poolsRouter);
app.use('/api/pool-configurations', poolConfigurationsRouter);
app.use('/api/visits', visitsRouter);
app.use('/api/users', usersRouter);


// --- Gestor de Errores ---
app.use(errorHandler);

export default app;


// ====== [57] packages/server/src/config/index.ts ======
import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

// --- Recreaci√≥n de __dirname para ES Modules ---
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
// ---------------------------------------------

dotenv.config({ path: path.resolve(__dirname, '../../.env') });

const getEnvVar = (key: string): string => {
  const value = process.env[key];
  if (!value) {
    throw new Error(`Falta la variable de entorno requerida: ${key}`);
  }
  return value;
};

const config = {
  PORT: parseInt(getEnvVar('PORT'), 10),
  JWT_SECRET: getEnvVar('JWT_SECRET'),
  JWT_EXPIRES_IN: parseInt(getEnvVar('JWT_EXPIRES_IN'), 10),
  DATABASE_URL: getEnvVar('DATABASE_URL'),
};

export default config;


// ====== [58] packages/server/src/middleware/auth.middleware.ts ======
import type { Request, Response, NextFunction } from 'express';
import { PrismaClient } from '@prisma/client';
import type { User } from '@prisma/client';
import { verifyToken } from '../utils/jwt.utils.js';

const prisma = new PrismaClient();

// Creamos un tipo "seguro" para el usuario, omitiendo la contrase√±a.
type SafeUser = Omit<User, 'password'>;

// Extendemos la interfaz Request de Express para que use nuestro tipo SafeUser.
export interface AuthRequest extends Request {
  user?: SafeUser;
}

/**
 * Middleware para proteger rutas. Verifica el token JWT de la cookie.
 * Si el token es v√°lido, adjunta el usuario a la request y pasa al siguiente middleware.
 * Si no, devuelve un error 401 (No autorizado).
 */
export const protect = async (
  req: AuthRequest,
  res: Response,
  next: NextFunction
) => {
  const token = req.cookies.token;

  if (!token) {
    return res.status(401).json({ message: 'No autenticado: no hay token.' });
  }

  try {
    const decoded = verifyToken<{ id: string }>(token);

    if (!decoded) {
      return res.status(401).json({ message: 'No autenticado: token inv√°lido.' });
    }

    const user = await prisma.user.findUnique({
      where: { id: decoded.id },
      // Seleccionamos todos los campos EXCEPTO la contrase√±a.
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        tenantId: true,
        createdAt: true,
        updatedAt: true,
      },
    });

    if (!user) {
      return res.status(401).json({ message: 'No autenticado: usuario no encontrado.' });
    }

    // Ahora `user` coincide con el tipo `SafeUser`, por lo que la asignaci√≥n es v√°lida.
    req.user = user;
    next();
  } catch (error) {
    return res.status(401).json({ message: 'No autenticado: error en la validaci√≥n.' });
  }
};


// ====== [59] packages/server/src/middleware/error.middleware.ts ======
import type { Request, Response, NextFunction } from 'express';

// Interfaz para asegurar que nuestros errores puedan tener un c√≥digo de estado
interface HttpError extends Error {
  statusCode?: number;
}

export const errorHandler = (
  err: HttpError,
  _req: Request,
  res: Response,
  _next: NextFunction
) => {
  // Guardamos el error en la consola para depuraci√≥n
  console.error(err);

  const statusCode = err.statusCode || 500;
  const message = err.message || 'Ha ocurrido un error inesperado en el servidor.';

  res.status(statusCode).json({
    success: false,
    statusCode: statusCode,
    message: message,
  });
};


// ====== [60] packages/server/src/server.ts ======
import app from './app.js';
import config from './config/index.js';

const PORT = config.PORT || 3001;

app.listen(PORT, () => {
  console.log(`üöÄ Servidor escuchando en http://localhost:${PORT}`);
});


// ====== [61] packages/server/src/utils/jwt.utils.ts ======
import jwt from 'jsonwebtoken';
import type { SignOptions } from 'jsonwebtoken';
import config from '../config/index.js';

/**
 * Firma un payload para crear un token JWT.
 * @param payload El objeto que se incluir√° en el token (ej. { userId: '...' }).
 * @returns El token JWT como una cadena de texto.
 */
export const signToken = (payload: object): string => {
  const options: SignOptions = {
    expiresIn: config.JWT_EXPIRES_IN,
  };

  return jwt.sign(payload, config.JWT_SECRET, options);
};

/**
 * Verifica un token JWT y devuelve su payload si es v√°lido.
 * @template T El tipo esperado del payload.
 * @param token El token JWT a verificar.
 * @returns El payload decodificado si el token es v√°lido; de lo contrario, null.
 */
export const verifyToken = <T>(token: string): T | null => {
  try {
    const decoded = jwt.verify(token, config.JWT_SECRET) as T;
    return decoded;
  } catch (error) {
    return null;
  }
};


// ====== [62] packages/server/src/utils/password.utils.ts ======
import bcrypt from 'bcryptjs';

const SALT_ROUNDS = 12;

/**
 * Genera el hash de una contrase√±a en texto plano.
 * @param password La contrase√±a en texto plano.
 * @returns Una promesa que resuelve en el hash de la contrase√±a.
 */
export const hashPassword = (password: string): Promise<string> => {
  return bcrypt.hash(password, SALT_ROUNDS);
};

/**
 * Compara una contrase√±a en texto plano con un hash.
 * @param password La contrase√±a en texto plano a comparar.
 * @param hash El hash almacenado en la base de datos.
 * @returns Una promesa que resuelve en `true` si las contrase√±as coinciden, `false` en caso contrario.
 */
export const comparePassword = (password: string, hash: string): Promise<boolean> => {
  return bcrypt.compare(password, hash);
};


// ====== [63] packages/server/tsconfig.json ======
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist"
  },
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules"]
}


// ====== [64] tsconfig.json ======
{
  "compilerOptions": {
    /* Base Options */
    "esModuleInterop": true,
    "skipLibCheck": true,
    "target": "ES2022",
    "allowJs": true,
    "resolveJsonModule": true,
    "moduleDetection": "force",
    "isolatedModules": true,
    "verbatimModuleSyntax": true,

    /* Strictness */
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitAny": true,

    /* Module Resolution */
    "moduleResolution": "NodeNext",
    "module": "NodeNext",

    /* Linter */
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true
  },
  "exclude": ["node_modules"]
}

